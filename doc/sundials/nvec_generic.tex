% This is a shared SUNDIALS TEX file with description of
% the generic nvector abstraction
%
The {\sundials} solvers are written in a data-independent manner.
They all operate on generic vectors (of type \Id{N\_Vector}) through a set of
operations defined by the particular {\nvector} implementation.
Users can provide their own specific implementation of the {\nvector}
module, or use one of the implementations provided with {\sundials}.
The generic {\nvector} is described below and the implementations
provided with {\sundials} are described in the following sections.

% ====================================================================
\section{The NVECTOR API}
\label{s:nvector_api}
% ====================================================================

The generic {\nvector} API can be broken down into five groups of functions:
the core vector operations, the fused vector operations, the vector array
operations, the local reduction operations, and finally some utility functions.
The first four groups are defined by a particular {\nvector} implementation.
The utility functions are defined by the generic {\nvector} itself.

% ====================================================================
\subsection{NVECTOR core functions}\label{ss:nvecops}

\ucfunctionf{N\_VGetVectorID}
{
  id = N\_VGetVectorID(w);
}
{
  Returns the vector type identifier for the vector \id{w}. It is used to determine the
  vector implementation type (e.g.~serial, parallel,\ldots) from the abstract
  \id{N\_Vector} interface.
}
{
  \begin{args}[w]
  \item[w] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  This function returns an \id{N\_Vector\_ID}. Possible values are given in Table
  \ref{t:vectorIDs}.
}
{}

\ucfunctionf{N\_VClone}
{
  v = N\_VClone(w);
}
{
  Creates a new \id{N\_Vector} of the same type as an existing vector \id{w} and sets the
  {\em ops} field. It does not copy the vector, but rather allocates storage for the new vector.
}
{
  \begin{args}[w]
  \item[w] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  This function returns an \id{N\_Vector} object. If an error occurs, then this
  routine will return \id{NULL}.
}
{}

\ucfunctionf{N\_VCloneEmpty}
{
  v = N\_VCloneEmpty(w);
}
{
  Creates a new \id{N\_Vector} of the same type as an existing vector \id{w} and sets the
  {\em ops} field. It does not allocate storage for data.
}
{
  \begin{args}[w]
  \item[w] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  This function returns an \id{N\_Vector} object. If an error occurs, then this
  routine will return \id{NULL}.
}
{}

\ucfunctionf{N\_VDestroy}
{
  N\_VDestroy(v);
}
{
  Destroys the \id{N\_Vector} \id{v} and frees memory allocated for its
  internal data.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector}) a {\nvector} object to destroy
  \end{args}
}
{}
{}

\ucfunctionfl{N\_VSpace}
{
  N\_VSpace(v, \&lrw, \&liw);
}
{
  Returns storage requirements for one \id{N\_Vector}.
  \id{lrw} contains the number of realtype words and \id{liw}
  contains the number of integer words, This function is advisory
  only, for use in determining a user's total space requirements;
  it could be a dummy function in a user-supplied
  {\nvector} module if that information is not of interest.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector}) a {\nvector} object
  \item[lrw] (\id{sunindextype*}) out parameter containing the number of realtype words
  \item[liw] (\id{sunindextype*}) out parameter containing the number of integer words
  \end{args}
}
{}
{}
{
  integer(c\_long) :: lrw(1), liw(1)\\
  call FN\_VSpace\_Serial(v, lrw, liw)
}

\ucfunctionf{N\_VGetArrayPointer}
{
  vdata = N\_VGetArrayPointer(v);
}
{
  Returns a pointer to a \id{realtype} array from the \id{N\_Vector} \id{v}.
  Note that this assumes that the internal data in \id{N\_Vector} is
  a contiguous array of \id{realtype}. This routine is only used in the
  solver-specific interfaces to the dense and banded (serial) linear
  solvers, the sparse linear solvers (serial and threaded), and in the
  interfaces to the banded (serial) and band-block-diagonal (parallel)
  preconditioner modules provided with {\sundials}.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype*}
}
{}

\ucfunctionf{N\_VSetArrayPointer}
{
  N\_VSetArrayPointer(vdata, v);
}
{
  Overwrites the pointer to the data in an \id{N\_Vector} with a given \id{realtype*}.
  Note that this assumes that the internal data in \id{N\_Vector} is a contiguous
  array of \id{realtype}. This routine is only used in the interfaces to the dense
  (serial) linear solver, hence need not exist in a user-supplied {\nvector} module
  for a parallel environment.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{}
{}

\ucfunctionf{N\_VGetCommunicator}
{
  N\_VGetCommunicator(v);
}
{

  Returns a pointer to the \id{MPI\_Comm} object associated with the
  vector (if applicable). For MPI-unaware vector implementations, this
  should return \id{NULL}.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  A \id{void *} pointer to the \id{MPI\_Comm} object if the vector is MPI-aware,
  otherwise \id{NULL}.
}
{}

\ucfunctionf{N\_VGetLength}
{
  N\_VGetLength(v);
}
{
  Returns the global length (number of `active' entries) in the
  {\nvector} \id{v}.  This value should be cumulative across all
  processes if the vector is used in a parallel environment.  If \id{v}
  contains additional storage, e.g., for parallel communication, those
  entries should not be included.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{sunindextype}
}
{}

\ucfunctionf{N\_VLinearSum}
{
  N\_VLinearSum(a, x, b, y, z);
}
{
  Performs the operation $z = a x + b y$, where $a$ and $b$ are \id{realtype}
  scalars and $x$ and $y$ are of type \id{N\_Vector}:
  $z_i = a x_i + b y_i, \: i=0,\ldots,n-1$.
}
{
  \begin{args}[a]
  \item[a] (\id{realtype}) constant that scales \id{x}
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[b] (\id{realtype}) constant that scales \id{y}
  \item[y] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VConst}
{
  N\_VConst(c, z);
}
{
  Sets all components of the \id{N\_Vector} \id{z} to \id{realtype} \id{c}:
  $z_i = c,\: i=0,\ldots,n-1$.
}
{
  \begin{args}[c]
  \item[c] (\id{realtype}) constant to set all components of \id{z} to
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VProd}
{
  N\_VProd(x, y, z);
}
{
  Sets the \id{N\_Vector} \id{z} to be the component-wise product of the
  \id{N\_Vector} inputs \id{x} and \id{y}: $z_i = x_i y_i,\: i=0,\ldots,n-1$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[y] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VDiv}
{
  N\_VDiv(x, y, z);
}
{
  Sets the \id{N\_Vector} \id{z} to be the component-wise ratio of the
  \id{N\_Vector} inputs \id{x} and \id{y}:
  $z_i = x_i / y_i,\: i=0,\ldots,n-1$. The $y_i$ may not be tested
  for $0$ values. It should only be called with a \id{y} that is
  guaranteed to have all nonzero components.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[y] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VScale}
{
  N\_VScale(c, x, z);
}
{
  Scales the \id{N\_Vector} \id{x} by the \id{realtype} scalar \id{c}
  and returns the result in \id{z}: $z_i = c x_i , \: i=0,\ldots,n-1$.
}
{
  \begin{args}[c]
  \item[c] (\id{realtype}) constant that scales the vector \id{x}
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VAbs}
{
  N\_VAbs(x, z);
}
{
  Sets the components of the \id{N\_Vector} \id{z} to be the absolute
  values of the components of the \id{N\_Vector} \id{x}:
  $y_i = | x_i | , \: i=0,\ldots,n-1$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VInv}
{
  N\_VInv(x, z);
}
{

  Sets the components of the \id{N\_Vector} \id{z} to be the inverses
  of the components of the \id{N\_Vector} \id{x}:
  $z_i = 1.0 /  x_i  , \: i=0,\ldots,n-1$. This routine
  may not check for division by $0$. It should be called only with an
  \id{x} which is guaranteed to have all nonzero components.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object to
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VAddConst}
{
  N\_VAddConst(x, b, z);
}
{
  Adds the \id{realtype} scalar \id{b} to all components of \id{x}
  and returns the result in the \id{N\_Vector} \id{z}:
  $z_i = x_i + b , \: i=0,\ldots,n-1$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[b] (\id{realtype}) constant added to all components of \id{x}
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VDotProd}
{
  d = N\_VDotProd(x, y);
}
{
  Returns the value of the ordinary dot product of \id{x} and \id{y}:
  $d=\sum_{i=0}^{n-1} x_i y_i$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
    with \id{y}
  \item[y] (\id{N\_Vector}) a {\nvector} object
    with \id{x}
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VMaxNorm}
{
  m = N\_VMaxNorm(x);
}
{
  Returns the maximum norm of the \id{N\_Vector} \id{x}:
  $m = \max_{i} | x_i |$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VWrmsNorm}
{
  m = N\_VWrmsNorm(x, w)
}
{
  Returns the weighted root-mean-square norm of the \id{N\_Vector} \id{x} with
  \id{realtype} weight vector \id{w}:
  $m = \sqrt{\left( \sum_{i=0}^{n-1} (x_i w_i)^2 \right) / n}$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[w] (\id{N\_Vector}) a {\nvector} object containing weights
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VWrmsNormMask}
{
  m = N\_VWrmsNormMask(x, w, id);
}
{
  Returns the weighted root mean square norm of the \id{N\_Vector} \id{x} with
  \id{realtype} weight vector \id{w} built using only
  the elements of \id{x} corresponding to
  positive elements of the \id{N\_Vector} \id{id}:
  $m = \sqrt{\left( \sum_{i=0}^{n-1} (x_i w_i H(id_i))^2 \right) / n}$,
  where
  $
  H(\alpha) =
  \begin{cases}
  1 & \alpha > 0 \\
  0 & \alpha \leq 0
  \end{cases}
  $
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[w] (\id{N\_Vector}) a {\nvector} object containing weights
  \item[id] (\id{N\_Vector}) mask vector
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VMin}
{
  m = N\_VMin(x);
}
{
  Returns the smallest element of the \id{N\_Vector} \id{x}:
  $m = \min_i x_i $.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VWL2Norm}
{
  m = N\_VWL2Norm(x, w);
}
{
  Returns the weighted Euclidean $\ell_2$ norm of the \id{N\_Vector} \id{x}
  with \id{realtype} weight vector \id{w}:
  $m = \sqrt{\sum_{i=0}^{n-1} (x_i w_i)^2}$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[w] (\id{N\_Vector}) a {\nvector} object containing weights
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VL1Norm}
{
  m = N\_VL1Norm(x);
}
{
  Returns the $\ell_1$ norm of the \id{N\_Vector} \id{x}:
  $m = \sum_{i=0}^{n-1} | x_i |$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object to obtain the norm of
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VCompare}
{
  N\_VCompare(c, x, z);
}
{
  Compares the components of the \id{N\_Vector} \id{x} to the \id{realtype}
  scalar \id{c} and returns an \id{N\_Vector} \id{z} such that:
  $z_i = 1.0$ if $| x_i | \ge c$ and $z_i = 0.0$ otherwise.
}
{
  \begin{args}[c]
  \item[c] (\id{realtype}) constant that each component of \id{x} is compared to
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{}
{}

\ucfunctionf{N\_VInvTest}
{
  t = N\_VInvTest(x, z);
}
{
  Sets the components of the \id{N\_Vector} \id{z} to be the inverses
  of the components of the \id{N\_Vector} \id{x}, with prior testing
  for zero values: $z_i = 1.0 /  x_i  , \: i=0,\ldots,n-1$.
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) an output {\nvector} object
  \end{args}
}
{
  Returns a \id{booleantype} with value \id{SUNTRUE} if all components
  of \id{x} are nonzero (successful inversion) and returns
  \id{SUNFALSE} otherwise.
}
{}

\ucfunctionf{N\_VConstrMask}
{
  t = N\_VConstrMask(c, x, m);
}
{
  Performs the following constraint tests:
  $x_i > 0$ if $c_i=2$,
  $x_i \ge 0$ if $c_i=1$,
  $x_i \le 0$ if $c_i=-1$,
  $x_i < 0$ if $c_i=-2$.
  There is no constraint on $x_i$ if $c_i=0$. This routine returns a boolean
  assigned to \id{SUNFALSE} if any element failed the constraint test and
  assigned to \id{SUNTRUE} if all passed.  It also sets a mask vector \id{m},
  with elements equal to $1.0$ where the constraint test failed, and $0.0$
  where the test passed. This routine is used only for constraint checking.
}
{
  \begin{args}[c]
  \item[c] (\id{realtype}) scalar constraint value
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[m] (\id{N\_Vector}) output mask vector
  \end{args}
}
{
  Returns a \id{booleantype} with value \id{SUNFALSE} if any element failed the
  constraint test, and \id{SUNTRUE} if all passed.
}
{}

\ucfunctionf{N\_VMinQuotient}
{
  minq = N\_VMinQuotient(num, denom);
}
{
  This routine returns the minimum of the quotients obtained
  by term-wise dividing \id{num}$_i$ by \id{denom}$_i$.
  A zero element in \id{denom} will be skipped.
  If no such quotients are found, then the large value
  \Id{BIG\_REAL} (defined in the header file \id{sundials\_types.h})
  is returned.
}
{
  \begin{args}[x]
  \item[num] (\id{N\_Vector}) a {\nvector} object used as the numerator
  \item[denom] (\id{N\_Vector}) a {\nvector} object used as the denominator
  \end{args}
}
{
  \id{realtype}
}
{}


% ====================================================================
\subsection{NVECTOR fused functions}\label{ss:nvecfusedops}

Fused and vector array operations are intended to increase data reuse, reduce
parallel communication on distributed memory systems, and lower the number of
kernel launches on systems with accelerators. If a particular {\nvector}
implementation defines a fused or vector array operation as \id{NULL}, the
generic {\nvector} module will automatically call standard vector operations as
necessary to complete the desired operation.  In all
{\sundials}-provided {\nvector} implementations, all fused and vector
array operations are disabled by default.  However, these
implementations provide additional user-callable functions to enable/disable
any or all of the fused and vector array operations. See the following sections
for the implementation specific functions to enable/disable operations.


\ucfunctionfl{N\_VLinearCombination}
{
  ier = N\_VLinearCombination(nv, c, X, z);
}
{
  This routine computes the linear combination of $n_v$ vectors with $n$
  elements:
  \begin{equation*}
    z_i = \sum_{j=0}^{n_v-1} c_j x_{j,i}, \quad i=0,\ldots,n-1,
  \end{equation*}
  where $c$ is an array of $n_v$ scalars, $X$ is an array of $n_v$ vectors,
  and $z$ is the output vector.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the linear combination
  \item[c] (\id{realtype*}) an array of $n_v$ scalars used to scale
    the corresponding vector in \id{X}
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
    to be scaled and combined
  \item[z] (\id{N\_Vector}) a {\nvector} object containing the result
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{
  If the output vector $z$ is one of the vectors in $X$, then it \textit{must} be
  the first vector in the vector array.
}
{
  real(c\_double) :: c(nv)\\
  type(c\_ptr), target :: X(nv)\\
  type(N\_Vector), pointer :: z\\
  ierr = FN\_VLinearCombination(nv, c, X, z)
}

\ucfunctionfl{N\_VScaleAddMulti}
{
  ier = N\_VScaleAddMulti(nv, c, x, Y, Z);
}
{
  This routine scales and adds one vector to $n_v$ vectors with $n$ elements:
  \begin{equation*}
    z_{j,i} = c_j x_i + y_{j,i}, \quad j=0,\ldots,n_v-1 \quad i=0,\ldots,n-1,
  \end{equation*}
  where $c$ is an array of $n_v$ scalars, $x$ is the vector to be scaled and
  added to each vector in the vector array of $n_v$ vectors $Y$, and $Z$ is a
  vector array of $n_v$ output vectors.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of scalars and vectors in \id{c}, \id{Y}, and \id{Z}
  \item[c] (\id{realtype*}) an array of $n_v$ scalars
  \item[x] (\id{N\_Vector}) a {\nvector} object to be scaled and added to each
    vector in \id{Y}
  \item[Y] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects where each vector
    $j$ will have the vector \id{x} scaled by \id{c\_j} added to it
  \item[Z] (\id{N\_Vector}) an output array of $n_v$ {\nvector} objects
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}
{
  real(c\_double) :: c(nv)\\
  type(c\_ptr), target :: Y(nv), Z(nv)\\
  type(N\_Vector), pointer :: x\\
  ierr = FN\_VScaleAddMulti(nv, c, x, Y, Z)
}

\ucfunctionfl{N\_VDotProdMulti}
{
  ier = N\_VDotProdMulti(nv, x, Y, d);
}
{
  This routine computes the dot product of a vector with $n_v$ other vectors:
  \begin{equation*}
    d_j = \sum_{i=0}^{n-1} x_i y_{j,i}, \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $d$ is an array of $n_v$ scalars containing the dot products of the
  vector $x$ with each of the $n_v$ vectors in the vector array $Y$.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in \id{Y}
  \item[x] (\id{N\_Vector}) a {\nvector} object to be used in a dot product
    with each of the vectors in \id{Y}
  \item[Y] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects to use
    in a dot product with \id{x}
  \item[d] (\id{realtype*}) an output array of $n_v$ dot products
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}
{
  real(c\_double) :: d(nv)\\
  type(c\_ptr), target :: Y(nv)\\
  type(N\_Vector), pointer :: x\\
  ierr = FN\_VDotProdMulti(nv, x, Y, d)
}


% ====================================================================
\subsection{NVECTOR vector array functions}\label{ss:nvecarrayops}


\ucfunctionf{N\_VLinearSumVectorArray}
{
  ier = N\_VLinearSumVectorArray(nv, a, X, b, Y, Z);
}
{
  This routine computes the linear sum of two vector arrays containing $n_v$
  vectors of $n$ elements:
  \begin{equation*}
    z_{j,i} = a x_{j,i} + b y_{j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $a$ and $b$ are scalars and $X$, $Y$, and $Z$ are arrays of $n_v$ vectors.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the vector arrays
  \item[a] (\id{realtype}) constant to scale each vector in \id{X} by
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[Y] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[Z] (\id{N\_Vector*}) an output array of $n_v$ {\nvector} objects
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

\ucfunctionf{N\_VScaleVectorArray}
{
  ier = N\_VScaleVectorArray(nv, c, X, Z);
}
{
  This routine scales each vector of $n$ elements in a vector array of $n_v$
  vectors by a potentially different constant:
  \begin{equation*}
    z_{j,i} = c_j x_{j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $c$ is an array of $n_v$ scalars and $X$ and $Z$ are arrays of $n_v$
  vectors.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the vector arrays
  \item[c] (\id{realtype}) constant to scale each vector in \id{X} by
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[Z] (\id{N\_Vector*}) an output array of $n_v$ {\nvector} objects
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

\ucfunctionf{N\_VConstVectorArray}
{
  ier = N\_VConstVectorArray(nv, c, X);
}
{
  This routine sets each element in a vector of $n$ elements in a vector array of
  $n_v$ vectors to the same value:
  \begin{equation*}
    z_{j,i} = c, \quad i=0,\ldots,n-1 \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $c$ is a scalar and $X$ is an array of $n_v$ vectors.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in \id{X}
  \item[c] (\id{realtype}) constant to set every element in every
    vector of \id{X} to
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

\ucfunctionf{N\_VWrmsNormVectorArray}
{
  ier = N\_VWrmsNormVectorArray(nv, X, W, m);
}
{
  This routine computes the weighted root mean square norm of $n_v$ vectors with
  $n$ elements:
  \begin{equation*}
    m_j = \left( \frac1n \sum_{i=0}^{n-1} \left(x_{j,i} w_{j,i}\right)^2\right)^{1/2}, \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $m$ contains the $n_v$ norms of the vectors in the vector array $X$ with
  corresponding weight vectors $W$.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the vector arrays
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[W] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[m] (\id{realtype*}) an output array of $n_v$ norms
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

\ucfunctionf{N\_VWrmsNormMaskVectorArray}
{
  ier = N\_VWrmsNormMaskVectorArray(nv, X, W, id, m);
}
{
  This routine computes the masked weighted root mean square norm of $n_v$
  vectors with $n$ elements:
  \begin{equation*}
    m_j = \left( \frac1n \sum_{i=0}^{n-1} \left(x_{j,i} w_{j,i}
    H(id_i)\right)^2 \right)^{1/2}, \quad j=0,\ldots,n_v-1,
  \end{equation*}
  $H(id_i)=1$ for $id_i > 0$ and is zero otherwise, $m$ contains the $n_v$
  norms of the vectors in the vector array $X$ with corresponding weight
  vectors $W$ and mask vector $id$.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the vector arrays
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[W] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[id] (\id{N\_Vector}) the mask vector
  \item[m] (\id{realtype*}) an output array of $n_v$ norms
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

\ucfunction{N\_VScaleAddMultiVectorArray}
{
  ier = N\_VScaleAddMultiVectorArray(nv, ns, c, X, YY, ZZ);
}
{
  This routine scales and adds a vector in a vector array of $n_v$ vectors to
  the corresponding vector in $n_s$ vector arrays:
  \begin{equation*}
    z_{j,i} = \sum_{k=0}^{n_s-1} c_k x_{k,j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $c$ is an array of $n_s$ scalars, $X$ is a vector array of $n_v$ vectors
  to be scaled and added to the corresponding vector in each of the $n_s$ vector
  arrays in the array of vector arrays $YY$ and stored in the output array of vector
  arrays $ZZ$.
}
{
  \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the vector arrays
  \item[ns] (\id{int}) the number of scalars in \id{c} and vector arrays
    in \id{YY} and \id{ZZ}
  \item[c] (\id{realtype*}) an array of $n_s$ scalars
  \item[X] (\id{N\_Vector*}) an array of $n_v$ {\nvector} objects
  \item[YY] (\id{N\_Vector**}) an array of $n_s$ {\nvector} arrays
  \item[ZZ] (\id{N\_Vector**}) an output array of $n_s$ {\nvector}
    arrays
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

\ucfunction{N\_VLinearCombinationVectorArray}
{
  ier = N\_VLinearCombinationVectorArray(nv, ns, c, XX, Z);
}
{
  This routine computes the linear combination of $n_s$ vector arrays containing
  $n_v$ vectors with $n$ elements:
  \begin{equation*}
  z_{j,i} = \sum_{k=0}^{n_s-1} c_k x_{k,j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,n_v-1,
  \end{equation*}
  where $c$ is an array of $n_s$ scalars (type \id{realtype*}), $XX$
  (type \id{N\_Vector**}) is an array of $n_s$ vector arrays each containing $n_v$
  vectors to be summed into the output vector array of $n_v$ vectors $Z$ (type
  \id{N\_Vector*}). If the output vector array $Z$ is one of the vector arrays in
  $XX$, then it \textit{must} be the first vector array in $XX$.
}
{
 \begin{args}[nv]
  \item[nv] (\id{int}) the number of vectors in the vector arrays
  \item[ns] (\id{int}) the number of scalars in \id{c} and vector arrays
    in \id{YY} and \id{ZZ}
  \item[c] (\id{realtype*}) an array of $n_s$ scalars
  \item[XX] (\id{N\_Vector**}) an array of $n_s$ {\nvector} arrays
  \item[Z] (\id{N\_Vector*}) an output array {\nvector} objects
  \end{args}
}
{
  Returns an \id{int} with value \id{0} for success and a non-zero value otherwise.
}
{}

% ====================================================================
\subsection{NVECTOR local reduction functions}\label{ss:nveclocalops}

Local reduction operations are intended to reduce parallel
communication on distributed memory systems, particularly when
{\nvector} objects are combined together within a \\
{\nvecmpimanyvector} object (see Section \ref{ss:nvec_mpimanyvector}).  If a
particular {\nvector} implementation defines a local reduction
operation as \id{NULL}, the {\nvecmpimanyvector} module will
automatically call standard vector reduction operations as necessary
to complete the desired operation. All {\sundials}-provided {\nvector}
implementations include these local reduction operations, which may be
used as templates for user-defined {\nvector} implementations.


\ucfunctionf{N\_VDotProdLocal}
{
  d = N\_VDotProdLocal(x, y);
}
{
  This routine computes the MPI task-local portion of the ordinary dot product of \id{x} and \id{y}:
  \begin{equation*}
    d=\sum_{i=0}^{n_{local}-1} x_i y_i,
  \end{equation*}
  where $n_{local}$ corresponds
  to the number of components in the vector on this MPI task (or
  $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[y] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VMaxNormLocal}
{
  m = N\_VMaxNormLocal(x);
}
{
  This routine computes the MPI task-local portion of the maximum norm of the \id{N\_Vector} \id{x}:
  \begin{equation*}
    m = \max_{0\le i< n_{local}} | x_i |,
  \end{equation*}
  where $n_{local}$ corresponds
  to the number of components in the vector on this MPI task (or
  $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VMinLocal}
{
  m = N\_VMinLocal(x);
}
{
  This routine computes the smallest element of the MPI task-local portion of
  the \id{N\_Vector} \id{x}:
  \begin{equation*}
    m = \min_{0\le i< n_{local}} x_i,
  \end{equation*}
  where $n_{local}$ corresponds
  to the number of components in the vector on this MPI task (or
  $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VL1NormLocal}
{
  n = N\_VL1NormLocal(x);
}
{
  This routine computes the MPI task-local portion of the $\ell_1$ norm of the \id{N\_Vector} \id{x}:
  \begin{equation*}
  n = \sum_{i=0}^{n_{local}-1} | x_i |,
  \end{equation*}
  where $n_{local}$ corresponds
  to the number of components in the vector on this MPI task (or
  $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VWSqrSumLocal}
{
  s = N\_VWSqrSumLocal(x,w);
}
{
  This routine computes the MPI task-local portion of the weighted
  squared sum of the \id{N\_Vector} \id{x} with weight vector \id{w}:
  \begin{equation*}
    s = \sum_{i=0}^{n_{local}-1} (x_i w_i)^2,
  \end{equation*}
  where $n_{local}$ corresponds
  to the number of components in the vector on this MPI task (or
  $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[w] (\id{N\_Vector}) a {\nvector} object containing weights
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VWSqrSumMaskLocal}
{
  s = N\_VWSqrSumMaskLocal(x,w,id);
}
{
  This routine computes the MPI task-local portion of the weighted
  squared sum of the \id{N\_Vector} \id{x} with weight
  vector \id{w} built using only the elements of \id{x} corresponding to
  positive elements of the \id{N\_Vector} \id{id}:
  \begin{equation*}
    m = \sum_{i=0}^{n_{local}-1} (x_i w_i H(id_i))^2, \quad \text{where} \quad H(\alpha)
  = \begin{cases} 1 & \alpha > 0 \\ 0 & \alpha \leq 0 \end{cases}
  \end{equation*}
  and
  $n_{local}$ corresponds to the number of components in the vector on
  this MPI task (or $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[w] (\id{N\_Vector}) a {\nvector} object containing weights
  \item[id] (\id{N\_Vector}) a {\nvector} object used as a mask
  \end{args}
}
{
  \id{realtype}
}
{}

\ucfunctionf{N\_VInvTestLocal}
{
  t = N\_VInvTestLocal(x, z);
}
{
  Sets the MPI task-local components of the \id{N\_Vector} \id{z} to
  be the inverses of the components of the \id{N\_Vector} \id{x}, with
  prior testing for zero values:
  \begin{equation*}
  z_i = 1.0 /  x_i  , \: i=0,\ldots,n_{local}-1,
  \end{equation*}
  where $n_{local}$
  corresponds to the number of components in the vector on this MPI task
  (or $n_{local}=n$ for MPI-unaware applications).
}
{
  \begin{args}[x]
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[z] (\id{N\_Vector}) an output {\nvector} object
  \end{args}
}
{
  Returns a \id{booleantype} with the value \id{SUNTRUE} if all task-local
  components of \id{x} are nonzero (successful inversion) and with the
  value \id{SUNFALSE} otherwise.
}
{}

\ucfunctionf{N\_VConstrMaskLocal}
{
  t = N\_VConstrMaskLocal(c,x,m);
}
{
  Performs the following constraint tests:
  {\begin{align*}
  x_i > 0        & \quad \text{if} \quad c_i=2, \\
  x_i \ge 0      & \quad \text{if} \quad c_i=1, \\
  x_i \le 0      & \quad \text{if} \quad c_i=-1, \\
  x_i < 0        & \quad \text{if} \quad c_i=-2, \text{and} \\
  \text{no test} & \quad \text{if} \quad c_i=0,
  \end{align*}}%
  for all MPI task-local components of the vectors.
  It sets a mask vector \id{m}, with elements equal to $1.0$ where
  the constraint test failed, and $0.0$ where the test passed. This
  routine is used only for constraint checking.
}
{
  \begin{args}[c]
  \item[c] (\id{realtype}) scalar constraint value
  \item[x] (\id{N\_Vector}) a {\nvector} object
  \item[m] (\id{N\_Vector}) output mask vector
  \end{args}
}
{
  Returns a \id{booleantype} with the value \id{SUNFALSE} if any
  task-local element failed the constraint test and the value
  \id{SUNTRUE} if all passed.
}
{}

\ucfunctionf{N\_VMinQuotientLocal}
{
  minq = N\_VMinQuotientLocal(num,denom);
}
{
  This routine returns the minimum of the quotients obtained
  by term-wise dividing \id{num}$_i$ by \id{denom}$_i$, for all MPI
  task-local components of the vectors.  A zero element in \id{denom}
  will be skipped. If no such quotients are found, then the large value
  \Id{BIG\_REAL} (defined in the header file \id{sundials\_types.h})
  is returned.
}
{
  \begin{args}[x]
  \item[num] (\id{N\_Vector}) a {\nvector} object used as the numerator
  \item[denom] (\id{N\_Vector}) a {\nvector} object used as the denominator
  \end{args}
}
{
  \id{realtype}
}
{}


% ====================================================================
\subsection{NVECTOR utility functions}\label{ss:nvecutils}

To aid in the creation of custom {\nvector} modules the generic {\nvector}
module provides three  utility functions \id{N\_VNewEmpty}, \id{N\_VCopyOps}
and \id{N\_VFreeEmpty}. When used in custom {\nvector} constructors and clone
routines these functions will ease the introduction of any new optional vector
operations to the {\nvector} API by ensuring only required operations need to
be set and all operations are copied when cloning a vector.

To aid the use of arrays of {\nvector} objects, the generic {\nvector} module
also provides the utility functions \ID{N\_VCloneVectorArray},
\ID{N\_VCloneVectorArrayEmpty}, and \ID{N\_VDestroyVectorArray}.


\ucfunctionf{N\_VNewEmpty}
{
  v = N\_VNewEmpty();
}
{
  The function \Id{N\_VNewEmpty} allocates a new generic {\nvector} object and
  initializes its content pointer and the function pointers in the operations
  structure to \id{NULL}.
}
{}
{
  This function returns an \id{N\_Vector} object. If an error occurs when
  allocating the object, then this routine will return \id{NULL}.
}
{}
{}

\ucfunctionf{N\_VCopyOps}
{
  retval = N\_VCopyOps(w, v);
}
{
  The function \Id{N\_VCopyOps} copies the function pointers in the \id{ops}
  structure of \id{w} into the \id{ops} structure of \id{v}.
}
{
  \begin{args}[w]
  \item[w] (\id{N\_Vector}) the vector to copy operations from
  \item[v] (\id{N\_Vector}) the vector to copy operations to
  \end{args}
}
{
  This returns \id{0} if successful and a non-zero value if either of the inputs
  are \id{NULL} or the \id{ops} structure of either input is \id{NULL}.
}
{}

\ucfunctionf{N\_VFreeEmpty}
{
  N\_VFreeEmpty(v);
}
{
  This routine frees the generic \id{N\_Vector} object, under the assumption that any
  implementation-specific data that was allocated within the underlying content structure
  has already been freed. It will additionally test whether the ops pointer is \id{NULL},
  and, if it is not, it will free it as well.
}
{
  \begin{args}[v]
  \item[v] (\id{N\_Vector})
  \end{args}
}
{}
{}

\ucfunction{N\_VCloneEmptyVectorArray}
{
  vecarray = N\_VCloneEmptyVectorArray(count, w);
}
{
  Creates an array of \id{count} variables of type \id{N\_Vector},
  each of the same type as the existing \id{N\_Vector} w. It achieves
  this by calling the implementation-specific \id{N\_VCloneEmpty} operation.
}
{
  \begin{args}[count]
  \item[count] (\id{int}) the size of the vector array
  \item[w] (\id{N\_Vector}) the vector to clone
  \end{args}
}
{
  Returns an array of \id{count} \id{N\_Vector} objects if successful, or
  \id{NULL} if an error occurred while cloning.
}
{}

\ucfunction{N\_VCloneVectorArray}
{
  vecarray = N\_VCloneVectorArray(count, w);
}
{
  Creates an array of \id{count} variables of type \id{N\_Vector},
  each of the same type as the existing \id{N\_Vector} w. It achieves
  this by calling the implementation-specific \id{N\_VClone} operation.
}
{
  \begin{args}[count]
  \item[count] (\id{int}) the size of the vector array
  \item[w] (\id{N\_Vector}) the vector to clone
  \end{args}
}
{
  Returns an array of \id{count} \id{N\_Vector} objects if successful, or
  \id{NULL} if an error occurred while cloning.
}
{}

\ucfunction{N\_VDestroyVectorArray}
{
   N\_VDestroyVectorArray(count, w);
}
{
  Destroys (frees) an array of variables of type \id{N\_Vector}. It
  depends on the implementation-specific \id{N\_VDestroy} operation.
}
{
  \begin{args}[count]
  \item[vs] (\id{N\_Vector*}) the array of vectors to destroy
  \item[count] (\id{int}) the size of the vector array
  \end{args}
}
{}
{}


% ====================================================================
\subsection{NVECTOR identifiers}
\label{ss:nvecIDs}

Each {\nvector} implementation included in {\sundials} has a
unique identifier specified in enumeration and shown in Table \ref{t:vectorIDs}.

\begin{table}
\centering
\caption{Vector Identifications associated with vector kernels supplied with \id{\sundials}.}
\label{t:vectorIDs}
\medskip
\begin{tabular}{|l|l|c|}
\hline
{\bf Vector ID} & {\bf Vector type} & {\bf ID Value} \\
\hline
SUNDIALS\_NVEC\_SERIAL        & Serial                                        & 0 \\
SUNDIALS\_NVEC\_PARALLEL      & Distributed memory parallel (MPI)             & 1 \\
SUNDIALS\_NVEC\_OPENMP        & OpenMP shared memory parallel                 & 2 \\
SUNDIALS\_NVEC\_PTHREADS      & PThreads shared memory parallel               & 3 \\
SUNDIALS\_NVEC\_PARHYP        & {\hypre} ParHyp parallel vector               & 4 \\
SUNDIALS\_NVEC\_PETSC         & {\petsc} parallel vector                      & 5 \\
SUNDIALS\_NVEC\_CUDA          & {\cuda} parallel vector                       & 6 \\
SUNDIALS\_NVEC\_RAJA          & {\raja} parallel vector                       & 7 \\
SUNDIALS\_NVEC\_OPENMPDEV     & OpenMP parallel vector with device offloading & 8 \\
SUNDIALS\_NVEC\_TRILINOS      & {\trilinos} Tpetra vector                     & 9 \\
SUNDIALS\_NVEC\_MANYVECTOR    & ``ManyVector'' vector                         & 10 \\
SUNDIALS\_NVEC\_MPIMANYVECTOR & MPI-enabled ``ManyVector'' vector             & 11 \\
SUNDIALS\_NVEC\_MPIPLUSX      & MPI+X vector                                  & 12 \\
SUNDIALS\_NVEC\_CUSTOM        & User-provided custom vector                   & 13 \\
\hline
\end{tabular}
\end{table}


% ====================================================================
\subsection{The generic NVECTOR module implementation}
\label{ss:nvec_impl_details}

The generic \ID{N\_Vector} type is a pointer to a structure that has an
implementation-dependent {\em content} field containing the
description and actual data of the vector, and an {\em ops} field
pointing to a structure with generic vector operations.
The type \id{N\_Vector} is defined as
%%
%%
\begin{verbatim}
typedef struct _generic_N_Vector *N_Vector;

struct _generic_N_Vector {
    void *content;
    struct _generic_N_Vector_Ops *ops;
};
\end{verbatim}
%%
%%
The \id{\_generic\_N\_Vector\_Ops} structure is essentially a list of pointers to
the various actual vector operations, and is defined as
%%
\begin{verbatim}
struct _generic_N_Vector_Ops {
  N_Vector_ID  (*nvgetvectorid)(N_Vector);
  N_Vector     (*nvclone)(N_Vector);
  N_Vector     (*nvcloneempty)(N_Vector);
  void         (*nvdestroy)(N_Vector);
  void         (*nvspace)(N_Vector, sunindextype *, sunindextype *);
  realtype*    (*nvgetarraypointer)(N_Vector);
  void         (*nvsetarraypointer)(realtype *, N_Vector);
  void*        (*nvgetcommunicator)(N_Vector);
  sunindextype (*nvgetlength)(N_Vector);
  void         (*nvlinearsum)(realtype, N_Vector, realtype, N_Vector, N_Vector);
  void         (*nvconst)(realtype, N_Vector);
  void         (*nvprod)(N_Vector, N_Vector, N_Vector);
  void         (*nvdiv)(N_Vector, N_Vector, N_Vector);
  void         (*nvscale)(realtype, N_Vector, N_Vector);
  void         (*nvabs)(N_Vector, N_Vector);
  void         (*nvinv)(N_Vector, N_Vector);
  void         (*nvaddconst)(N_Vector, realtype, N_Vector);
  realtype     (*nvdotprod)(N_Vector, N_Vector);
  realtype     (*nvmaxnorm)(N_Vector);
  realtype     (*nvwrmsnorm)(N_Vector, N_Vector);
  realtype     (*nvwrmsnormmask)(N_Vector, N_Vector, N_Vector);
  realtype     (*nvmin)(N_Vector);
  realtype     (*nvwl2norm)(N_Vector, N_Vector);
  realtype     (*nvl1norm)(N_Vector);
  void         (*nvcompare)(realtype, N_Vector, N_Vector);
  booleantype  (*nvinvtest)(N_Vector, N_Vector);
  booleantype  (*nvconstrmask)(N_Vector, N_Vector, N_Vector);
  realtype     (*nvminquotient)(N_Vector, N_Vector);
  int          (*nvlinearcombination)(int, realtype*, N_Vector*, N_Vector);
  int          (*nvscaleaddmulti)(int, realtype*, N_Vector, N_Vector*, N_Vector*);
  int          (*nvdotprodmulti)(int, N_Vector, N_Vector*, realtype*);
  int          (*nvlinearsumvectorarray)(int, realtype, N_Vector*, realtype,
                                         N_Vector*, N_Vector*);
  int          (*nvscalevectorarray)(int, realtype*, N_Vector*, N_Vector*);
  int          (*nvconstvectorarray)(int, realtype, N_Vector*);
  int          (*nvwrmsnomrvectorarray)(int, N_Vector*, N_Vector*, realtype*);
  int          (*nvwrmsnomrmaskvectorarray)(int, N_Vector*, N_Vector*, N_Vector,
                                            realtype*);
  int          (*nvscaleaddmultivectorarray)(int, int, realtype*, N_Vector*,
                                             N_Vector**, N_Vector**);
  int          (*nvlinearcombinationvectorarray)(int, int, realtype*, N_Vector**,
                                                 N_Vector*);
  realtype     (*nvdotprodlocal)(N_Vector, N_Vector);
  realtype     (*nvmaxnormlocal)(N_Vector);
  realtype     (*nvminlocal)(N_Vector);
  realtype     (*nvl1normlocal)(N_Vector);
  booleantype  (*nvinvtestlocal)(N_Vector, N_Vector);
  booleantype  (*nvconstrmasklocal)(N_Vector, N_Vector, N_Vector);
  realtype     (*nvminquotientlocal)(N_Vector, N_Vector);
  realtype     (*nvwsqrsumlocal)(N_Vector, N_Vector);
  realtype     (*nvwsqrsummasklocal(N_Vector, N_Vector, N_Vector);

};
\end{verbatim}

The generic {\nvector} module defines and implements the vector operations
acting on an \id{N\_Vector}. These routines are nothing but wrappers for
the vector operations defined by a particular {\nvector} implementation,
which are accessed through the {\em ops} field of the \id{N\_Vector}
structure. To illustrate this point we show below the implementation of a
typical vector operation from the generic {\nvector} module, namely \id{N\_VScale},
which performs the scaling of a vector \id{x} by a scalar \id{c}:
%%
%%
\begin{verbatim}
void N_VScale(realtype c, N_Vector x, N_Vector z)
{
   z->ops->nvscale(c, x, z);
}
\end{verbatim}
%%
%%
Section \ref{ss:nvecops} defines a complete list of all standard vector operations
defined by the generic {\nvector} module. Sections \ref{ss:nvecfusedops},
\ref{ss:nvecarrayops} and \ref{ss:nveclocalops} list \textit{optional} fused,
vector array and local reduction operations, respectively.


The Fortran 2003 interface provides a \id{bind(C)} derived-type for the
\id{\_generic\_N\_Vector} and the \id{\_generic\_N\_Vector\_Ops} structures.
Their definition is given below.
%%
%%
\begin{verbatim}
 type, bind(C), public :: N_Vector
  type(C_PTR), public :: content
  type(C_PTR), public :: ops
 end type N_Vector

 type, bind(C), public :: N_Vector_Ops
  type(C_FUNPTR), public :: nvgetvectorid
  type(C_FUNPTR), public :: nvclone
  type(C_FUNPTR), public :: nvcloneempty
  type(C_FUNPTR), public :: nvdestroy
  type(C_FUNPTR), public :: nvspace
  type(C_FUNPTR), public :: nvgetarraypointer
  type(C_FUNPTR), public :: nvsetarraypointer
  type(C_FUNPTR), public :: nvgetcommunicator
  type(C_FUNPTR), public :: nvgetlength
  type(C_FUNPTR), public :: nvlinearsum
  type(C_FUNPTR), public :: nvconst
  type(C_FUNPTR), public :: nvprod
  type(C_FUNPTR), public :: nvdiv
  type(C_FUNPTR), public :: nvscale
  type(C_FUNPTR), public :: nvabs
  type(C_FUNPTR), public :: nvinv
  type(C_FUNPTR), public :: nvaddconst
  type(C_FUNPTR), public :: nvdotprod
  type(C_FUNPTR), public :: nvmaxnorm
  type(C_FUNPTR), public :: nvwrmsnorm
  type(C_FUNPTR), public :: nvwrmsnormmask
  type(C_FUNPTR), public :: nvmin
  type(C_FUNPTR), public :: nvwl2norm
  type(C_FUNPTR), public :: nvl1norm
  type(C_FUNPTR), public :: nvcompare
  type(C_FUNPTR), public :: nvinvtest
  type(C_FUNPTR), public :: nvconstrmask
  type(C_FUNPTR), public :: nvminquotient
  type(C_FUNPTR), public :: nvlinearcombination
  type(C_FUNPTR), public :: nvscaleaddmulti
  type(C_FUNPTR), public :: nvdotprodmulti
  type(C_FUNPTR), public :: nvlinearsumvectorarray
  type(C_FUNPTR), public :: nvscalevectorarray
  type(C_FUNPTR), public :: nvconstvectorarray
  type(C_FUNPTR), public :: nvwrmsnormvectorarray
  type(C_FUNPTR), public :: nvwrmsnormmaskvectorarray
  type(C_FUNPTR), public :: nvscaleaddmultivectorarray
  type(C_FUNPTR), public :: nvlinearcombinationvectorarray
  type(C_FUNPTR), public :: nvdotprodlocal
  type(C_FUNPTR), public :: nvmaxnormlocal
  type(C_FUNPTR), public :: nvminlocal
  type(C_FUNPTR), public :: nvl1normlocal
  type(C_FUNPTR), public :: nvinvtestlocal
  type(C_FUNPTR), public :: nvconstrmasklocal
  type(C_FUNPTR), public :: nvminquotientlocal
  type(C_FUNPTR), public :: nvwsqrsumlocal
  type(C_FUNPTR), public :: nvwsqrsummasklocal
 end type N_Vector_Ops
\end{verbatim}

% =====================================================================
\subsection{Implementing a custom NVECTOR}
\label{ss:nvector_custom_implmentation}

A particular implementation of the {\nvector} module must:

\begin{itemize}
\item Specify the {\em content} field of \id{N\_Vector}.
\item Define and implement the vector operations.
  Note that the names of these routines should be unique to that implementation in order
  to permit using more than one {\nvector} module (each with different \id{N\_Vector}
  internal data representations) in the same code.
\item Define and implement user-callable constructor and destructor
  routines to create and free an \id{N\_Vector} with
  the new {\em content} field and with {\em ops} pointing to the
  new vector operations.
\item Optionally, define and implement additional user-callable routines
  acting on the newly defined \id{N\_Vector} (e.g., a routine to print
  the content for debugging purposes).
\item Optionally, provide accessor macros as needed for that particular implementation to
  be used to access different parts in the {\em content} field of the newly defined \id{N\_Vector}.
\end{itemize}

It is recommended that a user-supplied {\nvector} implementation returns the
\id{SUNDIALS\_NVEC\_CUSTOM} identifier from the \id{N\_VGetVectorID} function.

To aid in the creation of custom {\nvector} modules the generic {\nvector}
module provides two utility functions \id{N\_VNewEmpty} and \id{N\_VCopyOps}.
When used in custom {\nvector} constructors and clone routines these functions
will ease the introduction of any new optional vector operations to the
{\nvector} API by ensuring only required operations need to be set and all
operations are copied when cloning a vector.


\subsubsection{Support for complex-valued vectors}

While {\sundials} itself is written under an assumption of real-valued
data, it does provide limited support for complex-valued problems.
However, since none of the built-in {\nvector} modules supports
complex-valued data, users must provide a custom {\nvector}
implementation for this task.  Many of the {\nvector} routines
described in Sections \ref{ss:nvecops}-\ref{ss:nveclocalops} above
naturally extend to complex-valued vectors; however, some do not.  To
this end, we provide the following guidance:

\begin{itemize}
\item \id{N\_VMin} and \id{N\_VMinLocal} should return the minimum of
  all \emph{real} components of the vector, i.e.,  $m = \min_i
  \operatorname{real}(x_i) $.

\item \id{N\_VConst} (and similarly \id{N\_VConstVectorArray}) should
  set the real components of the vector to the input constant, and set
  all imaginary components to zero, i.e.,
  $z_i = c + 0 j,\: i=0,\ldots,n-1$.

\item \id{N\_VAddConst} should only update the real components of the
  vector with the input constant, leaving all imaginary components
  unchanged.

\item \id{N\_VWrmsNorm}, \id{N\_VWrmsNormMask}, \id{N\_VWSqrSumLocal}
  and \id{N\_VWSqrSumMaskLocal} should assume that all entries of the
  weight vector \id{w} and the mask vector \id{id} are real-valued.

\item \id{N\_VDotProd} should mathematically return a complex number
  for complex-valued vectors; as this is not possible with
  {\sundials}' current \id{realtype}, this routine should
  be set to \id{NULL} in the custom {\nvector} implementation.

\item \id{N\_VCompare}, \id{N\_VConstrMask}, \id{N\_VMinQuotient},
  \id{N\_VConstrMaskLocal} and \id{N\_VMinQuotientLocal}
  are ill-defined due to the lack of a clear ordering in the
  complex plane.  These routines should be set to \id{NULL}
  in the custom {\nvector} implementation.

\end{itemize}

While many {\sundials} solver modules may be utilized on
complex-valued data, others cannot.  Specifically, although both
{\sunnonlinsolnewton} and {\sunnonlinsolfixedpoint} may be used with
any of the IVP solvers ({\cvode}, {\cvodes}, {\ida}, {\idas} and
{\arkode}) for complex-valued problems, the Anderson-acceleration
feature {\sunnonlinsolfixedpoint} cannot be used due to its reliance
on \id{N\_VDotProd}.  By this same logic, the Anderson acceleration
feature within {\kinsol} also will not work with complex-valued
vectors.

Similarly, although each package's linear solver interface (e.g.,
{\cvls}) may be used on complex-valued problems, none of the built-in
{\sunmatrix} or {\sunlinsol} modules work.  Hence a complex-valued
user should provide a custom {\sunlinsol} (and optionally a custom
{\sunmatrix}) implementation for solving linear systems, and then
attach this module as normal to the package's linear solver
interface.

Finally, constraint-handling features of each package cannot be used
for complex-valued data, due to the issue of
ordering in the complex plane discussed above with
\id{N\_VCompare}, \id{N\_VConstrMask}, \id{N\_VMinQuotient},
\id{N\_VConstrMaskLocal} and \id{N\_VMinQuotientLocal}.

We provide a simple example of a complex-valued example problem,
including a custom complex-valued Fortran 2003 {\nvector} module, in the
files
\newline\noindent\id{examples/arkode/F2003\_custom/ark\_analytic\_complex\_f2003.f90},
\newline\noindent\id{examples/arkode/F2003\_custom/fnvector\_complex\_mod.f90}, and
\newline\noindent\id{examples/arkode/F2003\_custom/test\_fnvector\_complex\_mod.f90}.

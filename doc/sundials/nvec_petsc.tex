% This is a shared SUNDIALS TEX file with description of
% the PETSc nvector wrapper implementation
%
The {\nvecpetsc} module is an {\nvector} wrapper around the {\petsc} vector.
It defines the {\em content} field of a \id{N\_Vector} to be a structure containing
the global and local lengths of the vector, a pointer to the {\petsc} vector,
an {\mpi} communicator, and a boolean flag {\em own\_data} indicating ownership of 
the wrapped {\petsc} vector.
%%
\begin{verbatim} 
struct _N_VectorContent_Petsc {
  long int local_length;
  long int global_length;
  booleantype own_data;
  Vec *pvec;
  MPI_Comm comm;
};
\end{verbatim}
%%
%%--------------------------------------------

The header file to be included when using this module is \id{nvector\_petsc.h}.
Unlike native {\sundials} vector types, {\nvecpetsc} does not provide macros 
to access its member variables.
Note that {\nvecpetsc} requires {\sundials} to be built with {\mpi} support.


%%
%%--------------------------------------------
%%
The {\nvecpetsc} module defines implementations of all vector operations listed 
in Table \ref{t:nvecops}, except for \verb|N_VGetArrayPointer| and 
\verb|N_VSetArrayPointer|. As such, this vector cannot be used with {\sundials} Fortran interfaces.
When access to raw vector data is needed, it is 
recommended to extract the {\petsc} vector first, and then use {\petsc} 
methods to access the data. Usage examples of {\nvecpetsc} are provided in 
example programs for {\ida} \cite{ida_ex}.

The names of vector operations are obtained from those in 
Table \ref{t:nvecops} by appending the suffix \id{\_petsc} (e.g. \id{N\_VDestroy\_Petsc}).
The module {\nvecpetsc}  provides the following additional user-callable routines:
%%
%%
\begin{itemize}

  
%%--------------------------------------

\item \ID{N\_VNewEmpty\_Petsc}
 
  This function creates a new {\nvector} wrapper with the pointer to
  the wrapped {\petsc} vector set to (\id{NULL}). It is used by the 
  \id{N\_VMake\_Petsc} and \id{N\_VClone\_Petsc} implementations. 

\begin{verbatim}
N_Vector N_VNewEmpty_Petsc(MPI_Comm comm, 
                           long int local_length, 
                           long int global_length);
\end{verbatim}

  
%%--------------------------------------

\item \ID{N\_VMake\_Petsc}
  
  This function creates and allocates memory for an {\nvecpetsc}
  wrapper around a user-provided {\petsc} vector. It does {\em not} 
  allocate memory for the vector \id{pvec} itself.

\begin{verbatim}
N_Vector N_VMake_Petsc(Vec *pvec);
\end{verbatim}

%%--------------------------------------

\item \ID{N\_VGetVector\_Petsc}
  
  This function returns a pointer to the underlying {\petsc} vector.

\begin{verbatim}
Vec *N_VGetVector_Petsc(N_Vector v);
\end{verbatim}

%%--------------------------------------


\item \ID{N\_VCloneVectorArray\_Petsc}
 
  This function creates (by cloning) an array of \id{count} {\nvecpetsc} vectors.
 
\begin{verbatim}
N_Vector *N_VCloneVectorArray_Petsc(int count, N_Vector w);
\end{verbatim}

%%--------------------------------------

\item \ID{N\_VCloneVectorArrayEmpty\_Petsc}
 
  This function creates (by cloning) an array of \id{count} {\nvecpetsc} vectors,
  each with pointers to {\petsc} vectors set to (\id{NULL}).
 
\begin{verbatim}
N_Vector *N_VCloneEmptyVectorArray_Petsc(int count, N_Vector w);
\end{verbatim}

%%--------------------------------------

\item \ID{N\_VDestroyVectorArray\_Petsc}
 
 This function frees memory allocated for the array of \id{count} variables of
 type \id{N\_Vector} created with \id{N\_VCloneVectorArray\_Petsc} or with
 \id{N\_VCloneVectorArrayEmpty\_Petsc}.
 

 \verb|void N_VDestroyVectorArray_Petsc(N_Vector *vs, int count);|


%%--------------------------------------

\item \ID{N\_VPrint\_Petsc}
  
  This function prints the content of a wrapped {\petsc} vector to stdout.
 
    
  \verb|void N_VPrint_Petsc(N_Vector v);|


\end{itemize}
%%
%%------------------------------------
%%
\paragraph{\bf Notes} 
           
\begin{itemize}
                                        
\item
  When there is a need to access components of an \id{N\_Vector\_Petsc}, \id{v}, 
  it is recommeded to extract the {\petsc} vector via       
  \id{x\_vec = N\_VGetVector\_Petsc(v)} and then access components using 
  appropriate {\petsc} functions.        
                                                               
\item
  {\warn}The functions \id{N\_VNewEmpty\_Petsc}, \id{N\_VMake\_Petsc}, and
  \id{N\_VCloneVectorArrayEmpty\_Petsc} set the field {\em own\_data} to \id{FALSE}.   
  \id{N\_VDestroy\_Petsc} and \id{N\_VDestroyVectorArray\_Petsc}
  will not attempt to free the pointer {\em pvec} for any \id{N\_Vector} with
  {\em own\_data} set to \id{FALSE}. In such a case, it is the user's responsibility to
  deallocate the {\em pvec} pointer.

\item
  {\warn}To maximize efficiency, vector operations in the {\nvecpetsc} implementation
  that have more than one \id{N\_Vector} argument do not check for
  consistent internal representations of these vectors. It is the user's 
  responsibility to ensure that such routines are called with \id{N\_Vector}
  arguments that were all created with the same internal representations.

\end{itemize}


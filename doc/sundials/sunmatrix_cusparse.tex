%% This is a shared SUNDIALS TEX file with a description of the
%% cuSPARSE SUNMatrix implementation.
%%
\section{The SUNMatrix\_cuSparse implementation}\label{ss:sunmat_cusparse}

The \id{SUNMATRIX\_CUSPARSE} implementation of the \id{SUNMatrix} module provided with
{\sundials}, is an interface to the NVIDIA cuSPARSE matrix for use on NVIDIA GPUs
\cite{cuSPARSE}. All data stored by this matrix implementation resides on the
GPU at all times. The implementation currently supports the cuSPARSE CSR matrix
format described in the cuSPARSE documentation as well as a unique low-storage
format for block-diagonal matrices of the form
\begin{equation*}
  \mathbf{A} =
  \begin{bmatrix}
    \mathbf{A_1} & 0 & \cdots & 0\\
    0 & \mathbf{A_2} & \cdots & 0\\
    \vdots & \vdots & \ddots & \vdots\\
    0 & 0 & \cdots & \mathbf{A_n}\\
  \end{bmatrix}
\end{equation*}
where all the block matrices $A_j$ share the same sparsity pattern.
We will refer to this format as BCSR (not to be confused with the canonical BSR format where
each block is stored as dense). In this format, the CSR column indices and row pointers
are only stored for the first block and are computed only as necessary for other blocks.
This can drastically reduce the amount of storage required compared to the regular CSR
format when there is a large number of blocks. This format is well-suited for, and
intended to be used with the \ref{ss:sunlinsol_cuspbqr}.

\noindent The header file to include when using this module is
\id{sunmatrix/sunmatrix\_cusparse.h}. The installed library to link to is
\id{libsundials\_sunmatrixcusparse.\textit{lib}} where \id{\em.lib} is typically \id{.so}
for shared libraries and \id{.a} for static libraries.
\newline
\newline
{\warn}The \id{SUNMatrix\_cuSparse} module is experimental and subject to change.

% ====================================================================
\subsection{SUNMatrix\_cuSparse functions}
\label{ss:sunmat_cusparse_functions}
% ====================================================================

The \id{SUNMATRIX\_CUSPARSE} module defines GPU-enabled sparse implementations of all matrix
operations listed in the section :ref:`SUNMatrix.Ops` except for the ``SUNMatSpace``
and ``SUNMatMatvecSetup`` operations:

\begin{enumerate}
  \item \id{SUNMatGetID\_cuSparse} -- returns \id{SUNMATRIX\_CUSPARSE}
  \item \id{SUNMatClone\_cuSparse}
  \item \id{SUNMatDestroy\_cuSparse}
  \item \id{SUNMatZero\_cuSparse}
  \item \id{SUNMatCopy\_cuSparse}
  \item \id{SUNMatScaleAdd\_cuSparse} -- performs $A = cA + B$, where $A$ and $B$
    must have the same sparsity pattern
  \item \id{SUNMatScaleAddI\_cuSparse} -- performs $A = cA + I$, where the diagonal
    of $A$ must be present
  \item \id{SUNMatMatvec\_cuSparse}
\end{enumerate}


In addition, the SUNMATRIX\_CUSPARSE module defines the following implementation specific
functions:

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_NewCSR}
{
  A = SUNMatrix\_cuSparse\_NewCSR(M, N, NNZ, cusp)
}
{
  This constructor function creates and allocates memory for a \id{SUMATRIX\_CUSPARSE}
  \id{SUNMatrix} that uses the CSR storage format.
}
{
  \begin{args}
  \item[M] (\id{int}) the number of matrix rows
  \item[N] (\id{int}) the number of matrix columns
  \item[NNZ] (\id{int}) the number of matrix nonzeros
  \item[cusp] (\id{cusparseHandle\_t}) a valid \id{cusparseHandle\_t}
  \end{args}
}
{
  a \id{SUNMatrix} object if successful else \id{NULL}
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_NewBlockCSR}
{
  A = SUNMatrix\_cuSparse\_NewBlockCSR(nblocks, blockrows, blockcols, blocknnz, cusp)
}
{
  This constructor function creates and allocates memory for a \id{SUMATRIX\_CUSPARSE}
  \id{SUNMatrix} that leverages the \id{SUNMAT\_CUSPARSE\_BCSR} storage
  format to store a block diagonal matrix where each block shares the same
  sparsity pattern. \textbf{The blocks must be square.}
}
{
  \begin{args}
  \item[nblocks] (\id{int}) the number of matrix blocks
  \item[blockrows] (\id{int}) the number of rows for a block
  \item[blockcols] (\id{int}) the number of columns for a block
  \item[blocknnz] (\id{int}) the number of nonzeros in a block
  \item[cusp] a valid \id{cusparseHandle\_t}
  \end{args}
}
{
  a \id{SUNMatrix} object if successful else \id{NULL}
}
{
  The \id{SUNMAT\_CUSPARSE\_BCSR} format currently only supports square matrices.
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_MakeCSR}
{
  A = SUNMatrix\_cuSparse\_MakeCSR(mat\_descr, M, N, NNZ, rowptrs, colind, data, cusp)
}
{
  This constructor function creates and allocates memory for a \id{SUMATRIX\_CUSPARSE}
  \id{SUNMatrix} that uses the CSR storage format from the user provided pointers.
}
{
  \begin{args}
  \item[mat\_decsr] a valid \id{cusparseMatDescr\_t} object;
    must use \id{CUSPARSE\_INDEX\_BASE\_ZERO} indexing
  \item[M] (\id{int}) the number of matrix rows
  \item[N] (\id{int}) the number of matrix columns
  \item[NNZ] (\id{int}) the number of matrix nonzeros
  \item[rowptrs] (\id{int*})a contiguous array of the CSR row pointers
  \item[colind] (\id{int*}) a contiguous array of the CSR column indices
  \item[data] (\id{realtype*}) a contiguous array of the nonzero data
  \item[cusp] (\id{cusparseHandle\_t}) a valid \id{cusparseHandle\_t}
  \end{args}
}
{
  a \id{SUNMatrix} object if successful else \id{NULL}
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_Rows}
{
  M = SUNMatrix\_cuSparse\_Rows(A)
}
{
  This function returns the number of rows in the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of rows in the sparse \id{SUNMatrix}
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_Columns}
{
  N = SUNMatrix\_cuSparse\_Columns(A)
}
{
  This function returns the number of columns in the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of columns in the sparse \id{SUNMatrix}
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_NNZ}
{
  nnz = SUNMatrix\_cuSparse\_NNZ(A)
}
{
  This function returns the number of nonzeros in the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of nonzeros in the sparse \id{SUNMatrix}
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_SparseType}
{
  type = SUNMatrix\_cuSparse\_SparseType(A)
}
{
  This function returns the sparsity format for the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the \id{SUNMAT\_CUSPARSE\_CSR} or \id{SUNMAT\_CUSPARSE\_BCSR} sparsity formats
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_IndexValues}
{
  colind = SUNMatrix\_cuSparse\_IndexValues(A)
}
{
  This function returns a pointer to the index value array for the sparse
  \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  for the CSR format this is an array of the column indices for each nonzero
  entry. For the BCSR format this is an array of the column indices
  for each nonzero entry in the first block only.
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_IndexPointers}
{
  rowptrs = SUNMatrix\_cuSparse\_IndexPointers(A)
}
{
  This function returns a pointer to the index pointers array for the
  sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  for the CSR format this is an array of the locations
  of the first entry of each row in the \id{data} and \id{indexvalues} arrays,
  for the BCSR format this is an array of the locations of each row in the
  \id{data} and \id{indexvalues} arrays in the first block only.
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_NumBlocks}
{
  nblocks = SUNMatrix\_cuSparse\_NumBlocks(A)
}
{
  This function returns the number of blocks in the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of matrix blocks
}
{
}


%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_BlockRows}
{
  blockrows = SUNMatrix\_cuSparse\_BlockRows(A)
}
{
  This function returns the number of rows of a
  block of the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of rows of a block
}
{
}


%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_BlockColumns}
{
  blockrows = SUNMatrix\_cuSparse\_BlockColumns(A)
}
{
  This function returns the number of columns of a
  block of the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of columns of a block
}
{
}


%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_BlockNNZ}
{
  blockdim = SUNMatrix\_cuSparse\_BlockNNZ(A)
}
{
  This function returns the nonzeros of a block of the sparse \id{SUNMatrix}.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \end{args}
}
{
  the number of nonzeros of a block
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_BlockData}
{
  nzdata = SUNMatrix\_cuSparse\_BlockData(A, blockidx)
}
{
  This function returns a pointer to the start of the nonzero values
  in the data array for given block index. The first block in the
  \id{SUNMatrix} is index 0, the second block is index 1, and so on.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \item[blockidx] (\id{int}) the index of the desired block
  \end{args}
}
{
  a pointer to the start of the nonzero values in the data array for given
  block index
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_CopyToDevice}
{
  retval = SUNMatrix\_cuSparse\_CopyToDevice(A, h\_data, h\_idxptrs, h\_idxvals)
}
{
  This functions copies the matrix information to the GPU device from the provided
  host arrays.  A user may provide \id{NULL} for any of \id{h\_data}, \id{h\_idxptrs}, or
  \id{h\_idxvals} to avoid copying that information.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \item[h\_data] (\id{realtype*}) a pointer to an allocated array of
    at least \id{SUNMatrix\_cuSparse\_NNZ(A)*sizeof(realtype)} bytes;
    the nonzero values will be copied from this array onto the device
  \item[h\_idxptrs] (\id{int*}) a pointer to an allocated array of
    at least \id{(SUNMatrix\_cuSparse\_BlockDim(A)+1)*sizeof(int)} bytes;
    the index pointers will be copied from this array onto the device
  \item[h\_idxvals] (\id{int*}) a pointer to an allocated array of
    at least \id{SUNMatrix\_cuSparse\_BlockNNZ(A)*sizeof(int)} bytes;
    the index values will be copied from this array onto the device
  \end{args}
}
{
  \id{SUNMAT\_SUCCESS} if the copy operation(s) were successful, or a nonzero error
  code otherwise.
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_CopyFromDevice}
{
  retval = SUNMatrix\_cuSparse\_CopyFromDevice(A, h\_data, h\_idxptrs, h\_idxvals)
}
{
  This functions copies the matrix information from the GPU device to the provided
  host arrays. A user may provide \id{NULL} for any of \id{h\_data}, \id{h\_idxptrs}, or
  \id{h\_idxvals} to avoid copying that information.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \item[h\_data] (\id{realtype*}) a pointer to an allocated array of
    at least \id{SUNMatrix\_cuSparse\_NNZ(A)*sizeof(realtype)} bytes;
    the nonzero values will be copied into this array from the device
  \item[h\_idxptrs] (\id{int*}) a pointer to an allocated array of
    at least \id{(SUNMatrix\_cuSparse\_BlockDim(A)+1)*sizeof(int)} bytes;
    the index pointers will be copied into this array from the device
  \item[h\_idxvals] (\id{int*}) a pointer to an allocated array of
    at least \id{SUNMatrix\_cuSparse\_BlockNNZ(A)*sizeof(int)} bytes;
    the index values will be copied into this array from the device
  \end{args}
}
{
  \id{SUNMAT\_SUCCESS} if the copy operation(s) were successful, or a nonzero error
  code otherwise.
}
{
}

%%--------------------------------------
%%
\ucfunction{SUNMatrix\_cuSparse\_SetFixedPattern}
{
  retval = SUNMatrix\_cuSparse\_SetFixedPattern(A, yesno)
}
{
  This function changes the behavior of the the \id{SUNMatZero} operation on
  the \id{SUNMatrix} object \id{A}. By default the matrix sparsity pattern
  is not considered to be fixed, thus, the \id{SUNMatZero} operation zeros out
  all \id{data} array as well as the \id{indexvalues} and \id{indexpointers} arrays.
  Providing a value of \id{1} or \id{SUNTRUE} for the  \id{yesno} argument changes
  the behavior of \id{SUNMatZero} on \id{A} so that only the data is zeroed out, but
  not the \id{indexvalues} or \id{indexpointers} arrays. Providing a value of \id{0}
  or \id{SUNFALSE} for the \id{yesno} argument is equivalent to the default behavior.
}
{
  \begin{args}
  \item[A] (\id{SUNMatrix})
  \item[yesno] (\id{booleantype})
  \end{args}
}
{
  \id{SUNMAT\_SUCCESS} if the operation(s) were successful, or a nonzero error
  code otherwise.
}
{
}

% ====================================================================
\subsection{SUNMatrix\_cuSparse Usage Notes}
\label{ss:sunmat_cusparse_notes}
% ====================================================================

The \id{SUNMATRIX\_CUSPARSE} module only supports 32-bit indexing,
thus {\sundials} must be built for 32-bit indexing to use this module.

The \id{SUNMATRIX\_CUSPARSE} module can be used with CUDA streams by
calling the cuSPARSE function \id{cusparseSetStream} on the the
\id{cusparseHandle\_t} that is provided to the \id{SUNMATRIX\_CUSPARSE}
constructor.

{\warn} When using the \id{SUNMATRIX\_CUSPARSE} module with a {\sundials}
package (e.g. {\cvode}), the stream given to cuSPARSE should be the same
stream used for the {\nvector} object that is provided to the package,
and the {\nvector} object given to the \id{SUNMatvec} operation. If different
streams are utilized, synchronization issues may occur.

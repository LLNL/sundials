%% This is a shared SUNDIALS TEX file with a description of the
%% klu sunlinsol implementation
%%

The {\klu} implementation of the {\sunlinsol} module provided with
{\sundials}, {\sunlinsolklu}, is designed to be used with the
corresponding {\sunmatsparse} matrix type, and one of the serial or
shared-memory {\nvector} implementations ({\nvecs}, {\nvecopenmp}, or 
{\nvecpthreads}).


%---------------------------------------------------------------------------
\subsection{{\sunlinsolklu} usage}\label{ss:sunlinsol_klu_usage}

The header file to include when using this module 
is \id{sunlinsol/sunlinsol\_klu.h}. The installed module
library to link to is
\id{libsundials\_sunlinsolklu.\textit{lib}}
where \id{\em.lib} is typically \id{.so} for shared libraries and
\id{.a} for static libraries. 

The module {\sunlinsolklu} provides the following user-callable routines: 
%%
% --------------------------------------------------------------------
\ucfunction{SUNLinSol\_KLU}
{
  LS = SUNLinSol\_KLU(y, A);
}
{
  The function \ID{SUNLinSol\_KLU} creates and allocates memory for a
  {\sunlinsolklu} object.
}
{
  \begin{args}[y]
  \item[y] (\id{N\_Vector})
    a template for cloning vectors needed within the solver
  \item[A] (\id{SUNMatrix})
    a {\sunmatsparse} matrix template for cloning matrices needed
    within the solver 
  \end{args}
}
{
  This returns a \id{SUNLinearSolver} object.  If either \id{A} or
  \id{y} are incompatible then this routine will return \id{NULL}.
}
{
  This routine will perform consistency checks to ensure that it is
  called with consistent {\nvector} and {\sunmatrix} implementations.
  These are currently limited to the {\sunmatsparse} matrix type
  (using either CSR or CSC storage formats) and the {\nvecs},
  {\nvecopenmp}, and {\nvecpthreads} vector types.  As additional
  compatible matrix and vector implementations are added to
  {\sundials}, these will be included within this compatibility
  check. 
}
% --------------------------------------------------------------------
\ucfunction{SUNLinSol\_KLUReInit}
{
  retval = SUNLinSol\_KLUReInit(LS, A, nnz, reinit\_type);
}
{
  The function \ID{SUNLinSol\_KLUReInit} reinitializes memory and
  flags for a new factorization (symbolic and numeric) to be conducted
  at the next solver setup call.  This routine is useful in the cases
  where the number of nonzeroes has changed or if the structure of the
  linear system has changed which would require a new symbolic (and
  numeric factorization). 
}
{
  \begin{args}[reinit\_type]
  \item[LS] (\id{SUNLinearSolver})
    a template for cloning vectors needed within the solver
  \item[A] (\id{SUNMatrix})
    a {\sunmatsparse} matrix template for cloning matrices needed
    within the solver 
  \item[nnz] (\id{sunindextype})
    the new number of nonzeros in the matrix
  \item[reinit\_type] (\id{int})
    flag governing the level of reinitialization.  The allowed values
    are:
    \begin{itemize}
    \item \texttt{SUNKLU\_REINIT\_FULL} -- The Jacobian matrix will be
      destroyed and a new one will be allocated based on the \id{nnz}
      value passed to this call.  New symbolic and numeric
      factorizations will be completed at the next solver setup. 
    \item \texttt{SUNKLU\_REINIT\_PARTIAL} -- Only symbolic and numeric 
      factorizations will be completed.  It is assumed that the
      Jacobian size has not exceeded the size of \id{nnz} given in the
      sparse matrix provided to the original constructor routine (or
      the previous \id{SUNLinSol\_KLUReInit} call). 
    \end{itemize}
  \end{args}
}
{
  The return values from this function are \id{SUNLS\_MEM\_NULL}
  (either \id{S} or \id{A} are \id{NULL}), \id{SUNLS\_ILL\_INPUT}
  (\id{A} does not have type \id{SUNMATRIX\_SPARSE} or
  \id{reinit\_type} is invalid), \id{SUNLS\_MEM\_FAIL} (reallocation
  of the sparse matrix failed) or \id{SUNLS\_SUCCESS}.
}
{
  This routine will perform consistency checks to ensure that it is
  called with consistent {\nvector} and {\sunmatrix} implementations.
  These are currently limited to the {\sunmatsparse} matrix type
  (using either CSR or CSC storage formats) and the {\nvecs},
  {\nvecopenmp}, and {\nvecpthreads} vector types.  As additional
  compatible matrix and vector implementations are added to
  {\sundials}, these will be included within this compatibility
  check.

  This routine assumes no other changes to solver use are necessary.
}
% --------------------------------------------------------------------
\ucfunction{SUNLinSol\_KLUSetOrdering}
{
  retval = SUNLinSol\_KLUSetOrdering(LS, ordering);
}
{
  This function sets the ordering used by {\klu} for reducing fill in
  the linear solve.
}
{
  \begin{args}[ordering]
  \item[LS] (\id{SUNLinearSolver})
    the {\sunlinsolklu} object
  \item[ordering] (\id{int})
    flag indication the reordering algorithm to use.  Options include:
    \begin{itemize}
    \item[0] AMD,
    \item[1] COLAMD, and
    \item[2] the natural ordering.
    \end{itemize}
    The default is 1 for COLAMD.
  \end{args}
}
{
  The return values from this function are \id{SUNLS\_MEM\_NULL}
  (\id{S} is \id{NULL}), \id{SUNLS\_ILL\_INPUT}
  (invalid \id{ordering}), or \id{SUNLS\_SUCCESS}.
}
{
}
% --------------------------------------------------------------------
%%
For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\begin{itemize}

\item \ID{SUNKLU}

  Wrapper function for \id{SUNLinSol\_KLU}

\item \ID{SUNKLUReInit}

  Wrapper function for \id{SUNLinSol\_KLUReInit}

\item \ID{SUNKLUSetOrdering}

  Wrapper function for \id{SUNLinSol\_KLUSetOrdering}

\end{itemize}
%%
%%------------------------------------
%%
For solvers that include a Fortran interface module, the
{\sunlinsolklu} module also includes a Fortran-callable function
for creating a \id{SUNLinearSolver} object.
% --------------------------------------------------------------------
\ucfunction{FSUNKLUINIT}
{
  FSUNKLUINIT(code, ier)
}
{
  The function \ID{FSUNKLUINIT} can be called for Fortran programs
  to create a {\sunlinsolklu} object.
}
{
  \begin{args}[code]
  \item[code] (\id{int*})
    is an integer input specifying the solver id (1 for {\cvode}, 2
    for {\ida}, 3 for {\kinsol}, and 4 for {\arkode}).
  \end{args}
}
{
  \id{ier} is a return completion flag equal to \id{0} for a success
  return and \id{-1} otherwise. See printed message for details in case
  of failure.
}
{
  This routine must be
  called \emph{after} both the {\nvector} and {\sunmatrix} objects have
  been initialized.
}
% --------------------------------------------------------------------
Additionally, when using
{\arkode} with a non-identity mass matrix, the {\sunlinsolklu} module
includes a Fortran-callable function for creating a
\id{SUNLinearSolver} mass matrix solver object.
% --------------------------------------------------------------------
\ucfunction{FSUNMASSKLUINIT}
{
  FSUNMASSKLUINIT(ier)
}
{
  The function \ID{FSUNMASSKLUINIT} can be called for Fortran programs
  to create a {\sunlinsolklu} object for mass matrix linear systems.
}
{
}
{
  \id{ier} is a \id{int} return completion flag equal to \id{0} for a success
  return and \id{-1} otherwise. See printed message for details in case
  of failure.
}
{
  This routine must be
  called \emph{after} both the {\nvector} and {\sunmatrix} mass-matrix
  objects have been initialized.
}
% --------------------------------------------------------------------
The \id{SUNLinSol\_KLUReInit} and \ID{SUNLinSol\_KLUSetOrdering}
routines also support Fortran interfaces for the system and mass
matrix solvers: 
% --------------------------------------------------------------------
\ucfunction{FSUNKLUREINIT}
{
  FSUNKLUREINIT(code, nnz, reinit\_type, ier)
}
{
  The function \ID{FSUNKLUREINIT} can be called for Fortran programs
  to re-initialize a {\sunlinsolklu} object.
}
{
  \begin{args}[reinit\_type]
  \item[code] (\id{int*})
    is an integer input specifying the solver id (1 for {\cvode}, 2
    for {\ida}, 3 for {\kinsol}, and 4 for {\arkode}).
  \item[nnz] (\id{sunindextype*})
    the new number of nonzeros in the matrix
  \item[reinit\_type] (\id{int*})
    flag governing the level of reinitialization.  The allowed values
    are:
    \begin{itemize}
    \item[1] -- The Jacobian matrix will be
      destroyed and a new one will be allocated based on the \id{nnz}
      value passed to this call.  New symbolic and numeric
      factorizations will be completed at the next solver setup. 
    \item[2] -- Only symbolic and numeric 
      factorizations will be completed.  It is assumed that the
      Jacobian size has not exceeded the size of \id{nnz} given in the
      sparse matrix provided to the original constructor routine (or
      the previous \id{SUNLinSol\_KLUReInit} call). 
    \end{itemize}
  \end{args}
}
{
  \id{ier} is a \id{int} return completion flag equal to \id{0} for a success
  return and \id{-1} otherwise. See printed message for details in case
  of failure.
}
{
  See \id{SUNLinSol\_KLUReInit} for complete further documentation of
  this routine. 
}
% --------------------------------------------------------------------
\ucfunction{FSUNMASSKLUREINIT}
{
  FSUNMASSKLUREINIT(nnz, reinit\_type, ier)
}
{
  The function \ID{FSUNMASSKLUREINIT} can be called for Fortran programs
  to re-initialize a {\sunlinsolklu} object for mass matrix linear systems.
}
{
  The arguments are identical to \id{FSUNKLUREINIT} above, except that
  \id{code} is not needed since mass matrix linear systems only arise
  in {\arkode}.
}
{
  \id{ier} is a \id{int} return completion flag equal to \id{0} for a success
  return and \id{-1} otherwise. See printed message for details in case
  of failure.
}
{
  See \id{SUNLinSol\_KLUReInit} for complete further documentation of
  this routine. 
}
% --------------------------------------------------------------------
\ucfunction{FSUNKLUSETORDERING}
{
  FSUNKLUSETORDERING(code, ordering, ier)
}
{
  The function \ID{FSUNKLUSETORDERING} can be called for Fortran programs
  to change the reordering algorithm used by {\klu}.
}
{
  \begin{args}[ordering]
  \item[code] (\id{int*})
    is an integer input specifying the solver id (1 for {\cvode}, 2
    for {\ida}, 3 for {\kinsol}, and 4 for {\arkode}).
  \item[ordering] (\id{int*})
    flag indication the reordering algorithm to use.  Options include:
    \begin{itemize}
    \item[0] AMD,
    \item[1] COLAMD, and
    \item[2] the natural ordering.
    \end{itemize}
    The default is 1 for COLAMD.
  \end{args}
}
{
  \id{ier} is a \id{int} return completion flag equal to \id{0} for a success
  return and \id{-1} otherwise. See printed message for details in case
  of failure.
}
{
  See \id{SUNLinSol\_KLUSetOrdering} for complete further documentation of
  this routine. 
}
% --------------------------------------------------------------------
\ucfunction{FSUNMASSKLUSETORDERING}
{
  FSUNMASSKLUSETORDERING(ier)
}
{
  The function \ID{FSUNMASSKLUSETORDERING} can be called for Fortran programs
  to change the reordering algorithm used by {\klu} for mass matrix linear systems.
}
{
  The arguments are identical to \id{FSUNKLUSETORDERING} above, except that
  \id{code} is not needed since mass matrix linear systems only arise
  in {\arkode}.
}
{
  \id{ier} is a \id{int} return completion flag equal to \id{0} for a success
  return and \id{-1} otherwise. See printed message for details in case
  of failure.
}
{
  See \id{SUNLinSol\_KLUSetOrdering} for complete further documentation of
  this routine. 
}


%---------------------------------------------------------------------------
\subsection{{\sunlinsolklu} description}\label{ss:sunlinsol_klu_description}


The {\sunlinsolklu} module defines the {\em
content} field of a \id{SUNLinearSolver} to be the following structure:
%%
\begin{verbatim} 
struct _SUNLinearSolverContent_KLU {
  long int         last_flag;
  int              first_factorize;
  sun_klu_symbolic *symbolic;
  sun_klu_numeric  *numeric;
  sun_klu_common   common;
  sunindextype     (*klu_solver)(sun_klu_symbolic*, sun_klu_numeric*,
                                 sunindextype, sunindextype,
                                 double*, sun_klu_common*);
};
\end{verbatim}
%%
These entries of the \emph{content} field contain the following
information:
\begin{description}
  \item[last\_flag] - last error return flag from internal function evaluations,
  \item[first\_factorize] - flag indicating whether the factorization
    has ever been performed, 
  \item[symbolic] - {\klu} storage structure for symbolic factorization components,
  \item[numeric] - {\klu} storage structure for numeric factorization components,
  \item[common] - storage structure for common {\klu} solver components,
  \item[klu\_solver] -- pointer to the appropriate {\klu} solver function
    (depending on whether it is using a CSR or CSC sparse matrix).
\end{description}

{\warn} The {\sunlinsolklu} module is a {\sunlinsol} wrapper for
the {\klu} sparse matrix factorization and solver library written by Tim
Davis \cite{KLU_site,DaPa:10}.  In order to use the
{\sunlinsolklu} interface to {\klu}, it is assumed that {\klu} has
been installed on the system prior to installation of {\sundials}, and
that {\sundials} has been configured appropriately to link with {\klu}
(see Appendix \ref{c:install} for details).  Additionally, this
wrapper only supports double-precision calculations, and therefore
cannot be compiled if {\sundials} is configured to have \id{realtype}
set to either \id{extended} or \id{single} (see Section \ref{s:types}).
Since the {\klu} library supports both 32-bit and 64-bit integers, this
interface will be compiled for either of the available \id{sunindextype} options.

The {\klu} library has a symbolic factorization routine that computes
the permutation of the linear system matrix to block triangular form
and the permutations that will pre-order the diagonal blocks (the only
ones that need to be factored) to reduce fill-in (using AMD, COLAMD,
CHOLAMD, natural, or an ordering given by the user).  Of these
ordering choices, the default value in the {\sunlinsolklu} 
module is the COLAMD ordering.

{\klu} breaks the factorization into two separate parts.  The first is
a symbolic factorization and the second is a numeric factorization
that returns the factored matrix along with final pivot information.   
{\klu} also has a refactor routine that can be called instead of the numeric 
factorization.  This routine will reuse the pivot information.  This routine 
also returns diagnostic information that a user can examine to determine if 
numerical stability is being lost and a full numerical factorization should 
be done instead of the refactor.

Since the linear systems that arise within the context of {\sundials}
calculations will typically have identical sparsity patterns, the
{\sunlinsolklu} module is constructed to perform the
following operations:
\begin{itemize}
\item The first time that the ``setup'' routine is called, it
  performs the symbolic factorization, followed by an initial
  numerical factorization.  
\item On subsequent calls to the ``setup'' routine, it calls the
  appropriate {\klu} ``refactor'' routine, followed by estimates of
  the numerical conditioning using the relevant ``rcond'', and if
  necessary ``condest'', routine(s).  If these estimates of the
  condition number are larger than $\varepsilon^{-2/3}$ (where
  $\varepsilon$ is the double-precision unit roundoff), then a new
  factorization is performed.
\item The module includes the routine \id{SUNKLUReInit}, that 
  can be called by the user to force a full or partial refactorization
  at the next ``setup'' call. 
\item The ``solve'' call performs pivoting and forward and
  backward substitution using the stored {\klu} data structures.  We
  note that in this solve {\klu} operates on the native data arrays
  for the right-hand side and solution vectors, without requiring
  costly data copies.
\end{itemize}


%%
%%----------------------------------------------
%%

\noindent The {\sunlinsolklu} module defines implementations of all
``direct'' linear solver operations listed in Sections
\ref{ss:sunlinsol_CoreFn}-\ref{ss:sunlinsol_GetFn}:
\begin{itemize}
\item \id{SUNLinSolGetType\_KLU}
\item \id{SUNLinSolInitialize\_KLU} -- this sets the
  \id{first\_factorize} flag to 1, forcing both symbolic and numerical
  factorizations on the subsequent ``setup'' call.
\item \id{SUNLinSolSetup\_KLU} -- this performs either a $LU$
  factorization or refactorization of the input matrix.
\item \id{SUNLinSolSolve\_KLU} -- this calls the appropriate {\klu}
  solve routine to utilize the $LU$ factors to solve the linear
  system. 
\item \id{SUNLinSolLastFlag\_KLU}
\item \id{SUNLinSolSpace\_KLU} -- this only returns information for
  the storage within the solver \emph{interface}, i.e.~storage for the
  integers \id{last\_flag} and \id{first\_factorize}.  For additional
  space requirements, see the {\klu} documentation.
\item \id{SUNLinSolFree\_KLU}
\end{itemize}

{\sundials} time integration packages are written in terms of generic nonlinear
solver operations defined by the {\sunnonlinsol} API and implemented by a
particular {\sunnonlinsol} module of type \noindent\Id{SUNNonlinearSolver}.
Users can supply their own {\sunnonlinsol} module, or use one of the modules
provided with {\sundials}. Depending on the package, nonlinear solver modules
can either target system presented in a rootfinding ($F(y) = 0$) or fixed-point
($G(y) = y$) formulation. For more information on the formulation of the
nonlinear system(s) see section \ref{s:sunnonlinsol_interface}.

The time integrators in {\sundials} specify a default nonlinear solver module
and as such this chapter is intended for users that wish to use a non-default
nonlinear solver module or would like to provide their own nonlinear solver
implementation. Users interested in using a non-default solver module may skip
the description of the {\sunnonlinsol} API in section \ref{s:sunnonlinsol_api}
and proceeded to the subsequent sections in this chapter that describe the
{\sunnonlinsol} modules provided with {\sundials}.

For users interested in providing their own {\sunnonlinsol} module, the
following section presents the {\sunnonlinsol} API and its implementation
beginning with the definition of {\sunnonlinsol} functions in sections
\ref{ss:sunnonlinsol_corefn} -- \ref{ss:sunnonlinsol_getfn}. This is followed by
the definition of functions supplied to a nonlinear solver implementation in
section \ref{ss:sunnonlinsol_sunsuppliedfn}. A table of nonlinear solver return
codes is given in section \ref{ss:sunnonlinsol_returncodes}. The
\id{SUNNonlinearSolver} type and the generic {\sunnonlinsol} module are defined
in section \ref{ss:sunnonlinsol_generic}. Section \ref{ss:sunnonlinsol_sens}
describes how {\sunnonlinsol} models interface with {\sundials} integrators
providing sensitivity analysis capabilities ({\cvodes} and {\idas}). Finally,
section \ref{ss:sunnonlinsol_custom} lists the requirements for supplying a
custom {\sunnonlinsol} module. Users wishing to supply their own {\sunnonlinsol}
module are encouraged to use the {\sunnonlinsol} implementations provided with
{\sundials} as a template for supplying custom nonlinear solver
modules.


% ====================================================================
\section{The SUNNonlinearSolver API}
\label{s:sunnonlinsol_api}
% ====================================================================

The {\sunnonlinsol} API defines several nonlinear solver operations that enable
{\sundials} integrators to utilize any {\sunnonlinsol} implementation that
provides the required functions. These functions can be divided into three
categories. The first are the core nonlinear solver functions. The second group
of functions consists of set routines to supply the nonlinear solver with
functions provided by the {\sundials} time integrators and to modify solver
parameters. The final group consists of get routines for retrieving nonlinear
solver statistics. All of these functions are defined in the header file
\id{sundials/sundials\_nonlinearsolver.h}.

% ====================================================================
\subsection{SUNNonlinearSolver core functions}
\label{ss:sunnonlinsol_corefn}
% ====================================================================
The core nonlinear solver functions consist of two required functions to get the
nonlinear solver type (\id{SUNNonlinsSolGetType}) and solve the nonlinear system
(\id{SUNNonlinSolSolve}). The remaining three functions for nonlinear solver
initialization (\id{SUNNonlinSolInitialization}), setup\\ \noindent
(\id{SUNNonlinSolSetup}), and destruction (\id{SUNNonlinSolFree}) are optional.

\ucfunctionf{SUNNonlinSolGetType}
{
  type = SUNNonlinSolGetType(NLS);
}
{
  The \textit{required} function \ID{SUNNonlinSolGetType} returns
  nonlinear solver type.
}
{
  \begin{args}[NLS]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \end{args}
}
{
  The return value \id{type} (of type \id{int}) will be one of the
  following:
  \begin{args}[SUNNONLINEARSOLVER\_FIXEDPOINT]
  \item[\Id{SUNNONLINEARSOLVER\_ROOTFIND}]
    \id{0}, the {\sunnonlinsol} module solves $F(y) = 0$.
  \item[\Id{SUNNONLINEARSOLVER\_FIXEDPOINT}]
    \id{1}, the {\sunnonlinsol} module solves $G(y) = y$.
  \end{args}
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolInitialize}
{
  retval = SUNNonlinSolInitialize(NLS);
}
{
  The \textit{optional} function \ID{SUNNonlinSolInitialize} performs
  nonlinear solver initialization and may perform any necessary memory
  allocations.
}
{
  \begin{args}[NLS]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) is zero for a
  successful call and a negative value for a failure.
}
{
  It is assumed all solver-specific options have been set prior to
  calling \\ \noindent
  \id{SUNNonlinSolInitialize}. {\sunnonlinsol} implementations
  that do not require initialization may set this operation
  to \id{NULL}.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolSetup}
{
  retval = SUNNonlinSolSetup(NLS, y, mem);
}
{
  The \textit{optional} function \ID{SUNNonlinSolSetup} performs any
  solver setup needed for a nonlinear solve.
}
{
  \begin{args}[NLS]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \item[y] (\id{N\_Vector})
    the initial iteration passed to the nonlinear solver.
  \item[mem] (\id{void *})
    the {\sundials} integrator memory structure.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) is zero for a
  successful call and a negative value for a failure.
}
{
  {\sundials} integrators call \id{SUNonlinSolSetup} before each step
  attempt. {\sunnonlinsol} implementations that do not require setup  may set
  this operation to \id{NULL}.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolSolve}
{
  retval = SUNNonlinSolSolve(NLS, y0, ycor, w, tol, callLSetup, mem);
}
{
  The \textit{required} function \ID{SUNNonlinSolSolve} solves the
  nonlinear system $F(y)=0$ or $G(y)=y$.
}
{
  \begin{args}[callLSetup]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \item[y0] (\id{N\_Vector})
    the predicted value for the new solution state. This \textit{must}
    remain unchanged throughout the solution process. See section
    \ref{s:sunnonlinsol_interface} for more detail on the nonlinear system
    formulation.
  \item[ycor] (\id{N\_Vector})
    on input the initial guess for the correction to the predicted state (zero)
    and on output the final correction to the predicted state. See section
    \ref{s:sunnonlinsol_interface} for more detail on the nonlinear system
    formulation.
  \item[w] (\id{N\_Vector})
    the solution error weight vector used for computing weighted error norms.
  \item[tol] (\id{realtype})
    the requested solution tolerance in the weighted root-mean-squared norm.
  \item[callLSetup] (\id{booleantype})
    a flag indicating that the integrator recommends for the linear
    solver setup function to be called.
  \item[mem] (\id{void *})
    the {\sundials} integrator memory structure.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) is zero for a successul solve,
  a positive value for a recoverable error (i.e., the solve failed and the
  integrator should reduce the step size and reattempt the step), and a negative
  value for an unrecoverable error (i.e., the solve failed and the integrator
  should halt and return an error to the user).
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolFree}
{
  retval = SUNNonlinSolFree(NLS);
}
{
  The \textit{optional} function \ID{SUNNonlinSolFree} frees any
  memory allocated by the nonlinear solver.
}
{
  \begin{args}[NLS]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure. {\sunnonlinsol}
  implementations that do not allocate data may set this operation
  to \id{NULL}.
}
{}


% ====================================================================
\subsection{SUNNonlinearSolver set functions}
\label{ss:sunnonlinsol_setfn}
% ====================================================================
The following set functions are used to supply nonlinear solver modules with
functions defined by the {\sundials} integrators and to modify solver
parameters. Only the routine for setting the nonlinear system defining function
(\id{SUNNonlinSolSetSysFn} is required. All other set functions are optional.

\ucfunctionf{SUNNonlinSolSetSysFn}
{
  retval = SUNNonlinSolSetSysFn(NLS, SysFn);
}
{
  The \textit{required} function \ID{SUNNonlinSolSetSysFn} is used
  to provide the nonlinear solver with the function defining the
  nonlinear system. This is the function $F(y)$ in $F(y)=0$ for
  \id{SUNNONLINEARSOLVER\_ROOTFIND} modules or $G(y)$ in $G(y)=y$ for\\
  \id{SUNNONLINEARSOLVER\_FIXEDPOINT} modules.
}
{
  \begin{args}[SysFn]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \item[SysFn] (\id{SUNNonlinSolSysFn})
    the function defining the nonlinear system. See section
    \ref{ss:sunnonlinsol_sunsuppliedfn} for the definition of
    \id{SUNNonlinSolSysFn}.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolSetLSetupFn}
{
  retval = SUNNonlinSolSetLSetupFn(NLS, LSetupFn);
}
{
  The \textit{optional} function \ID{SUNNonlinSolLSetupFn} is called
  by {\sundials} integrators to provide the nonlinear solver with
  access to its linear solver setup function.
}
{
  \begin{args}[LSetupFn]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \item[LSetupFn] (\id{SUNNonlinSolLSetupFn})
    a wrapper function to the {\sundials} integrator's linear solver setup
    function. See section \ref{ss:sunnonlinsol_sunsuppliedfn} for the
    definition of \\ \noindent
    \id{SUNNonlinLSetupFn}.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{
  The \id{SUNNonlinLSetupFn} function sets up the linear system $Ax=b$ where
  $A = \frac{\partial F}{\partial y}$ is the linearization of the nonlinear
  residual function $F(y) = 0$ (when using {\sunlinsol} direct linear solvers)
  or calls the user-defined preconditioner setup function (when using
  {\sunlinsol} iterative linear solvers). {\sunnonlinsol} implementations that
  do not require solving this system, do not utilize {\sunlinsol} linear
  solvers, or use {\sunlinsol} linear solvers that do not require setup may set
  this operation to \id{NULL}.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolSetLSolveFn}
{
  retval = SUNNonlinSolSetLSolveFn(NLS, LSolveFn);
}
{
  The \textit{optional} function \ID{SUNNonlinSolSetLSolveFn} is called by
  {\sundials} integrators to provide the nonlinear solver with access to
  its linear solver solve function.
}
{
  \begin{args}[LSolveFn]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object
  \item[LSolveFn] (\id{SUNNonlinSolLSolveFn})
    a wrapper function to the {\sundials} integrator's linear solver solve
    function. See section \ref{ss:sunnonlinsol_sunsuppliedfn} for the definition
    of\\ \noindent
    \id{SUNNonlinSolLSolveFn}.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{
  The \id{SUNNonlinLSolveFn} function solves the linear system $Ax=b$ where
  $A = \frac{\partial F}{\partial y}$ is the linearization of the nonlinear
  residual function $F(y) = 0$. {\sunnonlinsol} implementations that do not
  require solving this system or do not use {\sunlinsol} linear solvers may set
  this operation to \id{NULL}.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolSetConvTestFn}
{
  retval = SUNNonlinSolSetConvTestFn(NLS, CTestFn, ctest\_data);
}
{
  The \textit{optional} function \ID{SUNNonlinSolSetConvTestFn} is used to
  provide the nonlinear solver with a function for determining if the nonlinear
  solver iteration has converged. This is typically called by {\sundials}
  integrators to define their nonlinear convergence criteria, but may be replaced
  by the user.
}
{
  \begin{args}[ctest\_data]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \item[CTestFn] (\id{SUNNonlineSolConvTestFn})
    a {\sundials} integrator's nonlinear solver convergence test function. See
    section \ref{ss:sunnonlinsol_sunsuppliedfn} for the definition of\\ \noindent
    \id{SUNNonlinSolConvTestFn}.
  \item[ctest\_data] (\id{void*})
    is a data pointer passed to \id{CTestFn} every time it is called.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{
  {\sunnonlinsol} implementations utilizing their own convergence test
  criteria may set this function to \id{NULL}.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolSetMaxIters}
{
  retval = SUNNonlinSolSetMaxIters(NLS, maxiters);
}
{
  The \textit{optional} function \ID{SUNNonlinSolSetMaxIters} sets the maximum
  number of nonlinear solver iterations. This is typically called by
  {\sundials} integrators to define their default iteration limit, but may be
  adjusted by the user.
}
{
  \begin{args}[maxiters]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object.
  \item[maxiters] (\id{int})
    the maximum number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure
  (e.g., $\id{maxiters} < 1$).
}
{}


% ====================================================================
\subsection{SUNNonlinearSolver get functions}
\label{ss:sunnonlinsol_getfn}
% ====================================================================
The following get functions allow {\sundials} integrators to retrieve nonlinear
solver statistics. The routines to get the current total number of
iterations (\id{SUNNonlinSolGetNumIters}) and number of convergence failures
(\id{SUNNonlinSolGetNumConvFails}) are optional. The routine to get
the current nonlinear solver iteration (\id{SUNNonlinSolGetCurIter}) is required
when using the convergence test provided by the {\sundials} integrator
or by the {\arkode} and {\cvode} linear solver interfaces.  Otherwise,
\id{SUNNonlinSolGetCurIter} is optional.

\ucfunctionf{SUNNonlinSolGetNumIters}
{
  retval = SUNNonlinSolGetNumIters(NLS, numiters);
}
{
  The \textit{optional} function \ID{SUNNonlinSolGetNumIters} returns
  the total number of nonlinear solver iterations. This is typically
  called by the {\sundials} integrator to store the nonlinear solver
  statistics, but may also be called by the user.
}
{
  \begin{args}[numiters]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object
  \item[numiters] (\id{long int*})
    the total number of nonlinear solver iterations.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolGetCurIter}
{
  retval = SUNNonlinSolGetCurIter(NLS, iter);
}
{
  The function \ID{SUNNonlinSolGetCurIter} returns the iteration index
  of the current nonlinear solve. This function is \textit{required}
  when using {\sundials} integrator-provided convergence tests or
  when using a {\sunlinsol} spils linear solver; otherwise it is
  \textit{optional}.
}
{
  \begin{args}[numiters]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object
  \item[iter] (\id{int*})
    the nonlinear solver iteration in the current solve starting from
    zero.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNNonlinSolGetNumConvFails}
{
  retval = SUNNonlinSolGetNumConvFails(NLS, nconvfails);
}
{
  The \textit{optional} function \ID{SUNNonlinSolGetNumConvFails} returns
  the total number of nonlinear solver convergence failures. This may be
  called by the {\sundials} integrator to store the nonlinear solver
  statistics, but may also be called by the user.
}
{
  \begin{args}[nconvfails]
  \item[NLS] (\id{SUNNonlinearSolver})
    a {\sunnonlinsol} object
  \item[nconvfails] (\id{long int*})
    the total number of nonlinear solver convergence failures.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) should be zero for a
  successful call, and a negative value for a failure.
}
{}
% --------------------------------------------------------------------

% ====================================================================
\subsection{Functions provided by SUNDIALS integrators}
\label{ss:sunnonlinsol_sunsuppliedfn}
% ====================================================================

To interface with {\sunnonlinsol} modules, the {\sundials} integrators
supply a variety of routines for evaluating the nonlinear system,
calling the {\sunlinsol} setup and solve functions, and testing the
nonlinear iteration for convergence.  These integrator-provided routines
translate between the user-supplied ODE or DAE systems and the generic
interfaces to the nonlinear or linear systems of equations that result
in their solution. The types for functions provided to a {\sunnonlinsol}
module are defined in the header file
\id{sundials/sundials\_nonlinearsolver.h}, and are described below.
% --------------------------------------------------------------------
\usfunction{SUNNonlinSolSysFn}
{
  typedef int (*SUNNonlinSolSysFn)(N\_Vector ycor, N\_Vector F, void* mem);
}
{
  These functions evaluate the nonlinear system $F(y)$
  for \id{SUNNONLINEARSOLVER\_ROOTFIND} type modules or $G(y)$
  for \id{SUNNONLINEARSOLVER\_FIXEDPOINT} type modules. Memory
  for \id{F} must by be allocated prior to calling this function. The
  vector \id{ycor} will be left unchanged.
}
{
  \begin{args}[ycor]
  \item[ycor]
    is the current correction to the predicted state at which the nonlinear
    system should be evaluated. See section \ref{s:sunnonlinsol_interface}
    for more detail on the nonlinear system formulation.
  \item[F]
    is the output vector containing $F(y)$ or $G(y)$, depending on the
    solver type.
  \item[mem]
    is the {\sundials} integrator memory structure.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) is zero for a
  successul solve, a positive value for a recoverable error, and a
  negative value for an unrecoverable error.
  %% The return value \id{retval} (of type \id{int}) will be one of the
  %% following:
  %% \begin{args}[*\_RHSFUNC\_RECVR]
  %% \item[\id{*\_SUCCESS}]
  %%   the function evaluation was successful
  %% \item[\id{*\_RHSFUNC\_RECVR}]
  %%   the ODE right-hand side function returned a recoverable error
  %% \item[\id{*\_RES\_RECVR}]
  %%   the DAE residual function returned a recoverable error
  %% \item[\id{*\_RHSFUNC\_FAIL}]
  %%   the ODE right-hand side function returned an unrecoverable error
  %% \item[\id{*\_RES\_FAIL}]
  %%   the DAE residual function returned an unrecoverable error
  %% \item[\id{*\_MEM\_NULL}]
  %%   the {\sundials} package memory was \id{NULL}
  %% \end{args}
  %% In the above return codes \id{*} is a {\sundials} package-specific
  %% prefix (\id{CV} for {\cvode} or {\cvodes}, \id{IDA} for {\ida} or
  %% {\idas}, and \id{ARK} for {\arkode}).
}
{
  As discussed in section \ref{s:sunnonlinsol_interface}, {\sundials}
  integrators formulate nonlinear systems as a function of the correction to the
  predicted solution. On each call to the nonlinear system function the
  integrator will compute and store the current solution based on the input
  correction. Additionally, the residual will store the value of the ODE
  right-hand side function or DAE residual used in computing the nonlinear
  system residual. These stored values are then directly used in the
  integrator-supplied linear solver setup and solve functions as applicable.
}
% --------------------------------------------------------------------
\usfunction{SUNNonlinSolLSetupFn}
{
  typedef int (*SUNNonlinSolLSetupFn)(&booleantype jbad, booleantype* jcur,\\
                                      &void* mem);
}
{
  These functions are wrappers to the {\sundials} integrator's function
  for setting up linear solves with {\sunlinsol} modules.
}
{
  \begin{args}[jcur]
  \item[jbad]
    is an input indicating whether the nonlinear solver believes that
    $A$ has gone stale (\id{SUNTRUE}) or not (\id{SUNFALSE}).
  \item[jcur]
    is an output indicating whether the routine has updated the
    Jacobian $A$ (\id{SUNTRUE}) or not (\id{SUNFALSE}).
  \item[mem]
    is the {\sundials} integrator memory structure.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) is zero for a
  successul solve, a positive value for a recoverable error, and a
  negative value for an unrecoverable error.
}
{
  The \id{SUNNonlinLSetupFn} function sets up the linear system $Ax=b$ where
  $A = \frac{\partial F}{\partial y}$ is the linearization of the nonlinear
  residual function $F(y) = 0$ (when using {\sunlinsol} direct linear solvers)
  or calls the user-defined preconditioner setup function (when using
  {\sunlinsol} iterative linear solvers). {\sunnonlinsol} implementations that
  do not require solving this system, do not utilize {\sunlinsol} linear
  solvers, or use {\sunlinsol} linear solvers that do not require setup may
  ignore these functions.

  As discussed in the description of \id{SUNNonlinSolSysFn}, the linear solver
  setup function assumes that the nonlinear system function has been called
  prior to the linear solver setup function as the setup will utilize saved
  values from the nonlinear system evaluation (e.g., the updated solution).
}
% --------------------------------------------------------------------
\usfunction{SUNNonlinSolLSolveFn}
{
  typedef int (*SUNNonlinSolLSolveFn)(N\_Vector b, void* mem);
}
{
  These functions are wrappers to the {\sundials} integrator's function
  for solving linear systems with {\sunlinsol} modules.
}
{
  \begin{args}[mem]
  \item[b]
    contains the right-hand side vector for the linear solve on input
    and the solution to the linear system on output.
  \item[mem]
    is the {\sundials} integrator memory structure.
  \end{args}
}
{
  The return value \id{retval} (of type \id{int}) is zero for a
  successul solve, a positive value for a recoverable error, and a
  negative value for an unrecoverable error.
}
{
  The \id{SUNNonlinLSolveFn} function solves the linear system $Ax=b$ where
  $A = \frac{\partial F}{\partial y}$ is the linearization of the nonlinear
  residual function $F(y) = 0$. {\sunnonlinsol} implementations that do not
  require solving this system or do not use {\sunlinsol} linear solvers may
  ignore these functions.

  As discussed in the description of \id{SUNNonlinSolSysFn}, the linear solver
  solve function assumes that the nonlinear system function has been called
  prior to the linear solver solve function as the solve may utilize saved
  values from the nonlinear system evaluation (e.g., the updated solution).
}
% --------------------------------------------------------------------
\usfunction{SUNNonlinSolConvTestFn}
{
  typedef int (*SUNNonlinSolConvTestFn)(&SUNNonlinearSolver NLS, N\_Vector ycor,\\
                                        &N\_Vector del, realtype tol,\\
                                        &N\_Vector ewt, void* ctest\_data);
}
{
  These functions are {\sundials} integrator-specific convergence tests for
  nonlinear solvers and are typically supplied by each {\sundials} integrator,
  but users may supply custom problem-specific versions as desired.
}
{
  \begin{args}[ctest\_data]
  \item[NLS]
    is the {\sunnonlinsol} object.
  \item[ycor]
    is the current correction (nonlinear iterate).
  \item[del]
    is the difference between the current and prior nonlinear iterates.
  \item[tol]
    is the nonlinear solver tolerance.
  \item[ewt]
    is the weight vector used in computing weighted norms.
  \item[ctest\_data]
    is the data pointer provided to \id{SUNNonlinSolSetConvTestFn}.
  \end{args}
}
{
  The return value of this routine will be a negative value if an unrecoverable
  error occurred or one of the following:
  \begin{args}[SUN\_NLS\_CONV\_RECVR]
  \item[\id{SUN\_NLS\_SUCCESS}]
    the iteration is converged.
  \item[\id{SUN\_NLS\_CONTINUE}]
    the iteration has not converged, keep iterating.
  \item[\id{SUN\_NLS\_CONV\_RECVR}]
    the iteration appears to be diverging, try to recover.
  \end{args}
}
{
  The tolerance passed to this routine by {\sundials} integrators is the
  tolerance in a weighted root-mean-squared norm with error weight
  vector \id{ewt}. {\sunnonlinsol} modules utilizing their own convergence
  criteria may ignore these functions.
}


% ====================================================================
\subsection{SUNNonlinearSolver return codes}
\label{ss:sunnonlinsol_returncodes}
% ====================================================================

The functions provided to {\sunnonlinsol} modules by each {\sundials}
integrator, and functions within the {\sundials}-provided {\sunnonlinsol}
implementations utilize a common set of return codes, shown below in
Table \ref{t:sunnonlinsol_returncodes}.  Here, negative values
correspond to non-recoverable failures, positive values to recoverable
failures, and zero to a successful call.

\newlength{\ColumnOneA}
\settowidth{\ColumnOneA}{\id{SUN\_NLS\_CONV\_RECVR}}
\newlength{\ColumnTwoA}
\settowidth{\ColumnTwoA}{\id{Value}}
\newlength{\ColumnThreeA}
\setlength{\ColumnThreeA}{\textwidth}
\addtolength{\ColumnThreeA}{-0.5in}
\addtolength{\ColumnThreeA}{-\ColumnOneA}
\addtolength{\ColumnThreeA}{-\ColumnTwoA}

\tablecaption{Description of the \id{SUNNonlinearSolver} return codes}\label{t:sunnonlinsol_returncodes}
\tablefirsthead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Value} & {\bf Description} \\[3mm] \hline\hline}
\tablehead{\hline \multicolumn{3}{|l|}{\small\slshape continued from last page} \\
           \hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Value} & {\bf Description} \\[3mm] \hline\hline}
%% \tablehead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Value} & {\bf Description} \\[3mm] \hline\hline}
\tabletail{\hline \multicolumn{3}{|r|}{\small\slshape continued on next page} \\ \hline}
\begin{xtabular}{|p{\ColumnOneA}|p{\ColumnTwoA}|p{\ColumnThreeA}|}
%%
\id{SUN\_NLS\_SUCCESS}     & \id{0}  & successful call or converged solve
\\[1mm]
%%
\id{SUN\_NLS\_CONTINUE}    & \id{1}  & the nonlinear solver is not
                                      converged, keep iterating
\\[1mm]
%%
\id{SUN\_NLS\_CONV\_RECVR} & \id{2}  & the nonlinear solver appears to
                                       be diverging, try to recover
\\[1mm]
%%
\id{SUN\_NLS\_MEM\_NULL}   & \id{-1} & a memory argument is \id{NULL}
\\[1mm]
%%
\id{SUN\_NLS\_MEM\_FAIL}   & \id{-2} & a memory access or allocation failed
\\[1mm]
%%
\id{SUN\_NLS\_ILL\_INPUT}  & \id{-3} & an illegal input option was provided
\\
\hline
\end{xtabular}
\bigskip


% ====================================================================
\subsection{The generic SUNNonlinearSolver module}
\label{ss:sunnonlinsol_generic}
% ====================================================================

{\sundials} integrators interact with specific {\sunnonlinsol}
implementations through the generic {\sunnonlinsol} module on which all
other {\sunnonlinsol} implementations are built. The \\ \noindent
\id{SUNNonlinearSolver} type is a pointer to a structure containing an
implementation-dependent \textit{content} field and an \textit{ops}
field. The type \id{SUNNonlinearSolver} is defined as follows:
%%
%%
\begin{verbatim}
typedef struct _generic_SUNNonlinearSolver *SUNNonlinearSolver;

struct _generic_SUNNonlinearSolver {
  void *content;
  struct _generic_SUNNonlinearSolver_Ops *ops;
};
\end{verbatim}
%%
%%
where the \id{\_generic\_SUNNonlinearSolver\_Ops} structure is a list of
pointers to the various actual nonlinear solver operations provided by a
specific implementation. The \id{\_generic\_SUNNonlinearSolver\_Ops}
structure is defined as
%%
%%
\begin{verbatim}
struct _generic_SUNNonlinearSolver_Ops {
  SUNNonlinearSolver_Type (*gettype)(SUNNonlinearSolver);
  int                     (*initialize)(SUNNonlinearSolver);
  int                     (*setup)(SUNNonlinearSolver, N_Vector, void*);
  int                     (*solve)(SUNNonlinearSolver, N_Vector, N_Vector,
                                   N_Vector, realtype, booleantype, void*);
  int                     (*free)(SUNNonlinearSolver);
  int                     (*setsysfn)(SUNNonlinearSolver, SUNNonlinSolSysFn);
  int                     (*setlsetupfn)(SUNNonlinearSolver, SUNNonlinSolLSetupFn);
  int                     (*setlsolvefn)(SUNNonlinearSolver, SUNNonlinSolLSolveFn);
  int                     (*setctestfn)(SUNNonlinearSolver, SUNNonlinSolConvTestFn,
                                        void*);
  int                     (*setmaxiters)(SUNNonlinearSolver, int);
  int                     (*getnumiters)(SUNNonlinearSolver, long int*);
  int                     (*getcuriter)(SUNNonlinearSolver, int*);
  int                     (*getnumconvfails)(SUNNonlinearSolver, long int*);
};
\end{verbatim}
%%
%%
The generic {\sunnonlinsol} module defines and implements the nonlinear
solver operations defined in Sections \ref{ss:sunnonlinsol_corefn}
-- \ref{ss:sunnonlinsol_getfn}. These routines are in fact only
wrappers to the nonlinear solver operations provided by a particular
{\sunnonlinsol} implementation, which are accessed through the ops
field of the \id{SUNNonlinearSolver} structure. To illustrate this
point we show below the implementation of a typical nonlinear solver
operation from the generic {\sunnonlinsol} module, namely
\id{SUNNonlinSolSolve}, which solves the nonlinear system and returns a flag
denoting a successful or failed solve:
%%
%%
\begin{verbatim}
int SUNNonlinSolSolve(SUNNonlinearSolver NLS,
                      N_Vector y0, N_Vector y,
                      N_Vector w, realtype tol,
                      booleantype callLSetup, void* mem)
{
  return((int) NLS->ops->solve(NLS, y0, y, w, tol, callLSetup, mem));
}
\end{verbatim}

The Fortran 2003 interface provides a \id{bind(C)} derived-type for the
\id{\_generic\_SUNNonlinearSolver} and the \id{\_generic\_SUNNonlinearSolver\_Ops} structures.
Their definition is given below.
%%
%%
\begin{verbatim}
 type, bind(C), public :: SUNNonlinearSolver
  type(C_PTR), public :: content
  type(C_PTR), public :: ops
 end type SUNNonlinearSolver

 type, bind(C), public :: SUNNonlinearSolver_Ops
  type(C_FUNPTR), public :: gettype
  type(C_FUNPTR), public :: initialize
  type(C_FUNPTR), public :: setup
  type(C_FUNPTR), public :: solve
  type(C_FUNPTR), public :: free
  type(C_FUNPTR), public :: setsysfn
  type(C_FUNPTR), public :: setlsetupfn
  type(C_FUNPTR), public :: setlsolvefn
  type(C_FUNPTR), public :: setctestfn
  type(C_FUNPTR), public :: setmaxiters
  type(C_FUNPTR), public :: getnumiters
  type(C_FUNPTR), public :: getcuriter
  type(C_FUNPTR), public :: getnumconvfails
 end type SUNNonlinearSolver_Ops
\end{verbatim}


% ====================================================================
\subsection{Usage with sensitivity enabled integrators}
\label{ss:sunnonlinsol_sens}
% ====================================================================

When used with {\sundials} packages that support sensitivity analysis
capabilities (e.g., {\cvodes} and {\idas}) a special {\nvector} module is used
to interface with {\sunnonlinsol} modules for solves involving sensitivity
vectors stored in an {\nvector} array. As described below, the {\nvecwrap}
module is an {\nvector} implementation where the vector content is an {\nvector}
array. This wrapper vector allows {\sunnonlinsol} modules to operate on data
stored as a collection of vectors.

For all {\sundials}-provided {\sunnonlinsol} modules a special constructor
wrapper is provided so users do not need to interact directly with the
{\nvecwrap} module. These constructors follow the naming
convention \id{SUNNonlinSol\_***Sens(count,...)} where \id{***} is the name of
the {\sunnonlinsol} module, \id{count} is the size of the vector wrapper,
and \id{...} are the module-specific constructor arguments.

% ====================================================================
\subsubsection*{The NVECTOR\_SENSWRAPPER module}
\label{ss:sunnonlinsol_senswrapper}
% ====================================================================

This section describes the {\nvecwrap} implementation of an {\nvector}. To
access the {\nvecwrap} module, include the header file \\ \noindent
\id{sundials/sundials\_nvector\_senswrapper.h}.

The {\nvecwrap} module defines an \id{N\_Vector} implementing all of the
standard vectors operations defined in Table \ref{ss:nvecops} but with some
changes to how operations are computed in order to accommodate operating on a
collection of vectors.
\begin{enumerate}

\item Element-wise vector operations are computed on a vector-by-vector basis. For
example, the linear sum of two wrappers containing $n_v$ vectors of length $n$,
\id{N\_VLinearSum(a,x,b,y,z)}, is computed as
\begin{equation*}
z_{j,i} = a x_{j,i} + b y_{j,i}, \quad i=0,\ldots,n-1, \quad j=0,\ldots,n_v-1.
\end{equation*}

\item The dot product of two wrappers containing $n_v$ vectors of length $n$ is
computed as if it were the dot product of two vectors of length $n n_v$.
Thus \id{d = N\_VDotProd(x,y)} is
\begin{equation*}
d = \sum_{j=0}^{n_v-1} \sum_{i=0}^{n-1} x_{j,i} y_{j,i}.
\end{equation*}

\item All norms are computed as the maximum of the individual norms of the $n_v$ vectors
in the wrapper. For example, the weighted root mean square norm
\id{m = N\_VWrmsNorm(x, w)} is
\begin{equation*}
m = \max_{j} \sqrt{ \left( \frac1n \sum_{i=0}^{n-1} \left(x_{j,i}
w_{j,i}\right)^2\right) }
\end{equation*}

\end{enumerate}
To enable usage alongside other {\nvector} modules the {\nvecwrap} functions
implementing vector operations have \id{\_SensWrapper} appended to the
generic vector operation name.

The {\nvecwrap} module provides the following constructors for creating an
{\nvecwrap}:
\ucfunctionf{N\_VNewEmpty\_SensWrapper}
{
  w = N\_VNewEmpty\_SensWrapper(count);
}
{
  The function \ID{N\_VNewEmpty\_SensWrapper} creates an empty {\nvecwrap}
  wrapper with space for \id{count} vectors.
}
{
  \begin{args}[count]
  \item[count] (\id{int})
    the number of vectors the wrapper will contain.
  \end{args}
}
{
  The return value \id{w} (of type \id{N\_Vector}) will be a {\nvector} object
  if the constructor exits successfully, otherwise \id{w} will be \id{NULL}.
}
{}
%
\ucfunctionf{N\_VNew\_SensWrapper}
{
  w = N\_VNew\_SensWrapper(count, y);
}
{
  The function \ID{N\_VNew\_SensWrapper} creates an {\nvecwrap}
  wrapper containing \id{count} vectors cloned from \id{y}.
}
{
  \begin{args}[count]
  \item[count] (\id{int})
    the number of vectors the wrapper will contain.
  \item[y] (\id{N\_Vector})
    the template vectors to use in creating the vector wrapper.
  \end{args}
}
{
  The return value \id{w} (of type \id{N\_Vector}) will be a {\nvector} object
  if the constructor exits successfully, otherwise \id{w} will be \id{NULL}.
}
{}

The {\nvecwrap} implementation of the {\nvector} module defines
the \textit{content} field of the \id{N\_Vector} to be a structure containing
an \id{N\_Vector} array, the number of vectors in the vector array, and a
boolean flag indicating ownership of the vectors in the vector array.
%
\begin{verbatim}
struct _N_VectorContent_SensWrapper {
  N_Vector* vecs;
  int nvecs;
  booleantype own_vecs;
};
\end{verbatim}
%
The following macros are provided to access the content of an {\nvecwrap}
vector.
\begin{itemize}
 \item \id{NV\_CONTENT\_SW(v)}   - provides access to the content structure
 \item \id{NV\_VECS\_SW(v)}      - provides access to the vector array
 \item \id{NV\_NVECS\_SW(v)}     - provides access to the number of vectors
 \item \id{NV\_OWN\_VECS\_SW(v)} - provides access to the ownership flag
 \item \id{NV\_VEC\_SW(v,i)}     - provides access to the \id{i}-th vector in
 the  vector array
\end{itemize}

% ====================================================================
\subsection{Implementing a Custom SUNNonlinearSolver Module}
\label{ss:sunnonlinsol_custom}
% ====================================================================

A {\sunnonlinsol} implementation \textit{must} do the following:
\begin{enumerate}
\item Specify the content of the {\sunnonlinsol} module.
\item Define and implement the required nonlinear solver operations
  defined in Sections \ref{ss:sunnonlinsol_corefn}
  -- \ref{ss:sunnonlinsol_getfn}. Note that the names of the module
  routines should be unique to that implementation in order to permit
  using more than one {\sunnonlinsol} module (each with different
  \id{SUNNonlinearSolver} internal data representations) in
  the same code.
\item Define and implement a user-callable constructor to create a
  \id{SUNNonlinearSolver} object.
\end{enumerate}
Additionally, a \id{SUNNonlinearSolver} implementation \textit{may} do
the following:
\begin{enumerate}
\item Define and implement additional user-callable ``set''
  routines acting on the \id{SUNNonlinearSolver} object, e.g., for
  setting various configuration options to tune the performance of
  the nonlinear solve algorithm.
\item Provide additional user-callable ``get'' routines acting on the
  \id{SUNNonlinearSolver} object, e.g., for returning various solve
  statistics.
\end{enumerate}

To aid in the creation of custom {\sunnonlinsol} modules the generic
{\sunnonlinsol} module provides the utility functions \id{SUNNonlinSolNewEmpty}
and \id{SUNNonlinsolFreeEmpty}. When used in custom {\sunnonlinsol} constructors,
the function \id{SUNNonlinSolNewEmpty} will ease the introduction of any new
optional nonlinear solver operations to the {\sunnonlinsol} API by ensuring only
required operations need to be set.
%
% --------------------------------------------------------------------
%
\ucfunctionf{SUNNonlinSolNewEmpty}
{
  NLS = SUNNonlinSolNewEmpty();
}
{
  The function \Id{SUNNonlinSolNewEmpty} allocates a new generic {\sunnonlinsol}
  object and initializes its content pointer and the function pointers in the
  operations structure to \id{NULL}.
}
{}
{
  This function returns a \id{SUNNonlinearSolver} object. If an error occurs when
  allocating the object, then this routine will return \id{NULL}.
}
{}
%
% --------------------------------------------------------------------
%
\ucfunctionf{SUNNonlinSolFreeEmpty}
{
  SUNNonlinSolFreeEmpty(NLS);
}
{
  This routine frees the generic \id{SUNNonlinearSolver} object, under the assumption that any
  implementation-specific data that was allocated within the underlying content structure
  has already been freed. It will additionally test whether the ops pointer is \id{NULL},
  and, if it is not, it will free it as well.
}
{
  \begin{args}[NLS]
  \item[NLS] (\id{SUNNonlinearSolver})
  \end{args}
}
{}
{}

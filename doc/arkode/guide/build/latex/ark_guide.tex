%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}

\usepackage[dontkeepoldnames]{sphinx}
\sphinxsetup{TitleColor={RGB}{0,0,0},verbatimwithframe=false,verbatimwrapslines=false,VerbatimColor={RGB}{240.0,240.0,240.0},HeaderFamily=\rmfamily\bfseries}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


% =====================================================
% Start custom preamble (see latex_elements in conf.py)
% =====================================================

% Use ragged-right for the whole document
\usepackage[document]{ragged2e}

% Specify depths for section numbering and table of contents
\setcounter{tocdepth}{1}
\setcounter{secnumdepth}{3}

% Link a footnote to its location in the text
\usepackage{footnotebackref}

% Add new command for SUNDIALS version
\newcommand{\sunreleasename}{v5.6.0}

% ===================================================
% End custom preamble (see latex_elements in conf.py)
% ===================================================


\title{User Documentation for ARKode}
\date{December 11, 2020}
\release{}
\author{
    Daniel R. Reynolds$^1$,
    David J. Gardner$^2$,
    Carol S. Woodward$^2$, and
    Cody J. Balos$^2$ \\
    \\
    {\em $^1$Department of Mathematics, Southern Methodist University} \\
    {\em $^2$Center for Applied Scientific Computing, Lawrence Livermore National Laboratory}
    }
\newcommand{\sphinxlogo}{\sphinxincludegraphics{doc_logo_blue.pdf}\par}
\renewcommand{\releasename}{v4.6.0}
\makeindex

\begin{document}


% =======================================================
% Start custom cover page (see latex_elements in conf.py)
% =======================================================

\makeatletter

% Start roman numbering
\pagenumbering{Roman}

% Title page
\begin{titlepage}
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
    \let \footnote \thanks
    {\huge \rmfamily \@title \space \releasename \par}
    {\Large \rmfamily SUNDIALS \space \sunreleasename \par}
    \vskip 3.0em%
    {\large \lineskip .5em%
     \begin{tabular}[t]{c}%
       \@author
     \end{tabular}\par}%
    \vskip 1em%
    {\large \@date \par}%
    \vfill
    {\includegraphics[width=0.5\textwidth]{doc_logo_blue}}
    \vfill
    {\large \rmfamily LLNL-SM-668082}
    \vfill
  \end{center}
  \par
  \vskip 1.5em
\end{titlepage}

\makeatother

\clearpage

% Disclaimer
\thispagestyle{empty}% no number of this page
\vglue5\baselineskip
\begin{center}
  {\bf DISCLAIMER}
\end{center}
\noindent
This document was prepared as an account of work sponsored by an agency of
the United States government. Neither the United States government nor
Lawrence Livermore National Security, LLC, nor any of their employees makes
any warranty, expressed or implied, or assumes any legal liability or responsibility
for the accuracy, completeness, or usefulness of any information, apparatus, product,
or process disclosed, or represents that its use would not infringe privately owned rights.
Reference herein to any specific commercial product, process, or service by trade name,
trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement,
recommendation, or favoring by the United States government or Lawrence Livermore National
Security, LLC. The views and opinions of authors expressed herein do not necessarily state
or reflect those of the United States government or Lawrence Livermore National Security, LLC,
and shall not be used for advertising or product endorsement purposes.

\vskip2\baselineskip
\noindent
This work was performed under the auspices of the U.S. Department of Energy by Lawrence
Livermore National Laboratory under Contract DE-AC52-07NA27344.
\vfill
\begin{center}
  Approved for public release; further dissemination unlimited
\end{center}

\clearpage

% Contributors
\thispagestyle{empty}% no number of this page
\vglue5\baselineskip
\begin{center}
{\bf CONTRIBUTORS}
\end{center}
\noindent
The SUNDIALS library has been developed over many years by a number of
contributors. The current SUNDIALS team consists of Cody J. Balos,
David J. Gardner, Alan C. Hindmarsh, Daniel R. Reynolds, and
Carol S. Woodward. We thank Radu Serban for significant and critical past
contributions.\\
\vskip 2em%
\noindent
Other contributors to SUNDIALS include: James Almgren-Bell, Lawrence E. Banks,
Peter N. Brown, George Byrne, Rujeko Chinomona, Scott D. Cohen, Aaron Collier,
Keith E. Grant, Steven L. Lee, Shelby L. Lockhart, John Loffeld, Daniel McGreer,
Slaven Peles, Cosmin Petra, H. Hunter Schwartz, Jean M. Sexton,
Dan Shumaker, Steve G. Smith, Allan G. Taylor, Hilari C. Tiedeman, Chris White,
Ting Yan, and Ulrike M. Yang.
\clearpage

% clear empty double page
\newpage{\pagestyle{empty}\cleardoublepage}

% Start arabic numbering
\pagenumbering{arabic}

% =====================================================
% End custom cover page (see latex_elements in conf.py)
% =====================================================

\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


This is the documentation for ARKode, an adaptive step time
integration package for stiff, nonstiff and mixed stiff/nonstiff
systems of ordinary differential equations (ODEs) using Runge-Kutta
(i.e. one-step, multi-stage) methods.  The ARKode solver is a
component of the \sphinxhref{https://computing.llnl.gov/casc/sundials/main.html}{SUNDIALS} suite of
nonlinear and differential/algebraic equation solvers. It is designed
to have a similar user experience to the \sphinxhref{https://computing.llnl.gov/casc/sundials/description/description.html\#descr\_cvode}{CVODE}
solver, including user modes to allow adaptive integration to specified
output times, return after each internal step and root-finding
capabilities, and for calculations in serial, using shared-memory
parallelism (via OpenMP, Pthreads, CUDA, Raja) or distributed-memory
parallelism (via MPI).  The default integration and solver options
should apply to most users, though control over nearly all internal
parameters and time adaptivity algorithms is enabled through optional
interface routines.

ARKode is written in C, with C++ and Fortran interfaces.

ARKode is developed by \sphinxhref{http://www.smu.edu}{Southern Methodist University}, with support by the \sphinxhref{http://www.doe.gov}{US Department of Energy} through the \sphinxhref{http://www.fastmath-scidac.org/}{FASTMath} SciDAC Institute, under subcontract
B598130 from \sphinxhref{http://www.llnl.gov}{Lawrence Livermore National Laboratory}.


\chapter{Introduction}
\label{\detokenize{Introduction:arkode-documentation}}\label{\detokenize{Introduction::doc}}\label{\detokenize{Introduction:introduction}}\label{\detokenize{Introduction:id1}}
The ARKode infrastructure provides adaptive-step time integration
modules for stiff, nonstiff and mixed stiff/nonstiff systems of
ordinary differential equations (ODEs).  ARKode itself is structured
to support a wide range of one-step (but multi-stage) methods,
allowing for rapid development of parallel implementations of
state-of-the-art time integration methods.  At present, ARKode is
packaged with two time-stepping modules, \sphinxstyleemphasis{ARKStep} and \sphinxstyleemphasis{ERKStep}.

\sphinxstyleemphasis{ARKStep} supports ODE systems posed in split, linearly-implicit form,

\phantomsection\label{\detokenize{Introduction:equation-ode-split-linearly-implicit}}\begin{equation}\label{equation:Introduction:ODE_split_linearly_implicit}
\begin{split}M \dot{y} = f^E(t,y) + f^I(t,y),  \qquad y(t_0) = y_0,\end{split}
\end{equation}
where \(t\) is the independent variable, \(y\) is the set of
dependent variables (in \(\mathbb{R}^N\)), \(M\) is a
user-specified, nonsingular operator from \(\mathbb{R}^N\) to
\(\mathbb{R}^N\), and the right-hand side function is partitioned
into up to two components:
\begin{itemize}
\item {} 
\(f^E(t,y)\) contains the “nonstiff” time scale components to be
integrated explicitly, and

\item {} 
\(f^I(t,y)\)  contains the “stiff” time scale components to be
integrated implicitly.

\end{itemize}

Either of these operators may be disabled, allowing for fully
explicit, fully implicit, or combination implicit-explicit (ImEx) time
integration.

The algorithms used in ARKStep are adaptive- and fixed-step additive
Runge Kutta methods. Such methods are defined through combining two
complementary Runge-Kutta methods: one explicit (ERK) and the other
diagonally implicit (DIRK).  Through appropriately partitioning the
ODE right-hand side into explicit and implicit components
\eqref{equation:Introduction:ODE_split_linearly_implicit}, such methods have the potential to
enable accurate and efficient time integration of stiff, nonstiff, and
mixed stiff/nonstiff systems of ordinary differential equations.  A
key feature allowing for high efficiency of these methods is that only
the components in \(f^I(t,y)\) must be solved implicitly, allowing
for splittings tuned for use with optimal implicit solver algorithms.

This framework allows for significant freedom over the constitutive
methods used for each component, and ARKode is packaged with a wide
array of built-in methods for use.  These built-in Butcher tables
include adaptive explicit methods of orders 2-8, adaptive implicit
methods of orders 2-5, and adaptive ImEx methods of orders 3-5.

\sphinxstyleemphasis{ERKStep} focuses specifically on problems posed in explicit form,

\phantomsection\label{\detokenize{Introduction:equation-ode-explicit}}\begin{equation}\label{equation:Introduction:ODE_explicit}
\begin{split}\dot{y} = f(t,y),  \qquad y(t_0) = y_0.\end{split}
\end{equation}
allowing for increased computational efficiency and memory savings.
The algorithms used in ERKStep are adaptive- and fixed-step explicit
Runge Kutta methods.   As with ARKStep, the ERKStep module is packaged
with adaptive explicit methods of orders 2-8.

For problems that include nonzero implicit term \(f^I(t,y)\), the
resulting implicit system (assumed nonlinear, unless specified
otherwise) is solved approximately at each integration step, using a
modified Newton method, inexact Newton method, or an
accelerated fixed-point solver.  For the Newton-based methods and the
serial or threaded NVECTOR modules in SUNDIALS, ARKode may use a
variety of linear solvers provided with SUNDIALS, including both
direct (dense, band, or sparse) and preconditioned Krylov iterative
(GMRES \phantomsection\label{\detokenize{Introduction:id2}}{\hyperref[\detokenize{References:ss1986}]{\sphinxcrossref{{[}SS1986{]}}}}, BiCGStab \phantomsection\label{\detokenize{Introduction:id3}}{\hyperref[\detokenize{References:v1992}]{\sphinxcrossref{{[}V1992{]}}}}, TFQMR \phantomsection\label{\detokenize{Introduction:id4}}{\hyperref[\detokenize{References:f1993}]{\sphinxcrossref{{[}F1993{]}}}}, FGMRES \phantomsection\label{\detokenize{Introduction:id5}}{\hyperref[\detokenize{References:s1993}]{\sphinxcrossref{{[}S1993{]}}}},
or PCG \phantomsection\label{\detokenize{Introduction:id6}}{\hyperref[\detokenize{References:hs1952}]{\sphinxcrossref{{[}HS1952{]}}}}) linear solvers.  When used with the MPI-based
parallel, PETSc, \sphinxstyleemphasis{hypre}, CUDA, HIP, and Raja NVECTOR modules, or a
user-provided vector data structure, only the Krylov solvers are
available, although a user may supply their own linear solver for any
data structures if desired.  For the serial or threaded vector
structures, we provide a banded preconditioner module called ARKBANDPRE
that may be used with the Krylov solvers, while for the MPI-based
parallel vector structure there is a preconditioner module called
ARKBBDPRE which provides a band-block-diagonal preconditioner.
Additionally, a user may supply more optimal, problem-specific
preconditioner routines.


\section{Changes from previous versions}
\label{\detokenize{Introduction:changes-from-previous-versions}}

\subsection{Changes in 4.6.0}
\label{\detokenize{Introduction:changes-in-4-6-0}}
A new NVECTOR implementation based on the AMD ROCm HIP platform has been added.
This vector can target NVIDIA or AMD GPUs. See {\hyperref[\detokenize{nvectors/NVector_HIP:nvectors-hip}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_HIP Module}}}} for more
details. This module is considered experimental and is subject to change from
version to version.

The RAJA NVECTOR implementation has been updated to support the HIP backend
in addition to the CUDA backend. Users can choose the backend when configuring
SUNDIALS by using the \sphinxcode{SUNDIALS\_RAJA\_BACKENDS} CMake variable. This module
remains experimental and is subject to change from version to version.

A new optional operation, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetDeviceArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetDeviceArrayPointer()}}}}, was added to the
N\_Vector API. This operation is useful for N\_Vectors that utilize dual memory
spaces, e.g. the native SUNDIALS CUDA N\_Vector.

The SUNMATRIX\_CUSPARSE and SUNLINEARSOLVER\_CUSOLVERSP\_BATCHQR implementations
no longer require the SUNDIALS CUDA N\_Vector. Instead, they require that the
vector utilized provides the {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetDeviceArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetDeviceArrayPointer()}}}} operation, and
that the pointer returned by {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetDeviceArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetDeviceArrayPointer()}}}} is a valid CUDA
device pointer.


\subsection{Changes in v4.5.0}
\label{\detokenize{Introduction:changes-in-v4-5-0}}
Refactored the SUNDIALS build system. CMake 3.12.0 or newer is now required.
Users will likely see deprecation warnings, but otherwise the changes
should be fully backwards compatible for almost all users. SUNDIALS
now exports CMake targets and installs a SUNDIALSConfig.cmake file.

Added support for SuperLU DIST 6.3.0 or newer.


\subsection{Changes in v4.4.0}
\label{\detokenize{Introduction:changes-in-v4-4-0}}
Added full support for time-dependent mass matrices in ARKStep, and expanded
existing non-identity mass matrix infrastructure to support use of the
fixed point nonlinear solver. Fixed bug for ERK method integration with
static mass matrices.

An interface between ARKStep and the XBraid multigrid reduction in time (MGRIT)
library \phantomsection\label{\detokenize{Introduction:id7}}{\hyperref[\detokenize{References:xbraid}]{\sphinxcrossref{{[}XBraid{]}}}} has been added to enable parallel-in-time integration. See the
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-xbraid}]{\sphinxcrossref{\DUrole{std,std-ref}{Multigrid Reduction in Time with XBraid}}}} section for more information and the example
codes in \sphinxcode{examples/arkode/CXX\_xbraid}. This interface required the addition of
three new N\_Vector operations to exchange vector data between computational
nodes, see {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufSize}]{\sphinxcrossref{\sphinxcode{N\_VBufSize()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufPack}]{\sphinxcrossref{\sphinxcode{N\_VBufPack()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufUnpack}]{\sphinxcrossref{\sphinxcode{N\_VBufUnpack()}}}}.  These N\_Vector operations are only used within the
XBraid interface and need not be implemented for any other context.

Updated the MRIStep time-stepping module in ARKode to support
higher-order MRI-GARK methods \phantomsection\label{\detokenize{Introduction:id8}}{\hyperref[\detokenize{References:s2019}]{\sphinxcrossref{{[}S2019{]}}}}, including methods that
involve solve-decoupled, diagonally-implicit treatment of the
slow time scale.

Added the functions {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSNormFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSNormFactor()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLSNormFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLSNormFactor()}}}}, and {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSNormFactor}]{\sphinxcrossref{\sphinxcode{MRIStepSetLSNormFactor()}}}}
to specify the factor for converting between integrator tolerances (WRMS norm)
and linear solver tolerances (L2 norm) i.e.,
\sphinxcode{tol\_L2 = nrmfac * tol\_WRMS}.

Added new reset functions {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}},
and {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}} to reset the stepper time and state vector to
user-provided values for continuing the integration from that point while
retaining the integration history. These function complement the
reinitialization functions {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}},
and {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} which reinitialize the stepper so that the problem
integration should resume as if started from scratch.

Added new functions {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepComputeState}]{\sphinxcrossref{\sphinxcode{ARKStepComputeState()}}}},
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{ARKStepGetNonlinearSystemData()}}}}, {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepComputeState}]{\sphinxcrossref{\sphinxcode{MRIStepComputeState()}}}}, and
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{MRIStepGetNonlinearSystemData()}}}} which advanced users might find useful
if providing a custom {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn()}}}}.

The expected behavior of {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetNumIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetNumIters()}}}} and
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetNumConvFails}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetNumConvFails()}}}} in the SUNNonlinearSolver API have been
updated to specify that they should return the number of nonlinear solver
iterations and convergence failures in the most recent solve respectively rather
than the cumulative number of iterations and failures across all solves
respectively. The API documentation and SUNDIALS provided SUNNonlinearSolver
implementations have been updated accordingly. As before, the cumulative number
of nonlinear iterations may be retrieved by calling
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvIters}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumNonlinSolvIters()}}}}, the cumulative number of failures with
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumNonlinSolvConvFails()}}}}, or both with
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNonlinSolvStats}]{\sphinxcrossref{\sphinxcode{ARKStepGetNonlinSolvStats()}}}}.

A minor bug in checking the Jacobian evaluation frequency has been fixed. As a
result codes using using a non-default Jacobian update frequency through a call
to \sphinxcode{ARKStepSetMaxStepsBetweenJac()} will need to increase the provided
value by 1 to achieve the same behavior as before. Additionally, for greater
clarity the functions \sphinxcode{ARKStepSetMaxStepsBetweenLSet()} and
\sphinxcode{ARKStepSetMaxStepsBetweenJac()} have been deprecated and replaced with
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSetupFrequency()}}}} and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacEvalFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacEvalFrequency()}}}}
respectively.

The \sphinxcode{NVECTOR\_RAJA} module has been updated to mirror the \sphinxcode{NVECTOR\_CUDA} module.
Notably, the update adds managed memory support to the \sphinxcode{NVECTOR\_RAJA} module.
Users of the module will need to update any calls to the \sphinxcode{N\_VMake\_Raja} function
because that signature was changed. This module remains experimental and is
subject to change from version to version.

The \sphinxcode{NVECTOR\_TRILINOS} module has been updated to work with Trilinos 12.18+.
This update changes the local ordinal type to always be an \sphinxcode{int}.

Added support for CUDA v11.


\subsection{Changes in v4.3.0}
\label{\detokenize{Introduction:changes-in-v4-3-0}}
Fixed a bug in ARKode where the prototypes for {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ERKStepSetMinReduction()}}}}
and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinReduction()}}}} were not included in \sphinxcode{arkode\_erkstep.h}
and \sphinxcode{arkode\_arkstep.h} respectively.

Fixed a bug where inequality constraint checking would need to be disabled and
then re-enabled to update the inequality constraint values after resizing a
problem. Resizing a problem will now disable constraints and a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}} or {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ERKStepSetConstraints()}}}} is
required to re-enable constraint checking for the new problem size.

Fixed a bug in the iterative linear solver modules where an error is not
returned if the Atimes function is \sphinxcode{NULL} or, if preconditioning is enabled,
the PSolve function is \sphinxcode{NULL}.

Added the ability to control the CUDA kernel launch parameters for the
\sphinxcode{NVECTOR\_CUDA} and \sphinxcode{SUNMATRIX\_CUSPARSE} modules. These modules remain
experimental and are subject to change from version to version.
In addition, the \sphinxcode{NVECTOR\_CUDA} kernels were rewritten to be more flexible.
Most users should see equivalent performance or some improvement, but a select
few may observe minor performance degradation with the default settings. Users
are encouraged to contact the SUNDIALS team about any perfomance changes
that they notice.

Added the optional function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimesRhsFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimesRhsFn()}}}} to specify an
alternative implicit right-hand side function for computing Jacobian-vector
products with the internal difference quotient approximation.

Added new capabilities for monitoring the solve phase in the \sphinxcode{SUNNONLINSOL\_NEWTON}
and \sphinxcode{SUNNONLINSOL\_FIXEDPOINT} modules, and the SUNDIALS iterative linear solver
modules. SUNDIALS must be built with the CMake option
\sphinxcode{SUNDIALS\_BUILD\_WITH\_MONITORING} to use these capabilties.


\subsection{Changes in v4.2.0}
\label{\detokenize{Introduction:changes-in-v4-2-0}}
Fixed a build system bug related to the Fortran 2003 interfaces when using the
IBM XL compiler. When building the Fortran 2003 interfaces with an XL compiler
it is recommended to set \sphinxcode{CMAKE\_Fortran\_COMPILER} to \sphinxcode{f2003}, \sphinxcode{xlf2003},
or \sphinxcode{xlf2003\_r}.

Fixed a bug in how ARKode interfaces with a user-supplied, iterative, unscaled linear solver.
In this case, ARKode adjusts the linear solver tolerance in an attempt to account for the
lack of support for left/right scaling matrices.  Previously, ARKode computed this scaling
factor using the error weight vector, \sphinxcode{ewt}; this fix changes that to the residual weight vector,
\sphinxcode{rwt}, that can differ from \sphinxcode{ewt} when solving problems with non-identity mass matrix.

Fixed a similar bug in how ARKode interfaces with scaled linear solvers when solving problems
with non-identity mass matrices.  Here, the left scaling matrix should correspond with \sphinxcode{rwt}
and the right scaling matrix with \sphinxcode{ewt}; these were reversed but are now correct.

Fixed a bug where a non-default value for the maximum allowed growth factor
after the first step would be ignored.

The function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolutionScaling}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolutionScaling()}}}} was added to
enable or disable the scaling applied to linear system solutions with
matrix-based linear solvers to account for a lagged value of \(\gamma\) in
the linear system matrix e.g., \(M - \gamma J\) or \(I - \gamma J\).
Scaling is enabled by default when using a matrix-based linear solver.

Added two new functions, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinReduction()}}}} and
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ERKStepSetMinReduction()}}}}, to change the minimum allowed step size
reduction factor after an error test failure.

Added a new \sphinxcode{SUNMatrix} implementation, {\hyperref[\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_CUSPARSE Module}}}}, that interfaces
to the sparse matrix implementation from the NVIDIA cuSPARSE library. In addition,
the {\hyperref[\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinSol\_cuSolverSp\_batchQR Module}}}} \sphinxcode{SUNLinearSolver} has been updated to
use this matrix, as such, users of this module will need to update their code.
These modules are still considered to be experimental, thus they are subject to
breaking changes even in minor releases.

Added a new “stiff” interpolation module, based on Lagrange polynomial interpolation,
that is accessible to each of the ARKStep, ERKStep and MRIStep time-stepping modules.
This module is designed to provide increased interpolation accuracy when integrating
stiff problems, as opposed to the ARKode-standard Hermite interpolation module that
can suffer when the IVP right-hand side has large Lipschitz constant.  While the
Hermite module remains the default, the new Lagrange module may be enabled using one
of the routines {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantType()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantType()}}}},
or {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantType()}}}}.  The serial example problem \sphinxcode{ark\_brusselator.c}
has been converted to use this Lagrange interpolation module.  Created accompanying routines
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}}, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}} to provide user control over these
interpolating polynomials.  While the routines {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDenseOrder}]{\sphinxcrossref{\sphinxcode{ARKStepSetDenseOrder()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDenseOrder}]{\sphinxcrossref{\sphinxcode{ARKStepSetDenseOrder()}}}} and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDenseOrder}]{\sphinxcrossref{\sphinxcode{ARKStepSetDenseOrder()}}}} still exist,
these have been deprecated and will be removed in a future release.


\subsection{Changes in v4.1.0}
\label{\detokenize{Introduction:changes-in-v4-1-0}}
Fixed a build system bug related to finding LAPACK/BLAS.

Fixed a build system bug related to checking if the KLU library works.

Fixed a build system bug related to finding PETSc when using the CMake
variables \sphinxcode{PETSC\_INCLUDES} and \sphinxcode{PETSC\_LIBRARIES} instead of
\sphinxcode{PETSC\_DIR}.

Added a new build system option, \sphinxcode{CUDA\_ARCH}, that can be used to specify
the CUDA architecture to compile for.

Fixed a bug in the Fortran 2003 interfaces to the ARKode Butcher table routines and structure.
This includes changing the \sphinxcode{ARKodeButcherTable} type to be a \sphinxcode{type(c\_ptr)} in Fortran.

Added two utility functions, \sphinxcode{SUNDIALSFileOpen} and \sphinxcode{SUNDIALSFileClose}
for creating/destroying file pointers that are useful when using the Fortran
2003 interfaces.

Added support for a user-supplied function to update the prediction for each
implicit stage solution in ARKStep.  If supplied, this routine will be called
\sphinxstyleemphasis{after} any existing ARKStep predictor algorithm completes, so that the
predictor may be modified by the user as desired.  The new user-supplied routine
has type \sphinxcode{ARKStepStagePredictFn}, and may be set by calling
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStagePredictFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStagePredictFn()}}}}.

The MRIStep module has been updated to support attaching different user data
pointers to the inner and outer integrators. If applicable, user codes will
need to add a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}} to attach their user data
pointer to the inner integrator memory as {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}} will
not set the pointer for both the inner and outer integrators. The MRIStep
examples have been updated to reflect this change.

Added support for constant damping to the \sphinxcode{SUNNonlinearSolver\_FixedPoint}
module when using Anderson acceleration. See {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsolfixedpoint-math}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver\_FixedPoint description}}}}
and the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetDamping_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetDamping\_FixedPoint()}}}} for more details.


\subsection{Changes in v4.0.0}
\label{\detokenize{Introduction:changes-in-v4-0-0}}
\sphinxstylestrong{Build system changes}

Increased the minimum required CMake version to 3.5 for most SUNDIALS
configurations, and 3.10 when CUDA or OpenMP with device offloading are enabled.

The CMake option \sphinxcode{BLAS\_ENABLE} and the variable \sphinxcode{BLAS\_LIBRARIES} have been
removed to simplify builds as SUNDIALS packages do not use BLAS directly. For
third party libraries that require linking to BLAS, the path to the BLAS
library should be included in the \sphinxcode{\_LIBRARIES} variable for the third party
library e.g., \sphinxcode{SUPERLUDIST\_LIBRARIES} when enabling SuperLU\_DIST.

Fixed a bug in the build system that prevented the PThreads NVECTOR module from
being built.

\sphinxstylestrong{NVECTOR module changes}

Two new functions were added to aid in creating custom NVECTOR objects. The
constructor {\hyperref[\detokenize{nvectors/NVector_Description:c.N_VNewEmpty}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty()}}}} allocates an “empty” generic NVECTOR with
the object’s content pointer and the function pointers in the operations
structure initialized to \sphinxcode{NULL}. When used in the constructor for custom
objects this function will ease the introduction of any new optional operations
to the NVECTOR API by ensuring only required operations need to be set.
Additionally, the function {\hyperref[\detokenize{nvectors/NVector_Description:c.N_VCopyOps}]{\sphinxcrossref{\sphinxcode{N\_VCopyOps()}}}} has been added to copy the
operation function pointers between vector objects. When used in clone routines
for custom vector objects these functions also will ease the introduction of
any new optional operations to the NVECTOR API by ensuring all operations
are copied when cloning objects.

Two new NVECTOR implementations, NVECTOR\_MANYVECTOR and
NVECTOR\_MPIMANYVECTOR, have been created to support flexible partitioning
of solution data among different processing elements (e.g., CPU + GPU) or for
multi-physics problems that couple distinct MPI-based simulations together. This
implementation is accompanied by additions to user documentation and SUNDIALS
examples.

One new required vector operation and ten new optional vector operations have
been added to the NVECTOR API. The new required operation, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetLength}]{\sphinxcrossref{\sphinxcode{N\_VGetLength()}}}},
returns the global length of an \sphinxcode{N\_Vector}. The optional operations have
been added to support the new NVECTOR\_MPIMANYVECTOR implementation. The
operation {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetCommunicator}]{\sphinxcrossref{\sphinxcode{N\_VGetCommunicator()}}}} must be implemented by subvectors that are
combined to create an NVECTOR\_MPIMANYVECTOR, but is not used outside of
this context. The remaining nine operations are optional local reduction
operations intended to eliminate unnecessary latency when performing vector
reduction operations (norms, etc.) on distributed memory systems. The optional
local reduction vector operations are
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProdLocal}]{\sphinxcrossref{\sphinxcode{N\_VDotProdLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMaxNormLocal}]{\sphinxcrossref{\sphinxcode{N\_VMaxNormLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinLocal}]{\sphinxcrossref{\sphinxcode{N\_VMinLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VL1NormLocal}]{\sphinxcrossref{\sphinxcode{N\_VL1NormLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWSqrSumLocal}]{\sphinxcrossref{\sphinxcode{N\_VWSqrSumLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWSqrSumMaskLocal}]{\sphinxcrossref{\sphinxcode{N\_VWSqrSumMaskLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VInvTestLocal}]{\sphinxcrossref{\sphinxcode{N\_VInvTestLocal()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMaskLocal}]{\sphinxcrossref{\sphinxcode{N\_VConstrMaskLocal()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotientLocal}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotientLocal()}}}}.
If an NVECTOR implementation defines any of the local operations as
\sphinxcode{NULL}, then the NVECTOR\_MPIMANYVECTOR will call standard NVECTOR
operations to complete the computation.

An additional NVECTOR implementation, NVECTOR\_MPIPLUSX, has been created to
support the MPI+X paradigm where X is a type of on-node parallelism
(\sphinxstyleemphasis{e.g.}, OpenMP, CUDA). The implementation is accompanied by additions to
user documentation and SUNDIALS examples.

The \sphinxcode{*\_MPICuda} and \sphinxcode{*\_MPIRaja} functions have been removed from the
NVECTOR\_CUDA and NVECTOR\_RAJA implementations respectively. Accordingly, the
\sphinxcode{nvector\_mpicuda.h}, \sphinxcode{nvector\_mpiraja.h}, \sphinxcode{libsundials\_nvecmpicuda.lib},
and \sphinxcode{libsundials\_nvecmpicudaraja.lib} files have been removed. Users should
use the NVECTOR\_MPIPLUSX module coupled in conjunction with the NVECTOR\_CUDA
or NVECTOR\_RAJA modules to replace the functionality. The necessary changes are
minimal and should require few code modifications. See the programs in
\sphinxcode{examples/ida/mpicuda} and \sphinxcode{examples/ida/mpiraja} for examples of how to
use the NVECTOR\_MPIPLUSX module with the NVECTOR\_CUDA and NVECTOR\_RAJA modules
respectively.

Fixed a memory leak in the NVECTOR\_PETSC module clone function.

Made performance improvements to the NVECTOR\_CUDA module. Users who utilize a
non-default stream should no longer see default stream synchronizations
after memory transfers.

Added a new constructor to the NVECTOR\_CUDA module that allows a user to provide
custom allocate and free functions for the vector data array and internal
reduction buffer.

Added new Fortran 2003 interfaces for most NVECTOR modules. See the
{\hyperref[\detokenize{ARKode_f_interface/index:fortraninterfaces}]{\sphinxcrossref{\DUrole{std,std-ref}{Using ARKode for Fortran Applications}}}} section for more details.

Added three new NVECTOR utility functions,
\sphinxcode{N\_VGetVecAtIndexVectorArray()}
\sphinxcode{N\_VSetVecAtIndexVectorArray()}, and
\sphinxcode{N\_VNewVectorArray()},
for working with \sphinxcode{N\_Vector} arrays when using the Fortran 2003 interfaces.

\sphinxstylestrong{SUNMatrix module changes}

Two new functions were added to aid in creating custom SUNMATRIX objects. The
constructor {\hyperref[\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatNewEmpty}]{\sphinxcrossref{\sphinxcode{SUNMatNewEmpty()}}}} allocates an “empty” generic SUNMATRIX with
the object’s content pointer and the function pointers in the operations
structure initialized to \sphinxcode{NULL}. When used in the constructor for custom
objects this function will ease the introduction of any new optional operations
to the SUNMATRIX API by ensuring only required operations need to be set.
Additionally, the function {\hyperref[\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatCopyOps}]{\sphinxcrossref{\sphinxcode{SUNMatCopyOps()}}}} has been added to copy the
operation function pointers between matrix objects. When used in clone routines
for custom matrix objects these functions also will ease the introduction of any
new optional operations to the SUNMATRIX API by ensuring all operations are
copied when cloning objects.

A new operation, {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatMatvecSetup}]{\sphinxcrossref{\sphinxcode{SUNMatMatvecSetup()}}}}, was added to the SUNMATRIX API.
Users who have implemented custom SUNMATRIX modules will need to at least
update their code to set the corresponding \sphinxcode{ops} structure member,
\sphinxcode{matvecsetup}, to \sphinxcode{NULL}.

A new operation, {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatMatvecSetup}]{\sphinxcrossref{\sphinxcode{SUNMatMatvecSetup()}}}}, was added to the SUNMATRIX API
to perform any setup necessary for computing a matrix-vector product. This
operation is useful for SUNMATRIX implementations which need to prepare the
matrix itself, or communication structures before performing the matrix-vector
product. Users who have implemented custom SUNMATRIX modules will need to at
least update their code to set the corresponding \sphinxcode{ops} structure member,
\sphinxcode{matvecsetup}, to \sphinxcode{NULL}.

The generic SUNMATRIX API now defines error codes to be returned by
SUNMATRIX operations. Operations which return an integer flag indiciating
success/failure may return different values than previously.

A new SUNMATRIX (and SUNLINEARSOLVER) implementation was added to
facilitate the use of the SuperLU\_DIST library with SUNDIALS.

Added new Fortran 2003 interfaces for most SUNMATRIX modules. See the
{\hyperref[\detokenize{ARKode_f_interface/index:fortraninterfaces}]{\sphinxcrossref{\DUrole{std,std-ref}{Using ARKode for Fortran Applications}}}} section for more details.

\sphinxstylestrong{SUNLinearSolver module changes}

A new function was added to aid in creating custom SUNLINEARSOLVER objects.
The constructor {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolNewEmpty}]{\sphinxcrossref{\sphinxcode{SUNLinSolNewEmpty()}}}} allocates an “empty” generic
SUNLINEARSOLVER with the object’s content pointer and the function pointers
in the operations structure initialized to \sphinxcode{NULL}. When used in the
constructor for custom objects this function will ease the introduction of any
new optional operations to the SUNLINEARSOLVER API by ensuring only required
operations need to be set.

The return type of the SUNLINEARSOLVER API function {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolLastFlag}]{\sphinxcrossref{\sphinxcode{SUNLinSolLastFlag()}}}}
has changed from \sphinxcode{long int} to \sphinxcode{sunindextype} to be consistent with the
type used to store row indices in dense and banded linear solver modules.

Added a new optional operation to the SUNLINEARSOLVER API,
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolGetID}]{\sphinxcrossref{\sphinxcode{SUNLinSolGetID()}}}}, that returns a \sphinxcode{SUNLinearSolver\_ID} for identifying
the linear solver module.

The SUNLINEARSOLVER API has been updated to make the initialize and setup
functions optional.

A new SUNLINEARSOLVER (and SUNMATRIX) implementation was added to
facilitate the use of the SuperLU\_DIST library with SUNDIALS.

Added a new SUNLinearSolver implementation, \sphinxcode{SUNLinearSolver\_cuSolverSp\_batchQR},
which leverages the NVIDIA cuSOLVER sparse batched QR method for efficiently
solving block diagonal linear systems on NVIDIA GPUs.

Added three new accessor functions to the SUNLinSol\_KLU module,
{\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUGetSymbolic}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUGetSymbolic()}}}}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUGetNumeric}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUGetNumeric()}}}}, and
{\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUGetCommon}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUGetCommon()}}}}, to provide user access to the underlying
KLU solver structures.

Added new Fortran 2003 interfaces for most SUNLINEARSOLVER modules. See the
{\hyperref[\detokenize{ARKode_f_interface/index:fortraninterfaces}]{\sphinxcrossref{\DUrole{std,std-ref}{Using ARKode for Fortran Applications}}}} section for more details.

\sphinxstylestrong{SUNNonlinearSolver module changes}

A new function was added to aid in creating custom SUNNONLINEARSOLVER
objects. The constructor {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolNewEmpty}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolNewEmpty()}}}} allocates an “empty”
generic SUNNONLINEARSOLVER with the object’s content pointer and the function
pointers in the operations structure initialized to \sphinxcode{NULL}. When used in the
constructor for custom objects this function will ease the introduction of any
new optional operations to the SUNNONLINEARSOLVER API by ensuring only
required operations need to be set.

To facilitate the use of user supplied nonlinear solver convergence test
functions the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetConvTestFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetConvTestFn()}}}} function in the
SUNNONLINEARSOLVER API has been updated to take a \sphinxcode{void*} data pointer as
input. The supplied data pointer will be passed to the nonlinear solver
convergence test function on each call.

The inputs values passed to the first two inputs of the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSolve}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSolve()}}}}
function in the SUNNONLINEARSOLVER have been changed to be the predicted
state and the initial guess for the correction to that state. Additionally,
the definitions of {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn}}}} and {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSolveFn}}}}
in the SUNNONLINEARSOLVER API have been updated to remove unused input
parameters.

Added a new \sphinxcode{SUNNonlinearSolver} implementation, \sphinxcode{SUNNonlinsol\_PetscSNES},
which interfaces to the PETSc SNES nonlinear solver API.

Added new Fortran 2003 interfaces for most SUNNONLINEARSOLVER modules. See the
{\hyperref[\detokenize{ARKode_f_interface/index:fortraninterfaces}]{\sphinxcrossref{\DUrole{std,std-ref}{Using ARKode for Fortran Applications}}}} section for more details.

\sphinxstylestrong{ARKode changes}

The MRIStep module has been updated to support explicit, implicit, or IMEX
methods as the fast integrator using the ARKStep module. As a result some
function signatures have been changed including {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} which
now takes an ARKStep memory structure for the fast integration as an input.

Fixed a bug in the ARKStep time-stepping module that would result in an infinite
loop if the nonlinear solver failed to converge more than the maximum allowed times
during a single step.

Fixed a bug that would result in a “too much accuracy requested” error when
using fixed time step sizes with explicit methods in some cases.

Fixed a bug in ARKStep where the mass matrix linear solver setup function was
not called in the Matrix-free case.

Fixed a minor bug in ARKStep where an incorrect flag is reported when an
error occurs in the mass matrix setup or Jacobian-vector product setup
functions.

Fixed a memeory leak in FARKODE when not using the default nonlinear solver.

The reinitialization functions {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}, and {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} have been updated to
retain the minimum and maxiumum step size values from before reinitialization
rather than resetting them to the default values.

Removed extraneous calls to {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMin}]{\sphinxcrossref{\sphinxcode{N\_VMin()}}}} for simulations where
the scalar valued absolute tolerance, or all entries of the
vector-valued absolute tolerance array, are strictly positive.  In
this scenario, ARKode will remove at least one global reduction per
time step.

The ARKLS interface has been updated to only zero the Jacobian matrix before
calling a user-supplied Jacobian evaluation function when the attached linear
solver has type \sphinxcode{SUNLINEARSOLVER\_DIRECT}.

A new linear solver interface function {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn()}}}} was added as an
alternative method for evaluating the linear system \(A = M - \gamma J\).

Added two new embedded ARK methods of orders 4 and 5 to ARKode (from \phantomsection\label{\detokenize{Introduction:id9}}{\hyperref[\detokenize{References:kc2019}]{\sphinxcrossref{{[}KC2019{]}}}}).

Support for optional inequality constraints on individual components of the
solution vector has been added the ARKode ERKStep and ARKStep modules. See
the descriptions of {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ERKStepSetConstraints()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}} for more details. Note that enabling
constraint handling requires the NVECTOR operations {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotient}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotient()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMask}]{\sphinxcrossref{\sphinxcode{N\_VConstrMask()}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VCompare}]{\sphinxcrossref{\sphinxcode{N\_VCompare()}}}} that were not previously
required by ARKode.

Added two new ‘Get’ functions to ARKStep, {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentGamma}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentGamma()}}}},
and {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentState}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentState()}}}}, that may be useful to users who choose
to provide their own nonlinear solver implementation.

Add two new ‘Set’ functions to MRIStep, {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPreInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetPreInnerFn()}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPostInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetPostInnerFn()}}}} for performing communication or memory
transfers needed before or after the inner integration.

A new Fortran 2003 interface to ARKode was added. This includes Fortran 2003 interfaces
to the ARKStep, ERKStep, and MRIStep time-stepping modules. See the
{\hyperref[\detokenize{ARKode_f_interface/index:fortraninterfaces}]{\sphinxcrossref{\DUrole{std,std-ref}{Using ARKode for Fortran Applications}}}} section for more details.


\subsection{Changes in v3.1.0}
\label{\detokenize{Introduction:changes-in-v3-1-0}}
An additional NVECTOR implementation was added for the
Tpetra vector from the Trilinos library to facilitate interoperability
between SUNDIALS and Trilinos. This implementation is accompanied by
additions to user documentation and SUNDIALS examples.

A bug was fixed where a nonlinear solver object could be freed twice in some use
cases.

The \sphinxcode{EXAMPLES\_ENABLE\_RAJA} CMake option has been removed. The option \sphinxcode{EXAMPLES\_ENABLE\_CUDA}
enables all examples that use CUDA including the RAJA examples with a CUDA back end
(if the RAJA NVECTOR is enabled).

The implementation header file \sphinxtitleref{arkode\_impl.h} is no longer installed. This means users
who are directly manipulating the \sphinxcode{ARKodeMem} structure will need to update their code
to use ARKode’s public API.

Python is no longer required to run \sphinxcode{make test} and \sphinxcode{make test\_install}.

Fixed a bug in \sphinxcode{ARKodeButcherTable\_Write} when printing a Butcher table
without an embedding.


\subsection{Changes in v3.0.2}
\label{\detokenize{Introduction:changes-in-v3-0-2}}
Added information on how to contribute to SUNDIALS and a contributing agreement.


\subsection{Changes in v3.0.1}
\label{\detokenize{Introduction:changes-in-v3-0-1}}
A bug in ARKode where single precision builds would fail to compile has been fixed.


\subsection{Changes in v3.0.0}
\label{\detokenize{Introduction:changes-in-v3-0-0}}
The ARKode library has been entirely rewritten to support a modular
approach to one-step methods, which should allow rapid research and
development of novel integration methods without affecting existing
solver functionality.  To support this, the existing ARK-based methods
have been encapsulated inside the new \sphinxcode{ARKStep} time-stepping
module. Two new time-stepping modules have been added:
\begin{itemize}
\item {} 
The \sphinxcode{ERKStep} module provides an optimized implementation for explicit
Runge-Kutta methods with reduced storage and number of calls to the ODE
right-hand side function.

\item {} 
The \sphinxcode{MRIStep} module implements two-rate explicit-explicit multirate
infinitesimal step methods utilizing different step sizes for slow
and fast processes in an additive splitting.

\end{itemize}

This restructure has resulted in numerous small changes to the user
interface, particularly the suite of “Set” routines for user-provided
solver parameters and “Get” routines to access solver statistics,
that are now prefixed with the name of time-stepping module (e.g., \sphinxcode{ARKStep}
or \sphinxcode{ERKStep}) instead of \sphinxcode{ARKode}.  Aside from affecting the names of these
routines, user-level changes have been kept to a minimum.  However, we recommend
that users consult both this documentation and the ARKode example programs for
further details on the updated infrastructure.

As part of the ARKode restructuring an {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} structure
has been added for storing Butcher tables. Functions for creating new Butcher
tables and checking their analytic order are provided along with other utility
routines. For more details see {\hyperref[\detokenize{ARKodeButcherTable:arkodebutchertable}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher Table Data Structure}}}}.

Two changes were made in the initial step size algorithm:
\begin{itemize}
\item {} 
Fixed an efficiency bug where an extra call to the right hand side function was made.

\item {} 
Changed the behavior of the algorithm if the max-iterations case is hit.
Before the algorithm would exit with the step size calculated on the
penultimate iteration. Now it will exit with the step size calculated
on the final iteration.

\end{itemize}

ARKode’s dense output infrastructure has been improved to support
higher-degree Hermite polynomial interpolants (up to degree 5) over
the last successful time step.

ARKode’s previous direct and iterative linear solver interfaces, ARKDLS and
ARKSPILS, have been merged into a single unified linear solver interface, ARKLS,
to support any valid SUNLINSOL module. This includes \sphinxcode{DIRECT} and
\sphinxcode{ITERATIVE} types as well as the new \sphinxcode{MATRIX\_ITERATIVE} type. Details
regarding how ARKLS utilizes linear solvers of each type as well as discussion
regarding intended use cases for user-supplied SUNLinSol implementations are
included in the chapter {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}. All ARKode examples programs and the
standalone linear solver examples have been updated to use the unified linear
solver interface.

The user interface for the new ARKLS module is very similar to the previous
ARKDLS and ARKSPILS interfaces. Additionally, we note that Fortran users will
need to enlarge their \sphinxcode{iout} array of optional integer outputs, and update the
indices that they query for certain linear-solver-related statistics.

The names of all constructor routines for SUNDIALS-provided SUNLinSol
implementations have been updated to follow the naming convention
\sphinxcode{SUNLinSol\_*} where \sphinxcode{*} is the name of the linear solver. The new names are
\sphinxcode{SUNLinSol\_Band}, \sphinxcode{SUNLinSol\_Dense}, \sphinxcode{SUNLinSol\_KLU},
\sphinxcode{SUNLinSol\_LapackBand}, \sphinxcode{SUNLinSol\_LapackDense}, \sphinxcode{SUNLinSol\_PCG},
\sphinxcode{SUNLinSol\_SPBCGS}, \sphinxcode{SUNLinSol\_SPFGMR}, \sphinxcode{SUNLinSol\_SPGMR},
\sphinxcode{SUNLinSol\_SPTFQMR}, and \sphinxcode{SUNLinSol\_SuperLUMT}.  Solver-specific “set”
routine names have been similarly standardized.  To minimize challenges in user
migration to the new names, the previous routine names may still be used; these
will be deprecated in future releases, so we recommend that users migrate to the
new names soon. All ARKode example programs and the standalone linear solver
examples have been updated to use the new naming convention.

The \sphinxcode{SUNBandMatrix} constructor has been simplified to remove the
storage upper bandwidth argument.

SUNDIALS integrators have been updated to utilize generic nonlinear solver
modules defined through the SUNNONLINSOL API. This API will ease the addition of
new nonlinear solver options and allow for external or user-supplied nonlinear
solvers. The SUNNONLINSOL API and SUNDIALS provided modules are described in
{\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} and follow the same object oriented design and
implementation used by the NVector, SUNMatrix, and SUNLinSol modules. Currently
two SUNNONLINSOL implementations are provided, SUNNonlinSol\_Newton and
SUNNonlinSol\_FixedPoint. These replicate the previous integrator specific
implementations of a Newton iteration and an accelerated fixed-point iteration,
respectively. Example programs using each of these nonlinear solver modules in a
standalone manner have been added and all ARKode example programs have been
updated to use generic SUNNonlinSol modules.

As with previous versions, ARKode will use the Newton solver (now
provided by SUNNonlinSol\_Newton) by default.  Use of the
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinear}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinear()}}}} routine (previously named
\sphinxcode{ARKodeSetLinear}) will indicate that the problem is
linearly-implicit, using only a single Newton iteration per implicit
stage.  Users wishing to switch to the accelerated fixed-point solver
are now required to create a SUNNonlinSol\_FixedPoint object and attach
that to ARKode, instead of calling the previous
\sphinxcode{ARKodeSetFixedPoint} routine.  See the documentation sections
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}}, and
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsol-fixedpoint}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNNonlinearSolver\_FixedPoint implementation}}}} for further details, or the serial C
example program \sphinxcode{ark\_brusselator\_fp.c} for an example.

Three fused vector operations and seven vector array operations have been added
to the NVECTOR API. These \sphinxstyleemphasis{optional} operations are disabled by default and may
be activated by calling vector specific routines after creating an NVector (see
{\hyperref[\detokenize{nvectors/NVector_Description:nvectors-description}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR Modules}}}} for more details). The new operations are intended
to increase data reuse in vector operations, reduce parallel communication on
distributed memory systems, and lower the number of kernel launches on systems
with accelerators. The fused operations are \sphinxcode{N\_VLinearCombination},
\sphinxcode{N\_VScaleAddMulti}, and \sphinxcode{N\_VDotProdMulti}, and the vector array operations
are \sphinxcode{N\_VLinearCombinationVectorArray}, \sphinxcode{N\_VScaleVectorArray},
\sphinxcode{N\_VConstVectorArray}, \sphinxcode{N\_VWrmsNormVectorArray},
\sphinxcode{N\_VWrmsNormMaskVectorArray}, \sphinxcode{N\_VScaleAddMultiVectorArray}, and
\sphinxcode{N\_VLinearCombinationVectorArray}. If an NVector implementation defines any of
these operations as \sphinxcode{NULL}, then standard NVector operations will
automatically be called as necessary to complete the computation.

Multiple changes to the CUDA NVECTOR were made:
\begin{itemize}
\item {} 
Changed the \sphinxcode{N\_VMake\_Cuda} function to take a host data pointer and a device
data pointer instead of an \sphinxcode{N\_VectorContent\_Cuda} object.

\item {} 
Changed \sphinxcode{N\_VGetLength\_Cuda} to return the global vector length instead of
the local vector length.

\item {} 
Added \sphinxcode{N\_VGetLocalLength\_Cuda} to return the local vector length.

\item {} 
Added \sphinxcode{N\_VGetMPIComm\_Cuda} to return the MPI communicator used.

\item {} 
Removed the accessor functions in the namespace \sphinxcode{suncudavec}.

\item {} 
Added the ability to set the \sphinxcode{cudaStream\_t} used for execution of the CUDA
NVECTOR kernels. See the function \sphinxcode{N\_VSetCudaStreams\_Cuda}.

\item {} 
Added \sphinxcode{N\_VNewManaged\_Cuda}, \sphinxcode{N\_VMakeManaged\_Cuda}, and \sphinxcode{N\_VIsManagedMemory\_Cuda}
functions to accommodate using managed memory with the CUDA NVECTOR.

\end{itemize}

Multiple changes to the RAJA NVECTOR were made:
\begin{itemize}
\item {} 
Changed \sphinxcode{N\_VGetLength\_Raja} to return the global vector length instead of
the local vector length.

\item {} 
Added \sphinxcode{N\_VGetLocalLength\_Raja} to return the local vector length.

\item {} 
Added \sphinxcode{N\_VGetMPIComm\_Raja} to return the MPI communicator used.

\item {} 
Removed the accessor functions in the namespace \sphinxcode{sunrajavec}.

\end{itemize}

A new NVECTOR implementation for leveraging OpenMP 4.5+ device offloading has
been added, NVECTOR\_OpenMPDEV. See {\hyperref[\detokenize{nvectors/NVector_OpenMPDEV:nvectors-openmpdev}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_OPENMPDEV Module}}}} for more details.


\subsection{Changes in v2.2.1}
\label{\detokenize{Introduction:changes-in-v2-2-1}}
Fixed a bug in the CUDA NVECTOR where the \sphinxcode{N\_VInvTest} operation could
write beyond the allocated vector data.

Fixed library installation path for multiarch systems. This fix changes the default
library installation path to \sphinxcode{CMAKE\_INSTALL\_PREFIX/CMAKE\_INSTALL\_LIBDIR}
from \sphinxcode{CMAKE\_INSTALL\_PREFIX/lib}. \sphinxcode{CMAKE\_INSTALL\_LIBDIR} is automatically
set, but is available as a CMAKE option that can modified.


\subsection{Changes in v2.2.0}
\label{\detokenize{Introduction:changes-in-v2-2-0}}
Fixed a problem with setting \sphinxcode{sunindextype} which would occur with
some compilers (e.g. armclang) that did not define \sphinxcode{\_\_STDC\_VERSION\_\_}.

Added hybrid MPI/CUDA and MPI/RAJA vectors to allow use of more than
one MPI rank when using a GPU system.  The vectors assume one GPU
device per MPI rank.

Changed the name of the RAJA NVECTOR library to
\sphinxcode{libsundials\_nveccudaraja.lib} from
\sphinxcode{libsundials\_nvecraja.lib} to better reflect that we only support CUDA
as a backend for RAJA currently.

Several changes were made to the build system:
\begin{itemize}
\item {} 
CMake 3.1.3 is now the minimum required CMake version.

\item {} 
Deprecate the behavior of the \sphinxcode{SUNDIALS\_INDEX\_TYPE} CMake option and
added the \sphinxcode{SUNDIALS\_INDEX\_SIZE} CMake option to select the \sphinxcode{sunindextype}
integer size.

\item {} 
The native CMake FindMPI module is now used to locate an MPI
installation.

\item {} 
If MPI is enabled and MPI compiler wrappers are not set, the build system
will check if \sphinxcode{CMAKE\_\textless{}language\textgreater{}\_COMPILER} can compile MPI programs before
trying to locate and use an MPI installation.

\item {} 
The previous options for setting MPI compiler wrappers and the executable
for running MPI programs have been have been depreated. The new options that
align with those used in native CMake FindMPI module are
\sphinxcode{MPI\_C\_COMPILER}, \sphinxcode{MPI\_CXX\_COMPILER}, \sphinxcode{MPI\_Fortran\_COMPILER},
and \sphinxcode{MPIEXEC\_EXECUTABLE}.

\item {} 
When a Fortran name-mangling scheme is needed (e.g., \sphinxcode{ENABLE\_LAPACK}
is \sphinxcode{ON}) the build system will infer the scheme from the Fortran
compiler. If a Fortran compiler is not available or the inferred or default
scheme needs to be overridden, the advanced options
\sphinxcode{SUNDIALS\_F77\_FUNC\_CASE} and \sphinxcode{SUNDIALS\_F77\_FUNC\_UNDERSCORES} can
be used to manually set the name-mangling scheme and bypass trying to infer
the scheme.

\item {} 
Parts of the main CMakeLists.txt file were moved to new files in the
\sphinxcode{src} and \sphinxcode{example} directories to make the CMake configuration file
structure more modular.

\end{itemize}


\subsection{Changes in v2.1.2}
\label{\detokenize{Introduction:changes-in-v2-1-2}}
Updated the minimum required version of CMake to 2.8.12 and enabled
using rpath by default to locate shared libraries on OSX.

Fixed Windows specific problem where sunindextype was not correctly
defined when using 64-bit integers for the SUNDIALS index type. On Windows
sunindextype is now defined as the MSVC basic type \sphinxcode{\_\_int64}.

Added sparse SUNMatrix “Reallocate” routine to allow specification of
the nonzero storage.

Updated the KLU SUNLinearSolver module to set constants for the two
reinitialization types, and fixed a bug in the full reinitialization
approach where the sparse SUNMatrix pointer would go out of scope on
some architectures.

Updated the “ScaleAdd” and “ScaleAddI” implementations in the
sparse SUNMatrix module to more optimally handle the case where the
target matrix contained sufficient storage for the sum, but had the
wrong sparsity pattern.  The sum now occurs in-place, by performing
the sum backwards in the existing storage.  However, it is still more
efficient if the user-supplied Jacobian routine allocates storage for
the sum \(I+\gamma J\) or \(M+\gamma J\) manually (with zero
entries if needed).

Changed LICENSE install path to \sphinxcode{instdir/include/sundials}.


\subsection{Changes in v2.1.1}
\label{\detokenize{Introduction:changes-in-v2-1-1}}
Fixed a potential memory leak in the SPGMR and SPFGMR linear solvers:
if “Initialize” was called multiple times then the solver memory was
reallocated (without being freed).

Fixed a minor bug in the ARKReInit routine, where a flag was
incorrectly set to indicate that the problem had been resized (instead
of just re-initialized).

Fixed C++11 compiler errors/warnings about incompatible use of string
literals.

Updated KLU SUNLinearSolver module to use a \sphinxcode{typedef} for the
precision-specific solve function to be used (to avoid compiler
warnings).

Added missing typecasts for some \sphinxcode{(void*)} pointers (again, to avoid
compiler warnings).

Bugfix in \sphinxcode{sunmatrix\_sparse.c} where we had used \sphinxcode{int} instead of
\sphinxcode{sunindextype} in one location.

Added missing \sphinxcode{\#include \textless{}stdio.h\textgreater{}} in NVECTOR and SUNMATRIX header files.

Added missing prototype for \sphinxcode{ARKSpilsGetNumMTSetups}.

Fixed an indexing bug in the CUDA NVECTOR implementation of
\sphinxcode{N\_VWrmsNormMask} and revised the RAJA NVECTOR implementation of
\sphinxcode{N\_VWrmsNormMask} to work with mask arrays using values other than
zero or one. Replaced \sphinxcode{double} with \sphinxcode{realtype} in the RAJA vector
test functions.

Fixed compilation issue with GCC 7.3.0 and Fortran programs that do
not require a SUNMatrix or SUNLinearSolver module (e.g. iterative
linear solvers, explicit methods, fixed point solver, etc.).


\subsection{Changes in v2.1.0}
\label{\detokenize{Introduction:changes-in-v2-1-0}}
Added NVECTOR print functions that write vector data to a specified
file (e.g. \sphinxcode{N\_VPrintFile\_Serial}).

Added \sphinxcode{make test} and \sphinxcode{make test\_install} options to the build
system for testing SUNDIALS after building with \sphinxcode{make} and
installing with \sphinxcode{make install} respectively.


\subsection{Changes in v2.0.0}
\label{\detokenize{Introduction:changes-in-v2-0-0}}
All interfaces to matrix structures and linear solvers have been
reworked, and all example programs have been updated.  The goal of the
redesign of these interfaces was to provide more encapsulation and
ease in interfacing custom linear solvers and interoperability with
linear solver libraries.

Specific changes include:
\begin{itemize}
\item {} 
Added generic SUNMATRIX module with three provided implementations:
dense, banded and sparse.  These replicate previous SUNDIALS Dls and
Sls matrix structures in a single object-oriented API.

\item {} 
Added example problems demonstrating use of generic SUNMATRIX modules.

\item {} 
Added generic SUNLINEARSOLVER module with eleven provided
implementations: dense, banded, LAPACK dense, LAPACK band, KLU,
SuperLU\_MT, SPGMR, SPBCGS, SPTFQMR, SPFGMR, PCG.  These replicate
previous SUNDIALS generic linear solvers in a single object-oriented
API.

\item {} 
Added example problems demonstrating use of generic SUNLINEARSOLVER modules.

\item {} 
Expanded package-provided direct linear solver (Dls) interfaces and
scaled, preconditioned, iterative linear solver (Spils) interfaces
to utilize generic SUNMATRIX and SUNLINEARSOLVER objects.

\item {} 
Removed package-specific, linear solver-specific, solver modules
(e.g. CVDENSE, KINBAND, IDAKLU, ARKSPGMR) since their functionality
is entirely replicated by the generic Dls/Spils interfaces and
SUNLINEARSOLVER/SUNMATRIX modules.  The exception is CVDIAG, a
diagonal approximate Jacobian solver available to CVODE and CVODES.

\item {} 
Converted all SUNDIALS example problems to utilize new generic
SUNMATRIX and SUNLINEARSOLVER objects, along with updated Dls and
Spils linear solver interfaces.

\item {} 
Added Spils interface routines to ARKode, CVODE, CVODES, IDA and
IDAS to allow specification of a user-provided “JTSetup” routine.
This change supports users who wish to set up data structures for
the user-provided Jacobian-times-vector (“JTimes”) routine, and
where the cost of one JTSetup setup per Newton iteration can be
amortized between multiple JTimes calls.

\end{itemize}

Two additional NVECTOR implementations were added \textendash{} one for CUDA and
one for RAJA vectors.  These vectors are supplied to provide very
basic support for running on GPU architectures.  Users are advised
that these vectors both move all data to the GPU device upon
construction, and speedup will only be realized if the user also
conducts the right-hand-side function evaluation on the device. In
addition, these vectors assume the problem fits on one GPU. Further
information about RAJA, users are referred to the web site,
\sphinxurl{https://software.llnl.gov/RAJA/}.
These additions are accompanied by additions to various interface
functions and to user documentation.

All indices for data structures were updated to a new \sphinxcode{sunindextype}
that can be configured to be a 32- or 64-bit integer data index type.
\sphinxcode{sunindextype} is defined to be \sphinxcode{int32\_t} or \sphinxcode{int64\_t} when
portable types are supported, otherwise it is defined as \sphinxcode{int} or
\sphinxcode{long int}. The Fortran interfaces continue to use \sphinxcode{long int} for
indices, except for their sparse matrix interface that now uses the
new \sphinxcode{sunindextype}.  This new flexible capability for index types
includes interfaces to PETSc, \sphinxstyleemphasis{hypre}, SuperLU\_MT, and KLU with either
32-bit or 64-bit capabilities depending how the user configures
SUNDIALS.

To avoid potential namespace conflicts, the macros defining
\sphinxcode{booleantype} values \sphinxcode{TRUE} and \sphinxcode{FALSE} have been changed to
\sphinxcode{SUNTRUE} and \sphinxcode{SUNFALSE} respectively.

Temporary vectors were removed from preconditioner setup and solve
routines for all packages.  It is assumed that all necessary data
for user-provided preconditioner operations will be allocated and
stored in user-provided data structures.

The file \sphinxcode{include/sundials\_fconfig.h} was added.  This file contains
SUNDIALS type information for use in Fortran programs.

Added functions SUNDIALSGetVersion and SUNDIALSGetVersionNumber to get
SUNDIALS release version information at runtime.

The build system was expanded to support many of the xSDK-compliant keys.
The xSDK is a movement in scientific software to provide a foundation for the
rapid and efficient production of high-quality,
sustainable extreme-scale scientific applications.  More information can
be found at, \sphinxurl{https://xsdk.info}.

In addition, numerous changes were made to the build system.
These include the addition of separate \sphinxcode{BLAS\_ENABLE} and \sphinxcode{BLAS\_LIBRARIES}
CMake variables, additional error checking during CMake configuration,
minor bug fixes, and renaming CMake options to enable/disable examples
for greater clarity and an added option to enable/disable Fortran 77 examples.
These changes included changing \sphinxcode{ENABLE\_EXAMPLES} to \sphinxcode{ENABLE\_EXAMPLES\_C},
changing \sphinxcode{CXX\_ENABLE} to \sphinxcode{EXAMPLES\_ENABLE\_CXX}, changing \sphinxcode{F90\_ENABLE} to
\sphinxcode{EXAMPLES\_ENABLE\_F90}, and adding an \sphinxcode{EXAMPLES\_ENABLE\_F77} option.

Corrections and additions were made to the examples, to
installation-related files, and to the user documentation.


\subsection{Changes in v1.1.0}
\label{\detokenize{Introduction:changes-in-v1-1-0}}
We have included numerous bugfixes and enhancements since the
v1.0.2 release.

The bugfixes include:
\begin{itemize}
\item {} 
For each linear solver, the various solver performance counters are
now initialized to 0 in both the solver specification function and
in the solver’s \sphinxcode{linit} function.  This ensures that these solver
counters are initialized upon linear solver instantiation as well as
at the beginning of the problem solution.

\item {} 
The choice of the method vs embedding the Billington and TRBDF2
explicit Runge-Kutta methods were swapped, since in those the
lower-order coefficients result in an A-stable method, while the
higher-order coefficients do not.  This change results in
significantly improved robustness when using those methods.

\item {} 
A bug was fixed for the situation where a user supplies a vector of
absolute tolerances, and also uses the vector Resize() functionality.

\item {} 
A bug was fixed wherein a user-supplied Butcher table without an
embedding is supplied, and the user is running with either fixed
time steps (or they do adaptivity manually); previously this had
resulted in an error since the embedding order was below 1.

\item {} 
Numerous aspects of the documentation were fixed and/or clarified.

\end{itemize}

The feature changes/enhancements include:
\begin{itemize}
\item {} 
Two additional NVECTOR implementations were added \textendash{} one for Hypre
(parallel) ParVector vectors, and one for PETSc vectors.  These
additions are accompanied by additions to various interface
functions and to user documentation.

\item {} 
Each NVECTOR module now includes a function, \sphinxcode{N\_VGetVectorID},
that returns the NVECTOR module name.

\item {} 
A memory leak was fixed in the banded preconditioner and
banded-block-diagonal preconditioner interfaces.  In addition,
updates were done to return integers from linear solver and
preconditioner ‘free’ routines.

\item {} 
The Krylov linear solver Bi-CGstab was enhanced by removing a
redundant dot product.  Various additions and corrections were made
to the interfaces to the sparse solvers KLU and SuperLU\_MT,
including support for CSR format when using KLU.

\item {} 
The ARKode implicit predictor algorithms were updated: methods 2 and
3 were improved slightly, a new predictor approach was added, and
the default choice was modified.

\item {} 
The underlying sparse matrix structure was enhanced to allow both
CSR and CSC matrices, with CSR supported by the KLU linear solver
interface.  ARKode interfaces to the KLU solver from both C and
Fortran were updated to enable selection of sparse matrix type, and a
Fortran-90 CSR example program was added.

\item {} 
The missing \sphinxcode{ARKSpilsGetNumMtimesEvals()} function was added
\textendash{} this had been included in the previous documentation but had not
been implemented.

\item {} 
The handling of integer codes for specifying built-in ARKode Butcher
tables was enhanced.  While a global numbering system is still used,
methods now have \#defined names to simplify the user interface and to
streamline incorporation of new Butcher tables into ARKode.

\item {} 
The maximum number of Butcher table stages was increased from 8 to
15 to accommodate very high order methods, and an 8th-order adaptive
ERK method was added.

\item {} 
Support was added for the explicit and implicit methods in an
additive Runge-Kutta method to utilize different stage times,
solution and embedding coefficients, to support new SSP-ARK
methods.

\item {} 
The FARKODE interface was extended to include a routine to set
scalar/array-valued residual tolerances, to support Fortran
applications with non-identity mass-matrices.

\end{itemize}


\section{Reading this User Guide}
\label{\detokenize{Introduction:reading-this-user-guide}}
This user guide is a combination of general usage instructions and
specific example programs.  We expect that some readers will want to
concentrate on the general instructions, while others will refer
mostly to the examples, and the organization is intended to
accommodate both styles.

The structure of this document is as follows:
\begin{itemize}
\item {} 
In the next section we provide a thorough presentation of the
underlying {\hyperref[\detokenize{Mathematics:mathematics}]{\sphinxcrossref{\DUrole{std,std-ref}{mathematics}}}} used within the ARKode
family of solvers.

\item {} 
We follow this with an overview of how the source code for ARKode is
{\hyperref[\detokenize{Organization:organization}]{\sphinxcrossref{\DUrole{std,std-ref}{organized}}}}.

\item {} 
The largest section follows, providing a full account of the
ARKStep module user interface, including a description of all
user-accessible functions and outlines for usage in serial and
parallel applications. Since ARKode is written in C, we first
present a section on {\hyperref[\detokenize{ARKStep_c_interface/index:arkstep-cinterface}]{\sphinxcrossref{\DUrole{std,std-ref}{using ARKStep for C and C++ applications}}}}, followed with a separate section on
{\hyperref[\detokenize{ARKode_f_interface/FARKODE:fortraninterface}]{\sphinxcrossref{\DUrole{std,std-ref}{using ARKode within Fortran applications}}}}.

\item {} 
The much smaller section describing the ERKStep time-stepping
module, {\hyperref[\detokenize{ERKStep_c_interface/index:erkstep-cinterface}]{\sphinxcrossref{\DUrole{std,std-ref}{using ERKStep for C and C++ applications}}}}, follows.

\item {} 
Subsequent sections discuss shared features between ARKode
and the rest of the SUNDIALS library:
{\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{vector data structures}}}},
{\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{matrix data structures}}}},
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{linear solver data structures}}}}, and the
{\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{installation procedure}}}}.

\item {} 
The final sections catalog the full set of {\hyperref[\detokenize{Constants:constants}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode constants}}}}, that are used for both input specifications and return
codes, and the full set of {\hyperref[\detokenize{Butcher:butcher}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher tables}}}} that are
packaged with ARKode.

\end{itemize}


\section{SUNDIALS Release License}
\label{\detokenize{Introduction:sundials-release-license}}
All SUNDIALS packages are released open source, under the BSD 3-Clause
license. The only requirements of the license are preservation of copyright and
a standard disclaimer of liability. The full text of the license and an
additional notice are provided below and may also be found in the LICENSE and
NOTICE files provided with all SUNDIALS packages.

\sphinxstylestrong{PLEASE NOTE}  If you are using SUNDIALS with any third party
libraries linked in (e.g., LAPACK, KLU, SuperLU\_MT, PETSc, or
\sphinxstyleemphasis{hypre}), be sure to review the respective license of the package as
that license may have more restrictive terms than the SUNDIALS
license.  For example, if someone builds SUNDIALS with a statically
linked KLU, the build is subject to terms of the more-restrictive LGPL
license (which is what KLU is released with) and \sphinxstyleemphasis{not} the SUNDIALS
BSD license anymore.


\subsection{BSD 3-Clause License}
\label{\detokenize{Introduction:bsd-3-clause-license}}
Copyright (c) 2002-2020, Lawrence Livermore National Security and Southern
Methodist University.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
\begin{itemize}
\item {} 
Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

\item {} 
Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

\item {} 
Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

\end{itemize}

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ‘’AS IS’’
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


\subsection{Additional Notice}
\label{\detokenize{Introduction:additional-notice}}
This work was produced under the auspices of the U.S. Department of
Energy by Lawrence Livermore National Laboratory under Contract
DE-AC52-07NA27344.

This work was prepared as an account of work sponsored by an agency of
the United States Government. Neither the United States Government nor
Lawrence Livermore National Security, LLC, nor any of their employees
makes any warranty, expressed or implied, or assumes any legal liability
or responsibility for the accuracy, completeness, or usefulness of any
information, apparatus, product, or process disclosed, or represents that
its use would not infringe privately owned rights.

Reference herein to any specific commercial product, process, or service
by trade name, trademark, manufacturer, or otherwise does not necessarily
constitute or imply its endorsement, recommendation, or favoring by the
United States Government or Lawrence Livermore National Security, LLC.

The views and opinions of authors expressed herein do not necessarily
state or reflect those of the United States Government or Lawrence
Livermore National Security, LLC, and shall not be used for advertising
or product endorsement purposes.


\subsection{SUNDIALS Release Numbers}
\label{\detokenize{Introduction:sundials-release-numbers}}
LLNL-CODE-667205  (ARKODE)

UCRL-CODE-155951  (CVODE)

UCRL-CODE-155950  (CVODES)

UCRL-CODE-155952  (IDA)

UCRL-CODE-237203  (IDAS)

LLNL-CODE-665877  (KINSOL)


\chapter{Mathematical Considerations}
\label{\detokenize{Mathematics:mathematics}}\label{\detokenize{Mathematics::doc}}\label{\detokenize{Mathematics:mathematical-considerations}}
ARKode solves ODE initial value problems (IVP) in \(\mathbb{R}^N\)
posed in the form

\phantomsection\label{\detokenize{Mathematics:equation-ivp}}\begin{equation}\label{equation:Mathematics:IVP}
\begin{split}M(t)\, \dot{y} = f(t,y), \qquad y(t_0) = y_0.\end{split}
\end{equation}
Here, \(t\) is the independent variable (e.g. time), and the
dependent variables are given by \(y \in \mathbb{R}^N\), where we
use the notation \(\dot{y}\) to denote \(dy/dt\).

For each value of \(t\), \(M(t)\) is a user-specified linear
operator from \(\mathbb{R}^N \to \mathbb{R}^N\).  This operator
is assumed to be nonsingular and independent of \(y\).  For
standard systems of ordinary differential equations and for
problems arising from the spatial semi-discretization of partial
differential equations using finite difference, finite volume, or
spectral finite element methods, \(M\) is typically the identity
matrix, \(I\).  For PDEs using standard finite-element
spatial semi-discretizations, \(M\) is typically a
well-conditioned mass matrix that is fixed throughout a simulation
(or at least fixed between spatial rediscretization events).

The ODE right-hand side is given by the function \(f(t,y)\) \textendash{}
in general we make no assumption that the problem \eqref{equation:Mathematics:IVP} is
autonomous (i.e., \(f=f(y)\)) or linear (\(f=Ay\)).
In general, the time integration methods within ARKode support
additive splittings of this right-hand side function, as described
in the subsections that follow.  Through these splittings, the
time-stepping methods currently supplied with ARKode are designed
to solve stiff, nonstiff, mixed stiff/nonstiff, and multirate
problems.  As per Ascher and Petzold \phantomsection\label{\detokenize{Mathematics:id1}}{\hyperref[\detokenize{References:ap1998}]{\sphinxcrossref{{[}AP1998{]}}}}, a problem is “stiff”
if the stepsize needed to maintain stability of the forward Euler
method is much smaller than that required to represent the solution
accurately.

In the sub-sections that follow, we elaborate on the numerical
methods utilized in ARKode.  We first discuss the “single-step” nature
of the ARKode infrastructure, including its usage modes and approaches
for interpolated solution output.  We then discuss the current suite
of time-stepping modules supplied with ARKode, including the ARKStep
module for {\hyperref[\detokenize{Mathematics:mathematics-ark}]{\sphinxcrossref{\DUrole{std,std-ref}{additive Runge-Kutta methods}}}},
the ERKStep module that is optimized for {\hyperref[\detokenize{Mathematics:mathematics-erk}]{\sphinxcrossref{\DUrole{std,std-ref}{explicit Runge-Kutta
methods}}}}, and the MRIStep module for
{\hyperref[\detokenize{Mathematics:mathematics-mristep}]{\sphinxcrossref{\DUrole{std,std-ref}{multirate infinitesimal step (MIS) based methods}}}}.
We then discuss the {\hyperref[\detokenize{Mathematics:mathematics-adaptivity}]{\sphinxcrossref{\DUrole{std,std-ref}{adaptive temporal error controllers}}}} shared by the time-stepping modules, including
discussion of our choice of norms for measuring errors within various components
of the solver.

We then discuss the nonlinear and linear solver strategies used by
ARKode’s time-stepping modules for solving implicit algebraic systems
that arise in computing each stage and/or step:
{\hyperref[\detokenize{Mathematics:mathematics-nonlinear}]{\sphinxcrossref{\DUrole{std,std-ref}{nonlinear solvers}}}},
{\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{linear solvers}}}},
{\hyperref[\detokenize{Mathematics:mathematics-preconditioning}]{\sphinxcrossref{\DUrole{std,std-ref}{preconditioners}}}},
{\hyperref[\detokenize{Mathematics:mathematics-error}]{\sphinxcrossref{\DUrole{std,std-ref}{error control}}}} within iterative nonlinear
and linear solvers, algorithms for
{\hyperref[\detokenize{Mathematics:mathematics-predictors}]{\sphinxcrossref{\DUrole{std,std-ref}{initial predictors}}}} for implicit stage
solutions, and approaches for handling
{\hyperref[\detokenize{Mathematics:mathematics-masssolve}]{\sphinxcrossref{\DUrole{std,std-ref}{non-identity mass-matrices}}}}.

We conclude with a section describing ARKode’s {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{rootfinding
capabilities}}}}, that may be used to stop
integration of a problem prematurely based on traversal of roots in
user-specified functions.


\section{Adaptive single-step methods}
\label{\detokenize{Mathematics:mathematics-singlestep}}\label{\detokenize{Mathematics:adaptive-single-step-methods}}
The ARKode infrastructure is designed to support single-step, IVP
integration methods, i.e.
\begin{equation*}
\begin{split}y_{n} = \varphi(y_{n-1}, h_n)\end{split}
\end{equation*}
where \(y_{n-1}\) is an approximation to the solution \(y(t_{n-1})\),
\(y_{n}\) is an approximation to the solution \(y(t_n)\),
\(t_n = t_{n-1} + h_n\), and the approximation method is
represented by the function \(\varphi\).

The choice of step size \(h_n\) is determined by the time-stepping
method (based on user-provided inputs, typically accuracy requirements).
However, users may place minimum/maximum bounds on \(h_n\) if desired.

ARKode’s time stepping modules may be run in a variety of “modes”:
\begin{itemize}
\item {} 
\sphinxstylestrong{NORMAL} \textendash{} The solver will take internal steps until it has just
overtaken a user-specified output time, \(t_\text{out}\), in the
direction of integration, i.e. \(t_{n-1} < t_\text{out} \le
t_{n}\) for forward integration, or \(t_{n} \le t_\text{out} <
t_{n-1}\) for backward integration.  It will then compute an
approximation to the solution \(y(t_\text{out})\) by
interpolation (using one of the dense output routines described in
the section {\hyperref[\detokenize{Mathematics:mathematics-interpolation}]{\sphinxcrossref{\DUrole{std,std-ref}{Interpolation}}}}).

\item {} 
\sphinxstylestrong{ONE-STEP} \textendash{} The solver will only take a single internal step
\(y_{n-1} \to y_{n}\) and then return control back to the
calling program.  If this step will overtake \(t_\text{out}\)
then the solver will again return an interpolated result; otherwise
it will return a copy of the internal solution \(y_{n}\).

\item {} 
\sphinxstylestrong{NORMAL-TSTOP} \textendash{} The solver will take internal steps until the next
step will overtake \(t_\text{out}\).  It will then limit
this next step so that \(t_n = t_{n-1} + h_n = t_\text{out}\),
and once the step completes it will return a copy of the internal
solution \(y_{n}\).

\item {} 
\sphinxstylestrong{ONE-STEP-TSTOP} \textendash{} The solver will check whether the next step
will overtake \(t_\text{out}\) \textendash{} if not then this mode is
identical to “one-step” above; otherwise it will limit this next
step so that \(t_n = t_{n-1} + h_n = t_\text{out}\).  In either
case, once the step completes it will return a copy of the internal
solution \(y_{n}\).

\end{itemize}

We note that interpolated solutions may be slightly less accurate than
the internal solutions produced by the solver.  Hence, to ensure that
the returned value has full method accuracy one of the “tstop” modes
may be used.


\section{Interpolation}
\label{\detokenize{Mathematics:interpolation}}\label{\detokenize{Mathematics:mathematics-interpolation}}
As mentioned above, the time-stepping modules in ARKode support
interpolation of solutions \(y(t_\text{out})\) and derivatives
\(y^{(d)}(t_\text{out})\), where \(t_\text{out}\) occurs
within a completed time step from \(t_{n-1} \to t_n\).
Additionally, this module supports extrapolation of solutions and
derivatives for \(t\) outside this interval (e.g. to construct
predictors for iterative nonlinear and linear solvers).  To this end,
ARKode currently supports construction of polynomial interpolants
\(p_q(t)\) of polynomial degree up to \(q=5\), although
users may select interpolants of lower degree.

ARKode provides two complementary interpolation approaches,
both of which are accessible from any of the
time-stepping modules: “Hermite” and “Lagrange”.  The former approach
has been included with ARKode since its inception, and is more
suitable for non-stiff problems; the latter is a new approach that is
designed to provide increased accuracy when integrating stiff problems.
Both are described in detail below.


\subsection{Hermite interpolation module}
\label{\detokenize{Mathematics:mathematics-interpolation-hermite}}\label{\detokenize{Mathematics:hermite-interpolation-module}}
For non-stiff problems, polynomial interpolants of Hermite form are provided.
Rewriting the IVP \eqref{equation:Mathematics:IVP} in standard form,
\begin{equation*}
\begin{split}\dot{y} = \hat{f}(t,y), \qquad y(t_0) = y_0.\end{split}
\end{equation*}
we typically construct temporal interpolants using the data
\(\left\{ y_{n-1}, \hat{f}_{n-1}, y_{n}, \hat{f}_{n} \right\}\),
where here we use the simplified notation \(\hat{f}_{k}\) to denote
\(\hat{f}(t_k,y_k)\).  Defining a normalized “time” variable,
\(\tau\), for the most-recently-computed solution interval
\(t_{n-1} \to t_{n}\) as
\begin{equation*}
\begin{split}\tau(t) = \frac{t-t_{n}}{h_{n}},\end{split}
\end{equation*}
we then construct the interpolants \(p_q(t)\) as follows:
\begin{itemize}
\item {} 
\(q=0\): constant interpolant
\begin{equation*}
\begin{split}p_0(\tau) = \frac{y_{n-1} + y_{n}}{2}.\end{split}
\end{equation*}
\item {} 
\(q=1\): linear Lagrange interpolant
\begin{equation*}
\begin{split}p_1(\tau) = -\tau\, y_{n-1} + (1+\tau)\, y_{n}.\end{split}
\end{equation*}
\item {} 
\(q=2\): quadratic Hermite interpolant
\begin{equation*}
\begin{split}p_2(\tau) =  \tau^2\,y_{n-1} + (1-\tau^2)\,y_{n} + h_n(\tau+\tau^2)\,\hat{f}_{n}.\end{split}
\end{equation*}
\item {} 
\(q=3\): cubic Hermite interpolant
\begin{equation*}
\begin{split}p_3(\tau) =  (3\tau^2 + 2\tau^3)\,y_{n-1} +
(1-3\tau^2-2\tau^3)\,y_{n} + h_n(\tau^2+\tau^3)\,\hat{f}_{n-1} +
h_n(\tau+2\tau^2+\tau^3)\,\hat{f}_{n}.\end{split}
\end{equation*}
\item {} 
\(q=4\): quartic Hermite interpolant
\begin{equation*}
\begin{split}p_4(\tau) &= (-6\tau^2 - 16\tau^3 - 9\tau^4)\,y_{n-1} +
(1 + 6\tau^2 + 16\tau^3 + 9\tau^4)\,y_{n} +
\frac{h_n}{4}(-5\tau^2 - 14\tau^3 - 9\tau^4)\,\hat{f}_{n-1} \\
&+ h_n(\tau + 2\tau^2 + \tau^3)\,\hat{f}_{n} +
\frac{27 h_n}{4}(-\tau^4 - 2\tau^3 - \tau^2)\,\hat{f}_a,\end{split}
\end{equation*}
where \(\hat{f}_a=\hat{f}\left(t_{n} - \dfrac{h_n}{3},p_3\left(-\dfrac13\right)\right)\).
We point out that interpolation at this degree requires an additional evaluation
of the full right-hand side function \(\hat{f}(t,y)\), thereby increasing its
cost in comparison with \(p_3(t)\).

\item {} 
\(q=5\): quintic Hermite interpolant
\begin{equation*}
\begin{split}p_5(\tau) &= (54\tau^5 + 135\tau^4 + 110\tau^3 + 30\tau^2)\,y_{n-1} +
(1 - 54\tau^5 - 135\tau^4 - 110\tau^3 - 30\tau^2)\,y_{n} \\
&+ \frac{h_n}{4}(27\tau^5 + 63\tau^4 + 49\tau^3 + 13\tau^2)\,\hat{f}_{n-1} +
\frac{h_n}{4}(27\tau^5 + 72\tau^4 + 67\tau^3 + 26\tau^2 + \tau)\,\hat{f}_n \\
&+ \frac{h_n}{4}(81\tau^5 + 189\tau^4 + 135\tau^3 + 27\tau^2)\,\hat{f}_a +
\frac{h_n}{4}(81\tau^5 + 216\tau^4 + 189\tau^3 + 54\tau^2)\,\hat{f}_b,\end{split}
\end{equation*}
where \(\hat{f}_a=\hat{f}\left(t_{n} - \dfrac{h_n}{3},p_4\left(-\dfrac13\right)\right)\)
and \(\hat{f}_b=\hat{f}\left(t_{n} - \dfrac{2h_n}{3},p_4\left(-\dfrac23\right)\right)\).
We point out that interpolation at this degree requires four additional evaluations
of the full right-hand side function \(\hat{f}(t,y)\), thereby significantly
increasing its cost over \(p_4(t)\).

\end{itemize}

We note that although interpolants of order \(q > 5\) are possible, these are
not currently implemented due to their increased computing and storage costs.


\subsection{Lagrange interpolation module}
\label{\detokenize{Mathematics:lagrange-interpolation-module}}\label{\detokenize{Mathematics:mathematics-interpolation-lagrange}}
For stiff problems where \(\hat{f}\) may have large Lipschitz constant,
polynomial interpolants of Lagrange form are provided.  These interpolants
are constructed using the data
\(\left\{ y_{n}, y_{n-1}, \ldots, y_{n-\nu} \right\}\) where
\(0\le\nu\le5\).  These polynomials have the form
\begin{equation*}
\begin{split}p(t) &= \sum_{j=0}^{\nu} y_{n-j} p_j(t),\quad\text{where}\\
p_j(t) &= \prod_{l=0, l\ne j}^{\nu} \left(\frac{t-t_l}{t_j-t_l}\right), \quad j=0,\ldots,\nu.\end{split}
\end{equation*}
Since we assume that the solutions \(y_{n-j}\) have length much larger
than \(\nu\le5\) in ARKode-based simulations, we evaluate \(p\) at
any desired \(t\in\mathbb{R}\) by first evaluating the Lagrange polynomial
basis functions at the input value for \(t\), and then performing a simple linear
combination of the vectors \(\{y_k\}_{k=0}^{\nu}\).  Derivatives \(p^{(d)}(t)\)
may be evaluated similarly as
\begin{equation*}
\begin{split}p^{(d)}(t) = \sum_{j=0}^{\nu} y_{n-j}\, p_j^{(d)}(t),\end{split}
\end{equation*}
however since the algorithmic complexity involved in evaluating derivatives of the
Lagrange basis functions increases dramatically as the derivative order grows, our Lagrange
interpolation module currently only provides derivatives up to \(d=3\).

We note that when using this interpolation module, during the first
\((\nu-1)\) steps of integration we do not have sufficient solution history
to construct the full \(\nu\)-degree interpolant.  Therefore during these
initial steps, we construct the highest-degree interpolants that are currently
available at the moment, achieving the full \(\nu\)-degree interpolant once
these initial steps have completed.


\section{ARKStep \textendash{} Additive Runge-Kutta methods}
\label{\detokenize{Mathematics:mathematics-ark}}\label{\detokenize{Mathematics:arkstep-additive-runge-kutta-methods}}
The ARKStep time-stepping module in ARKode is designed for IVPs of the
form

\phantomsection\label{\detokenize{Mathematics:equation-imex-ivp}}\begin{equation}\label{equation:Mathematics:IMEX_IVP}
\begin{split}M(t)\, \dot{y} = f^E(t,y) + f^I(t,y), \qquad y(t_0) = y_0,\end{split}
\end{equation}
i.e. the right-hand side function is additively split into two
components:
\begin{itemize}
\item {} 
\(f^E(t,y)\) contains the “nonstiff” components of the
system (this will be integrated using an explicit method);

\item {} 
\(f^I(t,y)\) contains the “stiff” components of the
system (this will be integrated using an implicit method);

\end{itemize}

and the left-hand side may include a nonsingular, possibly
time-dependent,  matrix \(M(t)\).

In solving the IVP \eqref{equation:Mathematics:IMEX_IVP}, we first consider the corresponding
problem in standard form,

\phantomsection\label{\detokenize{Mathematics:equation-imex-ivp-standard}}\begin{equation}\label{equation:Mathematics:IMEX_IVP_standard}
\begin{split}\dot{y} = \hat{f}^E(t,y) + \hat{f}^I(t,y), \qquad y(t_0) = y_0,\end{split}
\end{equation}
where \(\hat{f}^E(t,y) = M(t)^{-1}\,f^E(t,y)\) and
\(\hat{f}^I(t,y) = M(t)^{-1}\,f^I(t,y)\).  ARKStep then utilizes variable-step,
embedded, \index{additive Runge-Kutta methods}additive Runge-Kutta methods (ARK), corresponding
to algorithms of the form

\phantomsection\label{\detokenize{Mathematics:equation-ark}}\begin{equation}\label{equation:Mathematics:ARK}
\begin{split}z_i &= y_{n-1} + h_n \sum_{j=1}^{i-1} A^E_{i,j} \hat{f}^E(t^E_{n,j}, z_j)
               + h_n \sum_{j=1}^{i} A^I_{i,j} \hat{f}^I(t^I_{n,j}, z_j),
\quad i=1,\ldots,s, \\
y_n &= y_{n-1} + h_n \sum_{i=1}^{s} \left(b^E_i \hat{f}^E(t^E_{n,i}, z_i)
              + b^I_i \hat{f}^I(t^I_{n,i}, z_i)\right), \\
\tilde{y}_n &= y_{n-1} + h_n \sum_{i=1}^{s} \left(
               \tilde{b}^E_i \hat{f}^E(t^E_{n,i}, z_i) +
               \tilde{b}^I_i \hat{f}^I(t^I_{n,i}, z_i)\right).\end{split}
\end{equation}
Here \(\tilde{y}_n\) are embedded solutions that approximate
\(y(t_n)\) and are used for error estimation; these typically
have slightly lower accuracy than the computed solutions \(y_n\).
The internal stage times are abbreviated using the notation
\(t^E_{n,j} = t_{n-1} + c^E_j h_n\) and
\(t^I_{n,j} = t_{n-1} + c^I_j h_n\).  The ARK method is
primarily defined through the coefficients \(A^E \in
\mathbb{R}^{s\times s}\), \(A^I \in \mathbb{R}^{s\times s}\),
\(b^E \in \mathbb{R}^{s}\), \(b^I \in \mathbb{R}^{s}\),
\(c^E \in \mathbb{R}^{s}\) and \(c^I \in \mathbb{R}^{s}\),
that correspond with the explicit and implicit Butcher tables.
Additional coefficients \(\tilde{b}^E \in \mathbb{R}^{s}\) and
\(\tilde{b}^I \in \mathbb{R}^{s}\) are used to construct the
embedding \(\tilde{y}_n\).  We note that ARKStep currently
enforces the constraint that the explicit and implicit methods in an
ARK pair must share the same number of stages, \(s\).  We note that
when the problem has a time-independent mass matrix \(M\), ARKStep
allows the possibility for different explicit and implicit abcissae,
i.e. \(c^E\) need not equal \(c^I\).

The user of ARKStep must choose appropriately between one of three
classes of methods: \sphinxstyleemphasis{ImEx}, \sphinxstyleemphasis{explicit}, and \sphinxstyleemphasis{implicit}.  All of
the built-in Butcher tables encoding the coefficients
\(c^E\), \(c^I\), \(A^E\), \(A^I\), \(b^E\),
\(b^I\), \(\tilde{b}^E\) and \(\tilde{b}^I\) are further
described in the {\hyperref[\detokenize{Butcher:butcher}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: Butcher tables}}}}.

For mixed stiff/nonstiff problems, a user should provide both of the
functions \(f^E\) and \(f^I\) that define the IVP system.  For
such problems, ARKStep currently implements the ARK methods proposed in
\phantomsection\label{\detokenize{Mathematics:id2}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}, allowing for methods having order of accuracy \(q =
\{3,4,5\}\); the tables for these methods are given in the section
{\hyperref[\detokenize{Butcher:butcher-additive}]{\sphinxcrossref{\DUrole{std,std-ref}{Additive Butcher tables}}}}.  Additionally, user-defined ARK tables are
supported.

For nonstiff problems, a user may specify that \(f^I = 0\),
i.e. the equation \eqref{equation:Mathematics:IMEX_IVP} reduces to the non-split IVP

\phantomsection\label{\detokenize{Mathematics:equation-ivp-explicit}}\begin{equation}\label{equation:Mathematics:IVP_explicit}
\begin{split}M(t)\, \dot{y} = f^E(t,y), \qquad y(t_0) = y_0.\end{split}
\end{equation}
In this scenario, the coefficients \(A^I=0\), \(c^I=0\),
\(b^I=0\) and \(\tilde{b}^I=0\) in \eqref{equation:Mathematics:ARK}, and the ARK
methods reduce to classical \index{explicit Runge-Kutta methods}explicit Runge-Kutta methods
(ERK).  For these classes of methods, ARKode provides coefficients
with orders of accuracy \(q = \{2,3,4,5,6,8\}\), with embeddings
of orders \(p = \{1,2,3,4,5,7\}\).  These default to the
{\hyperref[\detokenize{Butcher:butcher-heun-euler}]{\sphinxcrossref{\DUrole{std,std-ref}{Heun-Euler-2-1-2}}}},
{\hyperref[\detokenize{Butcher:butcher-bogacki-shampine}]{\sphinxcrossref{\DUrole{std,std-ref}{Bogacki-Shampine-4-2-3}}}}, {\hyperref[\detokenize{Butcher:butcher-zonneveld}]{\sphinxcrossref{\DUrole{std,std-ref}{Zonneveld-5-3-4}}}},
{\hyperref[\detokenize{Butcher:butcher-cash-karp}]{\sphinxcrossref{\DUrole{std,std-ref}{Cash-Karp-6-4-5}}}}, {\hyperref[\detokenize{Butcher:butcher-verner-6-5}]{\sphinxcrossref{\DUrole{std,std-ref}{Verner-8-5-6}}}} and
{\hyperref[\detokenize{Butcher:butcher-fehlberg-8-7}]{\sphinxcrossref{\DUrole{std,std-ref}{Fehlberg-13-7-8}}}} methods, respectively.  As with ARK
methods, user-defined ERK tables are supported.

Alternately, for stiff problems the user may specify that \(f^E = 0\),
so the equation \eqref{equation:Mathematics:IMEX_IVP} reduces to the non-split IVP

\phantomsection\label{\detokenize{Mathematics:equation-ivp-implicit}}\begin{equation}\label{equation:Mathematics:IVP_implicit}
\begin{split}M(t)\, \dot{y} = f^I(t,y), \qquad y(t_0) = y_0.\end{split}
\end{equation}
Similarly to ERK methods, in this scenario the coefficients
\(A^E=0\), \(c^E=0\), \(b^E=0\) and \(\tilde{b}^E=0\)
in \eqref{equation:Mathematics:ARK}, and the ARK methods reduce to classical
\index{diagonally-implicit Runge-Kutta methods}diagonally-implicit Runge-Kutta methods (DIRK).  For these
classes of methods, ARKode provides tables with orders of accuracy
\(q = \{2,3,4,5\}\), with embeddings of orders
\(p = \{1,2,3,4\}\). These default to the
{\hyperref[\detokenize{Butcher:butcher-sdirk-2-1}]{\sphinxcrossref{\DUrole{std,std-ref}{SDIRK-2-1-2}}}}, {\hyperref[\detokenize{Butcher:butcher-ark-4-2-3-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-4-2-3 (implicit)}}}},
{\hyperref[\detokenize{Butcher:butcher-sdirk-5-4}]{\sphinxcrossref{\DUrole{std,std-ref}{SDIRK-5-3-4}}}} and {\hyperref[\detokenize{Butcher:butcher-ark-8-4-5-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-8-4-5 (implicit)}}}} methods,
respectively.  Again, user-defined DIRK tables are supported.


\section{ERKStep \textendash{} Explicit Runge-Kutta methods}
\label{\detokenize{Mathematics:mathematics-erk}}\label{\detokenize{Mathematics:erkstep-explicit-runge-kutta-methods}}
The ERKStep time-stepping module in ARKode is designed for IVP
of the form

\phantomsection\label{\detokenize{Mathematics:equation-ivp-simple-explicit}}\begin{equation}\label{equation:Mathematics:IVP_simple_explicit}
\begin{split}\dot{y} = f(t,y), \qquad y(t_0) = y_0,\end{split}
\end{equation}
i.e., unlike the more general problem form \eqref{equation:Mathematics:IMEX_IVP}, ERKStep
requires that problems have an identity mass matrix (i.e., \(M(t)=I\))
and that the right-hand side function is not split into separate
components.

For such problems, ERKStep provides variable-step, embedded,
\index{explicit Runge-Kutta methods}explicit Runge-Kutta methods (ERK), corresponding to
algorithms of the form

\phantomsection\label{\detokenize{Mathematics:equation-erk}}\begin{equation}\label{equation:Mathematics:ERK}
\begin{split}z_i &= y_{n-1} + h_n \sum_{j=1}^{i-1} A_{i,j} f(t_{n,j}, z_j),
\quad i=1,\ldots,s, \\
y_n &= y_{n-1} + h_n \sum_{i=1}^{s} b_i f(t_{n,i}, z_i), \\
\tilde{y}_n &= y_{n-1} + h_n \sum_{i=1}^{s} \tilde{b}_i f(t_{n,i}, z_i),\end{split}
\end{equation}
where the variables have the same meanings as in the previous section.

Clearly, the problem \eqref{equation:Mathematics:IVP_simple_explicit} is fully encapsulated
in the more general problem \eqref{equation:Mathematics:IVP_explicit}, and the algorithm
\eqref{equation:Mathematics:ERK} is similarly encapsulated in the more general algorithm \eqref{equation:Mathematics:ARK}.
While it therefore follows that ARKStep can be used to solve every
problem solvable by ERKStep, using the same set of methods, we
include ERKStep as a distinct time-stepping module since this
simplified form admits a more efficient and memory-friendly solution
process than when considering the more general form \eqref{equation:Mathematics:IVP_simple_explicit}.


\section{MRIStep \textendash{} Multirate infinitesimal step methods}
\label{\detokenize{Mathematics:mathematics-mristep}}\label{\detokenize{Mathematics:mristep-multirate-infinitesimal-step-methods}}
The MRIStep time-stepping module in ARKode is designed for IVPs
of the form

\phantomsection\label{\detokenize{Mathematics:equation-ivp-two-rate}}\begin{equation}\label{equation:Mathematics:IVP_two_rate}
\begin{split}\dot{y} = f^S(t,y) + f^F(t,y), \qquad y(t_0) = y_0.\end{split}
\end{equation}
i.e. the right-hand side function is additively split into two
components:
\begin{itemize}
\item {} 
\(f^S(t,y)\) contains the “slow” components of the
system (this will be integrated using a large time step \(h^S\)),

\item {} 
\(f^F(t,y)\) contains the “fast” components of the
system (this will be integrated using small time steps \(h^F \ll h^S\)).

\end{itemize}

As with ERKStep, MRIStep currently requires that problems be posed with
an identity mass matrix, \(M(t)=I\).

For such problems, MRIStep provides fixed-step slow step multirate infinitesimal
step and multirate infinitesimal GARK methods (see \phantomsection\label{\detokenize{Mathematics:id3}}{\hyperref[\detokenize{References:skaw2009}]{\sphinxcrossref{{[}SKAW2009{]}}}}, \phantomsection\label{\detokenize{Mathematics:id4}}{\hyperref[\detokenize{References:skaw2012a}]{\sphinxcrossref{{[}SKAW2012a{]}}}},
\phantomsection\label{\detokenize{Mathematics:id5}}{\hyperref[\detokenize{References:skaw2012b}]{\sphinxcrossref{{[}SKAW2012b{]}}}}, and \phantomsection\label{\detokenize{Mathematics:id6}}{\hyperref[\detokenize{References:s2019}]{\sphinxcrossref{{[}S2019{]}}}}) that combine two Runge-Kutta methods.  The outer
(slow) method derives from an \(s\) stage Runge-Kutta method where the stage values
and the new solution are computed by solving an auxiliary ODE with an inner
(fast) Runge-Kutta method. This corresponds to the following algorithm for a
single step:
\begin{enumerate}
\item {} 
Set \(z_1 = y_{n-1}\)

\item {} 
For \(i = 2,\ldots,s+1\)
\begin{enumerate}
\item {} 
Let \(v(0) = z_{i-1}\), \(t_{n,i-1}^S = t_{n-1} + c_{i-1}^S h^S\), and \(\Delta c_i^S=\left(c^S_i - c^S_{i-1}\right)\).

\item {} 
Let \(r(\tau) = \sum\limits_{j=1}^i \gamma_{i,j}\left(\tau/h^S\right) f^S(t_{n,j}^S, z_j)\)

\item {} 
For \(\tau \in [0, h^S]\), solve \(\dot{v}(\tau) = \Delta c_i^S f^F(t_{n,i-1}^S+\Delta c_i^S\tau, v) + r(\tau)\)

\item {} 
Set \(z_i = v(h^S)\),

\end{enumerate}

\item {} 
Set \(y_{n} = z_{s+1}\).

\end{enumerate}

where \(c^S_{s+1}=1\) and the coefficients \(\gamma_{i,j}\) are polynomials in time that dictate the
couplings from the slow to the fast time scale; these can be expressed as in \phantomsection\label{\detokenize{Mathematics:id7}}{\hyperref[\detokenize{References:s2019}]{\sphinxcrossref{{[}S2019{]}}}}:

\phantomsection\label{\detokenize{Mathematics:equation-mri-coupling}}\begin{equation}\label{equation:Mathematics:MRI_coupling}
\begin{split}\gamma_{i,j}(\theta) &= \sum_{k\geq 0} \gamma_{i,j}^{\{k\}} \theta^k,\end{split}
\end{equation}
and where the tables \(\Gamma^{\{k\}}\in\mathbb{R}^{(s+1)\times(s+1)}\) define the slow-to-fast coupling.
For traditional MIS methods (as in \phantomsection\label{\detokenize{Mathematics:id8}}{\hyperref[\detokenize{References:skaw2009}]{\sphinxcrossref{{[}SKAW2009{]}}}}, \phantomsection\label{\detokenize{Mathematics:id9}}{\hyperref[\detokenize{References:skaw2012a}]{\sphinxcrossref{{[}SKAW2012a{]}}}}, and \phantomsection\label{\detokenize{Mathematics:id10}}{\hyperref[\detokenize{References:skaw2012b}]{\sphinxcrossref{{[}SKAW2012b{]}}}}), these coefficients are
uniquely defined based on a slow Butcher table \((A^S,b^S,c^S)\) having explicit first stage (i.e.,
\(c^S_1=0\) and \(A^S_{1,j}=0\) for \(1\le j\le s\)), sorted abcissae (i.e.,
\(c^S_{i} \ge  c^S_{i-1}\) for \(2\le i\le s\)), and final abcissa \(c^S_s \leq 1\) as:

\phantomsection\label{\detokenize{Mathematics:equation-mis-to-mri}}\begin{equation}\label{equation:Mathematics:MIS_to_MRI}
\begin{split}\gamma_{i,j}^{\{0\}} = \begin{cases}
0, & \text{if}\; i=1,\\
A^S_{i,j} - A^S_{i-1,j}, & \text{if}\; 2\le i\le s,\\
b^S_j - A^S_{s,j}, & \text{if}\; i=s+1.
\end{cases}\end{split}
\end{equation}
For general slow tables \((A^S,b^S,c^S)\) with at least second-order accuracy, the corresponding MIS
method will be second order.  However, if this slow table is at least third order and satisfies the additional
condition

\phantomsection\label{\detokenize{Mathematics:equation-mis-order3}}\begin{equation}\label{equation:Mathematics:MIS_order3}
\begin{split}\sum_{i=2}^{s} \left(c_i^S-c_{i-1}^S\right) \left(\mathbf{e}_i+\mathbf{e}_{i-1}\right)^T A^S c^S
+ \left(1-c_{s}^S\right) \left(\frac12+\mathbf{e}_{s}^T A^S c^S\right) = \frac13,\end{split}
\end{equation}
where \(\mathbf{e}_j\) corresponds to the \(j\)-th column from the identity matrix, then the overall
MIS method will be third order.

As with standard Runge\textendash{}Kutta methods, implicitness at the slow time scale is characterized by nonzero values
on or above the diagonal of the matrices \(\Gamma^{\{k\}}\).  Typically, MRI methods are at most
diagonally-implicit (i.e., \(\gamma_{i,j}^{\{k\}}=0\) for all \(j>i\)).  Additionally, an implicit
stage \(i\) may be characterized as being “solve-decoupled,” wherein \(c^S_i - c^S_{i-1}=0\) and thus
the ‘fast’ IVP for \(v\) over \(\tau \in [0, h^S]\) may be solved analytically,

\phantomsection\label{\detokenize{Mathematics:equation-mri-dirk-solve-decoupled}}\begin{equation}\label{equation:Mathematics:MRI_dirk_solve_decoupled}
\begin{split}&z_i = z_{i-1} + \int_0^{h^S} r(\tau)\,\mathrm d\tau\\
\Leftrightarrow\quad&\\
&z_i = z_{i-1} + h^S \sum_{j=1}^i \left(\sum_{k\geq 0}
\frac{\gamma_{i,j}^{\{k\}}}{k+1}\right)f^S(t_{n,j}^S, z_j),\end{split}
\end{equation}
corresponding to a standard diagonally-implicit Runge\textendash{}Kutta stage.  Alternately, an implicit MRI stage
\(i\) is considered “solve-coupled” if both \(c^S_i - c^S_{i-1}\ne 0\) and
\(\sum\limits_{k\geq 0} \dfrac{\gamma_{i,j}^{\{k\}}}{k+1} \ne 0\), in which case the stage solution
\(z_i\) is \sphinxstyleemphasis{both} an input to \(r(\tau)\) and the result of time-evolution of the fast IVP,
necessitating an implicit solve that is coupled to the ‘fast’ solver.

The default method supported by the MRIStep module is the explicit, third-order MIS method defined by
the slow Butcher table ({\hyperref[\detokenize{Butcher:butcher-knoth-wolke}]{\sphinxcrossref{\DUrole{std,std-ref}{Knoth-Wolke-3-3}}}}); however, other slow Butcher tables \((A^S,b^S,c^S)\)
or coupling tables \(\Gamma^{\{k\}}\in\mathbb{R}^{(s+1)\times(s+1)}\) may be provided.  At present, only
‘solve-decoupled’ implicit MRI methods are supported.

At present, the inner ODEs for step 2c of the MRI algorithm must be solved using the ARKStep
module.  As such, this can be evolved using either an explicit, implicit, or IMEX method with adaptive
or fixed time steps.


\section{Error norms}
\label{\detokenize{Mathematics:error-norms}}\label{\detokenize{Mathematics:mathematics-error-norm}}
In the process of controlling errors at various levels (time
integration, nonlinear solution, linear solution), the methods in
ARKode use a \index{weighted root-mean-square norm}weighted root-mean-square norm, denoted
\(\|\cdot\|_\text{WRMS}\), for all error-like quantities,

\phantomsection\label{\detokenize{Mathematics:equation-wrms-norm}}\begin{equation}\label{equation:Mathematics:WRMS_NORM}
\begin{split}\|v\|_\text{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N \left(v_i\,
w_i\right)^2\right)^{1/2}.\end{split}
\end{equation}
The utility of this norm arises in the specification of the weighting
vector \(w\), that combines the units of the problem with
user-supplied values that specify an “acceptable” level of error.  To
this end, we construct an \index{error weight vector}error weight vector using
the most-recent step solution and user-supplied relative and
absolute tolerances, namely

\phantomsection\label{\detokenize{Mathematics:equation-ewt}}\begin{equation}\label{equation:Mathematics:EWT}
\begin{split}w_i = \big(RTOL\cdot |y_{n-1,i}| + ATOL_i\big)^{-1}.\end{split}
\end{equation}
Since \(1/w_i\) represents a tolerance in the \(i\)-th component of the
solution vector \(y\), a vector whose WRMS norm is 1 is regarded
as “small.”  For brevity, unless specified otherwise we will drop the
subscript WRMS on norms in the remainder of this section.

Additionally, for problems involving a non-identity mass matrix,
\(M\ne I\), the units of equation \eqref{equation:Mathematics:IMEX_IVP} may differ from the
units of the solution \(y\).  In this case, we may additionally
construct a \index{residual weight vector}residual weight vector,

\phantomsection\label{\detokenize{Mathematics:equation-rwt}}\begin{equation}\label{equation:Mathematics:RWT}
\begin{split}w_i = \Big(RTOL\cdot \left| \big(M(t_{n-1})\, y_{n-1}\big)_i \right| + ATOL'_i\Big)^{-1},\end{split}
\end{equation}
where the user may specify a separate absolute residual tolerance
value or array, \(ATOL'\).  The choice of weighting vector used
in any given norm is determined by the quantity being measured: values
having “solution” units use \eqref{equation:Mathematics:EWT}, whereas values having “equation”
units use \eqref{equation:Mathematics:RWT}.  Obviously, for problems with \(M=I\), the
solution and equation units are identical, so the solvers in ARKode
will use \eqref{equation:Mathematics:EWT} when computing all error norms.


\section{Time step adaptivity}
\label{\detokenize{Mathematics:time-step-adaptivity}}\label{\detokenize{Mathematics:mathematics-adaptivity}}
A critical component of IVP “solvers” (rather than just
time-steppers) is their adaptive control of local truncation error (LTE).
At every step, we estimate the local error, and ensure that it
satisfies tolerance conditions.  If this local error test fails, then
the step is recomputed with a reduced step size.  To this end, the
Runge-Kutta methods packaged within both the ARKStep and ERKStep
modules admit an embedded solution \(\tilde{y}_n\), as shown in
equations \eqref{equation:Mathematics:ARK} and \eqref{equation:Mathematics:ERK}.  Generally, these embedded
solutions attain a slightly lower order of accuracy than the computed
solution \(y_n\).  Denoting the order of accuracy for \(y_n\)
as \(q\) and for \(\tilde{y}_n\) as \(p\), most of these
embedded methods satisfy \(p = q-1\).  These values of \(q\)
and \(p\) correspond to the \sphinxstyleemphasis{global} orders of accuracy for the
method and embedding, hence each admit local truncation errors
satisfying \phantomsection\label{\detokenize{Mathematics:id11}}{\hyperref[\detokenize{References:hw1993}]{\sphinxcrossref{{[}HW1993{]}}}}

\phantomsection\label{\detokenize{Mathematics:equation-asymptoticerrors}}\begin{equation}\label{equation:Mathematics:AsymptoticErrors}
\begin{split}\| y_n - y(t_n) \| = C h_n^{q+1} + \mathcal O(h_n^{q+2}), \\
\| \tilde{y}_n - y(t_n) \| = D h_n^{p+1} + \mathcal O(h_n^{p+2}),\end{split}
\end{equation}
where \(C\) and \(D\) are constants independent of
\(h_n\), and where we have assumed exact initial conditions for
the step, i.e. \(y_{n-1} = y(t_{n-1})\). Combining these
estimates, we have
\begin{equation*}
\begin{split}\| y_n - \tilde{y}_n \| = \| y_n - y(t_n) - \tilde{y}_n + y(t_n) \|
\le \| y_n - y(t_n) \| + \| \tilde{y}_n - y(t_n) \|
\le D h_n^{p+1} + \mathcal O(h_n^{p+2}).\end{split}
\end{equation*}
We therefore use the norm of the difference between \(y_n\) and
\(\tilde{y}_n\) as an estimate for the LTE at the step \(n\)

\phantomsection\label{\detokenize{Mathematics:equation-lte}}\begin{equation}\label{equation:Mathematics:LTE}
\begin{split}T_n = \beta \left(y_n - \tilde{y}_n\right) =
\beta h_n \sum_{i=1}^{s} \left[
\left(b^E_i - \tilde{b}^E_i\right) \hat{f}^E(t^E_{n,i}, z_i) +
\left(b^I_i - \tilde{b}^I_i\right) \hat{f}^I(t^I_{n,i}, z_i) \right]\end{split}
\end{equation}
for ARK methods, and similarly for ERK methods.  Here, \(\beta>0\)
is an error \sphinxstyleemphasis{bias} to help account for the error constant \(D\);
the default value of this constant is \(\beta = 1.5\), which may
be modified by the user.

With this LTE estimate, the local error test is simply
\(\|T_n\| < 1\) since this norm includes the user-specified
tolerances.  If this error test passes, the step is considered
successful, and the estimate is subsequently used to estimate the next
step size, the algorithms used for this purpose are described below in
the section {\hyperref[\detokenize{Mathematics:mathematics-adaptivity-errorcontrol}]{\sphinxcrossref{\DUrole{std,std-ref}{Asymptotic error control}}}}.  If the error
test fails, the step is rejected and a new step size \(h'\) is
then computed using the same error controller as for successful steps.
A new attempt at the step is made, and the error test is repeated.  If
the error test fails twice, then \(h'/h\) is limited above to 0.3,
and limited below to 0.1 after an additional step failure.  After
seven error test failures, control is returned to the user with a
failure message.  We note that all of the constants listed above are
only the default values; each may be modified by the user.

We define the step size ratio between a prospective step \(h'\)
and a completed step \(h\) as \(\eta\), i.e. \(\eta = h'
/ h\).  This value is subsequently bounded from above by
\(\eta_\text{max}\) to ensure that step size adjustments are not
overly aggressive.  This upper bound changes according to the step
and history,
\begin{equation*}
\begin{split}\eta_\text{max} = \begin{cases}
  \text{etamx1}, & \quad\text{on the first step (default is 10000)}, \\
  \text{growth}, & \quad\text{on general steps (default is 20)}, \\
  1, & \quad\text{if the previous step had an error test failure}.
\end{cases}\end{split}
\end{equation*}
A flowchart detailing how the time steps are modified at each
iteration to ensure solver convergence and successful steps is given
in the figure below.  Here, all norms correspond to the WRMS norm, and
the error adaptivity function \sphinxstylestrong{arkAdapt} is supplied by one of the
error control algorithms discussed in the subsections below.

\phantomsection\label{\detokenize{Mathematics:adaptivity-figure}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.6]{{time_adaptivity}.png}
\label{\detokenize{Mathematics:adaptivity-figure}}\end{figure}

For some problems it may be preferable to avoid small step size
adjustments.  This can be especially true for problems that construct
a Newton Jacobian matrix or a preconditioner for a nonlinear or an
iterative linear solve, where this construction is computationally
expensive, and where convergence can be seriously hindered through use
of an inaccurate matrix.  To accommodate these scenarios, the step is
left unchanged when \(\eta \in [\eta_L, \eta_U]\).  The default
values for this interval are \(\eta_L = 1\) and \(\eta_U =
1.5\), and may be modified by the user.

We note that any choices for \(\eta\) (or equivalently,
\(h'\)) are subsequently constrained by the optional user-supplied
bounds \(h_\text{min}\) and \(h_\text{max}\).  Additionally,
the time-stepping algorithms in ARKode may similarly limit \(h'\)
to adhere to a user-provided “TSTOP” stopping point,
\(t_\text{stop}\).


\subsection{Asymptotic error control}
\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol}}\label{\detokenize{Mathematics:asymptotic-error-control}}
As mentioned above, the time-stepping modules in ARKode adapt the step
size in order to attain local errors within desired tolerances of the
true solution.  These adaptivity algorithms estimate the prospective
step size \(h'\) based on the asymptotic local error estimates
\eqref{equation:Mathematics:AsymptoticErrors}.  We define the values \(\varepsilon_n\),
\(\varepsilon_{n-1}\) and \(\varepsilon_{n-2}\) as
\begin{equation*}
\begin{split}\varepsilon_k \ \equiv \ \|T_k\| \ = \ \beta \|y_k - \tilde{y}_k\|,\end{split}
\end{equation*}
corresponding to the local error estimates for three consecutive
steps, \(t_{n-3} \to t_{n-2} \to t_{n-1} \to t_n\).  These local
error history values are all initialized to 1 upon program
initialization, to accommodate the few initial time steps of a
calculation where some of these error estimates have not yet been
computed.  With these estimates, ARKode supports a variety of error
control algorithms, as specified in the subsections below.


\subsubsection{PID controller}
\label{\detokenize{Mathematics:pid-controller}}\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-pid}}
This is the default time adaptivity controller used by the ARKStep and
ERKStep modules.  It derives from those found in \phantomsection\label{\detokenize{Mathematics:id12}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}, \phantomsection\label{\detokenize{Mathematics:id13}}{\hyperref[\detokenize{References:s1998}]{\sphinxcrossref{{[}S1998{]}}}}, \phantomsection\label{\detokenize{Mathematics:id14}}{\hyperref[\detokenize{References:s2003}]{\sphinxcrossref{{[}S2003{]}}}} and
\phantomsection\label{\detokenize{Mathematics:id15}}{\hyperref[\detokenize{References:s2006}]{\sphinxcrossref{{[}S2006{]}}}}, and uses all three of the local error estimates
\(\varepsilon_n\), \(\varepsilon_{n-1}\) and
\(\varepsilon_{n-2}\) in determination of a prospective step size,
\begin{equation*}
\begin{split}h' \;=\; h_n\; \varepsilon_n^{-k_1/p}\; \varepsilon_{n-1}^{k_2/p}\;
     \varepsilon_{n-2}^{-k_3/p},\end{split}
\end{equation*}
where the constants \(k_1\), \(k_2\) and \(k_3\) default
to 0.58, 0.21 and 0.1, respectively, and may be modied by the user.
In this estimate, a floor of \(\varepsilon > 10^{-10}\) is
enforced to avoid division-by-zero errors.


\subsubsection{PI controller}
\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-pi}}\label{\detokenize{Mathematics:pi-controller}}
Like with the previous method, the PI controller derives from those
found in \phantomsection\label{\detokenize{Mathematics:id16}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}, \phantomsection\label{\detokenize{Mathematics:id17}}{\hyperref[\detokenize{References:s1998}]{\sphinxcrossref{{[}S1998{]}}}}, \phantomsection\label{\detokenize{Mathematics:id18}}{\hyperref[\detokenize{References:s2003}]{\sphinxcrossref{{[}S2003{]}}}} and \phantomsection\label{\detokenize{Mathematics:id19}}{\hyperref[\detokenize{References:s2006}]{\sphinxcrossref{{[}S2006{]}}}}, but it differs in
that it only uses the two most recent step sizes in its adaptivity
algorithm,
\begin{equation*}
\begin{split}h' \;=\; h_n\; \varepsilon_n^{-k_1/p}\; \varepsilon_{n-1}^{k_2/p}.\end{split}
\end{equation*}
Here, the default values of \(k_1\) and \(k_2\) default
to 0.8 and 0.31, respectively, though they may be changed by the user.


\subsubsection{I controller}
\label{\detokenize{Mathematics:i-controller}}\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-i}}
This is the standard time adaptivity control algorithm in use by most
publicly-available ODE solver codes.  It bases the prospective time step
estimate entirely off of the current local error estimate,
\begin{equation*}
\begin{split}h' \;=\; h_n\; \varepsilon_n^{-k_1/p}.\end{split}
\end{equation*}
By default, \(k_1=1\), but that may be modified by the user.


\subsubsection{Explicit Gustafsson controller}
\label{\detokenize{Mathematics:explicit-gustafsson-controller}}\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-egus}}
This step adaptivity algorithm was proposed in \phantomsection\label{\detokenize{Mathematics:id20}}{\hyperref[\detokenize{References:g1991}]{\sphinxcrossref{{[}G1991{]}}}}, and
is primarily useful with explicit Runge-Kutta methods.
In the notation of our earlier controllers, it has the form

\phantomsection\label{\detokenize{Mathematics:equation-expgus}}\begin{equation}\label{equation:Mathematics:expGus}
\begin{split}h' \;=\; \begin{cases}
   h_1\; \varepsilon_1^{-1/p}, &\quad\text{on the first step}, \\
   h_n\; \varepsilon_n^{-k_1/p}\;
     \left(\varepsilon_n/\varepsilon_{n-1}\right)^{k_2/p}, &
   \quad\text{on subsequent steps}.
\end{cases}\end{split}
\end{equation}
The default values of \(k_1\) and \(k_2\) are 0.367 and 0.268,
respectively, and may be modified by the user.


\subsubsection{Implicit Gustafsson controller}
\label{\detokenize{Mathematics:implicit-gustafsson-controller}}\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-igus}}
A version of the above controller suitable for implicit Runge-Kutta
methods was introduced in \phantomsection\label{\detokenize{Mathematics:id21}}{\hyperref[\detokenize{References:g1994}]{\sphinxcrossref{{[}G1994{]}}}}, and has the form

\phantomsection\label{\detokenize{Mathematics:equation-impgus}}\begin{equation}\label{equation:Mathematics:impGus}
\begin{split}h' = \begin{cases}
   h_1 \varepsilon_1^{-1/p}, &\quad\text{on the first step}, \\
   h_n \left(h_n / h_{n-1}\right) \varepsilon_n^{-k_1/p}
     \left(\varepsilon_n/\varepsilon_{n-1}\right)^{-k_2/p}, &
   \quad\text{on subsequent steps}.
\end{cases}\end{split}
\end{equation}
The algorithm parameters default to \(k_1 = 0.98\) and
\(k_2 = 0.95\), but may be modified by the user.


\subsubsection{ImEx Gustafsson controller}
\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-iegus}}\label{\detokenize{Mathematics:imex-gustafsson-controller}}
An ImEx version of these two preceding controllers is also available.
This approach computes the estimates \(h'_1\) arising from
equation \eqref{equation:Mathematics:expGus} and the estimate \(h'_2\) arising from
equation \eqref{equation:Mathematics:impGus}, and selects
\begin{equation*}
\begin{split}h' = \frac{h}{|h|}\min\left\{|h'_1|, |h'_2|\right\}.\end{split}
\end{equation*}
Here, equation \eqref{equation:Mathematics:expGus} uses \(k_1\) and
\(k_2\) with default values of 0.367 and 0.268, while equation
\eqref{equation:Mathematics:impGus} sets both parameters to the input \(k_3\) that
defaults to 0.95.  All of these values may be modified by the user.


\subsubsection{User-supplied controller}
\label{\detokenize{Mathematics:user-supplied-controller}}\label{\detokenize{Mathematics:mathematics-adaptivity-errorcontrol-user}}
Finally, ARKode’s time-stepping modules allow the user to define their
own time step adaptivity function,
\begin{equation*}
\begin{split}h' = H(y, t, h_n, h_{n-1}, h_{n-2}, \varepsilon_n, \varepsilon_{n-1}, \varepsilon_{n-2}, q, p),\end{split}
\end{equation*}
to allow for problem-specific choices, or for continued
experimentation with temporal error controllers.


\section{Explicit stability}
\label{\detokenize{Mathematics:explicit-stability}}\label{\detokenize{Mathematics:mathematics-stability}}
For problems that involve a nonzero explicit component,
i.e. \(f^E(t,y) \ne 0\) in ARKStep or for any problem in
ERKStep, explicit and ImEx Runge-Kutta methods may benefit from
additional user-supplied information regarding the explicit stability
region.  All ARKode adaptivity methods utilize estimates of the local
error, and it is often the case that such local error control will be
sufficient for method stability, since unstable steps will typically
exceed the error control tolerances.  However, for problems in which
\(f^E(t,y)\) includes even moderately stiff components, and
especially for higher-order integration methods, it may occur that
a significant number of attempted steps will exceed the error
tolerances.  While these steps will automatically be recomputed, such
trial-and-error can result in an unreasonable number of failed steps,
increasing the cost of the computation.  In these scenarios, a
stability-based time step controller may also be useful.

Since the maximum stable explicit step for any method depends on the
problem under consideration, in that the value \((h_n\lambda)\) must
reside within a bounded stability region, where \(\lambda\) are
the eigenvalues of the linearized operator \(\partial f^E /
\partial y\), information on the maximum stable step size is not
readily available to ARKode’s time-stepping modules.  However, for
many problems such information may be easily obtained through analysis
of the problem itself, e.g. in an advection-diffusion calculation
\(f^I\) may contain the stiff diffusive components and
\(f^E\) may contain the comparably nonstiff advection terms.  In
this scenario, an explicitly stable step \(h_\text{exp}\) would be
predicted as one satisfying the Courant-Friedrichs-Lewy (CFL)
stability condition for the advective portion of the problem,
\begin{equation*}
\begin{split}|h_\text{exp}| < \frac{\Delta x}{|\lambda|}\end{split}
\end{equation*}
where \(\Delta x\) is the spatial mesh size and \(\lambda\) is
the fastest advective wave speed.

In these scenarios, a user may supply a routine to predict this
maximum explicitly stable step size, \(|h_\text{exp}|\).  If a
value for \(|h_\text{exp}|\) is supplied, it is compared against
the value resulting from the local error controller,
\(|h_\text{acc}|\), and the eventual time step used will be
limited accordingly,
\begin{equation*}
\begin{split}h' = \frac{h}{|h|}\min\{c\, |h_\text{exp}|,\, |h_\text{acc}|\}.\end{split}
\end{equation*}
Here the explicit stability step factor \(c>0\) (often called the
“CFL number”) defaults to \(1/2\) but may be modified by the user.


\subsection{Fixed time stepping}
\label{\detokenize{Mathematics:fixed-time-stepping}}\label{\detokenize{Mathematics:mathematics-fixedstep}}
While both the ARKStep and ERKStep time-stepping modules are designed
for tolerance-based time step adaptivity, they additionally support a
“fixed-step” mode (\sphinxstyleemphasis{note: fixed-step mode is currently required for
the slow time scale in the MRIStep module}).  This mode is typically
used for debugging purposes, for verification against hand-coded
Runge-Kutta methods, or for problems where the time steps should be
chosen based on other problem-specific information.  In this mode,
all internal time step adaptivity is disabled:
\begin{itemize}
\item {} 
temporal error control is disabled,

\item {} 
nonlinear or linear solver non-convergence will result in an error
(instead of a step size adjustment),

\item {} 
no check against an explicit stability condition is performed.

\end{itemize}

Additional information on this mode is provided in the sections
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKStep Optional Inputs}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{ERKStep Optional Inputs}}}}, and
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStep Optional Inputs}}}}.


\section{Algebraic solvers}
\label{\detokenize{Mathematics:mathematics-algebraicsolvers}}\label{\detokenize{Mathematics:algebraic-solvers}}
When solving a problem involving either an implicit component (e.g., in
ARKStep with \(f^I(t,y) \ne 0\), or in MRIStep with a solve-decoupled
implicit slow stage), or a non-identity mass matrix (\(M(t) \ne I\) in
ARKStep), systems of linear or nonlinear algebraic equations must be solved
at each stage and/or step of the method.  This section therefore focuses on
the variety of mathematical methods provided in the ARKode infrastructure
for such problems, including
{\hyperref[\detokenize{Mathematics:mathematics-nonlinear}]{\sphinxcrossref{\DUrole{std,std-ref}{nonlinear solvers}}}},
{\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{linear solvers}}}},
{\hyperref[\detokenize{Mathematics:mathematics-preconditioning}]{\sphinxcrossref{\DUrole{std,std-ref}{preconditioners}}}},
{\hyperref[\detokenize{Mathematics:mathematics-error}]{\sphinxcrossref{\DUrole{std,std-ref}{iterative solver error control}}}},
{\hyperref[\detokenize{Mathematics:mathematics-predictors}]{\sphinxcrossref{\DUrole{std,std-ref}{implicit predictors}}}}, and techniques
used for simplifying the above solves when using different classes of
{\hyperref[\detokenize{Mathematics:mathematics-masssolve}]{\sphinxcrossref{\DUrole{std,std-ref}{mass-matrices}}}}.


\subsection{Nonlinear solver methods}
\label{\detokenize{Mathematics:nonlinear-solver-methods}}\label{\detokenize{Mathematics:mathematics-nonlinear}}
For the DIRK and ARK methods corresponding to \eqref{equation:Mathematics:IMEX_IVP} and
\eqref{equation:Mathematics:IVP_implicit} in ARKStep, and the solve-decoupled implicit slow
stages \eqref{equation:Mathematics:MRI_dirk_solve_decoupled} in MRIStep, an implicit system

\phantomsection\label{\detokenize{Mathematics:equation-residual}}\begin{equation}\label{equation:Mathematics:Residual}
\begin{split}G(z_i) = 0\end{split}
\end{equation}
must be solved for each stage \(z_i, i=1,\ldots,s\).  In order to
maximize solver efficiency, we define this root-finding problem differently
based on the type of mass-matrix supplied by the user.
\begin{itemize}
\item {} 
In the case that \(M=I\) within ARKStep, we define the residual as

\phantomsection\label{\detokenize{Mathematics:equation-residual-meqi}}\begin{equation}\label{equation:Mathematics:Residual_MeqI}
\begin{split}G(z_i) \equiv z_i - h_n A^I_{i,i} f^I(t^I_{n,i}, z_i) - a_i,\end{split}
\end{equation}
where we have the data
\begin{equation*}
\begin{split}a_i \equiv y_{n-1} + h_n \sum_{j=1}^{i-1} \left[
A^E_{i,j} f^E(t^E_{n,j}, z_j) +
A^I_{i,j} f^I(t^I_{n,j}, z_j) \right].\end{split}
\end{equation*}
\item {} 
In the case of non-identity mass matrix \(M\ne I\) within ARKStep, but where
\(M\) is independent of \(t\), we define the residual as

\phantomsection\label{\detokenize{Mathematics:equation-residual-mfixed}}\begin{equation}\label{equation:Mathematics:Residual_Mfixed}
\begin{split}G(z_i) &\equiv M z_i - h_n A^I_{i,i} f^I(t^I_{n,i}, z_i) - a_i,\end{split}
\end{equation}
where we have the data
\begin{equation*}
\begin{split}a_i \equiv M y_{n-1} + h_n \sum_{j=1}^{i-1} \left[
A^E_{i,j} f^E(t^E_{n,j}, z_j) +
A^I_{i,j} f^I(t^I_{n,j}, z_j) \right].\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This form of residual, as opposed to
\(G(z_i) = z_i - h_n A^I_{i,i} \hat{f}^I(t^I_{n,i}, z_i) - a_i\)
(with \(a_i\) defined appropriately), removes the need to perform the
nonlinear solve with right-hand side function \(\hat{f}^I=M^{-1}\,f^I\),
as that would require a linear solve with \(M\) at \sphinxstyleemphasis{every evaluation} of
the implicit right-hand side routine.
\end{sphinxadmonition}

\item {} 
In the case of ARKStep with \(M\) dependent on \(t\), we define the residual as

\phantomsection\label{\detokenize{Mathematics:equation-residual-mtimedep}}\begin{equation}\label{equation:Mathematics:Residual_MTimeDep}
\begin{split}G(z_i) &\equiv M(t^I_{n,i}) (z_i - a_i) - h_n A^I_{i,i} f^I(t^I_{n,i}, z_i)\end{split}
\end{equation}
where we have the data
\begin{equation*}
\begin{split}a_i \equiv y_{n-1} + h_n \sum_{j=1}^{i-1} \left[
A^E_{i,j} \hat{f}^E(t^E_{n,j}, z_j) +
A^I_{i,j} \hat{f}^I(t^I_{n,j}, z_j) \right].\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
As above, this form of the residual is chosen to remove excessive
mass-matrix solves from the nonlinear solve process.
\end{sphinxadmonition}

\item {} 
Similarly, in MRIStep (that always assumes \(M=I\)), we have the residual

\phantomsection\label{\detokenize{Mathematics:equation-mristep-residual}}\begin{equation}\label{equation:Mathematics:MRIStep_Residual}
\begin{split}G(z_i) \equiv z_i - h^S \left(\sum_{k\geq 0} \frac{\gamma_{i,i}^{\{k\}}}{k+1}\right)
f^S(t_{n,i}^S, z_i) - a_i = 0\end{split}
\end{equation}
where
\begin{equation*}
\begin{split}a_i \equiv z_{i-1} + h^S \sum_{j=1}^{i-1} \left(\sum_{k\geq 0}
\frac{\gamma_{i,j}^{\{k\}}}{k+1}\right)f^S(t_{n,j}^S, z_j).\end{split}
\end{equation*}
\end{itemize}

In each of the above nonlinear residual functions, if \(f^I(t,y)\) or \(f^S(t,y)\)
depends nonlinearly on \(y\) then \eqref{equation:Mathematics:Residual} corresponds to a nonlinear system of
equations; if instead \(f^I(t,y)\) or \(f^S(t,y)\) depends linearly on \(y\)
then this is a linear system of equations.

To solve each of the above root-finding problems ARKode provides a choice of strategies,
with the default being a variant of \index{Newton's method}Newton’s method,

\phantomsection\label{\detokenize{Mathematics:equation-newton-iteration}}\begin{equation}\label{equation:Mathematics:Newton_iteration}
\begin{split}z_i^{(m+1)} = z_i^{(m)} + \delta^{(m+1)},\end{split}
\end{equation}
where \(m\) is the Newton iteration index, and the \index{Newton
update}Newton
update \(\delta^{(m+1)}\) in turn requires the solution of the
\index{Newton linear system}Newton linear system

\phantomsection\label{\detokenize{Mathematics:equation-newton-system}}\begin{equation}\label{equation:Mathematics:Newton_system}
\begin{split}{\mathcal A}\left(t^I_{n,i}, z_i^{(m)}\right)\, \delta^{(m+1)} =
-G\left(z_i^{(m)}\right),\end{split}
\end{equation}
in which

\phantomsection\label{\detokenize{Mathematics:equation-newtonmatrix}}\begin{equation}\label{equation:Mathematics:NewtonMatrix}
\begin{split}{\mathcal A}(t,z) \approx M(t) - \gamma J(t,z), \quad
J(t,z) = \frac{\partial f^I(t,z)}{\partial z}, \quad\text{and}\quad
\gamma = h_n A^I_{i,i}\end{split}
\end{equation}
within ARKStep, or

\phantomsection\label{\detokenize{Mathematics:equation-newtonmatrix-mristep}}\begin{equation}\label{equation:Mathematics:NewtonMatrix_MRIStep}
\begin{split}{\mathcal A}(t,z) \approx I - \gamma J(t,z), \quad
J(t,z) = \frac{\partial f^S(t,z)}{\partial z}, \quad\text{and}\quad
\gamma = h^S \sum_{k\geq 0} \frac{\gamma_{i,i}^{\{k\}}}{k+1}\end{split}
\end{equation}
within MRIStep.

As an alternative to Newton’s method, ARKode provides a
\index{fixed point iteration}fixed point iteration for solving the stages \(z_i, i=1,\ldots,s\),

\phantomsection\label{\detokenize{Mathematics:equation-aafp-iteration}}\begin{equation}\label{equation:Mathematics:AAFP_iteration}
\begin{split}z_i^{(m+1)} = \Phi\left(z_i^{(m)}\right) \equiv z_i^{(m)} -
M(t^I_{n,i})^{-1}\,G\left(z_i^{(m)}\right), \quad m=0,1,\ldots.\end{split}
\end{equation}
This iteration may additionally be improved using a technique
called “Anderson acceleration”  \phantomsection\label{\detokenize{Mathematics:id22}}{\hyperref[\detokenize{References:wn2011}]{\sphinxcrossref{{[}WN2011{]}}}}.  Unlike with Newton’s
method, these methods \sphinxstyleemphasis{do not} require the solution of a linear system
involving the Jacobian of \(f\) at each iteration, instead opting
for solution of a low-dimensional least-squares solution to construct
the nonlinear update.

Finally, if the user specifies that \(f^I(t,y)\) or \(f^S(t,y)\)
depend linearly on \(y\) in ARKStep or MRIStep, respectively, and
if the Newton-based nonlinear solver is chosen, then the problem
\eqref{equation:Mathematics:Residual} will be solved using only a single Newton iteration.
In this case, an additional user-supplied argument indicates whether
this Jacobian is time-dependent or not, signaling whether the Jacobian
or preconditioner needs to be recomputed at each stage or time step,
or if it can be reused throughout the full simulation.

The optimal choice of solver (Newton vs fixed-point) is highly
problem dependent.  Since fixed-point solvers do not require the
solution of linear systems involving the Jacobian of \(f\), each
iteration may be significantly less costly than their Newton
counterparts.  However, this can come at the cost of slower
convergence (or even divergence) in comparison with Newton-like
methods.  On the other hand, these fixed-point solvers do allow for
user specification of the Anderson-accelerated subspace size,
\(m_k\).  While the required amount of solver memory for
acceleration grows proportionately to \(m_k N\), larger values
of \(m_k\) may result in faster convergence.  In our experience,
this improvement is most significant for relatively modest values,
e.g. \(1\le m_k\le 5\), and that larger values of \(m_k\)
may not result in improved convergence.

While a Newton-based iteration is the default solver in ARKode due
to its increased robustness on very stiff problems, we strongly
recommend that users also consider the fixed-point solver when
attempting a new problem.

For either the Newton or fixed-point solvers, it is well-known that
both the efficiency and robustness of the algorithm intimately depend
on the choice of a good initial guess.  The initial guess
for these solvers is a prediction \(z_i^{(0)}\) that is computed
explicitly from previously-computed data (e.g. \(y_{n-2}\),
\(y_{n-1}\), and \(z_j\) where \(j<i\)).  Additional
information on the specific predictor algorithms
is provided in the following section, {\hyperref[\detokenize{Mathematics:mathematics-predictors}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit predictors}}}}.


\subsection{Linear solver methods}
\label{\detokenize{Mathematics:linear-solver-methods}}\label{\detokenize{Mathematics:mathematics-linear}}
When a Newton-based method is chosen for solving each nonlinear
system, a linear system of equations must be solved at each nonlinear
iteration.  For this solve ARKode provides several choices, including
the option of a user-supplied linear solver module.  The linear solver
modules distributed with SUNDIALS are organized into two families: a
\sphinxstyleemphasis{direct} family comprising direct linear solvers for dense, banded or
sparse matrices, and a \sphinxstyleemphasis{spils} family comprising scaled, preconditioned,
iterative (Krylov) linear solvers.  The methods offered through these
modules are as follows:
\begin{itemize}
\item {} 
dense direct solvers, using either an internal SUNDIALS
implementation or a BLAS/LAPACK implementation (serial version
only),

\item {} 
band direct solvers, using either an internal SUNDIALS
implementation or a BLAS/LAPACK implementation (serial version
only),

\item {} 
sparse direct solvers, using either the KLU sparse matrix library
\phantomsection\label{\detokenize{Mathematics:id23}}{\hyperref[\detokenize{References:klu}]{\sphinxcrossref{{[}KLU{]}}}}, or the OpenMP or PThreads-enabled SuperLU\_MT sparse matrix
library \phantomsection\label{\detokenize{Mathematics:id24}}{\hyperref[\detokenize{References:superlumt}]{\sphinxcrossref{{[}SuperLUMT{]}}}} {[}Note that users will need to download and
install the KLU or SuperLU\_MT packages independent of ARKode{]},

\item {} 
SPGMR, a scaled, preconditioned GMRES (Generalized Minimal Residual)
solver,

\item {} 
SPFGMR, a scaled, preconditioned FGMRES (Flexible Generalized Minimal
Residual) solver,

\item {} 
SPBCGS, a scaled, preconditioned Bi-CGStab (Bi-Conjugate Gradient
Stable) solver,

\item {} 
SPTFQMR, a scaled, preconditioned TFQMR (Transpose-free
Quasi-Minimal Residual) solver, or

\item {} 
PCG, a preconditioned CG (Conjugate Gradient method) solver for
symmetric linear systems.

\end{itemize}

For large stiff systems where direct methods are often infeasible, the
combination of an implicit integrator and a preconditioned
Krylov method can yield a powerful tool because it combines
established methods for stiff integration, nonlinear solver iteration,
and Krylov (linear) iteration with a problem-specific treatment of the
dominant sources of stiffness, in the form of a user-supplied
preconditioner matrix \phantomsection\label{\detokenize{Mathematics:id25}}{\hyperref[\detokenize{References:bh1989}]{\sphinxcrossref{{[}BH1989{]}}}}.  We note that the direct linear
solver modules currently provided by SUNDIALS are only designed to be
used with the serial and threaded vector representations.

\index{modified Newton iteration}\ignorespaces 

\subsubsection{Matrix-based linear solvers}
\label{\detokenize{Mathematics:index-11}}\label{\detokenize{Mathematics:matrix-based-linear-solvers}}\label{\detokenize{Mathematics:mathematics-linear-direct}}
In the case that a matrix-based linear solver is used, a \sphinxstyleemphasis{modified
Newton iteration} is utilized.  In a modified newton iteration, the matrix
\({\mathcal A}\) is held fixed for multiple Newton iterations.
More precisely, each Newton iteration is computed from the modified
equation

\phantomsection\label{\detokenize{Mathematics:equation-modified-newton-system}}\begin{equation}\label{equation:Mathematics:modified_Newton_system}
\begin{split}\tilde{\mathcal A}\left(\tilde{t},\tilde{z}\right)\, \delta^{(m+1)}
= -G\left(z_i^{(m)}\right),\end{split}
\end{equation}
in which

\phantomsection\label{\detokenize{Mathematics:equation-modified-newtonmatrix-ark}}\begin{equation}\label{equation:Mathematics:modified_NewtonMatrix_ARK}
\begin{split}\tilde{\mathcal A}(\tilde{t},\tilde{z}) \approx M(\tilde{t}) - \tilde{\gamma} J(\tilde{t},\tilde{z}),
\quad\text{and}\quad
\tilde{\gamma} = \tilde{h} A^I_{i,i} \quad\text{(ARKStep)}\\\end{split}
\end{equation}
or

\phantomsection\label{\detokenize{Mathematics:equation-modified-newtonmatrix-mri}}\begin{equation}\label{equation:Mathematics:modified_NewtonMatrix_MRI}
\begin{split}\tilde{\mathcal A}(\tilde{t},\tilde{z}) \approx I - \tilde{\gamma} J(\tilde{t},\tilde{z}),
\quad\text{and}\quad
\tilde{\gamma} = \tilde{h} \sum_{k\geq 0} \frac{\gamma_{i,i}^{\{k\}}}{k+1}\quad\text{(MRIStep)}.\end{split}
\end{equation}
Here, the solution \(\tilde{z}\), time \(\tilde{t}\), and step
size \(\tilde{h}\) upon which the modified equation rely, are
merely values of these quantities from a previous iteration.  In other
words, the matrix \(\tilde{\mathcal A}\) is only computed rarely,
and reused for repeated solves.  The frequency at which
\(\tilde{\mathcal A}\) is recomputed defaults to 20 time steps,
but may be modified by the user.

When using the dense and band SUNMatrix objects for the linear systems
\eqref{equation:Mathematics:modified_Newton_system}, the Jacobian \(J\) may be supplied
by a user routine, or approximated internally by finite-differences.
In the case of differencing, we use the standard approximation
\begin{equation*}
\begin{split}J_{i,j}(t,z) \approx \frac{f^*_i(t,z+\sigma_j e_j) - f^*_i(t,z)}{\sigma_j},\end{split}
\end{equation*}
where \(f^*\) is either \(f^I\) for ARKStep or \(f^S\) for MRIStep,
\(e_j\) is the \(j\)-th unit vector, and the increments
\(\sigma_j\) are given by
\begin{equation*}
\begin{split}\sigma_j = \max\left\{ \sqrt{U}\, |z_j|, \frac{\sigma_0}{w_j} \right\}.\end{split}
\end{equation*}
Here \(U\) is the unit roundoff, \(\sigma_0\) is a small
dimensionless value, and \(w_j\) is the error weight defined in
\eqref{equation:Mathematics:EWT}.  In the dense case, this approach requires \(N\)
evaluations of \(f^*\), one for each column of \(J\).  In the
band case, the columns of \(J\) are computed in groups, using the
Curtis-Powell-Reid algorithm, with the number of \(f^*\)
evaluations equal to the matrix bandwidth.

We note that with sparse and user-supplied SUNMatrix objects, the
Jacobian \sphinxstyleemphasis{must} be supplied by a user routine.

\index{inexact Newton iteration}\ignorespaces 

\subsubsection{Matrix-free iterative linear solvers}
\label{\detokenize{Mathematics:mathematics-linear-iterative}}\label{\detokenize{Mathematics:matrix-free-iterative-linear-solvers}}\label{\detokenize{Mathematics:index-12}}
In the case that a matrix-free iterative linear solver is chosen,
an \sphinxstyleemphasis{inexact Newton iteration} is utilized.  Here, the
matrix \({\mathcal A}\) is not itself constructed since the
algorithms only require the product of this matrix with a given
vector.  Additionally, each Newton system \eqref{equation:Mathematics:Newton_system} is not
solved completely, since these linear solvers are iterative (hence the
“inexact” in the name). As a result. for these linear solvers
\({\mathcal A}\) is applied in a matrix-free manner,
\begin{equation*}
\begin{split}{\mathcal A}(t,z)\, v = M(t)\,v - \gamma\, J(t,z)\, v.\end{split}
\end{equation*}
The mass matrix-vector products \(Mv\) \sphinxstyleemphasis{must} be provided through a
user-supplied routine; the Jacobian matrix-vector products \(Jv\)
are obtained by either calling an optional user-supplied routine, or
through a finite difference approximation to the directional
derivative:
\begin{equation*}
\begin{split}J(t,z)\,v \approx \frac{f^*(t,z+\sigma v) - f^*(t,z)}{\sigma},\end{split}
\end{equation*}
where again \(f^*\) is either \(f^I\) for ARKStep or \(f^S\) for MRIStep,
and we use the increment \(\sigma = 1/\|v\|\) to ensure that \(\|\sigma v\| = 1\).

As with the modified Newton method that reused \({\mathcal A}\)
between solves, the inexact Newton iteration may also recompute
the preconditioner \(P\) infrequently to balance the high costs
of matrix construction and factorization against the reduced
convergence rate that may result from a stale preconditioner.

\index{linear solver setup}\ignorespaces 

\subsubsection{Updating the linear solver}
\label{\detokenize{Mathematics:index-13}}\label{\detokenize{Mathematics:mathematics-linear-setup}}\label{\detokenize{Mathematics:updating-the-linear-solver}}
In cases where recomputation of the Newton matrix
\(\tilde{\mathcal A}\) or preconditioner \(P\) is lagged,
these structures will be recomputed only in the
following circumstances:
\begin{itemize}
\item {} 
when starting the problem,

\item {} 
when more than 20 steps have been taken since the last update (this
value may be modified by the user),

\item {} 
when the value \(\tilde{\gamma}\) of \(\gamma\) at the last
update satisfies \(\left|\gamma/\tilde{\gamma} - 1\right| >
0.2\) (this value may be modified by the user),

\item {} 
when a non-fatal convergence failure just occurred,

\item {} 
when an error test failure just occurred, or

\item {} 
if the problem is linearly implicit and \(\gamma\) has
changed by a factor larger than 100 times machine epsilon.

\end{itemize}

When an update is forced due to a convergence failure, an update of
\(\tilde{\mathcal A}\) or \(P\) may or may not involve a
re-evaluation of \(J\) (in \(\tilde{\mathcal A}\)) or of
Jacobian data (in \(P\)), depending on whether errors in the
Jacobian were the likely cause of the failure.  More generally, the
decision is made to re-evaluate \(J\) (or instruct the user to
update \(P\)) when:
\begin{itemize}
\item {} 
starting the problem,

\item {} 
more than 50 steps have been taken since the last evaluation,

\item {} 
a convergence failure occurred with an outdated matrix, and the
value \(\tilde{\gamma}\) of \(\gamma\) at the last update
satisfies \(\left|\gamma/\tilde{\gamma} - 1\right| > 0.2\),

\item {} 
a convergence failure occurred that forced a step size reduction, or

\item {} 
if the problem is linearly implicit and \(\gamma\) has
changed by a factor larger than 100 times machine epsilon.

\end{itemize}

However, for linear solvers and preconditioners that do not
rely on costly matrix construction and factorization operations
(e.g. when using a geometric multigrid method as preconditioner), it
may be more efficient to update these structures more frequently than
the above heuristics specify, since the increased rate of
linear/nonlinear solver convergence may more than account for the
additional cost of Jacobian/preconditioner construction.  To this end,
a user may specify that the system matrix \({\mathcal A}\) and/or
preconditioner \(P\) should be recomputed more frequently.

As will be further discussed in the section
{\hyperref[\detokenize{Mathematics:mathematics-preconditioning}]{\sphinxcrossref{\DUrole{std,std-ref}{Preconditioning}}}}, in the case of most Krylov methods,
preconditioning may be applied on the left, right, or on both sides of
\({\mathcal A}\), with user-supplied routines for the
preconditioner setup and solve operations.


\subsection{Iteration Error Control}
\label{\detokenize{Mathematics:mathematics-error}}\label{\detokenize{Mathematics:iteration-error-control}}

\subsubsection{Nonlinear iteration error control}
\label{\detokenize{Mathematics:mathematics-error-nonlinear}}\label{\detokenize{Mathematics:nonlinear-iteration-error-control}}
The stopping test for all of the nonlinear solver algorithms is
related to the temporal local error test, with the goal of keeping the
nonlinear iteration errors from interfering with local error control.
Denoting the final computed value of each stage solution as
\(z_i^{(m)}\), and the true stage solution solving \eqref{equation:Mathematics:Residual}
as \(z_i\), we want to ensure that the iteration error
\(z_i - z_i^{(m)}\) is “small” (recall that a norm less than 1 is
already considered within an acceptable tolerance).

To this end, we first estimate the linear convergence rate \(R_i\)
of the nonlinear iteration.  We initialize \(R_i=1\), and reset it
to this value whenever \(\tilde{\mathcal A}\) or \(P\) are
updated.  After computing a nonlinear correction \(\delta^{(m)} =
z_i^{(m)} - z_i^{(m-1)}\), if \(m>0\) we update \(R_i\) as
\begin{equation*}
\begin{split}R_i \leftarrow \max\left\{ 0.3 R_i, \left\|\delta^{(m)}\right\| / \left\|\delta^{(m-1)}\right\| \right\}.\end{split}
\end{equation*}
where the factor 0.3 is user-modifiable.

Let \(y_n^{(m)}\) denote the time-evolved solution constructed
using our approximate nonlinear stage solutions, \(z_i^{(m)}\),
and let \(y_n^{(\infty)}\) denote the time-evolved solution
constructed using \sphinxstyleemphasis{exact} nonlinear stage solutions.  We then use the
estimate
\begin{equation*}
\begin{split}\left\| y_n^{(\infty)} - y_n^{(m)} \right\| \approx
\max_i \left\| z_i^{(m+1)} - z_i^{(m)} \right\| \approx
\max_i R_i \left\| z_i^{(m)} - z_i^{(m-1)} \right\| =
\max_i R_i \left\| \delta^{(m)} \right\|.\end{split}
\end{equation*}
Therefore our convergence (stopping) test for the nonlinear iteration
for each stage is

\phantomsection\label{\detokenize{Mathematics:equation-nonlineartolerance}}\begin{equation}\label{equation:Mathematics:NonlinearTolerance}
\begin{split}R_i \left\|\delta^{(m)} \right\| < \epsilon,\end{split}
\end{equation}
where the factor \(\epsilon\) has default value 0.1.  We default
to a maximum of 3 nonlinear iterations.  We also declare the
nonlinear iteration to be divergent if any of the ratios
\(\|\delta^{(m)}\| / \|\delta^{(m-1)}\| > 2.3\) with \(m>0\).
If convergence fails in the fixed point iteration, or in the Newton
iteration with \(J\) or \({\mathcal A}\) current, we reduce
the step size \(h_n\) by a factor of 0.25.  The integration will
be halted after 10 convergence failures, or if a convergence failure
occurs with \(h_n = h_\text{min}\).  However, since the
nonlinearity of \eqref{equation:Mathematics:Residual} may vary significantly based on the
problem under consideration, these default constants may all be
modified by the user.


\subsubsection{Linear iteration error control}
\label{\detokenize{Mathematics:linear-iteration-error-control}}\label{\detokenize{Mathematics:mathematics-error-linear}}
When a Krylov method is used to solve the linear Newton systems
\eqref{equation:Mathematics:Newton_system}, its errors must also be controlled.  To this end,
we approximate the linear iteration error in the solution vector
\(\delta^{(m)}\) using the preconditioned residual vector,
e.g. \(r = P{\mathcal A}\delta^{(m)} + PG\) for the case of left
preconditioning (the role of the preconditioner is further elaborated
in the next section).  In an attempt to ensure that the linear
iteration errors do not interfere with the nonlinear solution error
and local time integration error controls, we require that the norm of
the preconditioned linear residual satisfies

\phantomsection\label{\detokenize{Mathematics:equation-lineartolerance}}\begin{equation}\label{equation:Mathematics:LinearTolerance}
\begin{split}\|r\| \le \frac{\epsilon_L \epsilon}{10}.\end{split}
\end{equation}
Here \(\epsilon\) is the same value as that is used above for the
nonlinear error control.  The factor of 10 is used to ensure that the
linear solver error does not adversely affect the nonlinear solver
convergence.  Smaller values for the parameter \(\epsilon_L\) are
typically useful for strongly nonlinear or very stiff ODE systems,
while easier ODE systems may benefit from a value closer to 1.  The
default value is \(\epsilon_L = 0.05\), which may be modified by
the user.  We note that for linearly
implicit problems the tolerance \eqref{equation:Mathematics:LinearTolerance} is similarly
used for the single Newton iteration.


\subsection{Preconditioning}
\label{\detokenize{Mathematics:preconditioning}}\label{\detokenize{Mathematics:mathematics-preconditioning}}
When using an inexact Newton method to solve the nonlinear system
\eqref{equation:Mathematics:Residual}, an iterative method is used repeatedly to solve
linear systems of the form \({\mathcal A}x = b\), where \(x\) is a
correction vector and \(b\) is a residual vector.  If this
iterative method is one of the scaled preconditioned iterative linear
solvers supplied with SUNDIALS, their efficiency may benefit
tremendously from preconditioning. A system \({\mathcal A}x=b\)
can be preconditioned using any one of:
\begin{equation*}
\begin{split}(P^{-1}{\mathcal A})x = P^{-1}b & \qquad\text{[left preconditioning]}, \\
({\mathcal A}P^{-1})Px = b  & \qquad\text{[right preconditioning]}, \\
(P_L^{-1} {\mathcal A} P_R^{-1}) P_R x = P_L^{-1}b & \qquad\text{[left and right
preconditioning]}.\end{split}
\end{equation*}
These Krylov iterative methods are then applied to a system with the
matrix \(P^{-1}{\mathcal A}\), \({\mathcal A}P^{-1}\), or
\(P_L^{-1} {\mathcal A} P_R^{-1}\), instead of \({\mathcal
A}\).  In order to improve the convergence of the Krylov iteration, the
preconditioner matrix \(P\), or the product \(P_L P_R\) in the
third case, should in some sense approximate the system matrix
\({\mathcal A}\).  Simultaneously, in order to be
cost-effective the matrix \(P\) (or matrices \(P_L\) and
\(P_R\)) should be reasonably efficient to evaluate and solve.
Finding an optimal point in this trade-off between rapid
convergence and low cost can be quite challenging.  Good choices are
often problem-dependent (for example, see \phantomsection\label{\detokenize{Mathematics:id26}}{\hyperref[\detokenize{References:bh1989}]{\sphinxcrossref{{[}BH1989{]}}}} for an
extensive study of preconditioners for reaction-transport systems).

Most of the iterative linear solvers supplied with SUNDIALS allow for
all three types of preconditioning (left, right or both), although for
non-symmetric matrices \({\mathcal A}\) we know of few situations
where preconditioning on both sides is superior to preconditioning on
one side only (with the product \(P = P_L P_R\)).  Moreover, for a
given preconditioner matrix, the merits of left vs. right
preconditioning are unclear in general, so we recommend that the user
experiment with both choices.  Performance can differ between these
since the inverse of the left preconditioner is included in the linear
system residual whose norm is being tested in the Krylov algorithm.
As a rule, however, if the preconditioner is the product of two
matrices, we recommend that preconditioning be done either on the left
only or the right only, rather than using one factor on each
side.  An exception to this rule is the PCG solver, that itself
assumes a symmetric matrix \({\mathcal A}\), since the PCG
algorithm in fact applies the single preconditioner matrix \(P\)
in both left/right fashion as \(P^{-1/2} {\mathcal A} P^{-1/2}\).

Typical preconditioners are based on approximations
to the system Jacobian, \(J = \partial f^I / \partial y\).  Since
the Newton iteration matrix involved is \({\mathcal A} = M -
\gamma J\), any approximation \(\bar{J}\) to \(J\) yields a
matrix that is of potential use as a preconditioner, namely \(P =
M - \gamma \bar{J}\). Because the Krylov iteration occurs within a
Newton iteration and further also within a time integration, and since
each of these iterations has its own test for convergence, the
preconditioner may use a very crude approximation, as long as it
captures the dominant numerical features of the system.  We have
found that the combination of a preconditioner with the Newton-Krylov
iteration, using even a relatively poor approximation to the Jacobian,
can be surprisingly superior to using the same matrix without Krylov
acceleration (i.e., a modified Newton iteration), as well as to using
the Newton-Krylov method with no preconditioning.


\subsection{Implicit predictors}
\label{\detokenize{Mathematics:mathematics-predictors}}\label{\detokenize{Mathematics:implicit-predictors}}
For problems with implicit components, a prediction algorithm is
employed for constructing the initial guesses for each implicit
Runge-Kutta stage, \(z_i^{(0)}\).  As is well-known with nonlinear
solvers, the selection of a good initial guess can have dramatic
effects on both the speed and robustness of the solve, making the
difference between rapid quadratic convergence versus divergence of
the iteration.  To this end, a variety of prediction algorithms are
provided.  In each case, the stage guesses \(z_i^{(0)}\) are
constructed explicitly using readily-available information, including
the previous step solutions \(y_{n-1}\) and \(y_{n-2}\), as
well as any previous stage solutions \(z_j, \quad j<i\).  In most
cases, prediction is performed by constructing an interpolating
polynomial through existing data, which is then evaluated at the
desired stage time to provide an inexpensive but (hopefully)
reasonable prediction of the stage solution.  Specifically, for most
Runge-Kutta methods each stage solution satisfies
\begin{equation*}
\begin{split}z_i \approx y(t^I_{n,i}),\end{split}
\end{equation*}
(similarly for MRI methods \(z_i \approx y(t^S_{n,i})\)),
so by constructing an interpolating polynomial \(p_q(t)\) through
a set of existing data, the initial guess at stage solutions may be
approximated as

\phantomsection\label{\detokenize{Mathematics:equation-extrapolant}}\begin{equation}\label{equation:Mathematics:extrapolant}
\begin{split}z_i^{(0)} = p_q(t^I_{n,i}).\end{split}
\end{equation}
As the stage times for MRI stages and implicit ARK and DIRK stages usually
have non-negative abcissae (i.e., \(c_j^I > 0\)), it is typically the
case that \(t^I_{n,j}\) (resp., \(t^S_{n,j}\)) is outside of the
time interval containing the data used to construct \(p_q(t)\), hence
\eqref{equation:Mathematics:extrapolant} will correspond to an extrapolant instead of an
interpolant.  The dangers of using a polynomial interpolant to extrapolate
values outside the interpolation interval are well-known, with higher-order
polynomials and predictions further outside the interval resulting in the
greatest potential inaccuracies.

The prediction algorithms available in ARKode therefore
construct a variety of interpolants \(p_q(t)\), having
different polynomial order and using different interpolation data, to
support ‘optimal’ choices for different types of problems, as
described below.  We note that due to the structural similarities between
implicit ARK and DIRK stages in ARKStep, and solve-decoupled implicit stages
in MRIStep, we use the ARKStep notation throughout the remainder of this
section, but each statement equally applies to MRIStep (unless otherwise noted).


\subsubsection{Trivial predictor}
\label{\detokenize{Mathematics:trivial-predictor}}\label{\detokenize{Mathematics:mathematics-predictors-trivial}}
The so-called “trivial predictor” is given by the formula
\begin{equation*}
\begin{split}p_0(t) = y_{n-1}.\end{split}
\end{equation*}
While this piecewise-constant interpolant is clearly not a highly
accurate candidate for problems with time-varying solutions, it is
often the most robust approach for highly stiff problems, or for
problems with implicit constraints whose violation may cause illegal
solution values (e.g. a negative density or temperature).


\subsubsection{Maximum order predictor}
\label{\detokenize{Mathematics:mathematics-predictors-max}}\label{\detokenize{Mathematics:maximum-order-predictor}}
At the opposite end of the spectrum, ARKode’s
{\hyperref[\detokenize{Mathematics:mathematics-interpolation}]{\sphinxcrossref{\DUrole{std,std-ref}{interpolation module}}}} can be used to
construct a higher-order polynomial interpolant, \(p_q(t)\).  The
implicit stage predictor is computed through evaulating this interpolant
at each stage time \(t^I_{n,i}\).


\subsubsection{Variable order predictor}
\label{\detokenize{Mathematics:mathematics-predictors-decreasing}}\label{\detokenize{Mathematics:variable-order-predictor}}
This predictor attempts to use higher-order polynomials
\(p_q(t)\) for predicting earlier stages, and lower-order
interpolants for later stages.  It uses the same interpolation module
as described above, but chooses the polynomial degree adaptively based on the
stage index \(i\), under the assumption that the
stage times are increasing, i.e. \(c^I_j < c^I_k\) for
\(j<k\):
\begin{equation*}
\begin{split}q_i = \max\{ q_\text{max} - i + 1,\; 1 \}, \quad i=1,\ldots,s.\end{split}
\end{equation*}

\subsubsection{Cutoff order predictor}
\label{\detokenize{Mathematics:cutoff-order-predictor}}\label{\detokenize{Mathematics:mathematics-predictors-cutoff}}
This predictor follows a similar idea as the previous algorithm, but
monitors the actual stage times to determine the polynomial
interpolant to use for prediction.  Denoting \(\tau = c_i^I
\dfrac{h_n}{h_{n-1}}\), the polynomial degree \(q_i\) is chosen as:
\begin{equation*}
\begin{split}q_i = \begin{cases}
   q_\text{max}, & \text{if}\quad \tau < \tfrac12,\\
   1, & \text{otherwise}.
\end{cases}\end{split}
\end{equation*}

\subsubsection{Bootstrap predictor (\protect\(M=I\protect\) only)}
\label{\detokenize{Mathematics:mathematics-predictors-bootstrap}}\label{\detokenize{Mathematics:bootstrap-predictor-only}}
This predictor does not use any information from the preceding
step, instead using information only within the current step
\([t_{n-1},t_n]\).  In addition to using the solution and ODE
right-hand side function, \(y_{n-1}\) and
\(f(t_{n-1},y_{n-1})\), this approach uses the right-hand
side from a previously computed stage solution in the same step,
\(f(t_{n-1}+c^I_j h,z_j)\) to construct a quadratic Hermite
interpolant for the prediction.  If we define the constants
\(\tilde{h} = c^I_j h\) and \(\tau = c^I_i h\), the predictor
is given by
\begin{equation*}
\begin{split}z_i^{(0)} = y_{n-1} + \left(\tau - \frac{\tau^2}{2\tilde{h}}\right)
   f(t_{n-1},y_{n-1}) + \frac{\tau^2}{2\tilde{h}} f(t_{n-1}+\tilde{h},z_j).\end{split}
\end{equation*}
For stages without a nonzero preceding stage time,
i.e. \(c^I_j\ne 0\) for \(j<i\), this method reduces to using
the trivial predictor \(z_i^{(0)} = y_{n-1}\).  For stages having
multiple preceding nonzero \(c^I_j\), we choose the stage having
largest \(c^I_j\) value, to minimize the level of extrapolation
used in the prediction.

We note that in general, each stage solution \(z_j\) has
significantly worse accuracy than the time step solutions
\(y_{n-1}\), due to the difference between the \sphinxstyleemphasis{stage order} and
the \sphinxstyleemphasis{method order} in Runge-Kutta methods.  As a result, the accuracy
of this predictor will generally be rather limited, but it is
provided for problems in which this increased stage error is better
than the effects of extrapolation far outside of the previous time
step interval \([t_{n-2},t_{n-1}]\).

Although this approach could be used with non-identity mass matrix, support for
that mode is not currently implemented, so selection of this predictor in the
case of a non-identity mass matrix will result in use of the trivial predictor.


\subsubsection{Minimum correction predictor (ARKStep, \protect\(M=I\protect\) only)}
\label{\detokenize{Mathematics:mathematics-predictors-minimumcorrection}}\label{\detokenize{Mathematics:minimum-correction-predictor-arkstep-only}}
The final predictor is not interpolation based; instead it
utilizes all existing stage information from the current step to
create a predictor containing all but the current stage solution.
Specifically, as discussed in equations \eqref{equation:Mathematics:ARK} and \eqref{equation:Mathematics:Residual},
each stage solves a nonlinear equation
\begin{equation*}
\begin{split}z_i &= y_{n-1} + h_n \sum_{j=1}^{i-1} A^E_{i,j} f^E(t^E_{n,j}, z_j)
+ h_n \sum_{j=1}^{i}   A^I_{i,j} f^I(t^I_{n,j}, z_j), \\
\Leftrightarrow \qquad \qquad & \\
G(z_i) &\equiv z_i - h_n A^I_{i,i} f^I(t^I_{n,i}, z_i) - a_i = 0.\end{split}
\end{equation*}
This prediction method merely computes the predictor \(z_i\) as
\begin{equation*}
\begin{split}z_i &= y_{n-1} + h_n \sum_{j=1}^{i-1} A^E_{i,j} f^E(t^E_{n,j}, z_j)
              + h_n \sum_{j=1}^{i-1}  A^I_{i,j} f^I(t^I_{n,j}, z_j), \\
\Leftrightarrow \quad \qquad & \\
z_i &= a_i.\end{split}
\end{equation*}
Again, although this approach could be used with non-identity mass matrix, support
for that mode is not currently implemented, so selection of this predictor in the
case of a non-identity mass matrix will result in use of the trivial predictor.


\subsection{Mass matrix solver (ARKStep only)}
\label{\detokenize{Mathematics:mathematics-masssolve}}\label{\detokenize{Mathematics:mass-matrix-solver-arkstep-only}}
Within the ARKStep algorithms described above, there are multiple
locations where a matrix-vector product

\phantomsection\label{\detokenize{Mathematics:equation-mass-multiply}}\begin{equation}\label{equation:Mathematics:mass_multiply}
\begin{split}b = M v\end{split}
\end{equation}
or a linear solve

\phantomsection\label{\detokenize{Mathematics:equation-mass-solve}}\begin{equation}\label{equation:Mathematics:mass_solve}
\begin{split}x = M^{-1} b\end{split}
\end{equation}
is required.

Of course, for problems in which \(M=I\) both of these operators
are trivial.  However for problems with non-identity mass matrix,
these linear solves \eqref{equation:Mathematics:mass_solve} may be handled using
any valid linear solver module, in the same manner as described in the
section {\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}} for solving the linear Newton
systems.

For ERK methods involving non-identity mass matrix, even though
calculation of individual stages does not require an algebraic solve,
both of the above operations (matrix-vector product, and mass matrix
solve) may be required within each time step.  Therefore, for these
users we recommend reading the rest of this section as it pertains to
ARK methods, with the obvious simplification that since \(f^E=f\)
and \(f^I=0\) no Newton or fixed-point nonlinear solve, and no
overall system linear solve, is involved in the solution process.

At present, for DIRK and ARK problems using a matrix-based solver for
the Newton nonlinear iterations, the type of matrix (dense, band,
sparse, or custom) for the Jacobian matrix \(J\) must match the
type of mass matrix \(M\), since these are combined to form the
Newton system matrix \(\tilde{\mathcal A}\).  When matrix-based
methods are employed, the user must supply a routine to compute
\(M(t)\) in the appropriate form to match the structure of
\({\mathcal A}\), with a user-supplied routine of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}.  This matrix structure is used internally to
perform any requisite mass matrix-vector products \eqref{equation:Mathematics:mass_multiply}.

When matrix-free methods are selected, a routine must be supplied to
perform the mass-matrix-vector product, \(Mv\).  As with iterative
solvers for the Newton systems, preconditioning may be applied to aid
in solution of the mass matrix systems \eqref{equation:Mathematics:mass_solve}.  When using an
iterative mass matrix linear solver, we require that the norm of the
preconditioned linear residual satisfies

\phantomsection\label{\detokenize{Mathematics:equation-masslineartolerance}}\begin{equation}\label{equation:Mathematics:MassLinearTolerance}
\begin{split}\|r\| \le \epsilon_L \epsilon,\end{split}
\end{equation}
where again, \(\epsilon\) is the nonlinear solver tolerance
parameter from \eqref{equation:Mathematics:NonlinearTolerance}.  When using iterative system
and mass matrix linear solvers, \(\epsilon_L\) may be specified
separately for both tolerances \eqref{equation:Mathematics:LinearTolerance} and
\eqref{equation:Mathematics:MassLinearTolerance}.

In the above algorithmic description there are five locations
where a linear solve of the form \eqref{equation:Mathematics:mass_solve} is required: (a) at each
iteration of a fixed-point nonlinear solve, (b) in computing the
Runge\textendash{}Kutta right-hand side vectors \(\hat{f}^E_i\) and
\(\hat{f}^I_i\), (c) in constructing the time-evolved solution
\(y_n\), (d) in estimating the local temporal truncation error, and (e)
in constructing predictors for the implicit solver iteration (see section
{\hyperref[\detokenize{Mathematics:mathematics-predictors-max}]{\sphinxcrossref{\DUrole{std,std-ref}{Maximum order predictor}}}}).  We note that different nonlinear
solver approaches (i.e., Newton vs fixed-point) and different types of
mass matrices (i.e., time-dependent versus fixed) result in different
subsets of the above operations.  We discuss each of these in the bullets below.
\begin{itemize}
\item {} 
When using a fixed-point nonlinear solver, at each fixed-point iteration
we must solve
\begin{equation*}
\begin{split}M(t^I_{n,i})\, z_i^{(m+1)} = G\left(z_i^{(m)}\right), \quad m=0,1,\ldots\end{split}
\end{equation*}
for the new fixed-point iterate, \(z_i^{(m+1)}\).

\item {} 
In the case of a time-dependent mass matrix, to construct the Runge\textendash{}Kutta
right-hand side vectors we must solve
\begin{equation*}
\begin{split}M(t^E_{n,i}) \hat{f}^{E}_i \ = \ f^{E}(t^E_{n,i},z_i)
\quad\text{and}\quad
M(t^I_{n,i}) \hat{f}^{I}_j \ = \ f^{I}(t^I_{n,i},z_i)\end{split}
\end{equation*}
for the vectors \(\hat{f}^{E}_i\) and \(\hat{f}^{I}_i\).

\item {} 
For fixed mass matrices, we construct the time-evolved solution \(y_n\)
from equation \eqref{equation:Mathematics:ARK} by solving
\begin{equation*}
\begin{split}&M y_n \ = \ M y_{n-1} + h_n \sum_{i=1}^{s} \left( b^E_i f^E(t^E_{n,i}, z_i)
              + b^I_i f^I(t^I_{n,i}, z_i)\right), \\
\Leftrightarrow \qquad & \\
&M (y_n -y_{n-1}) \ = \ h_n \sum_{i=1}^{s} \left(b^E_i f^E(t^E_{n,i}, z_i)
              + b^I_i f^I(t^I_{n,i}, z_i)\right), \\
\Leftrightarrow \qquad & \\
&M \nu \ = \ h_n \sum_{i=1}^{s} \left(b^E_i f^E(t^E_{n,i}, z_i)
              + b^I_i f^I(t^I_{n,i}, z_i)\right),\end{split}
\end{equation*}
for the update \(\nu = y_n - y_{n-1}\).

Similarly, we compute the local temporal error
estimate \(T_n\) from equation \eqref{equation:Mathematics:LTE} by solving systems of the form

\phantomsection\label{\detokenize{Mathematics:equation-mass-solve-lte}}\begin{equation}\label{equation:Mathematics:mass_solve_LTE}
\begin{split}M\, T_n = h \sum_{i=1}^{s} \left[
\left(b^E_i - \tilde{b}^E_i\right) f^E(t^E_{n,i}, z_i) +
\left(b^I_i - \tilde{b}^I_i\right) f^I(t^I_{n,i}, z_i) \right].\end{split}
\end{equation}
\item {} 
For problems with either form of non-identity mass matrix, in constructing
dense output and implicit predictors of order 2 or higher (see the
section {\hyperref[\detokenize{Mathematics:mathematics-predictors-max}]{\sphinxcrossref{\DUrole{std,std-ref}{Maximum order predictor}}}} above), we compute the derivative
information \(\hat{f}_k\) from the equation
\begin{equation*}
\begin{split}M(t_n) \hat{f}_n = f^E(t_n, y_n) + f^I(t_n, y_n).\end{split}
\end{equation*}
\end{itemize}

In total, for problems with time-independent mass matrix, we require only
two mass-matrix linear solves \eqref{equation:Mathematics:mass_solve} per attempted time step,
with one more upon completion of a time step that meets the solution accuracy
requirements.  When fixed time-stepping is used (\(h_n=h\)), the
solve \eqref{equation:Mathematics:mass_solve_LTE} is not performed at each attempted step.

Similarly, for problems with time-dependent mass matrix, we require
\(2s\) mass-matrix linear solves \eqref{equation:Mathematics:mass_solve} per attempted step,
where \(s\) is the number of stages in the ARK method (only half of
these are required for purely explicit or purely implicit problems,
\eqref{equation:Mathematics:IVP_explicit} or \eqref{equation:Mathematics:IVP_implicit}), with one more upon completion of
a time step that meets the solution accuracy requirements.

In addition to the above totals, when using a fixed-point nonlinear solver
(assumed to require \(m\) iterations), we will need an additional
\(ms\) mass-matrix linear solves \eqref{equation:Mathematics:mass_solve} per attempted time
step (but zero linear solves with the system Jacobian).


\section{Rootfinding}
\label{\detokenize{Mathematics:rootfinding}}\label{\detokenize{Mathematics:mathematics-rootfinding}}
All of the time-stepping modules in ARKode also support a rootfinding
feature.  This means that, while integrating the IVP \eqref{equation:Mathematics:IVP}, these
can also find the roots of a set of user-defined functions
\(g_i(t,y)\) that depend on \(t\) and the solution vector
\(y = y(t)\). The number of these root functions is arbitrary, and
if more than one \(g_i\) is found to have a root in any given
interval, the various root locations are found and reported in the
order that they occur on the \(t\) axis, in the direction of
integration.

Generally, this rootfinding feature finds only roots of odd
multiplicity, corresponding to changes in sign of \(g_i(t,
y(t))\), denoted \(g_i(t)\) for short. If a user root function has
a root of even multiplicity (no sign change), it will almost certainly
be missed due to the realities of floating-point arithmetic.  If such
a root is desired, the user should reformulate the root function so
that it changes sign at the desired root.

The basic scheme used is to check for sign changes of any
\(g_i(t)\) over each time step taken, and then (when a sign change
is found) to home in on the root (or roots) with a modified secant
method \phantomsection\label{\detokenize{Mathematics:id27}}{\hyperref[\detokenize{References:hs1980}]{\sphinxcrossref{{[}HS1980{]}}}}.  In addition, each time \(g\) is
evaluated, ARKode checks to see if \(g_i(t) = 0\) exactly, and if
so it reports this as a root.  However, if an exact zero of any
\(g_i\) is found at a point \(t\), ARKode computes
\(g(t+\delta)\) for a small increment \(\delta\), slightly
further in the direction of integration, and if any
\(g_i(t+\delta) = 0\) also, ARKode stops and reports an
error. This way, each time ARKode takes a time step, it is guaranteed
that the values of all \(g_i\) are nonzero at some past value of
\(t\), beyond which a search for roots is to be done.

At any given time in the course of the time-stepping, after suitable
checking and adjusting has been done, ARKode has an interval
\((t_\text{lo}, t_\text{hi}]\) in which roots of the
\(g_i(t)\) are to be sought, such that \(t_\text{hi}\) is
further ahead in the direction of integration, and all
\(g_i(t_\text{lo}) \ne 0\).  The endpoint \(t_\text{hi}\) is
either \(t_n\), the end of the time step last taken, or the next
requested output time \(t_\text{out}\) if this comes sooner. The
endpoint \(t_\text{lo}\) is either \(t_{n-1}\), or the last
output time \(t_\text{out}\) (if this occurred within the last
step), or the last root location (if a root was just located within
this step), possibly adjusted slightly toward \(t_n\) if an exact
zero was found. The algorithm checks \(g(t_\text{hi})\) for zeros, and
it checks for sign changes in \((t_\text{lo}, t_\text{hi})\). If no sign
changes are found, then either a root is reported (if some
\(g_i(t_\text{hi}) = 0\)) or we proceed to the next time interval
(starting at \(t_\text{hi}\)). If one or more sign changes were found,
then a loop is entered to locate the root to within a rather tight
tolerance, given by
\begin{equation*}
\begin{split}\tau = 100\, U\, (|t_n| + |h|)\qquad (\text{where}\; U = \text{unit roundoff}).\end{split}
\end{equation*}
Whenever sign changes are seen in two or more root functions, the one
deemed most likely to have its root occur first is the one with the
largest value of
\(\left|g_i(t_\text{hi})\right| / \left| g_i(t_\text{hi}) - g_i(t_\text{lo})\right|\),
corresponding to the closest to \(t_\text{lo}\) of the secant method
values. At each pass through the loop, a new value \(t_\text{mid}\) is
set, strictly within the search interval, and the values of
\(g_i(t_\text{mid})\) are checked. Then either \(t_\text{lo}\) or
\(t_\text{hi}\) is reset to \(t_\text{mid}\) according to which
subinterval is found to have the sign change. If there is none in
\((t_\text{lo}, t_\text{mid})\) but some \(g_i(t_\text{mid}) = 0\), then that
root is reported. The loop continues until \(\left|t_\text{hi} -
t_\text{lo} \right| < \tau\), and then the reported root location is
\(t_\text{hi}\).  In the loop to locate the root of \(g_i(t)\), the
formula for \(t_\text{mid}\) is
\begin{equation*}
\begin{split}t_\text{mid} = t_\text{hi} -
\frac{g_i(t_\text{hi}) (t_\text{hi} - t_\text{lo})}{g_i(t_\text{hi}) - \alpha g_i(t_\text{lo})} ,\end{split}
\end{equation*}
where \(\alpha\) is a weight parameter. On the first two passes
through the loop, \(\alpha\) is set to 1, making \(t_\text{mid}\)
the secant method value. Thereafter, \(\alpha\) is reset according
to the side of the subinterval (low vs high, i.e. toward
\(t_\text{lo}\) vs toward \(t_\text{hi}\)) in which the sign change was
found in the previous two passes. If the two sides were opposite,
\(\alpha\) is set to 1. If the two sides were the same, \(\alpha\)
is halved (if on the low side) or doubled (if on the high side). The
value of \(t_\text{mid}\) is closer to \(t_\text{lo}\) when
\(\alpha < 1\) and closer to \(t_\text{hi}\) when \(\alpha > 1\).
If the above value of \(t_\text{mid}\) is within \(\tau /2\) of
\(t_\text{lo}\) or \(t_\text{hi}\), it is adjusted inward, such that its
fractional distance from the endpoint (relative to the interval size)
is between 0.1 and 0.5 (with 0.5 being the midpoint), and the actual
distance from the endpoint is at least \(\tau/2\).

Finally, we note that when running in parallel, ARKode’s rootfinding
module assumes that the entire set of root defining functions
\(g_i(t,y)\) is replicated on every MPI task.  Since in these
cases the vector \(y\) is distributed across tasks, it is the
user’s responsibility to perform any necessary inter-task
communication to ensure that \(g_i(t,y)\) is identical on each task.


\section{Inequality Constraints}
\label{\detokenize{Mathematics:inequality-constraints}}\label{\detokenize{Mathematics:mathematics-inequalityconstraints}}
The ARKStep and ERKStep modules in ARKode permit the user to impose optional
inequality constraints on individual components of the solution vector \(y\).
Any of the following four constraints can be imposed: \(y_i > 0\), \(y_i < 0\),
\(y_i \geq 0\), or \(y_i \leq 0\). The constraint satisfaction is tested
after a successful step and before the error test. If any constraint fails, the
step size is reduced and a flag is set to update the Jacobian or preconditioner
if applicable. Rather than cutting the step size by some arbitrary factor,
ARKode estimates a new step size \(h'\) using a linear approximation of the
components in \(y\) that failed the constraint test (including a safety
factor of 0.9 to cover the strict inequality case). If a step fails to satisfy
the constraints 10 times (a value which may be modified by the user) within a
step attempt or fails with the minimum step size then the integration is halted
and an error is returned. In this case the user may need to employ other
strategies as discussed in {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-tolerances}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKStep tolerance specification functions}}}} and
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-tolerances}]{\sphinxcrossref{\DUrole{std,std-ref}{ERKStep tolerance specification functions}}}} to satisfy the inequality constraints.


\chapter{Code Organization}
\label{\detokenize{Organization::doc}}\label{\detokenize{Organization:code-organization}}\label{\detokenize{Organization:organization}}
The family of solvers referred to as SUNDIALS consists of the solvers
CVODE and ARKode (for ODE systems), KINSOL (for nonlinear algebraic
systems), and IDA (for differential-algebraic systems).  In addition,
SUNDIALS also includes variants of CVODE and IDA with sensitivity analysis
capabilities (using either forward or adjoint methods), called CVODES and
IDAS, respectively.

The various solvers of this family share many subordinate modules.
For this reason, it is organized as a family, with a directory
structure that exploits that sharing (see the following Figures
{\hyperref[\detokenize{Organization:sunorg1}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS organization}}}} and {\hyperref[\detokenize{Organization:sunorg2}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS tree}}}}).
The following is a list of the solver packages presently available, and the
basic functionality of each:
\begin{itemize}
\item {} 
CVODE, a linear multistep solver for stiff and nonstiff ODE systems
\(\dot{y} = f(t,y)\) based on Adams and BDF methods;

\item {} 
CVODES, a linear multistep solver for stiff and nonstiff ODEs with
sensitivity analysis capabilities;

\item {} 
ARKode, a Runge-Kutta based solver for stiff, nonstiff, mixed stiff-nonstiff,
and multirate ODE systems;

\item {} 
IDA, a linear multistep solver for differential-algebraic systems
\(F(t,y,\dot{y}) = 0\) based on BDF methods;

\item {} 
IDAS, a linear multistep solver for differential-algebraic systems with sensitivity
analysis capabilities;

\item {} 
KINSOL, a solver for nonlinear algebraic systems \(F(u) = 0\).

\end{itemize}

Note for modules that provide interfaces to third-party libraries (i.e., LAPACK,
KLU, SuperLU\_MT, SuperLU\_DIST, \sphinxstyleemphasis{hypre}, PETSc, Trilinos, and RAJA users will
need to download and compile those packages independently.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{sunorg1}.png}
\caption{\sphinxstyleemphasis{SUNDIALS organization}: High-level diagram of the SUNDIALS structure}\label{\detokenize{Organization:sunorg1}}\label{\detokenize{Organization:id3}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{sunorg2}.png}
\caption{\sphinxstyleemphasis{SUNDIALS tree}: Directory structure of the source tree.}\label{\detokenize{Organization:sunorg2}}\label{\detokenize{Organization:id4}}\end{figure}


\section{ARKode organization}
\label{\detokenize{Organization:arkode-organization}}
The ARKode package is written in the ANSI C language.  The
following summarizes the basic structure of the package, although
knowledge of this structure is not necessary for its use.

The overall organization of the ARKode package is shown in Figure
{\hyperref[\detokenize{Organization:arkorg}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode organization}}}}.  The central integration modules,
implemented in the files \sphinxcode{arkode.h}, \sphinxcode{arkode\_impl.h},
\sphinxcode{arkode\_butcher.h}, \sphinxcode{arkode.c}, \sphinxcode{arkode\_arkstep.c} ,
\sphinxcode{arkode\_erkstep.c}, \sphinxcode{arkode\_mristep.h}, and \sphinxcode{arkode\_butcher.c}, deal with
the evaluation of integration stages, the nonlinear solvers, estimation of
the local truncation error, selection of step size, and interpolation
to user output points, among other issues.  ARKode currently supports
modified Newton, inexact Newton, and accelerated fixed-point solvers
for these nonlinearly implicit problems.  However, when using the
Newton-based iterations, or when using a non-identity mass matrix
\(M\ne I\), ARKode has flexibility in the choice of method used to
solve the linear sub-systems that arise.  Therefore, for any user
problem invoking the Newton solvers, or any user problem with
\(M\ne I\), one (or more) of the linear system solver modules
should be specified by the user, which is then invoked as needed
during the integration process.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{arkorg}.png}
\caption{\sphinxstyleemphasis{ARKode organization}: Overall structure of the ARKode package.
Modules specific to ARKode are the timesteppers (ARKODE), linear solver
interfaces (ARKLS), nonlinear solver interfaces (ARKNLS), and preconditioners
(ARKBANDPRE and ARKBBDPRE); all other items correspond to generic SUNDIALS
vector, matrix, and solver modules.}\label{\detokenize{Organization:arkorg}}\label{\detokenize{Organization:id5}}\end{figure}

For solving these linear systems, ARKode’s linear solver interface
supports both direct and iterative linear solvers built using the
generic SUNLINSOL API (see {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}).  These solvers may
utilize a SUNMATRIX object for storing Jacobian information, or they
may be matrix-free.  Since ARKode can operate on any valid SUNLINSOL
implementation, the set of linear solver modules available to ARKode
will expand as new SUNLINSOL modules are developed.

For users employing dense or banded Jacobians, ARKode includes
algorithms for their approximation  through difference quotients,
although the user also has the option of supplying a routine to
compute the Jacobian (or an approximation to it) directly.  This
user-supplied routine is required when using sparse or user-supplied
Jacobian matrices.

For users employing iterative linear solvers, ARKode includes an
algorithm for the approximation by difference quotients of the product
\(Av\). Again, the user has the option of providing routines for
this operation, in two phases: setup (preprocessing of Jacobian data)
and multiplication.

When solve problems with non-identity mass matrices, corresponding
user-supplied routines for computing either the mass matrix \(M\)
or the product \(Mv\) are required.  Additionally, the type of
linear solver module (iterative, dense-direct, band-direct,
sparse-direct) used for both the IVP system and mass matrix must
match.

For preconditioned iterative methods for either the system or mass
matrix solves, the preconditioning must be supplied by the user, again
in two phases: setup and solve.  While there is no default choice of
preconditioner analogous to the difference-quotient approximation in
the direct case, the references \phantomsection\label{\detokenize{Organization:id1}}{\hyperref[\detokenize{References:bh1989}]{\sphinxcrossref{{[}BH1989{]}}}} and \phantomsection\label{\detokenize{Organization:id2}}{\hyperref[\detokenize{References:b1992}]{\sphinxcrossref{{[}B1992{]}}}}, together with
the example and demonstration programs included with ARKode and CVODE,
offer considerable assistance in building simple preconditioners.

ARKode’s linear solver interface consists of four primary phases,
devoted to
\begin{enumerate}
\item {} 
memory allocation and initialization,

\item {} 
setup of the matrix/preconditioner data involved,

\item {} 
solution of the system, and

\item {} 
freeing of memory.

\end{enumerate}

The setup and solution phases are separate because the evaluation of
Jacobians and preconditioners is done only periodically during the
integration process, and only as required to achieve convergence.

ARKode also provides two rudimentary preconditioner modules, for
use with any of the Krylov iterative linear solvers.  The first,
ARKBANDPRE is intended to be used with the serial or threaded vector
data structures (NVECTOR\_SERIAL, NVECTOR\_OPENMP and NVECTOR\_PTHREADS),
and provides a banded difference-quotient approximation to the
Jacobian as the preconditioner, with corresponding setup and solve
routines.  The second preconditioner module, ARKBBDPRE, is intended to
work with the parallel vector data structure, NVECTOR\_PARALLEL, and
generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix owned by a single processor.

All state information used by ARKode to solve a given problem is
saved in a single opaque memory structure, and a pointer to that
structure is returned to the user.  For C and C++ applications there
is no global data in the ARKode package, and so in this respect it is
reentrant.  State information specific to the linear solver interface
is saved in a separate data structure, a pointer to which resides in
the ARKode memory structure.  State information specific to the linear
solver implementation (and matrix implementation, if applicable) are
stored in their own data structures, that are returned to the user
upon construction, and subsequently provided to ARKode for use.  We
note that the ARKode Fortran interface, however, currently uses global
variables, so at most one of each of these objects may be created per
memory space (i.e. one per MPI task in distributed memory
computations).


\chapter{Using ARKStep for C and C++ Applications}
\label{\detokenize{ARKStep_c_interface/index::doc}}\label{\detokenize{ARKStep_c_interface/index:using-arkstep-for-c-and-c-applications}}\label{\detokenize{ARKStep_c_interface/index:arkstep-cinterface}}
This chapter is concerned with the use of the ARKStep time-stepping
module for the solution of initial value problems (IVPs) in a C or C++
language setting.  The following sections discuss the header files and
the layout of the user’s main program, and provide descriptions of the
ARKStep user-callable functions and user-supplied functions.

The example programs described in the companion document \phantomsection\label{\detokenize{ARKStep_c_interface/index:id1}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}} may
be helpful. Those codes may be used as templates for new codes and are
included in the ARKode package \sphinxcode{examples} subdirectory.

Users with applications written in Fortran should see the chapter
{\hyperref[\detokenize{ARKode_f_interface/FARKODE:fortraninterface}]{\sphinxcrossref{\DUrole{std,std-ref}{FARKODE, an Interface Module for FORTRAN Applications}}}}, which describes the Fortran/C interface
module for ARKStep, and may look to the Fortran example programs also
described in the companion document \phantomsection\label{\detokenize{ARKStep_c_interface/index:id2}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}}.  These codes are also
located in the ARKode package \sphinxcode{examples} directory.

The user should be aware that not all SUNLINSOL, SUNMATRIX, and
preconditioning modules are compatible with all NVECTOR
implementations.  Details on compatibility are given in the
documentation for each SUNMATRIX (see {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}}) and each
SUNLINSOL module (see {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}). For example, NVECTOR\_PARALLEL
is not compatible with the dense, banded, or sparse SUNMATRIX types,
or with the corresponding dense, banded, or sparse SUNLINSOL modules.
Please check the sections {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} and {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}} to
verify compatibility between these modules.  In addition to that
documentation, we note that the ARKBANDPRE preconditioning module is
only compatible with the NVECTOR\_SERIAL, NVECTOR\_OPENMP or
NVECTOR\_PTHREADS vector implementations, and the preconditioner module
ARKBBDPRE can only be used with NVECTOR\_PARALLEL.

ARKStep uses various input and output constants from the shared ARKode
infrastructure. These are defined as needed in this chapter, but for
convenience the full list is provided separately in the section
{\hyperref[\detokenize{Constants:constants}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: ARKode Constants}}}}.

The relevant information on using ARKStep’s C and C++ interfaces is
detailed in the following sub-sections.


\section{Access to library and header files}
\label{\detokenize{ARKStep_c_interface/General:arkstep-cinterface-headers}}\label{\detokenize{ARKStep_c_interface/General::doc}}\label{\detokenize{ARKStep_c_interface/General:access-to-library-and-header-files}}
At this point, it is assumed that the installation of ARKode,
following the procedure described in the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}},
has been completed successfully.

Regardless of where the user’s application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
ARKode. The relevant library files are
\begin{itemize}
\item {} 
\sphinxcode{libdir/libsundials\_arkode.lib},

\item {} 
\sphinxcode{libdir/libsundials\_nvec*.lib},

\end{itemize}

where the file extension \sphinxcode{.lib} is typically \sphinxcode{.so} for shared
libraries and \sphinxcode{.a} for static libraries.  The relevant header files
are located in the subdirectories
\begin{itemize}
\item {} 
\sphinxcode{incdir/include/arkode}

\item {} 
\sphinxcode{incdir/include/sundials}

\item {} 
\sphinxcode{incdir/include/nvector}

\item {} 
\sphinxcode{incdir/include/sunmatrix}

\item {} 
\sphinxcode{incdir/include/sunlinsol}

\item {} 
\sphinxcode{incdir/include/sunnonlinsol}

\end{itemize}

The directories \sphinxcode{libdir} and \sphinxcode{incdir} are the installation library
and include directories, respectively.  For a default installation,
these are \sphinxcode{instdir/lib} and \sphinxcode{instdir/include}, respectively, where
\sphinxcode{instdir} is the directory where SUNDIALS was installed (see the
section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}} for further details).


\section{Data Types}
\label{\detokenize{ARKStep_c_interface/General:arkstep-cinterface-datatypes}}\label{\detokenize{ARKStep_c_interface/General:data-types}}
The \sphinxcode{sundials\_types.h} file contains the definition of the variable
type \sphinxcode{realtype}, which is used by the SUNDIALS solvers for all
floating-point data, the definition of the integer type
\sphinxcode{sunindextype}, which is used for vector and matrix indices, and
\sphinxcode{booleantype}, which is used for certain logic operations within
SUNDIALS.


\subsection{Floating point types}
\label{\detokenize{ARKStep_c_interface/General:floating-point-types}}
The type “\index{realtype}realtype” can be set to
\sphinxcode{float}, \sphinxcode{double}, or \sphinxcode{long double}, depending on how SUNDIALS
was installed (with the default being \sphinxcode{double}). The user can change
the precision of the SUNDIALS solvers’ floating-point arithmetic at the
configuration stage (see the section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}}).

Additionally, based on the current precision, \sphinxcode{sundials\_types.h}
defines the values \index{BIG\_REAL}BIG\_REAL to be the largest value
representable as a \sphinxcode{realtype}, \index{SMALL\_REAL}SMALL\_REAL to be the
smallest positive value representable as a \sphinxcode{realtype}, and
\index{UNIT\_ROUNDOFF}UNIT\_ROUNDOFF to be the smallest realtype number,
\(\varepsilon\), such that \(1.0 + \varepsilon \ne 1.0\).

Within SUNDIALS, real constants may be set to have the appropriate
precision by way of a macro called \index{RCONST}RCONST.  It is this macro
that needs the ability to branch on the definition \sphinxcode{realtype}.  In
ANSI C, a floating-point constant with no suffix is stored as a
\sphinxcode{double}. Placing the suffix “F” at the end of a floating point
constant makes it a \sphinxcode{float}, whereas using the suffix “L” makes it a
\sphinxcode{long double}. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define A 1.0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define B 1.0F}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define C 1.0L}
\end{sphinxVerbatim}

defines \sphinxcode{A} to be a \sphinxcode{double} constant equal to 1.0, \sphinxcode{B} to be a
\sphinxcode{float} constant equal to 1.0, and \sphinxcode{C} to be a \sphinxcode{long double} constant
equal to 1.0.  The macro call \sphinxcode{RCONST(1.0)} automatically expands to
1.0 if \sphinxcode{realtype} is \sphinxcode{double}, to \sphinxcode{1.0F} if \sphinxcode{realtype} is \sphinxcode{float}, or
to \sphinxcode{1.0L} if \sphinxcode{realtype} is \sphinxcode{long double}. SUNDIALS uses the \sphinxcode{RCONST}
macro internally to declare all of its floating-point constants.

Additionally, SUNDIALS defines several macros for common mathematical
functions \sphinxstyleemphasis{e.g.}\}, \sphinxcode{fabs}, \sphinxcode{sqrt}, \sphinxcode{exp}, etc. in \sphinxcode{sundials\_math.h}. The
macros are prefixed with \sphinxcode{SUNR} and expand to the appropriate C function based
on the \sphinxcode{realtype}. For example, the macro \sphinxcode{SUNRabs} expands to the C
function \sphinxcode{fabs} when \sphinxcode{realtype} is \sphinxcode{double}, \sphinxcode{fabsf} when \sphinxcode{realtype}
is \sphinxcode{float}, and \sphinxcode{fabsl} when \sphinxcode{realtype} is \sphinxcode{long double}.

A user program which uses the type \sphinxcode{realtype}, the \sphinxcode{RCONST} macro, and the
\sphinxcode{SUNR} mathematical function macros is precision-independent except for any
calls to precision-specific library functions. Our example programs use
\sphinxcode{realtype}, \sphinxcode{RCONST}, and the \sphinxcode{SUNR} macros. Users can, however, use the
type \sphinxcode{double}, \sphinxcode{float}, or \sphinxcode{long double} in their code (assuming that this
usage is consistent with the typedef for \sphinxcode{realtype}) and call the appropriate
math library functions directly. Thus, a previously existing piece of ANSI C
code can use SUNDIALS without modifying the code to use \sphinxcode{realtype},
\sphinxcode{RCONST}, or the \sphinxcode{SUNR} macros so long as the SUNDIALS libraries use
the correct precision (for details see {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\subsection{Integer types used for vector and matrix indices}
\label{\detokenize{ARKStep_c_interface/General:integer-types-used-for-vector-and-matrix-indices}}
The type \sphinxcode{sunindextype} can be either a 32- or 64-bit \sphinxstyleemphasis{signed} integer.
The default is the portable \sphinxcode{int64\_t} type, and the user can change it
to \sphinxcode{int32\_t} at the configuration stage. The configuration system
will detect if the compiler does not support portable types, and will
replace \sphinxcode{int32\_t} and \sphinxcode{int64\_t} with \sphinxcode{int}, \sphinxcode{long int}, or
\sphinxcode{long long int} as appropriate, to ensure use of the desired sizes on
Linux, Mac OS X, and Windows platforms. SUNDIALS currently does not support
\sphinxstyleemphasis{unsigned} integer types for vector and matrix indices, although these could
be added in the future if there is sufficient demand.

A user program which uses \sphinxcode{sunindextype} to handle vector and matrix indices
will work with both index storage types except for any calls to index storage-specific
external libraries. (Our \sphinxcode{C} and \sphinxcode{C++} example programs use \sphinxcode{sunindextype}.)
Users can, however, use any one of \sphinxcode{int}, \sphinxcode{long int}, \sphinxcode{int32\_t}, \sphinxcode{int64\_t} or
\sphinxcode{long long int} in their code, assuming that this usage is consistent with the typedef
for \sphinxcode{sunindextype} on their architecture. Thus, a previously existing piece of ANSI
C code can use SUNDIALS without modifying the code to use \sphinxcode{sunindextype},
so long as the SUNDIALS libraries use the appropriate index storage type (for details
see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\section{Header Files}
\label{\detokenize{ARKStep_c_interface/General:header-files}}
When using ARKStep, the calling program must include several header
files so that various macros and data types can be used. The header
file that is always required is:
\begin{itemize}
\item {} 
\sphinxcode{arkode/arkode\_arkstep.h}, the main header file for the ARKStep
time-stepping module, which defines the several types and various
constants, includes function prototypes, and includes the shared
\sphinxcode{arkode/arkode.h} and \sphinxcode{arkode/arkode\_ls.h} header files.

\end{itemize}

Note that \sphinxcode{arkode.h} includes \sphinxcode{sundials\_types.h} directly, which
defines the types \sphinxcode{realtype},  \sphinxcode{sunindextype} and \sphinxcode{booleantype}
and the constants \sphinxcode{SUNFALSE} and \sphinxcode{SUNTRUE}, so a user program does
not need to include \sphinxcode{sundials\_types.h} directly.

Additionally, the calling program must also include a NVECTOR
implementation header file, of the form \sphinxcode{nvector/nvector\_***.h},
corresponding to the user’s preferred data layout and form of
parallelism.  See the section {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}} for details for the
appropriate name.  This file in turn includes the header file
\sphinxcode{sundials\_nvector.h} which defines the abstract \sphinxcode{N\_Vector} data
type.

If the user wishes to manually select between any of the pre-defined
ERK or DIRK Butcher tables, these are defined through a set of constants
that are enumerated in the header files \sphinxcode{arkode/arkode\_butcher\_erk.h}
and \sphinxcode{arkode/arkode\_butcher\_dirk.h}, or if a user wishes to manually
specify one or more Butcher tables, the corresponding \sphinxcode{ARKodeButcherTable}
structure is defined in \sphinxcode{arkode/arkode\_butcher.h}.

If the user includes a non-trivial implicit component to their
ODE system, then each implicit stage will require a nonlinear solver for
the resulting system of algebraic equations \textendash{} the default for this is a
modified or inexact Newton iteration, depending on the user’s choice of
linear solver.  If using a non-default nonlinear solver
module, or when interacting with a SUNNONLINSOL module directly, the
calling program must also include a SUNNONLINSOL header file, of the
form \sphinxcode{sunnonlinsol/sunnonlinsol\_***.h} where \sphinxcode{***} is the name of
the nonlinear solver module (see the section {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for
more information).  This file in turn includes the header file
\sphinxcode{sundials\_nonlinearsolver.h} which defines the abstract
\sphinxcode{SUNNonlinearSolver} data type.

If using a nonlinear solver that requires the solution of a linear
system of the form \(\mathcal{A}x=b\) (e.g., the default Newton
iteration), then a linear solver module header file will also
be required.  Similarly, if the ODE system involves a non-identity
mass matrix \(M \ne I\), then each time step will require a linear
solver for systems of the form \(Mx=b\).  The header files
corresponding to the SUNDIALS-provided linear solver modules available
for use with ARKode are:
\begin{itemize}
\item {} 
Direct linear solvers:
\begin{itemize}
\item {} 
\sphinxcode{sunlinsol/sunlinsol\_dense.h},
which is used with the dense linear solver module,
SUNLINSOL\_DENSE;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_band.h},
which is used with the banded linear solver module,
SUNLINSOL\_BAND;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_lapackdense.h},
which is used with the LAPACK dense linear solver module,
SUNLINSOL\_LAPACKDENSE;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_lapackband.h},
which is used with the LAPACK banded linear solver module,
SUNLINSOL\_LAPACKBAND;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_klu.h},
which is used with the KLU sparse linear solver module,
SUNLINSOL\_KLU;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_superlumt.h},
which is used with the SuperLU\_MT sparse linear solver module,
SUNLINSOL\_SUPERLUMT;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_superludist.h},
which is used with the SuperLU\_DIST parallel sparse linear solver module,
SUNLINSOL\_SUPERLUDIST;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_cusolversp\_batchqr.h},
which is used with the batched sparse QR factorization method provided
by the NVDIA cuSOLVER library, SUNLINSOL\_CUSOLVERSP\_BATCHQR;

\end{itemize}

\item {} 
Iterative linear solvers:
\begin{itemize}
\item {} 
\sphinxcode{sunlinsol/sunlinsol\_spgmr.h},
which is used with the scaled, preconditioned GMRES Krylov linear
solver module, SUNLINSOL\_SPGMR;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_spfgmr.h},
which is used with the scaled, preconditioned FGMRES Krylov linear
solver module, SUNLINSOL\_SPFGMR;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_spbcgs.h},
which is used with the scaled, preconditioned Bi-CGStab Krylov
linear solver module, SUNLINSOL\_SPBCGS;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_sptfqmr.h},
which is used with the scaled, preconditioned TFQMR Krylov linear
solver module, SUNLINSOL\_SPTFQMR;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_pcg.h},
which is used with the scaled, preconditioned CG Krylov linear
solver module, SUNLINSOL\_PCG;

\end{itemize}

\end{itemize}

The header files for the SUNLINSOL\_DENSE and SUNLINSOL\_LAPACKDENSE
linear solver modules include the file
\sphinxcode{sunmatrix/sunmatrix\_dense.h}, which defines the SUNMATRIX\_DENSE
matrix module, as well as various functions and macros for acting on
such matrices.

The header files for the SUNLINSOL\_BAND and SUNLINSOL\_LAPACKBAND
linear solver modules include the file \sphinxcode{sunmatrix/sunmatrix\_band.h},
which defines the SUNMATRIX\_BAND matrix module, as well as various
functions and macros for acting on such matrices.

The header files for the SUNLINSOL\_KLU and SUNLINSOL\_SUPERLUMT linear
solver modules include the file \sphinxcode{sunmatrix/sunmatrix\_sparse.h},
which defines the SUNMATRIX\_SPARSE matrix module, as well as various
functions and macros for acting on such matrices.

The header file for the SUNLINSOL\_CUSOLVERSP\_BATCHQR
linear solver module includes the file \sphinxcode{sunmatrix/sunmatrix\_cusparse.h},
which defines the SUNMATRIX\_CUSPARSE matrix module, as well as various
functions for acting on such matrices.

The header file for the SUNLINSOL\_SUPERLUDIST
linear solver module includes the file \sphinxcode{sunmatrix/sunmatrix\_slunrloc.h},
which defines the SUNMATRIX\_SLUNRLOC matrix module, as well as various
functions for acting on such matrices.

The header files for the Krylov iterative solvers include the file
\sphinxcode{sundials/sundials\_iterative.h}, which enumerates the
preconditioning type and (for the SPGMR and SPFGMR solvers) the
choices for the Gram-Schmidt orthogonalization process.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, if preconditioning for an iterative
linear solver were performed using the ARKBBDPRE module, the header
\sphinxcode{arkode/arkode\_bbdpre.h} is needed to access the preconditioner
initialization routines.


\section{A skeleton of the user’s main program}
\label{\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}}\label{\detokenize{ARKStep_c_interface/Skeleton::doc}}\label{\detokenize{ARKStep_c_interface/Skeleton:a-skeleton-of-the-user-s-main-program}}
The following is a skeleton of the user’s main program (or calling
program) for the integration of an ODE IVP using the ARKStep module.
Most of the steps are independent of the NVECTOR, SUNMATRIX, SUNLINSOL
and SUNNONLINSOL implementations used.  For the steps that are not,
refer to the sections {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}}, {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}},
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}, and  {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for the specific name of
the function to be called or macro to be referenced.

\index{User main program}\ignorespaces \begin{enumerate}
\item {} 
Initialize parallel or multi-threaded environment, if appropriate.

For example, call \sphinxcode{MPI\_Init} to initialize MPI if used, or set
\sphinxcode{num\_threads}, the number of threads to use within the threaded
vector functions, if used.

\item {} 
Set problem dimensions, etc.

This generally includes the problem size, \sphinxcode{N}, and may include
the local vector length \sphinxcode{Nlocal}.

\begin{sphinxadmonition}{note}{Note:}
The variables \sphinxcode{N} and \sphinxcode{Nlocal} should be of type
\sphinxcode{sunindextype}.
\end{sphinxadmonition}

\item {} 
Set vector of initial values

To set the vector \sphinxcode{y0} of initial values, use the appropriate
functions defined by the particular NVECTOR implementation.

For native SUNDIALS vector implementations (except the CUDA and
RAJA based ones), use a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

if the \sphinxcode{realtype} array \sphinxcode{ydata} containing the initial values of
\(y\) already exists.  Otherwise, create a new vector by making
a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNew\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and then set its elements by accessing the underlying data where it
is located with a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

See the sections {\hyperref[\detokenize{nvectors/NVector_Serial:nvectors-nvserial}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_SERIAL Module}}}} through
{\hyperref[\detokenize{nvectors/NVector_Pthreads:nvectors-pthreads}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PTHREADS Module}}}} for details.

For the HYPRE and PETSc vector wrappers, first create and initialize
the underlying vector, and then create the NVECTOR wrapper with a call
of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{yvec}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{yvec} is a HYPRE or PETSc vector.  Note that calls like
\sphinxcode{N\_VNew\_***(...)} and \sphinxcode{N\_VGetArrayPointer\_***(...)} are not
available for these vector wrappers.  See the sections
{\hyperref[\detokenize{nvectors/NVector_ParHyp:nvectors-parhyp}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PARHYP Module}}}} and {\hyperref[\detokenize{nvectors/NVector_PETSc:nvectors-nvpetsc}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PETSC Module}}}} for details.

If using either the CUDA- or RAJA-based vector implementations use
calls to the module-specific routines

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

as applicable.  See the sections
{\hyperref[\detokenize{nvectors/NVector_CUDA:nvectors-cuda}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_CUDA Module}}}} and {\hyperref[\detokenize{nvectors/NVector_RAJA:nvectors-raja}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_RAJA Module}}}} for details.

\item {} 
Create ARKStep object

Call \sphinxcode{arkode\_mem = ARKStepCreate(...)} to create the ARKStep memory
block. {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} returns a \sphinxcode{void*} pointer to
this memory structure. See the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-initialization}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKStep initialization and deallocation functions}}}} for details.

\item {} 
Specify integration tolerances

Call {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSStolerances()}}}} or
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSVtolerances()}}}} to specify either a scalar relative
tolerance and scalar absolute tolerance, or a scalar relative
tolerance and a vector of absolute tolerances,
respectively.  Alternatively, call {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepWFtolerances()}}}}
to specify a function which sets directly the weights used in
evaluating WRMS vector norms. See the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-tolerances}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKStep tolerance specification functions}}}} for details.

If a problem with non-identity mass matrix is used, and the
solution units differ considerably from the equation units,
absolute tolerances for the equation residuals (nonlinear and
linear) may be specified separately through calls to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResStolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResStolerance()}}}}, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResVtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResVtolerance()}}}}, or
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResFtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResFtolerance()}}}}.

\item {} 
Create matrix object

If a nonlinear solver requiring a linear solver will be used (e.g.,
a Newton iteration) and the linear solver will be a matrix-based linear
solver, then a template Jacobian matrix must be created by using the
appropriate functions defined by the particular SUNMATRIX
implementation.

For the SUNDIALS-supplied SUNMATRIX implementations, the
matrix object may be created using a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatrix} \PYG{n}{A} \PYG{o}{=} \PYG{n}{SUNBandMatrix}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatrix} \PYG{n}{A} \PYG{o}{=} \PYG{n}{SUNDenseMatrix}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatrix} \PYG{n}{A} \PYG{o}{=} \PYG{n}{SUNSparseMatrix}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or similarly for the CUDA and SuperLU\_DIST matrix modules (see the
sections {\hyperref[\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_CUSPARSE Module}}}} or {\hyperref[\detokenize{sunmatrix/SUNMatrix_SLUNRloc:sunmatrix-slunrloc}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_SLUNRLOC Module}}}} for
further information).

Similarly, if the problem involves a non-identity mass matrix, and
the mass-matrix linear systems will be solved using a direct linear
solver, then a template mass matrix must be created by using the
appropriate functions defined by the particular SUNMATRIX
implementation.

NOTE: The dense, banded, and sparse matrix objects are usable only in a
serial or threaded environment.

\item {} 
Create linear solver object

If a nonlinear solver requiring a linear solver will be used (e.g.,
a Newton iteration), or if the problem involves a non-identity mass
matrix, then the desired linear solver object(s) must be created by
using the appropriate functions defined by the particular SUNLINSOL
implementation.

For any of the SUNDIALS-supplied SUNLINSOL implementations, the
linear solver object may be created using a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNLinearSolver} \PYG{n}{LS} \PYG{o}{=} \PYG{n}{SUNLinSol\PYGZus{}}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{*} can be replaced with “Dense”, “SPGMR”, or other
options, as discussed in the sections
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface functions}}}} and {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

\item {} 
Set linear solver optional inputs

Call \sphinxcode{*Set*} functions from the selected linear solver module
to change optional inputs specific to that linear solver.  See the
documentation for each SUNLINSOL module in the section
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}} for details.

\item {} 
Attach linear solver module

If a linear solver was created above for implicit stage solves,
initialize the ARKLS linear solver interface by attaching the
linear solver object (and Jacobian matrix object, if applicable)
with the call (for details see the section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface functions}}}}):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKStepSetLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Similarly, if the problem involves a non-identity mass matrix,
initialize the ARKLS mass matrix linear solver interface by
attaching the mass linear solver object (and mass matrix object,
if applicable) with the call (for details see the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface functions}}}}):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKStepSetMassLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Create nonlinear solver object

If the problem involves an implicit component, and if a non-default
nonlinear solver object will be used for implicit stage solves
(see the section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}}),
then the desired nonlinear solver object must be created by using
the appropriate functions defined by the particular SUNNONLINSOL
implementation (e.g., \sphinxcode{NLS = SUNNonlinSol\_***(...);} where
\sphinxcode{***} is the name of the nonlinear solver (see the section
{\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for details).

For the SUNDIALS-supplied SUNNONLINSOL implementations, the
nonlinear solver object may be created using a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNNonlinearSolver} \PYG{n}{NLS} \PYG{o}{=} \PYG{n}{SUNNonlinSol\PYGZus{}}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{*} can be replaced with “Newton”, “FixedPoint”, or other
options, as discussed in the sections
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}} and {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}}.

\item {} 
Attach nonlinear solver module

If a nonlinear solver object was created above, then it must be
attached to ARKStep using the call (for details see the
section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}}):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKStepSetNonlinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Set nonlinear solver optional inputs

Call the appropriate set functions for the selected nonlinear
solver module to change optional inputs specific to that nonlinear
solver.  These \sphinxstyleemphasis{must} be called after attaching the nonlinear
solver to ARKStep, otherwise the optional inputs will be
overridden by ARKStep defaults.  See the section
{\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for more information on optional inputs.

\item {} 
Set optional inputs

Call \sphinxcode{ARKStepSet*} functions to change any optional inputs that
control the behavior of ARKStep from their default values. See the
section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details.

\item {} 
Specify rootfinding problem

Optionally, call {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}} to initialize a rootfinding
problem to be solved during the integration of the ODE system. See
the section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding initialization function}}}} for general details, and
the section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for relevant optional
input calls.

\item {} 
Advance solution in time

For each point at which output is desired, call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKStepEvolve}\PYG{p}{(}\PYG{n}{arkode\PYGZus{}mem}\PYG{p}{,} \PYG{n}{tout}\PYG{p}{,} \PYG{n}{yout}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tret}\PYG{p}{,} \PYG{n}{itask}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{itask} specifies the return mode. The vector \sphinxcode{yout}
(which can be the same as the vector \sphinxcode{y0} above) will contain
\(y(t_\text{out})\). See the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKStep solver function}}}} for details.

\item {} 
Get optional outputs

Call \sphinxcode{ARKStepGet*} functions to obtain optional output. See
the section {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}} for details.

\item {} 
Deallocate memory for solution vector

Upon completion of the integration, deallocate memory for the
vector \sphinxcode{y} (or \sphinxcode{yout}) by calling the destructor function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDestroy}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Free solver memory

Call \sphinxcode{ARKStepFree(\&arkode\_mem)} to free the memory allocated for
the ARKStep module (and any nonlinear solver module).

\item {} 
Free linear solver and matrix memory

Call {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolFree}]{\sphinxcrossref{\sphinxcode{SUNLinSolFree()}}}} and (possibly)
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatDestroy}]{\sphinxcrossref{\sphinxcode{SUNMatDestroy()}}}} to free any memory allocated for the
linear solver and matrix objects created above.

\item {} 
Free nonlinear solver memory

If a user-supplied \sphinxcode{SUNNonlinearSolver} was provided to ARKStep,
then call {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolFree}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolFree()}}}} to free any memory allocated
for the nonlinear solver object created above.

\item {} 
Finalize MPI, if used

Call \sphinxcode{MPI\_Finalize} to terminate MPI.

\end{enumerate}

SUNDIALS provides some linear solvers only as a means for users to get
problems running and not as highly efficient solvers.  For example, if
solving a dense system, we suggest using the LAPACK solvers if the
size of the linear system is \(> 50,000\) (thanks to A. Nicolai
for his testing and recommendation).  The table below shows the
linear solver interfaces available as \sphinxcode{SUNLinearSolver} modules and
the vector implementations required for use.  As an example, one
cannot use the dense direct solver interfaces with the MPI-based
vector implementation.  However, as discussed in section
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}} the SUNDIALS packages operate on generic
\sphinxcode{SUNLinearSolver} objects, allowing a user to develop their own
solvers should they so desire.


\subsection{SUNDIALS linear solver interfaces and vector implementations that can be used for each}
\label{\detokenize{ARKStep_c_interface/Skeleton:sundials-linear-solver-interfaces-and-vector-implementations-that-can-be-used-for-each}}\label{\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-solver-vector}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Linear Solver
Interface
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Serial
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Parallel
(MPI)
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
OpenMP
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
pThreads
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{hypre}
Vec.
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
PETSc
Vec.
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CUDA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
RAJA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
User
Suppl.
\unskip}\relax \\
\hline
Dense
&
X
&&
X
&
X
&&&&&
X
\\
\hline
Band
&
X
&&
X
&
X
&&&&&
X
\\
\hline
LapackDense
&
X
&&
X
&
X
&&&&&
X
\\
\hline
LapackBand
&
X
&&
X
&
X
&&&&&
X
\\
\hline
KLU
&
X
&&
X
&
X
&&&&&
X
\\
\hline
SuperLU\_DIST
&
X
&
X
&
X
&
X
&
X
&
X
&&&
X
\\
\hline
SuperLU\_MT
&
X
&&
X
&
X
&&&&&
X
\\
\hline
SPGMR
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
SPFGMR
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
SPBCGS
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
SPTFQMR
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
PCG
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
User supplied
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{ARKStep User-callable functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-user-callable-functions}}\label{\detokenize{ARKStep_c_interface/User_callable::doc}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-usercallable}}
This section describes the functions that are called by the user to
setup and then solve an IVP using the ARKStep time-stepping
module. Some of these are required; however, starting with the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs may be
skipped for a casual use of ARKode’s ARKStep module. In any case,
refer to the preceding section, {\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}},
for the correct order of these calls.

On an error, each user-callable function returns a negative value (or
\sphinxcode{NULL} if the function returns a pointer) and sends an error message
to the error handler routine, which prints the message to \sphinxcode{stderr}
by default. However, the user can set a file as error output or can
provide her own error handler function (see the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details).


\subsection{ARKStep initialization and deallocation functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-initialization}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-initialization-and-deallocation-functions}}\index{ARKStepCreate (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}}\pysiglinewithargsret{void* \sphinxbfcode{ARKStepCreate}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ fe}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ fi}, realtype\sphinxstyleemphasis{ t0}, N\_Vector\sphinxstyleemphasis{ y0}}{}
This function creates an internal memory block for a problem to be
solved using the ARKStep time-stepping module in ARKode.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{fe} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the explicit portion of the right-hand side function in
\(M\, \dot{y} = f^E(t,y) + f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{fi} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the implicit portion of the right-hand side function in
\(M\, \dot{y} = f^E(t,y) + f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the initial value of \(t\).

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the initial condition vector \(y(t_0)\).

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  If successful, a pointer to initialized problem memory
of type \sphinxcode{void*}, to be passed to all user-facing ARKStep routines
listed below.  If unsuccessful, a \sphinxcode{NULL} pointer will be
returned, and an error message will be printed to \sphinxcode{stderr}.

\end{fulllineitems}

\index{ARKStepFree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepFree}}\pysiglinewithargsret{void \sphinxbfcode{ARKStepFree}}{void**\sphinxstyleemphasis{ arkode\_mem}}{}
This function frees the problem memory \sphinxstyleemphasis{arkode\_mem} created by
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  None

\end{fulllineitems}



\subsection{ARKStep tolerance specification functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-tolerances}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-tolerance-specification-functions}}
These functions specify the integration tolerances. One of them
\sphinxstylestrong{should} be called before the first call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}; otherwise default values of \sphinxcode{reltol =
1e-4} and \sphinxcode{abstol = 1e-9} will be used, which may be entirely
incorrect for a specific problem.

The integration tolerances \sphinxcode{reltol} and \sphinxcode{abstol} define a vector
of error weights, \sphinxcode{ewt}.  In the case of
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSStolerances()}}}}, this vector has components

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

whereas in the case of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSVtolerances()}}}} the vector components
are given by

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This vector is used in all error and convergence tests, which use a
weighted RMS norm on all error-like vectors \(v\):
\begin{equation*}
\begin{split}\|v\|_{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N (v_i\; ewt_i)^2 \right)^{1/2},\end{split}
\end{equation*}
where \(N\) is the problem dimension.

Alternatively, the user may supply a custom function to supply the
\sphinxcode{ewt} vector, through a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepWFtolerances()}}}}.
\index{ARKStepSStolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSStolerances}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSStolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ reltol}, realtype\sphinxstyleemphasis{ abstol}}{}
This function specifies scalar relative and absolute tolerances.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{reltol} \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{abstol} \textendash{} scalar absolute tolerance.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ARKStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepSVtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSVtolerances}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSVtolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ reltol}, N\_Vector\sphinxstyleemphasis{ abstol}}{}
This function specifies a scalar relative tolerance and a vector
absolute tolerance (a potentially different absolute tolerance for
each vector component).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{reltol} \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{abstol} \textendash{} vector containing the absolute tolerances for each
solution component.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ARKStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepWFtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWFtolerances}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepWFtolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{ARKEwtFn}}}\sphinxstyleemphasis{ efun}}{}
This function specifies a user-supplied function \sphinxstyleemphasis{efun} to compute
the error weight vector \sphinxcode{ewt}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{efun} \textendash{} the name of the function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn()}}}})
that implements the error weight vector computation.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ARKStep memory was not allocated by the time-stepping module

\end{itemize}

\end{description}

\end{fulllineitems}


Moreover, for problems involving a non-identity mass matrix
\(M \ne I\), the units of the solution vector \(y\) may differ
from the units of the IVP, posed for the vector \(My\).  When this
occurs, iterative solvers for the Newton linear systems and the mass
matrix linear systems may require a different set of tolerances.
Since the relative tolerance is dimensionless, but the absolute
tolerance encodes a measure of what is “small” in the units of the
respective quantity, a user may optionally define absolute tolerances
in the equation units.  In this case, ARKStep defines a vector of residual
weights, \sphinxcode{rwt} for measuring convergence of these iterative solvers.
In the case of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResStolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResStolerance()}}}}, this vector has components

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rwt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{My}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rabstol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

whereas in the case of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResVtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResVtolerance()}}}} the vector components
are given by

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rwt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{My}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rabstol}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This residual weight vector is used in all iterative solver
convergence tests, which similarly use a weighted RMS norm on all
residual-like vectors \(v\):
\begin{equation*}
\begin{split}\|v\|_{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N (v_i\; rwt_i)^2 \right)^{1/2},\end{split}
\end{equation*}
where \(N\) is the problem dimension.

As with the error weight vector, the user may supply a custom function
to supply the \sphinxcode{rwt} vector, through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResFtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResFtolerance()}}}}.  Further information on all three of
these functions is provided below.
\index{ARKStepResStolerance (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResStolerance}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepResStolerance}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ abstol}}{}
This function specifies a scalar absolute residual tolerance.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rabstol} \textendash{} scalar absolute residual tolerance.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ARKStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepResVtolerance (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResVtolerance}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepResVtolerance}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ rabstol}}{}
This function specifies a vector of absolute residual tolerances.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rabstol} \textendash{} vector containing the absolute residual
tolerances for each solution component.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ARKStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepResFtolerance (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResFtolerance}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepResFtolerance}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKRwtFn}]{\sphinxcrossref{ARKRwtFn}}}\sphinxstyleemphasis{ rfun}}{}
This function specifies a user-supplied function \sphinxstyleemphasis{rfun} to compute
the residual weight vector \sphinxcode{rwt}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rfun} \textendash{} the name of the function (of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKRwtFn}]{\sphinxcrossref{\sphinxcode{ARKRwtFn()}}}})
that implements the residual weight vector computation.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ARKStep memory was not allocated by the time-stepping module

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{General advice on the choice of tolerances}
\label{\detokenize{ARKStep_c_interface/User_callable:general-advice-on-the-choice-of-tolerances}}
For many users, the appropriate choices for tolerance values in
\sphinxcode{reltol}, \sphinxcode{abstol}, and \sphinxcode{rabstol} are a concern. The following pieces
of advice are relevant.
\begin{enumerate}
\item {} 
The scalar relative tolerance \sphinxcode{reltol} is to be set to control
relative errors. So a value of \(10^{-4}\) means that errors
are controlled to .01\%. We do not recommend using \sphinxcode{reltol} larger
than \(10^{-3}\). On the other hand, \sphinxcode{reltol} should not be so
small that it is comparable to the unit roundoff of the machine
arithmetic (generally around \(10^{-15}\) for double-precision).

\item {} 
The absolute tolerances \sphinxcode{abstol} (whether scalar or vector) need
to be set to control absolute errors when any components of the
solution vector \(y\) may be so small that pure relative error
control is meaningless.  For example, if \(y_i\) starts at some
nonzero value, but in time decays to zero, then pure relative
error control on \(y_i\) makes no sense (and is overly costly)
after \(y_i\) is below some noise level. Then \sphinxcode{abstol} (if
scalar) or \sphinxcode{abstol{[}i{]}} (if a vector) needs to be set to that
noise level. If the different components have different noise
levels, then \sphinxcode{abstol} should be a vector.  For example, see the
example problem \sphinxcode{ark\_robertson.c}, and the discussion
of it in the ARKode Examples Documentation \phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:id1}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}}.  In that
problem, the three components vary between 0 and 1, and have
different noise levels; hence the \sphinxcode{atols} vector therein. It is
impossible to give any general advice on \sphinxcode{abstol} values,
because the appropriate noise levels are completely
problem-dependent. The user or modeler hopefully has some idea as
to what those noise levels are.

\item {} 
The residual absolute tolerances \sphinxcode{rabstol} (whether scalar or
vector) follow a similar explanation as for \sphinxcode{abstol}, except
that these should be set to the noise level of the equation
components, i.e. the noise level of \(My\).  For problems in
which \(M=I\), it is recommended that \sphinxcode{rabstol} be left
unset, which will default to the already-supplied \sphinxcode{abstol}
values.

\item {} 
Finally, it is important to pick all the tolerance values
conservatively, because they control the error committed on each
individual step. The final (global) errors are an accumulation of
those per-step errors, where that accumulation factor is
problem-dependent.  A general rule of thumb is to reduce the
tolerances by a factor of 10 from the actual desired limits on
errors.  So if you want .01\% relative accuracy (globally), a good
choice for \sphinxcode{reltol} is \(10^{-5}\).  In any case, it is
a good idea to do a few experiments with the tolerances to see how
the computed solution values vary as tolerances are reduced.

\end{enumerate}


\subsubsection{Advice on controlling nonphysical negative values}
\label{\detokenize{ARKStep_c_interface/User_callable:advice-on-controlling-nonphysical-negative-values}}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the
numerical solution, however, small negative (nonphysical) values
can then occur. In most cases, these values are harmless, and simply
need to be controlled, not eliminated, but in other cases any value
that violates a constraint may cause a simulation to halt. For both of
these scenarios the following pieces of advice are relevant.
\begin{enumerate}
\item {} 
The best way to control the size of unwanted negative computed
values is with tighter absolute tolerances.  Again this requires
some knowledge of the noise level of these components, which may
or may not be different for different components. Some
experimentation may be needed.

\item {} 
If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of
avoiding a long explanation of them, if nothing else), then
eliminate them, but only in the context of the output medium. Then
the internal values carried by the solver are unaffected. Remember
that a small negative value in \(y\) returned by ARKStep, with
magnitude comparable to \sphinxcode{abstol} or less, is equivalent to zero
as far as the computation is concerned.

\item {} 
The user’s right-hand side routines \(f^E\) and \(f^I\)
should never change a negative value in the solution vector \(y\)
to a non-negative value in attempt to “fix” this problem,
since this can lead to numerical instability.  If the \(f^E\)
or \(f^I\) routines cannot tolerate a zero or negative value
(e.g. because there is a square root or log), then the offending
value should be changed to zero or a tiny positive number in a
temporary variable (not in the input \(y\) vector) for the
purposes of computing \(f^E(t, y)\) or \(f^I(t, y)\).

\item {} 
Positivity and non-negativity constraints on components can be
enforced by use of the recoverable error return feature in the
user-supplied right-hand side functions, \(f^E\) and
\(f^I\). When a recoverable error is encountered, ARKStep will
retry the step with a smaller step size, which typically
alleviates the problem.  However, because this option involves
some additional overhead cost, it should only be exercised if the
use of absolute tolerances to control the computed values is
unsuccessful.

\end{enumerate}


\subsection{Linear solver interface functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-linearsolvers}}\label{\detokenize{ARKStep_c_interface/User_callable:linear-solver-interface-functions}}
As previously explained, the Newton iterations used in solving
implicit systems within ARKStep require the solution of linear
systems of the form
\begin{equation*}
\begin{split}{\mathcal A}\left(z_i^{(m)}\right) \delta^{(m+1)} = -G\left(z_i^{(m)}\right)\end{split}
\end{equation*}
where
\begin{equation*}
\begin{split}{\mathcal A} \approx M - \gamma J, \qquad J = \frac{\partial f^I}{\partial y}.\end{split}
\end{equation*}
ARKode’s ARKLS linear solver interface supports all valid
\sphinxcode{SUNLinearSolver} modules for this task.

Matrix-based \sphinxcode{SUNLinearSolver} modules utilize \sphinxcode{SUNMatrix} objects
to store the approximate Jacobian matrix \(J\), the Newton matrix
\({\mathcal A}\), the mass matrix \(M\), and, when using direct
solvers, the factorizations used throughout the solution process.

Matrix-free \sphinxcode{SUNLinearSolver} modules instead use iterative methods
to solve the Newton systems of equations, and only require the
\sphinxstyleemphasis{action} of the matrix on a vector, \({\mathcal A}v\).  With most
of these methods, preconditioning can be done on the left only, on the
right only, on both the left and the right, or not at all.  The
exceptions to this rule are SPFGMR that supports right preconditioning
only and PCG that performs symmetric preconditioning.  For the
specification of a preconditioner, see the iterative linear solver
portions of the sections {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

If preconditioning is done, user-supplied functions should be used to
define left and right preconditioner matrices \(P_1\) and
\(P_2\) (either of which could be the identity matrix), such that
the product \(P_{1}P_{2}\) approximates the Newton matrix
\({\mathcal A} = M - \gamma J\).

To specify a generic linear solver for ARKStep to use for the Newton
systems, after the call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} but before any
calls to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, the user’s program must create the
appropriate \sphinxcode{SUNLinearSolver} object and call the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}, as documented below.  To create
the \sphinxcode{SUNLinearSolver} object, the user may call one of the
SUNDIALS-packaged SUNLinSol module constructor routines via a call of
the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNLinearSolver} \PYG{n}{LS} \PYG{o}{=} \PYG{n}{SUNLinSol\PYGZus{}}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The current list of such constructor routines includes
{\hyperref[\detokenize{sunlinsol/SUNLinSol_Dense:c.SUNLinSol_Dense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Dense()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_Band:c.SUNLinSol_Band}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Band()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackDense:c.SUNLinSol_LapackDense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackDense()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackBand:c.SUNLinSol_LapackBand}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackBand()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLU}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLU()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMT}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMT()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUDIST()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_cuSolverSp:c.SUNLinSol_cuSolverSp_batchQR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_cuSolverSp\_batchQR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGS()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMR()}}}}, and
{\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCG()}}}}.

Alternately, a user-supplied
\sphinxcode{SUNLinearSolver} module may be created and used instead.  The use
of each of the generic linear solvers involves certain constants,
functions and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific \sphinxcode{SUNMatrix} or \sphinxcode{SUNLinearSolver}
module in question, as described in the sections {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} and
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

Once this solver object has been constructed, the user should attach
it to ARKStep via a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}. The
first argument passed to this function is the ARKStep memory pointer
returned by {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}; the second argument is the
\sphinxcode{SUNLinearSolver} object created above.  The third argument is an
optional \sphinxcode{SUNMatrix} object to accompany matrix-based
\sphinxcode{SUNLinearSolver} inputs (for matrix-free linear solvers, the third
argument should be \sphinxcode{NULL}).  A call to this function initializes the
ARKLS linear solver interface, linking it to the ARKStep integrator,
and allows the user to specify additional parameters and routines
pertinent to their choice of linear solver.
\index{ARKStepSetLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetLinearSolver}}{void*\sphinxstyleemphasis{ arkode\_mem}, SUNLinearSolver\sphinxstyleemphasis{ LS}, SUNMatrix\sphinxstyleemphasis{ J}}{}
This function specifies the \sphinxcode{SUNLinearSolver} object that ARKStep
should use, as well as a template Jacobian \sphinxcode{SUNMatrix} object (if
applicable).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{LS} \textendash{} the \sphinxcode{SUNLinearSolver} object to use.

\item {} 
\sphinxstyleemphasis{J} \textendash{} the template Jacobian \sphinxcode{SUNMatrix} object to use (or
\sphinxcode{NULL} if not applicable).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}   if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if ARKLS is incompatible with the
provided \sphinxstyleemphasis{LS} or \sphinxstyleemphasis{J} input objects, or the current
\sphinxcode{N\_Vector} module.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  If \sphinxstyleemphasis{LS} is a matrix-free linear solver, then the \sphinxstyleemphasis{J}
argument should be \sphinxcode{NULL}.

If \sphinxstyleemphasis{LS} is a matrix-based linear solver, then the template Jacobian
matrix \sphinxstyleemphasis{J} will be used in the solve process, so if additional
storage is required within the \sphinxcode{SUNMatrix} object (e.g. for
factorization of a banded matrix), ensure that the input object is
allocated with sufficient size (see the documentation of
the particular SUNMATRIX type in the section {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} for
further information).

When using sparse linear solvers, it is typically much more
efficient to supply \sphinxstyleemphasis{J} so that it includes the full sparsity
pattern of the Newton system matrices \({\mathcal A} =
I-\gamma J\) (or \({\mathcal A} = M-\gamma J\) in the case of
non-identity mass matrix), even if \sphinxstyleemphasis{J} itself has zeros in nonzero
locations of \(I\) (or \(M\)).  The reasoning for this is
that \({\mathcal A}\) is constructed in-place, on top of the
user-specified values of \sphinxstyleemphasis{J}, so if the sparsity pattern in \sphinxstyleemphasis{J} is
insufficient to store \({\mathcal A}\) then it will need to be
resized internally by ARKStep.

\end{fulllineitems}



\subsection{Mass matrix solver specification functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-massmatrixsolvers}}\label{\detokenize{ARKStep_c_interface/User_callable:mass-matrix-solver-specification-functions}}
As discussed in section {\hyperref[\detokenize{Mathematics:mathematics-masssolve}]{\sphinxcrossref{\DUrole{std,std-ref}{Mass matrix solver (ARKStep only)}}}}, if the ODE
system involves a non-identity mass matrix \(M\ne I\), then ARKStep
must solve linear systems of the form
\begin{equation*}
\begin{split}M x = b.\end{split}
\end{equation*}
ARKode’s ARKLS mass-matrix linear solver interface supports all valid
\sphinxcode{SUNLinearSolver} modules for this task.  For iterative linear
solvers, user-supplied preconditioning can be applied.  For the
specification of a preconditioner, see the iterative linear solver
portions of the sections {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.  If preconditioning is to be
performed, user-supplied functions should be used to define left and
right preconditioner matrices \(P_1\) and \(P_2\) (either of
which could be the identity matrix), such that the product
\(P_{1}P_{2}\) approximates the mass matrix \(M\).

To specify a generic linear solver for ARKStep to use for mass matrix
systems, after the call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} but before any
calls to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, the user’s program must create the
appropriate \sphinxcode{SUNLinearSolver} object and call the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}, as documented below.  The
first argument passed to this functions is the ARKStep memory
pointer returned by {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}; the second argument is
the desired \sphinxcode{SUNLinearSolver} object to use for solving mass matrix
systems.  The third object is a template \sphinxcode{SUNMatrix} to use with the
provided \sphinxcode{SUNLinearSolver} (if applicable).  The fourth input is a
flag to indicate whether the mass matrix is time-dependent,
i.e. \(M = M(t)\) or not.  A call to this function initializes the
ARKLS mass matrix linear solver interface, linking this to the main
ARKStep integrator, and allows the user to specify additional
parameters and routines pertinent to their choice of linear solver.

The use of each of the generic linear solvers involves certain
constants and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific \sphinxcode{SUNMatrix} or
\sphinxcode{SUNLinearSolver} module in question, as described in the
sections {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} and {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

Note: if the user program includes linear solvers for \sphinxstyleemphasis{both} the
Newton and mass matrix systems, these must have the same type:
\begin{itemize}
\item {} 
If both are matrix-based, then they must utilize the same
\sphinxcode{SUNMatrix} type, since these will be added when forming the
Newton system matrices \({\mathcal A}\).  In this case, both the
Newton and mass matrix linear solver interfaces can use the same
\sphinxcode{SUNLinearSolver} object, although different solver objects
(e.g. with different solver parameters) are also allowed.

\item {} 
If both are matrix-free, then the Newton and mass matrix
\sphinxcode{SUNLinearSolver} objects must be different.  These may even use
different solver algorithms (SPGMR, SPBCGS, etc.), if desired.
For example, if the mass matrix is symmetric but the Jacobian is not,
then PCG may be used for the mass matrix systems and SPGMR for the
Newton systems.

\end{itemize}

As with the Newton system solvers, the mass matrix linear system
solvers listed below are all built on top of generic SUNDIALS solver
modules.
\index{ARKStepSetMassLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMassLinearSolver}}{void*\sphinxstyleemphasis{ arkode\_mem}, SUNLinearSolver\sphinxstyleemphasis{ LS}, SUNMatrix\sphinxstyleemphasis{ M}, booleantype\sphinxstyleemphasis{ time\_dep}}{}
This function specifies the \sphinxcode{SUNLinearSolver} object
that ARKStep should use for mass matrix systems, as well as a
template \sphinxcode{SUNMatrix} object.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{LS} \textendash{} the \sphinxcode{SUNLinearSolver} object to use.

\item {} 
\sphinxstyleemphasis{M} \textendash{} the template mass \sphinxcode{SUNMatrix} object to use.

\item {} 
\sphinxstyleemphasis{time\_dep} \textendash{} flag denoting whether the mass matrix depends on
the independent variable (\(M = M(t)\)) or not (\(M
\ne M(t)\)).  \sphinxcode{SUNTRUE} indicates time-dependence of the
mass matrix.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}   if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if ARKLS is incompatible with the
provided \sphinxstyleemphasis{LS} or \sphinxstyleemphasis{M} input objects, or the current
\sphinxcode{N\_Vector} module.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  If \sphinxstyleemphasis{LS} is a matrix-free linear solver, then the \sphinxstyleemphasis{M}
argument should be \sphinxcode{NULL}.

If \sphinxstyleemphasis{LS} is a matrix-based linear solver, then the template mass
matrix \sphinxstyleemphasis{M} will be used in the solve process, so if additional
storage is required within the \sphinxcode{SUNMatrix} object (e.g. for
factorization of a banded matrix), ensure that the input object is
allocated with sufficient size.

If called with \sphinxstyleemphasis{time\_dep} set to \sphinxcode{SUNFALSE}, then the mass matrix is
only computed and factored once (or when either {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}
or :c:func{}`ARKStepResize(){}` are called), with the results reused
throughout the entire ARKStep simulation.

Unlike the system Jacobian, the system mass matrix is not approximated
using finite-differences of any functions provided to ARKStep.  Hence,
use of the a matrix-based \sphinxstyleemphasis{LS} requires the user to provide a
mass-matrix constructor routine (see {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}}).

Similarly, the system mass matrix-vector-product is not approximated
using finite-differences of any functions provided to ARKStep.  Hence,
use of a matrix-free \sphinxstyleemphasis{LS} requires the user to provide a
mass-matrix-times-vector product routine (see
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesVecFn}}}} and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}}).

\end{fulllineitems}



\subsection{Nonlinear solver interface functions}
\label{\detokenize{ARKStep_c_interface/User_callable:nonlinear-solver-interface-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-nonlinearsolvers}}
When changing the nonlinear solver in ARKStep, after the
call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} but before any calls to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, the user’s program must create the
appropriate SUNNonlinSol object and call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinearSolver()}}}}, as documented below.  If any
calls to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} have been made, then ARKStep will
need to be reinitialized by calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} to
ensure that the nonlinear solver is initialized correctly before any
subsequent calls to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}.

The first argument passed to the routine
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinearSolver()}}}} is the ARKStep memory pointer
returned by {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}; the second argument passed
to this function is the desired SUNNonlinSol object to use for solving
the nonlinear system for each implicit stage. A call to this function
attaches the nonlinear solver to the main ARKStep integrator.
\index{ARKStepSetNonlinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinearSolver}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetNonlinearSolver}}{void*\sphinxstyleemphasis{ arkode\_mem}, SUNNonlinearSolver\sphinxstyleemphasis{ NLS}}{}
This function specifies the \sphinxcode{SUNNonlinearSolver} object
that ARKStep should use for implicit stage solves.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{NLS} \textendash{} the \sphinxcode{SUNNonlinearSolver} object to use.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS}   if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if ARKStep is incompatible with the
provided \sphinxstyleemphasis{NLS} input object.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  ARKStep will use the Newton SUNNonlinSol module by
default; a call to this routine replaces that module with the
supplied \sphinxstyleemphasis{NLS} object.

\end{fulllineitems}



\subsection{Rootfinding initialization function}
\label{\detokenize{ARKStep_c_interface/User_callable:rootfinding-initialization-function}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-rootfinding}}
As described in the section {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding}}}}, while
solving the IVP, ARKode’s time-stepping modules have the capability to
find the roots of a set of user-defined functions.  To activate the
root-finding algorithm, call the following function.  This is normally
called only once, prior to the first call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, but if the rootfinding problem is to be
changed during the solution, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}} can also be
called prior to a continuation call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}.
\index{ARKStepRootInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepRootInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ nrtfn}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{ARKRootFn}}}\sphinxstyleemphasis{ g}}{}
Initializes a rootfinding problem to be solved during the
integration of the ODE system.  It must be called after
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}, and before {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nrtfn} \textendash{} number of functions \(g_i\), an integer \(\ge\) 0.

\item {} 
\sphinxstyleemphasis{g} \textendash{} name of user-supplied function, of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{\sphinxcode{ARKRootFn()}}}},
defining the functions \(g_i\) whose roots are sought.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if \sphinxstyleemphasis{nrtfn} is greater than zero but \sphinxstyleemphasis{g} = \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} To disable the rootfinding feature after it has already
been initialized, or to free memory associated with ARKStep’s
rootfinding module, call \sphinxstyleemphasis{ARKStepRootInit} with \sphinxstyleemphasis{nrtfn = 0}.

Similarly, if a new IVP is to be solved with a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}, where the new IVP has no rootfinding
problem but the prior one did, then call \sphinxstyleemphasis{ARKStepRootInit} with
\sphinxstyleemphasis{nrtfn = 0}.

\end{fulllineitems}



\subsection{ARKStep solver function}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-solver-function}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-integration}}
This is the central step in the solution process \textendash{} the call to perform
the integration of the IVP.  The input argument \sphinxstyleemphasis{itask} specifies one of two
modes as to where ARKStep is to return a solution.  These modes are modified if
the user has set a stop time (with a call to the optional input function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ARKStepSetStopTime()}}}}) or has requested rootfinding.
\index{ARKStepEvolve (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepEvolve}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tout}, N\_Vector\sphinxstyleemphasis{ yout}, realtype\sphinxstyleemphasis{ *tret}, int\sphinxstyleemphasis{ itask}}{}
Integrates the ODE over an interval in \(t\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{tout} \textendash{} the next time at which a computed solution is desired.

\item {} 
\sphinxstyleemphasis{yout} \textendash{} the computed solution vector.

\item {} 
\sphinxstyleemphasis{tret} \textendash{} the time corresponding to \sphinxstyleemphasis{yout} (output).

\item {} 
\sphinxstyleemphasis{itask} \textendash{} a flag indicating the job of the solver for the next
user step.

The \sphinxstyleemphasis{ARK\_NORMAL} option causes the solver to take internal
steps until it has just overtaken a user-specified output
time, \sphinxstyleemphasis{tout}, in the direction of integration,
i.e. \(t_{n-1} <\) \sphinxstyleemphasis{tout} \(\le t_{n}\) for forward
integration, or \(t_{n} \le\) \sphinxstyleemphasis{tout} \(< t_{n-1}\) for
backward integration.  It will then compute an approximation
to the solution \(y(tout)\) by interpolation (using one
of the dense output routines described in the section
{\hyperref[\detokenize{Mathematics:mathematics-interpolation}]{\sphinxcrossref{\DUrole{std,std-ref}{Interpolation}}}}).

The \sphinxstyleemphasis{ARK\_ONE\_STEP} option tells the solver to only take a
single internal step \(y_{n-1} \to y_{n}\) and then return
control back to the calling program.  If this step will
overtake \sphinxstyleemphasis{tout} then the solver will again return an
interpolated result; otherwise it will return a copy of the
internal solution \(y_{n}\) in the vector \sphinxstyleemphasis{yout}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_ROOT\_RETURN} if {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} succeeded, and
found one or more roots.  If the number of root functions,
\sphinxstyleemphasis{nrtfn}, is greater than 1, call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{ARKStepGetRootInfo()}}}} to see which \(g_i\) were
found to have a root at (\sphinxstyleemphasis{*tret}).

\item {} 
\sphinxstyleemphasis{ARK\_TSTOP\_RETURN} if {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} succeeded and
returned at \sphinxstyleemphasis{tstop}.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the \sphinxstyleemphasis{arkode\_mem} argument was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC} if \sphinxstyleemphasis{arkode\_mem} was not allocated.

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if one of the inputs to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} is illegal, or some other input to
the solver was either illegal or missing.  Details will be
provided in the error message.  Typical causes of this failure:
\begin{enumerate}
\item {} 
A component of the error weight vector became zero during
internal time-stepping.

\item {} 
The linear solver initialization function (called by the
user after calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}) failed to set
the linear solver-specific \sphinxstyleemphasis{lsolve} field in
\sphinxstyleemphasis{arkode\_mem}.

\item {} 
A root of one of the root functions was found both at a
point \(t\) and also very near \(t\).

\item {} 
The initial condition violates the inequality constraints.

\end{enumerate}

\item {} 
\sphinxstyleemphasis{ARK\_TOO\_MUCH\_WORK} if the solver took \sphinxstyleemphasis{mxstep} internal steps
but could not reach \sphinxstyleemphasis{tout}.  The default value for \sphinxstyleemphasis{mxstep} is
\sphinxstyleemphasis{MXSTEP\_DEFAULT = 500}.

\item {} 
\sphinxstyleemphasis{ARK\_TOO\_MUCH\_ACC} if the solver could not satisfy the accuracy
demanded by the user for some internal step.

\item {} 
\sphinxstyleemphasis{ARK\_ERR\_FAILURE} if error test failures occurred either too many
times (\sphinxstyleemphasis{ark\_maxnef}) during one internal time step or occurred
with \(|h| = h_{min}\).

\item {} 
\sphinxstyleemphasis{ARK\_CONV\_FAILURE} if either convergence test failures occurred
too many times (\sphinxstyleemphasis{ark\_maxncf}) during one internal time step or
occurred with \(|h| = h_{min}\).

\item {} 
\sphinxstyleemphasis{ARK\_LINIT\_FAIL} if the linear solver’s initialization
function failed.

\item {} 
\sphinxstyleemphasis{ARK\_LSETUP\_FAIL} if the linear solver’s setup routine failed in
an unrecoverable manner.

\item {} 
\sphinxstyleemphasis{ARK\_LSOLVE\_FAIL} if the linear solver’s solve routine failed in
an unrecoverable manner.

\item {} 
\sphinxstyleemphasis{ARK\_MASSINIT\_FAIL} if the mass matrix solver’s
initialization function failed.

\item {} 
\sphinxstyleemphasis{ARK\_MASSSETUP\_FAIL} if the mass matrix solver’s setup routine
failed.

\item {} 
\sphinxstyleemphasis{ARK\_MASSSOLVE\_FAIL} if the mass matrix solver’s solve routine
failed.

\item {} 
\sphinxstyleemphasis{ARK\_VECTOROP\_ERR} a vector operation error occured.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The input vector \sphinxstyleemphasis{yout} can use the same memory as the
vector \sphinxstyleemphasis{y0} of initial conditions that was passed to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}.

In \sphinxstyleemphasis{ARK\_ONE\_STEP} mode, \sphinxstyleemphasis{tout} is used only on the first call, and
only to get the direction and a rough scale of the independent
variable.

All failure return values are negative and so testing the return argument for
negative values will trap all {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} failures.

Since interpolation may reduce the accuracy in the reported
solution, if full method accuracy is desired the user should issue
a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ARKStepSetStopTime()}}}} before the call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} to specify a fixed stop time to
end the time step and return to the user.  Upon return from
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, a copy of the internal solution
\(y_{n}\) will be returned in the vector \sphinxstyleemphasis{yout}.  Once the
integrator returns at a \sphinxstyleemphasis{tstop} time, any future testing for
\sphinxstyleemphasis{tstop} is disabled (and can be re-enabled only though a new call
to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ARKStepSetStopTime()}}}}).

On any error return in which one or more internal steps were taken
by {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, the returned values of \sphinxstyleemphasis{tret} and
\sphinxstyleemphasis{yout} correspond to the farthest point reached in the integration.
On all other error returns, \sphinxstyleemphasis{tret} and \sphinxstyleemphasis{yout} are left unchanged
from those provided to the routine.

\end{fulllineitems}



\subsection{Optional input functions}
\label{\detokenize{ARKStep_c_interface/User_callable:optional-input-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}}
There are numerous optional input parameters that control the behavior
of the ARKStep solver, each of which may be modified from its default
value through calling an appropriate input function.  The following
tables list all optional input functions, grouped by which aspect of
ARKStep they control.  Detailed information on the calling syntax and
arguments for each function are then provided following each table.

The optional inputs are grouped into the following categories:
\begin{itemize}
\item {} 
General ARKStep options ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for ARKStep}}}}),

\item {} 
IVP method solver options ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepmethodinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for IVP method selection}}}}),

\item {} 
Step adaptivity solver options ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepadaptivityinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for time step adaptivity}}}}),

\item {} 
Implicit stage solver options ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepsolverinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for implicit stage solves}}}}),

\item {} 
Linear solver interface options ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface optional input functions}}}}), and

\item {} 
Rootfinding options ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arksteprootfindinginputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding optional input functions}}}}).

\end{itemize}

For the most casual use of ARKStep, relying on the default set of
solver parameters, the reader can skip to the following section,
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

We note that, on an error return, all of the optional input functions send an
error message to the error handler function. All error return values are
negative, so a test on the return arguments for negative values will catch all
errors. Finally, a call to an \sphinxcode{ARKStepSet***} function can generally be made
from the user’s calling program at any time and, if successful, takes effect
immediately. \sphinxcode{ARKStepSet***} functions that cannot be called at any time note
this in the “\sphinxstylestrong{Notes}:” section of the function documentation.


\subsubsection{Optional inputs for ARKStep}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepinputtable}}\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-arkstep}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Return ARKStep parameters to their defaults
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDefaults}]{\sphinxcrossref{\sphinxcode{ARKStepSetDefaults()}}}}
&
internal
\\
\hline
Set dense output interpolation type
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantType()}}}}
&
\sphinxcode{ARK\_INTERP\_HERMITE}
\\
\hline
Set dense output polynomial degree
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}}
&
5
\\
\hline
Supply a pointer to a diagnostics output file
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDiagnostics}]{\sphinxcrossref{\sphinxcode{ARKStepSetDiagnostics()}}}}
&
\sphinxcode{NULL}
\\
\hline
Supply a pointer to an error output file
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrFile}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrFile()}}}}
&
\sphinxcode{stderr}
\\
\hline
Supply a custom error handler function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrHandlerFn()}}}}
&
internal fn
\\
\hline
Disable time step adaptivity (fixed-step mode)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}}
&
disabled
\\
\hline
Supply an initial step size to attempt
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetInitStep()}}}}
&
estimated
\\
\hline
Maximum no. of warnings for \(t_n+h = t_n\)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxHnilWarns}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxHnilWarns()}}}}
&
10
\\
\hline
Maximum no. of internal steps before \sphinxstyleemphasis{tout}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNumSteps}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxNumSteps()}}}}
&
500
\\
\hline
Maximum absolute step size
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxStep()}}}}
&
\(\infty\)
\\
\hline
Minimum absolute step size
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinStep()}}}}
&
0.0
\\
\hline
Set a value for \(t_{stop}\)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ARKStepSetStopTime()}}}}
&
\(\infty\)
\\
\hline
Supply a pointer for user data
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}
&
\sphinxcode{NULL}
\\
\hline
Maximum no. of ARKStep error test failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxErrTestFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxErrTestFails()}}}}
&
7
\\
\hline
Set ‘optimal’ adaptivity params. for a method
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetOptimalParams}]{\sphinxcrossref{\sphinxcode{ARKStepSetOptimalParams()}}}}
&
internal
\\
\hline
Set inequality constraints on solution
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}}
&
\sphinxcode{NULL}
\\
\hline
Set max number of constraint failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNumConstrFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxNumConstrFails()}}}}
&
10
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepSetDefaults (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDefaults}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetDefaults}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Resets all optional input parameters to ARKStep’s original
default values.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Does not change the \sphinxstyleemphasis{user\_data} pointer or any
parameters within the specified time-stepping module.

Also leaves alone any data structures or options related to
root-finding (those can be reset using {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}}).

\end{fulllineitems}

\index{ARKStepSetInterpolantType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantType}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetInterpolantType}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ itype}}{}
Specifies use of the Lagrange or Hermite interpolation modules (used for
dense output \textendash{} interpolation of solution output values and implicit
method predictors).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{itype} \textendash{} requested interpolant type (\sphinxcode{ARK\_INTERP\_HERMITE} or \sphinxcode{ARK\_INTERP\_LAGRANGE})

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL} if the interpolation module cannot be allocated

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if the \sphinxstyleemphasis{itype} argument is not recognized or the
interpolation module has already been initialized

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The Hermite interpolation module is described in the Section
{\hyperref[\detokenize{Mathematics:mathematics-interpolation-hermite}]{\sphinxcrossref{\DUrole{std,std-ref}{Hermite interpolation module}}}}, and the Lagrange interpolation module
is described in the Section {\hyperref[\detokenize{Mathematics:mathematics-interpolation-lagrange}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagrange interpolation module}}}}.

This routine frees any previously-allocated interpolation module, and re-creates
one according to the specified argument.  Thus any previous calls to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}} will be nullified.

This routine may only be called \sphinxstyleemphasis{after} the call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}.
After the first call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} the interpolation type may
not be changed without first calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}.

If this routine is not called, the Hermite interpolation module will be used.

\end{fulllineitems}

\index{ARKStepSetInterpolantDegree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetInterpolantDegree}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ degree}}{}
Specifies the degree of the polynomial interpolant
used for dense output (i.e. interpolation of solution output values
and implicit method predictors).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{degree} \textendash{} requested polynomial degree.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory or interpolation module are \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_INTERP\_FAIL} if this is called after {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value or the
interpolation module has already been initialized

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Allowed values are between 0 and 5.

This routine should be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} and \sphinxstyleemphasis{before}
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}. After the first call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}
the interpolation degree may not be changed without first calling
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}.

If a user calls both this routine and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantType()}}}}, then
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantType()}}}} must be called first.

Since the accuracy of any polynomial interpolant is limited by the accuracy of
the time-step solutions on which it is based, the \sphinxstyleemphasis{actual} polynomial degree that
is used by ARKStep will be the minimum of \(q-1\) and the input \sphinxstyleemphasis{degree},
where \(q\) is the order of accuracy for the time integration method.

\end{fulllineitems}

\index{ARKStepSetDenseOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDenseOrder}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetDenseOrder}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ dord}}{}
\sphinxstyleemphasis{This function is deprecated, and will be removed in a future release.
Users should transition to calling} {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}}
\sphinxstyleemphasis{instead.}

\end{fulllineitems}

\index{ARKStepSetDiagnostics (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDiagnostics}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetDiagnostics}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE*\sphinxstyleemphasis{ diagfp}}{}
Specifies the file pointer for a diagnostics file where
all ARKStep step adaptivity and solver information is written.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{diagfp} \textendash{} pointer to the diagnostics output file.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This parameter can be \sphinxcode{stdout} or \sphinxcode{stderr}, although the
suggested approach is to specify a pointer to a unique file opened
by the user and returned by \sphinxcode{fopen}.  If not called, or if called
with a \sphinxcode{NULL} file pointer, all diagnostics output is disabled.

When run in parallel, only one process should set a non-NULL value
for this pointer, since statistics from all processes would be
identical.

\end{fulllineitems}

\index{ARKStepSetErrFile (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrFile}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetErrFile}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE*\sphinxstyleemphasis{ errfp}}{}
Specifies a pointer to the file where all ARKStep warning and error
messages will be written if the default internal error handling
function is used.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{errfp} \textendash{} pointer to the output file.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value for \sphinxstyleemphasis{errfp} is \sphinxcode{stderr}.

Passing a \sphinxcode{NULL} value disables all future error message output
(except for the case wherein the ARKStep memory pointer is
\sphinxcode{NULL}).  This use of the function is strongly discouraged.

If used, this routine should be called before any other
optional input functions, in order to take effect for subsequent
error messages.

\end{fulllineitems}

\index{ARKStepSetErrHandlerFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrHandlerFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetErrHandlerFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}]{\sphinxcrossref{ARKErrHandlerFn}}}\sphinxstyleemphasis{ ehfun}, void*\sphinxstyleemphasis{ eh\_data}}{}
Specifies the optional user-defined function to be used
in handling error messages.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ehfun} \textendash{} name of user-supplied error handler function.

\item {} 
\sphinxstyleemphasis{eh\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{ehfun} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Error messages indicating that the ARKStep solver memory is
\sphinxcode{NULL} will always be directed to \sphinxcode{stderr}.

\end{fulllineitems}

\index{ARKStepSetFixedStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetFixedStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hfixed}}{}
Disabled time step adaptivity within ARKStep, and specifies the
fixed time step size to use for all internal steps.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hfixed} \textendash{} value of the fixed step size to use.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass 0.0 to return ARKStep to the default (adaptive-step) mode.

Use of this function is not recommended, since we it gives no
assurance of the validity of the computed solutions.  It is
primarily provided for code-to-code verification testing purposes.

When using {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}}, any values provided to
the functions
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetInitStep()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityFn()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxErrTestFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxErrTestFails()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityMethod()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetCFLFraction}]{\sphinxcrossref{\sphinxcode{ARKStepSetCFLFraction()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrorBias}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrorBias()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStepBounds}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStepBounds()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxCFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxCFailGrowth()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxEFailGrowth()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxFirstGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxFirstGrowth()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxGrowth()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinReduction()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSafetyFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetSafetyFactor()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSmallNumEFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetSmallNumEFails()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStabilityFn()}}}}
will be ignored, since temporal adaptivity is disabled.

If both {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ARKStepSetStopTime()}}}} are used, then the fixed step size
will be used for all steps until the final step preceding the
provided stop time (which may be shorter).  To resume use of the
previous fixed step size, another call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}} must be made prior to calling
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} to resume integration.

It is \sphinxstyleemphasis{not} recommended that {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}} be used
in concert with {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxStep()}}}} or
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinStep()}}}}, since at best those latter two
routines will provide no useful information to the solver, and at
worst they may interfere with the desired fixed step size.

\end{fulllineitems}

\index{ARKStepSetInitStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetInitStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hin}}{}
Specifies the initial time step size ARKStep should use after
initialization, re-initialization, or resetting.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hin} \textendash{} value of the initial step to be attempted \((\ne 0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass 0.0 to use the default value.

By default, ARKStep estimates the initial step size to be the
solution \(h\) of the equation \(\left\| \frac{h^2
\ddot{y}}{2}\right\| = 1\), where \(\ddot{y}\) is an estimated
value of the second derivative of the solution at \sphinxstyleemphasis{t0}.

This routine will also reset the step size and error history.

\end{fulllineitems}

\index{ARKStepSetMaxHnilWarns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxHnilWarns}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxHnilWarns}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ mxhnil}}{}
Specifies the maximum number of messages issued by the
solver to warn that \(t+h=t\) on the next internal step, before
ARKStep will instead return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mxhnil} \textendash{} maximum allowed number of warning messages \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 10; set \sphinxstyleemphasis{mxhnil} to zero to specify
this default.

A negative value indicates that no warning messages should be issued.

\end{fulllineitems}

\index{ARKStepSetMaxNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNumSteps}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxNumSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int\sphinxstyleemphasis{ mxsteps}}{}
Specifies the maximum number of steps to be taken by the
solver in its attempt to reach the next output time, before ARKStep
will return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mxsteps} \textendash{} maximum allowed number of internal steps.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing \sphinxstyleemphasis{mxsteps} = 0 results in ARKStep using the
default value (500).

Passing \sphinxstyleemphasis{mxsteps} \textless{} 0 disables the test (not recommended).

\end{fulllineitems}

\index{ARKStepSetMaxStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hmax}}{}
Specifies the upper bound on the magnitude of the time step size.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hmax} \textendash{} maximum absolute value of the time step size \((\ge 0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass \sphinxstyleemphasis{hmax} \(\le 0.0\) to set the default value of \(\infty\).

\end{fulllineitems}

\index{ARKStepSetMinStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMinStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hmin}}{}
Specifies the lower bound on the magnitude of the time step size.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hmin} \textendash{} minimum absolute value of the time step size \((\ge 0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass \sphinxstyleemphasis{hmin} \(\le 0.0\) to set the default value of 0.

\end{fulllineitems}

\index{ARKStepSetStopTime (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetStopTime}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tstop}}{}
Specifies the value of the independent variable
\(t\) past which the solution is not to proceed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{tstop} \textendash{} stopping time for the integrator.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is that no stop time is imposed.

\end{fulllineitems}

\index{ARKStepSetUserData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetUserData}}{void*\sphinxstyleemphasis{ arkode\_mem}, void*\sphinxstyleemphasis{ user\_data}}{}
Specifies the user data block \sphinxstyleemphasis{user\_data} and
attaches it to the main ARKStep memory block.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} pointer to the user data.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If specified, the pointer to \sphinxstyleemphasis{user\_data} is passed to all
user-supplied functions for which it is an argument; otherwise
\sphinxcode{NULL} is passed.

If \sphinxstyleemphasis{user\_data} is needed in user linear solver or preconditioner
functions, the call to this function must be made \sphinxstyleemphasis{before} the call
to specify the linear solver.

\end{fulllineitems}

\index{ARKStepSetMaxErrTestFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxErrTestFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxErrTestFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxnef}}{}
Specifies the maximum number of error test failures
permitted in attempting one step, before returning with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{maxnef} \textendash{} maximum allowed number of error test failures \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 7; set \sphinxstyleemphasis{maxnef} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ARKStepSetOptimalParams (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetOptimalParams}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetOptimalParams}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Sets all adaptivity and solver parameters to our ‘best
guess’ values, for a given integration method (ERK, DIRK, ARK) and
a given method order.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Should only be called after the method order and integration
method have been set.  These values resulted from repeated testing
of ARKStep’s solvers on a variety of training problems.  However,
all problems are different, so these values may not be optimal for
all users.

\end{fulllineitems}

\index{ARKStepSetConstraints (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetConstraints}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ constraints}}{}
Specifies a vector defining inequality constraints for each component of the
solution vector \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{constraints} \textendash{} vector of constraint flags. If \sphinxcode{constraints{[}i{]}} is
\begin{itemize}
\item {} 
0.0 then no constraint is imposed on \(y_i\)

\item {} 
1.0 then \(y_i\) will be constrained to be \(y_i \geq 0.0\)

\item {} 
-1.0 then \(y_i\) will be constrained to be \(y_i \leq 0.0\)

\item {} 
2.0 then \(y_i\) will be constrained to be \(y_i > 0.0\)

\item {} 
-2.0 then \(y_i\) will be constrained to be \(y_i < 0.0\)

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if the constraints vector contains illegal values

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The presence of a non-\sphinxcode{NULL} constraints vector that is not 0.0
in all components will cause constraint checking to be performed. However, a
call with 0.0 in all components of \sphinxcode{constraints} will result in an illegal
input return. A \sphinxcode{NULL} constraints vector will disable constraint checking.

After a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} inequality constraint checking
will be disabled and a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}} is
required to re-enable constraint checking.

Since constraint-handling is performed through cutting time steps that would
violate the constraints, it is possible that this feature will cause some
problems to fail due to an inability to enforce constraints even at the
minimum time step size.  Additionally, the features {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}}
and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}} are incompatible, and should not be used
simultaneously.

\end{fulllineitems}

\index{ARKStepSetMaxNumConstrFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNumConstrFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxNumConstrFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxfails}}{}
Specifies the maximum number of constraint failures in a step before ARKStep
will return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{maxfails} \textendash{} maximum allowed number of constrain failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing \sphinxstyleemphasis{maxfails} \textless{}= 0 results in ARKStep using the
default value (10).

\end{fulllineitems}



\subsubsection{Optional inputs for IVP method selection}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepmethodinputtable}}\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-ivp-method-selection}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Set integrator method order
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetOrder}]{\sphinxcrossref{\sphinxcode{ARKStepSetOrder()}}}}
&
4
\\
\hline
Specify implicit/explicit problem
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImEx}]{\sphinxcrossref{\sphinxcode{ARKStepSetImEx()}}}}
&
\sphinxcode{SUNTRUE}
\\
\hline
Specify explicit problem
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetExplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetExplicit()}}}}
&
\sphinxcode{SUNFALSE}
\\
\hline
Specify implicit problem
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetImplicit()}}}}
&
\sphinxcode{SUNFALSE}
\\
\hline
Set additive RK tables
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}
&
internal
\\
\hline
Specify additive RK table numbers
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}
&
internal
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepSetOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetOrder}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetOrder}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ ord}}{}
Specifies the order of accuracy for the ARK/DIRK/ERK integration
method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ord} \textendash{} requested order of accuracy.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} For explicit methods, the allowed values are \(2 \le\)
\sphinxstyleemphasis{ord} \(\le 8\).  For implicit methods, the allowed values are
\(2\le\) \sphinxstyleemphasis{ord} \(\le 5\), and for ImEx methods the allowed
values are \(3 \le\) \sphinxstyleemphasis{ord} \(\le 5\).  Any illegal input
will result in the default value of 4.

Since \sphinxstyleemphasis{ord} affects the memory requirements for the internal
ARKStep memory block, it cannot be changed after the first call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, unless {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} is called.

\end{fulllineitems}

\index{ARKStepSetImEx (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImEx}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetImEx}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Specifies that both the implicit and explicit portions
of problem are enabled, and to use an additive Runge Kutta method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is automatically deduced when neither of the function
pointers \sphinxstyleemphasis{fe} or \sphinxstyleemphasis{fi} passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} are
\sphinxcode{NULL}, but may be set directly by the user if desired.

\end{fulllineitems}

\index{ARKStepSetExplicit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetExplicit}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetExplicit}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Specifies that the implicit portion of problem is disabled,
and to use an explicit RK method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is automatically deduced when the function pointer \sphinxtitleref{fi}
passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} is \sphinxcode{NULL}, but may be set
directly by the user if desired.

If the problem is posed in explicit form, i.e. \(\dot{y} =
f(t,y)\), then we recommend that the ERKStep time-stepper module be
used instead.

\end{fulllineitems}

\index{ARKStepSetImplicit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImplicit}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetImplicit}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Specifies that the explicit portion of problem is disabled,
and to use a diagonally implicit RK method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is automatically deduced when the function pointer \sphinxtitleref{fe}
passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} is \sphinxcode{NULL}, but may be set
directly by the user if desired.

\end{fulllineitems}

\index{ARKStepSetTables (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetTables}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ q}, int\sphinxstyleemphasis{ p}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ Bi}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ Be}}{}
Specifies a customized Butcher table (or pair) for the ERK, DIRK,
or ARK method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{q} \textendash{} global order of accuracy for the ARK method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} global order of accuracy for the embedded ARK method.

\item {} 
\sphinxstyleemphasis{Bi} \textendash{} the Butcher table for the implicit RK method.

\item {} 
\sphinxstyleemphasis{Be} \textendash{} the Butcher table for the explicit RK method.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}

For a description of the {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} type and related
functions for creating Butcher tables see {\hyperref[\detokenize{ARKodeButcherTable:arkodebutchertable}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher Table Data Structure}}}}.

To set an explicit table, \sphinxstyleemphasis{Bi} must be \sphinxcode{NULL}.  This automatically calls
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetExplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetExplicit()}}}}.  However, if the problem is posed
in explicit form, i.e. \(\dot{y} = f(t,y)\), then we recommend
that the ERKStep time-stepper module be used instead of ARKStep.

To set an implicit table, \sphinxstyleemphasis{Be} must be \sphinxcode{NULL}.  This automatically calls
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetImplicit()}}}}.

If both \sphinxstyleemphasis{Bi} and \sphinxstyleemphasis{Be} are provided, this routine automatically calls
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImEx}]{\sphinxcrossref{\sphinxcode{ARKStepSetImEx()}}}}.

When only one table is provided (i.e., \sphinxstyleemphasis{Bi} or \sphinxstyleemphasis{Be} is \sphinxcode{NULL}) then the
input values of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} are ignored and the global order of the method
and embedding (if applicable) are obtained from the Butcher table
structures. If both \sphinxstyleemphasis{Bi} and \sphinxstyleemphasis{Be} are non-NULL (e.g, an IMEX method is
provided) then the input values of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} are used as the order of the
ARK method may be less than the orders of the individual tables. No error
checking is performed to ensure that either \sphinxstyleemphasis{p} or \sphinxstyleemphasis{q} correctly describe the
coefficients that were input.

Error checking is performed on \sphinxstyleemphasis{Bi} and \sphinxstyleemphasis{Be} (if non-NULL) to ensure
that they specify DIRK and ERK methods, respectively.

If the inputs \sphinxstyleemphasis{Bi} or \sphinxstyleemphasis{Be} do not contain an embedding (when the
corresponding explicit or implicit table is non-NULL), the user \sphinxstyleemphasis{must} call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}} to enable fixed-step mode and set the
desired time step size.

\end{fulllineitems}

\index{ARKStepSetTableNum (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetTableNum}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ itable}, int\sphinxstyleemphasis{ etable}}{}
Indicates to use specific built-in Butcher tables for the ERK, DIRK
or ARK method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{itable} \textendash{} index of the DIRK Butcher table.

\item {} 
\sphinxstyleemphasis{etable} \textendash{} index of the ERK Butcher table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}

The allowable values for both the \sphinxstyleemphasis{itable} and \sphinxstyleemphasis{etable} arguments
corresponding to built-in tables may be found {\hyperref[\detokenize{Butcher:butcher}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: Butcher tables}}}}.

To choose an explicit table, set \sphinxstyleemphasis{itable} to a negative value.  This
automatically calls {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetExplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetExplicit()}}}}.  However, if
the problem is posed in explicit form, i.e. \(\dot{y} =
f(t,y)\), then we recommend that the ERKStep time-stepper module be
used instead of ARKStep.

To select an implicit table, set \sphinxstyleemphasis{etable} to a negative value.
This automatically calls {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetImplicit()}}}}.

If both \sphinxstyleemphasis{itable} and \sphinxstyleemphasis{etable} are non-negative, then these should
match an existing implicit/explicit pair, listed in the section
{\hyperref[\detokenize{Butcher:butcher-additive}]{\sphinxcrossref{\DUrole{std,std-ref}{Additive Butcher tables}}}}.  This automatically calls
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImEx}]{\sphinxcrossref{\sphinxcode{ARKStepSetImEx()}}}}.

In all cases, error-checking is performed to ensure that the tables
exist.

\end{fulllineitems}



\subsubsection{Optional inputs for time step adaptivity}
\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-time-step-adaptivity}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepadaptivityinputtable}}
The mathematical explanation of ARKode’s time step adaptivity
algorithm, including how each of the parameters below is used within
the code, is provided in the section {\hyperref[\detokenize{Mathematics:mathematics-adaptivity}]{\sphinxcrossref{\DUrole{std,std-ref}{Time step adaptivity}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Set a custom time step adaptivity function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityFn()}}}}
&
internal
\\
\hline
Choose an existing time step adaptivity method
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityMethod()}}}}
&
0
\\
\hline
Explicit stability safety factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetCFLFraction}]{\sphinxcrossref{\sphinxcode{ARKStepSetCFLFraction()}}}}
&
0.5
\\
\hline
Time step error bias factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrorBias}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrorBias()}}}}
&
1.5
\\
\hline
Bounds determining no change in step size
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStepBounds}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStepBounds()}}}}
&
1.0  1.5
\\
\hline
Maximum step growth factor on convergence fail
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxCFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxCFailGrowth()}}}}
&
0.25
\\
\hline
Maximum step growth factor on error test fail
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxEFailGrowth()}}}}
&
0.3
\\
\hline
Maximum first step growth factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxFirstGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxFirstGrowth()}}}}
&
10000.0
\\
\hline
Maximum allowed general step growth factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxGrowth()}}}}
&
20.0
\\
\hline
Minimum allowed step reduction factor on error test fail
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinReduction()}}}}
&
0.1
\\
\hline
Time step safety factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSafetyFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetSafetyFactor()}}}}
&
0.96
\\
\hline
Error fails before MaxEFailGrowth takes effect
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSmallNumEFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetSmallNumEFails()}}}}
&
2
\\
\hline
Explicit stability function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStabilityFn()}}}}
&
none
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepSetAdaptivityFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetAdaptivityFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}]{\sphinxcrossref{ARKAdaptFn}}}\sphinxstyleemphasis{ hfun}, void*\sphinxstyleemphasis{ h\_data}}{}
Sets a user-supplied time-step adaptivity function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hfun} \textendash{} name of user-supplied adaptivity function.

\item {} 
\sphinxstyleemphasis{h\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{hfun} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This function should focus on accuracy-based time step
estimation; for stability based time steps the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStabilityFn()}}}} should be used instead.

\end{fulllineitems}

\index{ARKStepSetAdaptivityMethod (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityMethod}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetAdaptivityMethod}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ imethod}, int\sphinxstyleemphasis{ idefault}, int\sphinxstyleemphasis{ pq}, realtype*\sphinxstyleemphasis{ adapt\_params}}{}
Specifies the method (and associated parameters) used for time step adaptivity.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{imethod} \textendash{} accuracy-based adaptivity method choice
(0 \(\le\) \sphinxtitleref{imethod} \(\le\) 5):
0 is PID, 1 is PI, 2 is I, 3 is explicit Gustafsson, 4 is
implicit Gustafsson, and 5 is the ImEx Gustafsson.

\item {} 
\sphinxstyleemphasis{idefault} \textendash{} flag denoting whether to use default adaptivity
parameters (1), or that they will be supplied in the
\sphinxstyleemphasis{adapt\_params} argument (0).

\item {} 
\sphinxstyleemphasis{pq} \textendash{} flag denoting whether to use the embedding order of
accuracy \sphinxstyleemphasis{p} (0) or the method order of accuracy \sphinxstyleemphasis{q} (1)
within the adaptivity algorithm.  \sphinxstyleemphasis{p} is the default.

\item {} 
\sphinxstyleemphasis{adapt\_params{[}0{]}} \textendash{} \(k_1\) parameter within accuracy-based adaptivity algorithms.

\item {} 
\sphinxstyleemphasis{adapt\_params{[}1{]}} \textendash{} \(k_2\) parameter within accuracy-based adaptivity algorithms.

\item {} 
\sphinxstyleemphasis{adapt\_params{[}2{]}} \textendash{} \(k_3\) parameter within accuracy-based adaptivity algorithms.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If custom parameters are supplied, they will be checked
for validity against published stability intervals.  If other
parameter values are desired, it is recommended to instead provide
a custom function through a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityFn()}}}}.

\end{fulllineitems}

\index{ARKStepSetCFLFraction (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetCFLFraction}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetCFLFraction}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ cfl\_frac}}{}
Specifies the fraction of the estimated explicitly stable step to use.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{cfl\_frac} \textendash{} maximum allowed fraction of explicitly stable step (default is 0.5).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default
value.

\end{fulllineitems}

\index{ARKStepSetErrorBias (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrorBias}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetErrorBias}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ bias}}{}
Specifies the bias to be applied to the error estimates within
accuracy-based adaptivity strategies.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{bias} \textendash{} bias applied to error in accuracy-based time
step estimation (default is 1.5).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value below 1.0 will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetFixedStepBounds (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStepBounds}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetFixedStepBounds}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ lb}, realtype\sphinxstyleemphasis{ ub}}{}
Specifies the step growth interval in which the step size will remain unchanged.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lb} \textendash{} lower bound on window to leave step size fixed (default is 1.0).

\item {} 
\sphinxstyleemphasis{ub} \textendash{} upper bound on window to leave step size fixed (default is 1.5).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any interval \sphinxstyleemphasis{not} containing 1.0 will imply a reset to the default values.

\end{fulllineitems}

\index{ARKStepSetMaxCFailGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxCFailGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxCFailGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ etacf}}{}
Specifies the maximum step size growth factor upon an algebraic
solver convergence failure on a stage solve within a step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{etacf} \textendash{} time step reduction factor on a nonlinear solver
convergence failure (default is 0.25).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value outside the interval \((0,1]\) will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetMaxEFailGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxEFailGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxEFailGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ etamxf}}{}
Specifies the maximum step size growth factor upon multiple successive
accuracy-based error failures in the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{etamxf} \textendash{} time step reduction factor on multiple error fails (default is 0.3).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value outside the interval \((0,1]\) will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetMaxFirstGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxFirstGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxFirstGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ etamx1}}{}
Specifies the maximum allowed growth factor in step size following the very
first integration step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{etamx1} \textendash{} maximum allowed growth factor after the first time
step (default is 10000.0).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value \(\le 1.0\) will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetMaxGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ mx\_growth}}{}
Specifies the maximum allowed growth factor in step size between
consecutive steps in the integration process.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mx\_growth} \textendash{} maximum allowed growth factor between consecutive time steps (default is 20.0).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value \(\le 1.0\) will imply a reset to the default
value.

\end{fulllineitems}

\index{ARKStepSetMinReduction (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinReduction}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMinReduction}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ eta\_min}}{}
Specifies the minimum allowed reduction factor in step size between
step attempts, resulting from a temporal error failure in the integration
process.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{eta\_min} \textendash{} minimum allowed reduction factor time step after an error
test failure (default is 0.1).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value \(\ge 1.0\) or \(\le 0.0\) will imply a reset to
the default value.

\end{fulllineitems}

\index{ARKStepSetSafetyFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSafetyFactor}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetSafetyFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ safety}}{}
Specifies the safety factor to be applied to the accuracy-based
estimated step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{safety} \textendash{} safety factor applied to accuracy-based time step (default is 0.96).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default
value.

\end{fulllineitems}

\index{ARKStepSetSmallNumEFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSmallNumEFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetSmallNumEFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ small\_nef}}{}
Specifies the threshold for “multiple” successive error failures
before the \sphinxstyleemphasis{etamxf} parameter from
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxEFailGrowth()}}}} is applied.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{small\_nef} \textendash{} bound to determine ‘multiple’ for \sphinxstyleemphasis{etamxf} (default is 2).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetStabilityFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStabilityFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetStabilityFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}]{\sphinxcrossref{ARKExpStabFn}}}\sphinxstyleemphasis{ EStab}, void*\sphinxstyleemphasis{ estab\_data}}{}
Sets the problem-dependent function to estimate a stable
time step size for the explicit portion of the ODE system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{EStab} \textendash{} name of user-supplied stability function.

\item {} 
\sphinxstyleemphasis{estab\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{EStab} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This function should return an estimate of the absolute
value of the maximum stable time step for the explicit portion of
the ODE system.  It is not required, since accuracy-based
adaptivity may be sufficient for retaining stability, but this can
be quite useful for problems where the explicit right-hand side
function \(f^E(t,y)\) may contain stiff terms.

\end{fulllineitems}



\subsubsection{Optional inputs for implicit stage solves}
\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-implicit-stage-solves}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepsolverinputtable}}
The mathematical explanation for the nonlinear solver strategies used
by ARKStep, including how each of the parameters below is used within
the code, is provided in the section {\hyperref[\detokenize{Mathematics:mathematics-nonlinear}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver methods}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Specify linearly implicit \(f^I\)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinear}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinear()}}}}
&
\sphinxcode{SUNFALSE}
\\
\hline
Specify nonlinearly implicit \(f^I\)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinear}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinear()}}}}
&
\sphinxcode{SUNTRUE}
\\
\hline
Implicit predictor method
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPredictorMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetPredictorMethod()}}}}
&
0
\\
\hline
Maximum number of nonlinear iterations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNonlinIters}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxNonlinIters()}}}}
&
3
\\
\hline
Coefficient in the nonlinear convergence test
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinConvCoef}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinConvCoef()}}}}
&
0.1
\\
\hline
Nonlinear convergence rate constant
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinCRDown}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinCRDown()}}}}
&
0.3
\\
\hline
Nonlinear residual divergence ratio
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinRDiv}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinRDiv()}}}}
&
2.3
\\
\hline
Maximum number of convergence failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxConvFails()}}}}
&
10
\\
\hline
User-provided implicit stage predictor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStagePredictFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStagePredictFn()}}}}
&
\sphinxcode{NULL}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepSetLinear (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinear}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetLinear}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ timedepend}}{}
Specifies that the implicit portion of the problem is linear.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{timedepend} \textendash{} flag denoting whether the Jacobian of
\(f^I(t,y)\) is time-dependent (1) or not (0).
Alternately, when using a matrix-free iterative linear solver
this flag denotes time dependence of the preconditioner.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Tightens the linear solver tolerances and takes only a
single Newton iteration.  Calls {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{ARKStepSetDeltaGammaMax()}}}}
to enforce Jacobian recomputation when the step size ratio changes
by more than 100 times the unit roundoff (since nonlinear
convergence is not tested).  Only applicable when used in
combination with the modified or inexact Newton iteration (not the
fixed-point solver).

The only SUNDIALS-provided SUNNonlinearSolver module that is compatible
with the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinear}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinear()}}}} option is the Newton solver.

\end{fulllineitems}

\index{ARKStepSetNonlinear (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinear}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetNonlinear}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Specifies that the implicit portion of the problem is nonlinear.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is the default behavior of ARKStep, so the function
is primarily useful to undo a previous call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinear}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinear()}}}}.  Calls
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{ARKStepSetDeltaGammaMax()}}}} to reset the step size ratio
threshold to the default value.

\end{fulllineitems}

\index{ARKStepSetPredictorMethod (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPredictorMethod}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetPredictorMethod}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ method}}{}
Specifies the method to use for predicting implicit solutions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{method} \textendash{} method choice (0 \(\le\) \sphinxstyleemphasis{method} \(\le\) 4):
\begin{itemize}
\item {} 
0 is the trivial predictor,

\item {} 
1 is the maximum order (dense output) predictor,

\item {} 
2 is the variable order predictor, that decreases the
polynomial degree for more distant RK stages,

\item {} 
3 is the cutoff order predictor, that uses the maximum order
for early RK stages, and a first-order predictor for distant
RK stages,

\item {} 
4 is the bootstrap predictor, that uses a second-order
predictor based on only information within the current step.

\item {} 
5 is the minimum correction predictor, that uses all
preceding stage information within the current step for
prediction.

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 0.  If \sphinxstyleemphasis{method} is set to an
undefined value, this default predictor will be used.

Options 4 and 5 are currently not supported when solving a problem involving
a non-identity mass matrix.  In that case, selection of \sphinxstyleemphasis{method} as 4 or 5 will
instead default to the trivial predictor (\sphinxstyleemphasis{method} 0).

\end{fulllineitems}

\index{ARKStepSetMaxNonlinIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNonlinIters}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxNonlinIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxcor}}{}
Specifies the maximum number of nonlinear solver
iterations permitted per RK stage within each time step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{maxcor} \textendash{} maximum allowed solver iterations per stage \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value or if the SUNNONLINSOL module is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NLS\_OP\_ERR} if the SUNNONLINSOL object returned a failure flag

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 3; set \sphinxstyleemphasis{maxcor} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ARKStepSetNonlinConvCoef (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinConvCoef}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetNonlinConvCoef}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ nlscoef}}{}
Specifies the safety factor used within the nonlinear
solver convergence test.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nlscoef} \textendash{} coefficient in nonlinear solver convergence test \((>0.0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 0.1; set \sphinxstyleemphasis{nlscoef} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ARKStepSetNonlinCRDown (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinCRDown}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetNonlinCRDown}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ crdown}}{}
Specifies the constant used in estimating the nonlinear solver convergence rate.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{crdown} \textendash{} nonlinear convergence rate estimation constant (default is 0.3).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetNonlinRDiv (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinRDiv}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetNonlinRDiv}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ rdiv}}{}
Specifies the nonlinear correction threshold beyond which the
iteration will be declared divergent.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rdiv} \textendash{} tolerance on nonlinear correction size ratio to
declare divergence (default is 2.3).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKStepSetMaxConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxConvFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMaxConvFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxncf}}{}
Specifies the maximum number of nonlinear solver convergence
failures permitted during one step, before ARKStep will return with
an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{maxncf} \textendash{} maximum allowed nonlinear solver convergence failures
per step \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 10; set \sphinxstyleemphasis{maxncf} \(\le 0\)
to specify this default.

Upon each convergence failure, ARKStep will first call the Jacobian
setup routine and try again (if a Newton method is used).  If a
convergence failure still occurs, the time step size is reduced by
the factor \sphinxstyleemphasis{etacf} (set within {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxCFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxCFailGrowth()}}}}).

\end{fulllineitems}

\index{ARKStepSetStagePredictFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStagePredictFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetStagePredictFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKStagePredictFn}]{\sphinxcrossref{ARKStagePredictFn}}}\sphinxstyleemphasis{ PredictStage}}{}
Sets the user-supplied function to update the implicit stage predictor prior to
execution of the nonlinear or linear solver algorithms that compute the implicit stage solution.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{PredictStage} \textendash{} name of user-supplied predictor function.  If \sphinxcode{NULL}, then any
previously-provided stage prediction function will be disabled.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} See the section {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-stagepredictfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit stage prediction function}}}} for more information on
this user-supplied routine.

\end{fulllineitems}



\subsubsection{Linear solver interface optional input functions}
\label{\detokenize{ARKStep_c_interface/User_callable:linear-solver-interface-optional-input-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsinputs}}
The mathematical explanation of the linear solver methods
available to ARKStep is provided in the section
{\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}}.  We group the user-callable routines into
four categories: general routines concerning the update frequency for
matrices and/or preconditioners, optional inputs for matrix-based
linear solvers, optional inputs for matrix-free linear solvers, and
optional inputs for iterative linear solvers.  We note that the
matrix-based and matrix-free groups are mutually exclusive, whereas the
“iterative” tag can apply to either case.

\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsinputs-general}}
\index{optional input!generic linear solver interface (ARKStep)}\ignorespaces 

\paragraph{Optional inputs for the ARKLS linear solver interface}
\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-the-arkls-linear-solver-interface}}\label{\detokenize{ARKStep_c_interface/User_callable:index-0}}
As discussed in the section {\hyperref[\detokenize{Mathematics:mathematics-linear-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Updating the linear solver}}}}, ARKode
strives to reuse matrix and preconditioner data for as many solves as
possible to amortize the high costs of matrix construction and
factorization.  To that end, ARKStep provides user-callable
routines to modify this behavior.  Recall that the
Newton system matrices that arise within an implicit stage solve are
\({\mathcal A}(t,z) \approx M - \gamma J(t,z)\), where the
implicit right-hand side function has Jacobian matrix
\(J(t,z) = \frac{\partial f^I(t,z)}{\partial z}\).

The matrix or preconditioner for \({\mathcal A}\) can only be
updated within a call to the linear solver ‘setup’ routine.  In
general, the frequency with which the linear solver setup routine is
called may be controlled with the \sphinxstyleemphasis{msbp} argument to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSetupFrequency()}}}}.  When this occurs, the
validity of \({\mathcal A}\) for successive time steps
intimately depends on whether the corresponding \(\gamma\) and
\(J\) inputs remain valid.

At each call to the linear solver setup routine the decision to update
\(\mathcal{A}\) with a new value of \(\gamma\), and to reuse
or reevaluate Jacobian information, depends on several factors including:
\begin{itemize}
\item {} 
the success or failure of previous solve attempts,

\item {} 
the success or failure of the previous time step attempts,

\item {} 
the change in \(\gamma\) from the value used when constructing \(\mathcal{A}\), and

\item {} 
the number of steps since Jacobian information was last evaluated.

\end{itemize}

The frequency with which to update Jacobian information can be controlled
with the \sphinxstyleemphasis{msbj} argument to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacEvalFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacEvalFrequency()}}}}.
We note that this is only checked \sphinxstyleemphasis{within} calls to the linear solver setup
routine, so values \sphinxstyleemphasis{msbj} \(<\) \sphinxstyleemphasis{msbp} do not make sense. For
linear-solvers with user-supplied preconditioning the above factors are used
to determine whether to recommend updating the Jacobian information in the
preconditioner (i.e., whether to set \sphinxstyleemphasis{jok} to \sphinxcode{SUNFALSE} in calling the
user-supplied \sphinxcode{ARKLsPrecSetupFn()}). For matrix-based linear solvers
these factors determine whether the matrix \(J(t,y) = \frac{\partial f^I(t,y)}{\partial y}\)
should be updated (either with an internal finite difference approximation or
a call to the user-supplied {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn}}}}); if not then the previous
value is reused and the system matrix \({\mathcal A}(t,y) \approx M - \gamma J(t,y)\)
is recomputed using the current \(\gamma\) value.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Max change in step signaling new \(J\)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{ARKStepSetDeltaGammaMax()}}}}
&
0.2
\\
\hline
Linear solver setup frequency
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSetupFrequency()}}}}
&
20
\\
\hline
Jacobian / preconditioner update frequency
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacEvalFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacEvalFrequency()}}}}
&
51
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepSetDeltaGammaMax (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDeltaGammaMax}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetDeltaGammaMax}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ dgmax}}{}
Specifies a scaled step size ratio tolerance, beyond which the
linear solver setup routine will be signaled.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{dgmax} \textendash{} tolerance on step size ratio change before calling
linear solver setup routine (default is 0.2).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}


\index{optional input!linear solver setup frequency (ARKStep)}\ignorespaces \index{ARKStepSetLSetupFrequency (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSetupFrequency}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetLSetupFrequency}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ msbp}}{}
Specifies the frequency of calls to the linear solver setup
routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{msbp} \textendash{} the linear solver setup frequency.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Positive values of \sphinxstylestrong{msbp} specify the linear solver setup frequency. For
example, an input of 1 means the setup function will be called every time
step while an input of 2 means it will be called called every other time
step. If \sphinxstylestrong{msbp} is 0, the default value of 20 will be used. A negative
value forces a linear solver step at each implicit stage.

\end{fulllineitems}


\index{optional input!Jacobian update frequency (ARKStep)}\index{optional input!preconditioner update frequency (ARKStep)}\ignorespaces \index{ARKStepSetJacEvalFrequency (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacEvalFrequency}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetJacEvalFrequency}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int\sphinxstyleemphasis{ msbj}}{}
Specifies the frequency for recomputing the Jacobian or recommending a
preconditioner update.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{msbj} \textendash{} the Jacobian re-computation or preconditioner update frequency.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
The Jacobian update frequency is only checked \sphinxstyleemphasis{within} calls to the linear
solver setup routine, as such values of \sphinxstyleemphasis{msbj} \(<\) \sphinxstyleemphasis{msbp} will result
in recomputing the Jacobian every \sphinxstyleemphasis{msbp} steps. See
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSetupFrequency()}}}} for setting the linear solver steup
frequency \sphinxstyleemphasis{msbp}.

Passing a value \sphinxstyleemphasis{msbj} \(\le 0\) indicates to use the
default value of 51.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver interface has
been initialized through a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

\end{fulllineitems}



\paragraph{Optional inputs for matrix-based \sphinxstyleliteralintitle{SUNLinearSolver} modules}
\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-matrix-based-sunlinearsolver-modules}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsinputs-matrixbased}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Jacobian function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}}
&
\sphinxcode{DQ}
\\
\hline
Linear system function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinSysFn()}}}}
&
internal
\\
\hline
Mass matrix function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}}
&
none
\\
\hline
Enable or disable linear solution scaling
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolutionScaling}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolutionScaling()}}}}
&
on
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

When using matrix-based linear solver modules, the ARKLS solver interface needs
a function to compute an approximation to the Jacobian matrix \(J(t,y)\) or
the linear system \(\mathcal{A(t,y)} = M(t) - \gamma J(t,y)\).

For \(J(t,y)\), the ARKLS interface is packaged with a routine that can approximate
\(J\) if the user has selected either dense or banded linear algebra.  Alternatively,
the user can supply a custom Jacobian function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}} \textendash{} this is
\sphinxstyleemphasis{required} when the user selects other matrix formats.  To specify a user-supplied
Jacobian function, ARKStep provides the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}}.

Alternatively, a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn()}}}} can be provided to
evaluate the matrix \(\mathcal{A(t,y)}\). By default, ARKLS uses an
internal linear system function leveraging the SUNMATRIX API to form the matrix
\(\mathcal{A(t,y)}\) by combining the matrices \(M(t)\) and \(J(t,y)\).
To specify a user-supplied linear system function instead, ARKStep provides the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinSysFn()}}}}.

If the ODE system involves a non-identity mass matrix, \(M\ne I\), matrix-based linear
solver modules require a function to compute an approximation to the mass matrix \(M(t)\).
There is no default difference quotient approximation (for any matrix type), so this
routine must be supplied by the user. This function must be of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}, and should be set using the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}}.

In either case (\(J(t,y)\) versus \(\mathcal{A(t,y)}\) is supplied) the matrix
information will be updated infrequently to reduce matrix construction and, with direct
solvers, factorization costs. As a result the value of \(\gamma\) may not be current
and a scaling factor is applied to the solution of the linear system to account for
the lagged value of \(\gamma\). See {\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-lagged-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagged matrix information}}}} for more details.
The function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolutionScaling}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolutionScaling()}}}} can be used to disable this
scaling when necessary, e.g., when providing a custom linear solver that updates the
matrix using the current \(\gamma\) as part of the solve.

The ARKLS interface passes the user data pointer to the Jacobian, linear
system, and mass matrix functions. This allows the user to create an arbitrary
structure with relevant problem data and access it during the execution of the
user-supplied Jacobian, linear system or mass matrix functions, without using global
data in the program. The user data pointer may be specified through
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.
\index{ARKStepSetJacFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetJacFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{ARKLsJacFn}}}\sphinxstyleemphasis{ jac}}{}
Specifies the Jacobian approximation routine to
be used for the matrix-based solver with the ARKLS interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{jac} \textendash{} name of user-supplied Jacobian approximation function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}  if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This routine must be called after the ARKLS linear
solver interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

By default, ARKLS uses an internal difference quotient function for
dense and band matrices.  If \sphinxcode{NULL} is passed in for \sphinxstyleemphasis{jac}, this
default is used. An error will occur if no \sphinxstyleemphasis{jac} is supplied when
using other matrix types.

The function type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}} is described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKStepSetLinSysFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinSysFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetLinSysFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{ARKLsLinSysFn}}}\sphinxstyleemphasis{ linsys}}{}
Specifies the linear system approximation routine to be used for the
matrix-based solver with the ARKLS interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{linsys} \textendash{} name of user-supplied linear system approximation function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}  if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This routine must be called after the ARKLS linear
solver interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

By default, ARKLS uses an internal linear system function that leverages the
SUNMATRIX API to form the system \(M - \gamma J\).  If \sphinxcode{NULL} is passed
in for \sphinxstyleemphasis{linsys}, this default is used.

The function type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn()}}}} is described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKStepSetMassFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMassFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{ARKLsMassFn}}}\sphinxstyleemphasis{ mass}}{}
Specifies the mass matrix approximation routine to be used for the
matrix-based solver with the ARKLS interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mass} \textendash{} name of user-supplied mass matrix approximation function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}  if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_MASSMEM\_NULL} if the mass matrix solver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This routine must be called after the ARKLS mass matrix
solver interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

Since there is no default difference quotient function for mass
matrices, \sphinxstyleemphasis{mass} must be non-\sphinxcode{NULL}.

The function type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}} is described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKStepSetLinearSolutionScaling (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolutionScaling}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetLinearSolutionScaling}}{void*\sphinxstyleemphasis{ arkode\_mem}, booleantype\sphinxstyleemphasis{ onoff}}{}
Enables or disables scaling the linear system solution to account for a
change in \(\gamma\) in the linear system. For more details see
{\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-lagged-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagged matrix information}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{onoff} \textendash{} flag to enable (\sphinxcode{SUNTRUE}) or disable (\sphinxcode{SUNFALSE})
scaling

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if the attached linear solver is not matrix-based

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Linear solution scaling is enabled by default when a matrix-based
linear solver is attached.

\end{fulllineitems}



\paragraph{Optional inputs for matrix-free \sphinxstyleliteralintitle{SUNLinearSolver} modules}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsinputs-matrixfree}}\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-matrix-free-sunlinearsolver-modules}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
\(Jv\) functions (\sphinxstyleemphasis{jtimes} and \sphinxstyleemphasis{jtsetup})
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimes()}}}}
&
DQ,  none
\\
\hline
\(Jv\) DQ rhs function (\sphinxstyleemphasis{jtimesRhsFn})
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimesRhsFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimesRhsFn()}}}}
&
fi
\\
\hline
\(Mv\) functions (\sphinxstyleemphasis{mtimes} and \sphinxstyleemphasis{mtsetup})
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}}
&
none, none
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

As described in the section {\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}}, when solving
the Newton linear systems with matrix-free methods, the ARKLS
interface requires a \sphinxstyleemphasis{jtimes} function to compute an approximation to
the product between the Jacobian matrix
\(J(t,y)\) and a vector \(v\). The user can supply a custom
Jacobian-times-vector approximation function, or use the default
internal difference quotient function that comes with the ARKLS
interface.

A user-defined Jacobian-vector function must be of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} and can be specified through a call
to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimes()}}}} (see the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}} for specification details).  As with the
user-supplied preconditioner functions, the evaluation and
processing of any Jacobian-related data needed by the user’s
Jacobian-times-vector function is done in the optional user-supplied
function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}} (see the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}} for specification details).  As with
the preconditioner functions, a pointer to the user-defined
data structure, \sphinxstyleemphasis{user\_data}, specified through
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}} (or a \sphinxcode{NULL} pointer otherwise) is
passed to the Jacobian-times-vector setup and product functions each
time they are called.
\index{ARKStepSetJacTimes (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimes}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetJacTimes}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{ARKLsJacTimesSetupFn}}}\sphinxstyleemphasis{ jtsetup}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{ARKLsJacTimesVecFn}}}\sphinxstyleemphasis{ jtimes}}{}
Specifies the Jacobian-times-vector setup and product functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{jtsetup} \textendash{} user-defined Jacobian-vector setup function.
Pass \sphinxcode{NULL} if no setup is necessary.

\item {} 
\sphinxstyleemphasis{jtimes} \textendash{} user-defined Jacobian-vector product function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\sphinxstyleemphasis{ARKLS\_SUNLS\_FAIL} if an error occurred when setting up
the Jacobian-vector product in the \sphinxcode{SUNLinearSolver}
object used by the ARKLS interface.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is to use an internal finite difference
quotient for \sphinxstyleemphasis{jtimes} and to leave out \sphinxstyleemphasis{jtsetup}.  If \sphinxcode{NULL} is
passed to \sphinxstyleemphasis{jtimes}, these defaults are used.  A user may
specify non-\sphinxcode{NULL} \sphinxstyleemphasis{jtimes} and \sphinxcode{NULL} \sphinxstyleemphasis{jtsetup} inputs.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver
interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

The function types {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} are described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}


When using the internal difference quotient the user may optionally supply
an alternative implicit right-hand side function for use in the Jacobian-vector
product approximation by calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimesRhsFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimesRhsFn()}}}}. The
alternative implicit right-hand side function should compute a suitable (and
differentiable) approximation to the \(f^I\) function provided to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}. For example, as done in \phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:id2}}{\hyperref[\detokenize{References:dfwbt2010}]{\sphinxcrossref{{[}DFWBT2010{]}}}}, the alternative
function may use lagged values when evaluating a nonlinearity in \(f^I\) to
avoid differencing a potentially non-differentiable factor.
\index{ARKStepSetJacTimesRhsFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimesRhsFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetJacTimesRhsFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ jtimesRhsFn}}{}
Specifies an alternative implicit right-hand side function for use in the
internal Jacobian-vector product difference quotient approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{jtimesRhsFn} \textendash{} the name of the C function (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}}) defining the alternative right-hand side function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is to use the implicit right-hand side function
provided to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} in the internal difference quotient. If
the input implicit right-hand side function is \sphinxcode{NULL}, the default is used.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver interface has
been initialized through a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

\end{fulllineitems}


Similarly, if a problem involves a non-identity mass matrix,
\(M\ne I\), then matrix-free solvers require a \sphinxstyleemphasis{mtimes} function
to compute an approximation to the product between the mass matrix
\(M(t)\) and a vector \(v\).  This function must be
user-supplied, since there is no default value.  \sphinxstyleemphasis{mtimes} must be
of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesVecFn()}}}}, and can be specified
through a call to the  {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}} routine.
Similarly to the user-supplied preconditioner functions, any evaluation
and processing of any mass matrix-related data needed by the user’s
mass-matrix-times-vector function may be done in an optional user-supplied
function of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn}}}} (see the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}} for specification details).
\index{ARKStepSetMassTimes (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMassTimes}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{ARKLsMassTimesSetupFn}}}\sphinxstyleemphasis{ mtsetup}, {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{ARKLsMassTimesVecFn}}}\sphinxstyleemphasis{ mtimes}, void*\sphinxstyleemphasis{ mtimes\_data}}{}
Specifies the mass matrix-times-vector setup and product functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mtsetup} \textendash{} user-defined mass matrix-vector setup function.
Pass \sphinxcode{NULL} if no setup is necessary.

\item {} 
\sphinxstyleemphasis{mtimes} \textendash{} user-defined mass matrix-vector product function.

\item {} 
\sphinxstyleemphasis{mtimes\_data} \textendash{} a pointer to user data, that will be supplied
to both the \sphinxstyleemphasis{mtsetup} and \sphinxstyleemphasis{mtimes} functions.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_MASSMEM\_NULL} if the mass matrix solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\sphinxstyleemphasis{ARKLS\_SUNLS\_FAIL} if an error occurred when setting up
the mass-matrix-vector product in the \sphinxcode{SUNLinearSolver}
object used by the ARKLS interface.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} There is no default finite difference quotient for
\sphinxstyleemphasis{mtimes}, so if using the ARKLS mass matrix solver interface with
NULL-valued \(M\), and this routine is called with NULL-valued
\sphinxstyleemphasis{mtimes}, an error will occur.  A user may specify \sphinxcode{NULL} for
\sphinxstyleemphasis{mtsetup}.

This function must be called \sphinxstyleemphasis{after} the ARKLS mass
matrix solver interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

The function types {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesVecFn}}}} are described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}



\paragraph{Optional inputs for iterative \sphinxstyleliteralintitle{SUNLinearSolver} modules}
\label{\detokenize{ARKStep_c_interface/User_callable:optional-inputs-for-iterative-sunlinearsolver-modules}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsinputs-iterative}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Newton preconditioning functions
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetPreconditioner()}}}}
&
\sphinxcode{NULL}, \sphinxcode{NULL}
\\
\hline
Mass matrix preconditioning functions
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassPreconditioner()}}}}
&
\sphinxcode{NULL}, \sphinxcode{NULL}
\\
\hline
Newton linear and nonlinear tolerance ratio
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetEpsLin()}}}}
&
0.05
\\
\hline
Mass matrix linear and nonlinear tolerance ratio
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassEpsLin()}}}}
&
0.05
\\
\hline
Newton linear solve tolerance conversion factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSNormFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSNormFactor()}}}}
&
vector length
\\
\hline
Mass matrix linear solve tolerance conversion factor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLSNormFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLSNormFactor()}}}}
&
vector length
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

As described in the section {\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}}, when using
an iterative linear solver the user may supply a preconditioning
operator to aid in solution of the system.  This operator consists of
two user-supplied functions, \sphinxstyleemphasis{psetup} and \sphinxstyleemphasis{psolve}, that are supplied
to ARKStep using either the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetPreconditioner()}}}} (for preconditioning the
Newton system), or the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassPreconditioner()}}}} (for preconditioning the
mass matrix system).  The \sphinxstyleemphasis{psetup} function supplied to these routines
should handle evaluation and preprocessing of any Jacobian or
mass-matrix data needed by the user’s preconditioner solve function,
\sphinxstyleemphasis{psolve}.  The user data pointer received through
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}} (or a pointer to \sphinxcode{NULL} if user data
was not specified) is passed to the \sphinxstyleemphasis{psetup} and \sphinxstyleemphasis{psolve} functions.
This allows the user to create an arbitrary
structure with relevant problem data and access it during the
execution of the user-supplied preconditioner functions without using
global data in the program.  If preconditioning is supplied for both
the Newton and mass matrix linear systems, it is expected that the
user will supply different \sphinxstyleemphasis{psetup} and \sphinxstyleemphasis{psolve} function for each.

Also, as described in the section {\hyperref[\detokenize{Mathematics:mathematics-error-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear iteration error control}}}}, the
ARKLS interface requires that iterative linear solvers stop when
the norm of the preconditioned residual satisfies
\begin{equation*}
\begin{split}\|r\| \le \frac{\epsilon_L \epsilon}{10}\end{split}
\end{equation*}
where the default \(\epsilon_L = 0.05\), which may be modified by
the user through the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetEpsLin()}}}} function.
\index{ARKStepSetPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetPreconditioner}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{ARKLsPrecSetupFn}}}\sphinxstyleemphasis{ psetup}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{ARKLsPrecSolveFn}}}\sphinxstyleemphasis{ psolve}}{}
Specifies the user-supplied preconditioner setup and solve functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{psetup} \textendash{} user defined preconditioner setup function.  Pass
\sphinxcode{NULL} if no setup is needed.

\item {} 
\sphinxstyleemphasis{psolve} \textendash{} user-defined preconditioner solve function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\sphinxstyleemphasis{ARKLS\_SUNLS\_FAIL} if an error occurred when setting up
preconditioning in the \sphinxcode{SUNLinearSolver} object used
by the ARKLS interface.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is \sphinxcode{NULL} for both arguments (i.e., no
preconditioning).

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver
interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

Both of the function types {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn()}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSolveFn()}}}} are described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKStepSetMassPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassPreconditioner}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMassPreconditioner}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSetupFn}]{\sphinxcrossref{ARKLsMassPrecSetupFn}}}\sphinxstyleemphasis{ psetup}, {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSolveFn}]{\sphinxcrossref{ARKLsMassPrecSolveFn}}}\sphinxstyleemphasis{ psolve}}{}
Specifies the mass matrix preconditioner setup and solve functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{psetup} \textendash{} user defined preconditioner setup function.  Pass
\sphinxcode{NULL} if no setup is to be done.

\item {} 
\sphinxstyleemphasis{psolve} \textendash{} user-defined preconditioner solve function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\sphinxstyleemphasis{ARKLS\_SUNLS\_FAIL} if an error occurred when setting up
preconditioning in the \sphinxcode{SUNLinearSolver} object used
by the ARKLS interface.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This function must be called \sphinxstyleemphasis{after} the ARKLS mass
matrix solver interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

The default is \sphinxcode{NULL} for both arguments (i.e. no
preconditioning).

Both of the function types {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSetupFn()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSolveFn()}}}} are described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKStepSetEpsLin (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetEpsLin}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetEpsLin}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ eplifac}}{}
Specifies the factor by which the tolerance on the nonlinear
iteration is multiplied to get a tolerance on the linear
iteration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{eplifac} \textendash{} linear convergence safety factor.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing a value \sphinxstyleemphasis{eplifac} \(\le 0\) indicates to use the
default value of 0.05.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver
interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

\end{fulllineitems}

\index{ARKStepSetMassEpsLin (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassEpsLin}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMassEpsLin}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ eplifac}}{}
Specifies the factor by which the tolerance on the nonlinear
iteration is multiplied to get a tolerance on the mass matrix
linear iteration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{eplifac} \textendash{} linear convergence safety factor.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_MASSMEM\_NULL} if the mass matrix solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  This function must be called \sphinxstyleemphasis{after} the ARKLS mass
matrix solver interface has been initialized through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

Passing a value \sphinxstyleemphasis{eplifac} \(\le 0\) indicates to use the default value
of 0.05.

\end{fulllineitems}

\index{ARKStepSetLSNormFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSNormFactor}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetLSNormFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ nrmfac}}{}
Specifies the factor to use when converting from the integrator tolerance
(WRMS norm) to the linear solver tolerance (L2 norm) for Newton linear system
solves e.g., \sphinxcode{tol\_L2 = fac * tol\_WRMS}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nrmfac} \textendash{} the norm conversion factor. If \sphinxstyleemphasis{nrmfac} is:

\(> 0\) then the provided value is used.

\(= 0\) then the conversion factor is computed using the vector
length i.e., \sphinxcode{nrmfac = sqrt(N\_VGetLength(y))} (\sphinxstyleemphasis{default}).

\(< 0\) then the conversion factor is computed using the vector dot
product i.e., \sphinxcode{nrmfac = sqrt(N\_VDotProd(v,v))} where all the entries
of \sphinxcode{v} are one.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function must be called \sphinxstyleemphasis{after} the ARKLS system solver interface has
been initialized through a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

Prior to the introduction of {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetLength}]{\sphinxcrossref{\sphinxcode{N\_VGetLength()}}}} in SUNDIALS v5.0.0 the
value of \sphinxcode{nrmfac} was computed using the vector dot product i.e., the
\sphinxcode{nrmfac \textless{} 0} case.
\index{ARKStepSetMassLSNormFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLSNormFactor}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetMassLSNormFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ nrmfac}}{}
\end{fulllineitems}


Specifies the factor to use when converting from the integrator tolerance
(WRMS norm) to the linear solver tolerance (L2 norm) for mass matrix linear
system solves e.g., \sphinxcode{tol\_L2 = fac * tol\_WRMS}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nrmfac} \textendash{} the norm conversion factor. If \sphinxstyleemphasis{nrmfac} is:

\(> 0\) then the provided value is used.

\(= 0\) then the conversion factor is computed using the vector
length i.e., \sphinxcode{nrmfac = sqrt(N\_VGetLength(y))} (\sphinxstyleemphasis{default}).

\(< 0\) then the conversion factor is computed using the vector dot
product i.e., \sphinxcode{nrmfac = sqrt(N\_VDotProd(v,v))} where all the entries
of \sphinxcode{v} are one.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function must be called \sphinxstyleemphasis{after} the ARKLS mass matrix solver interface
has been initialized through a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

Prior to the introduction of {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetLength}]{\sphinxcrossref{\sphinxcode{N\_VGetLength()}}}} in SUNDIALS v5.0.0
(ARKODE v4.0.0) the value of \sphinxcode{nrmfac} was computed using the vector dot
product i.e., the \sphinxcode{nrmfac \textless{} 0} case.

\end{fulllineitems}



\subsubsection{Rootfinding optional input functions}
\label{\detokenize{ARKStep_c_interface/User_callable:rootfinding-optional-input-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arksteprootfindinginputtable}}
The following functions can be called to set optional inputs to
control the rootfinding algorithm, the mathematics of which are
described in the section {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Direction of zero-crossings to monitor
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetRootDirection}]{\sphinxcrossref{\sphinxcode{ARKStepSetRootDirection()}}}}
&
both
\\
\hline
Disable inactive root warnings
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNoInactiveRootWarn}]{\sphinxcrossref{\sphinxcode{ARKStepSetNoInactiveRootWarn()}}}}
&
enabled
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepSetRootDirection (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetRootDirection}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetRootDirection}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ rootdir}}{}
Specifies the direction of zero-crossings to be located and returned.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rootdir} \textendash{} state array of length \sphinxstyleemphasis{nrtfn}, the number of root
functions \(g_i\) (the value of \sphinxstyleemphasis{nrtfn} was supplied in
the call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}}).  If \sphinxcode{rootdir{[}i{]} ==
0} then crossing in either direction for \(g_i\) should be
reported.  A value of +1 or -1 indicates that the solver
should report only zero-crossings where \(g_i\) is
increasing or decreasing, respectively.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default behavior is to monitor for both zero-crossing directions.

\end{fulllineitems}

\index{ARKStepSetNoInactiveRootWarn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNoInactiveRootWarn}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepSetNoInactiveRootWarn}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Disables issuing a warning if some root function appears
to be identically zero at the beginning of the integration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} ARKStep will not report the initial conditions as a
possible zero-crossing (assuming that one or more components
\(g_i\) are zero at the initial time).  However, if it appears
that some \(g_i\) is identically zero at the initial time
(i.e., \(g_i\) is zero at the initial time \sphinxstyleemphasis{and} after the
first step), ARKStep will issue a warning which can be disabled with
this optional input function.

\end{fulllineitems}



\subsection{Interpolated output function}
\label{\detokenize{ARKStep_c_interface/User_callable:interpolated-output-function}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-interpolatedoutput}}
An optional function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetDky}]{\sphinxcrossref{\sphinxcode{ARKStepGetDky()}}}} is available to obtain
additional values of solution-related quantities.  This function
should only be called after a successful return from
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, as it provides interpolated values either of
\(y\) or of its derivatives (up to the 5th derivative)
interpolated to any value of \(t\) in the last internal step taken
by {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}.  Internally, this \sphinxstyleemphasis{dense output} algorithm is
identical to the algorithm used for the maximum order implicit
predictors, described in the section
{\hyperref[\detokenize{Mathematics:mathematics-predictors-max}]{\sphinxcrossref{\DUrole{std,std-ref}{Maximum order predictor}}}}, except that derivatives of the
polynomial model may be evaluated upon request.
\index{ARKStepGetDky (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetDky}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetDky}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ t}, int\sphinxstyleemphasis{ k}, N\_Vector\sphinxstyleemphasis{ dky}}{}
Computes the \sphinxstyleemphasis{k}-th derivative of the function
\(y\) at the time \sphinxstyleemphasis{t},
i.e. \(\frac{d^{(k)}}{dt^{(k)}}y(t)\), for values of the
independent variable satisfying \(t_n-h_n \le t \le t_n\), with
\(t_n\) as current internal time reached, and \(h_n\) is
the last internal step size successfully used by the solver.  This
routine uses an interpolating polynomial of degree \sphinxstyleemphasis{min(degree, 5)},
where \sphinxstyleemphasis{degree} is the argument provided to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ARKStepSetInterpolantDegree()}}}}.  The user may request \sphinxstyleemphasis{k} in the
range \{0,…,*min(degree, kmax)*\} where \sphinxstyleemphasis{kmax} depends on the choice of
interpolation module. For Hermite interpolants \sphinxstyleemphasis{kmax = 5} and for Lagrange
interpolants \sphinxstyleemphasis{kmax = 3}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the value of the independent variable at which the
derivative is to be evaluated.

\item {} 
\sphinxstyleemphasis{k} \textendash{} the derivative order requested.

\item {} 
\sphinxstyleemphasis{dky} \textendash{} output vector (must be allocated by the user).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_K} if \sphinxstyleemphasis{k} is not in the range \{0,…,*min(degree, kmax)*\}.

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_T} if \sphinxstyleemphasis{t} is not in the interval \([t_n-h_n, t_n]\)

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_DKY} if the \sphinxstyleemphasis{dky} vector was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} It is only legal to call this function after a successful
return from {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}.

A user may access the values \(t_n\) and \(h_n\) via the
functions {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetLastStep()}}}}, respectively.

\end{fulllineitems}



\subsection{Optional output functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}}\label{\detokenize{ARKStep_c_interface/User_callable:optional-output-functions}}
ARKStep provides an extensive set of functions that can be used to
obtain solver performance information.  We organize these into groups:
\begin{enumerate}
\item {} 
SUNDIALS version information accessor routines are in the subsection
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-sunversioninfo}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS version information}}}},

\item {} 
General ARKStep output routines are in the subsection
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepmainoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Main solver optional output functions}}}},

\item {} 
ARKStep implicit solver output routines are in the subsection
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepimplicitsolveroutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit solver optional output functions}}}},

\item {} 
Output routines regarding root-finding results are in the subsection
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arksteprootoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding optional output functions}}}},

\item {} 
Linear solver output routines are in the subsection
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface optional output functions}}}} and

\item {} 
General usability routines (e.g. to print the current ARKStep
parameters, or output the current Butcher table(s)) are in the
subsection {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepextraoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{General usability functions}}}}.

\end{enumerate}

Following each table, we elaborate on each function.

Some of the optional outputs, especially the various counters, can be
very useful in determining the efficiency of various methods inside
ARKStep.  For example:
\begin{itemize}
\item {} 
The counters \sphinxstyleemphasis{nsteps}, \sphinxstyleemphasis{nfe\_evals} and \sphinxstyleemphasis{nfi\_evals}
provide a rough measure of the overall cost of a given run, and can
be compared between runs with different solver options to suggest
which set of options is the most efficient.

\item {} 
The ratio \sphinxstyleemphasis{nniters/nsteps} measures the performance of the
nonlinear iteration in solving the nonlinear systems at each stage,
providing a measure of the degree of nonlinearity in the problem.
Typical values of this for a Newton solver on a general problem
range from 1.1 to 1.8.

\item {} 
When using a Newton nonlinear solver, the ratio \sphinxstyleemphasis{njevals/nniters}
(in the case of a direct linear solver), and the ratio
\sphinxstyleemphasis{npevals/nniters} (in the case of an iterative linear solver)
can measure the overall degree of nonlinearity in the problem,
since these are updated infrequently, unless the Newton method
convergence slows.

\item {} 
When using a Newton nonlinear solver, the ratio \sphinxstyleemphasis{njevals/nniters}
(when using a direct linear solver), and the ratio
\sphinxstyleemphasis{nliters/nniters} (when using an iterative linear solver) can
indicate the quality of the approximate Jacobian or preconditioner being
used.  For example, if this ratio is larger for a user-supplied
Jacobian or Jacobian-vector product routine than for the
difference-quotient routine, it can indicate that the user-supplied
Jacobian is inaccurate.

\item {} 
The ratio \sphinxstyleemphasis{expsteps/accsteps} can measure the quality of the ImEx
splitting used, since a higher-quality splitting will be dominated
by accuracy-limited steps.

\item {} 
The ratio \sphinxstyleemphasis{nsteps/step\_attempts} can measure the quality of the
time step adaptivity algorithm, since a poor algorithm will result
in more failed steps, and hence a lower ratio.

\end{itemize}

It is therefore recommended that users retrieve and output these
statistics following each run, and take some time to investigate
alternate solver options that will be more optimal for their
particular problem of interest.


\subsubsection{SUNDIALS version information}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-sunversioninfo}}\label{\detokenize{ARKStep_c_interface/User_callable:sundials-version-information}}
The following functions provide a way to get SUNDIALS version
information at runtime.
\index{SUNDIALSGetVersion (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.SUNDIALSGetVersion}}\pysiglinewithargsret{int \sphinxbfcode{SUNDIALSGetVersion}}{char\sphinxstyleemphasis{ *version}, int\sphinxstyleemphasis{ len}}{}
This routine fills a string with SUNDIALS version information.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{version} \textendash{} character array to hold the SUNDIALS version information.

\item {} 
\sphinxstyleemphasis{len} \textendash{} allocated length of the \sphinxstyleemphasis{version} character array.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS version

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} An array of 25 characters should be sufficient to hold
the version information.

\end{fulllineitems}

\index{SUNDIALSGetVersionNumber (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.SUNDIALSGetVersionNumber}}\pysiglinewithargsret{int \sphinxbfcode{SUNDIALSGetVersionNumber}}{int\sphinxstyleemphasis{ *major}, int\sphinxstyleemphasis{ *minor}, int\sphinxstyleemphasis{ *patch}, char\sphinxstyleemphasis{ *label}, int\sphinxstyleemphasis{ len}}{}
This routine sets integers for the SUNDIALS major,
minor, and patch release numbers and fills a string with the
release label if applicable.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{major} \textendash{} SUNDIALS release major version number.

\item {} 
\sphinxstyleemphasis{minor} \textendash{} SUNDIALS release minor version number.

\item {} 
\sphinxstyleemphasis{patch} \textendash{} SUNDIALS release patch version number.

\item {} 
\sphinxstyleemphasis{label} \textendash{} string to hold the SUNDIALS release label.

\item {} 
\sphinxstyleemphasis{len} \textendash{} allocated length of the \sphinxstyleemphasis{label} character array.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS label

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} An array of 10 characters should be sufficient to hold
the label information. If a label is not used in the release
version, no information is copied to \sphinxstyleemphasis{label}.

\end{fulllineitems}



\subsubsection{Main solver optional output functions}
\label{\detokenize{ARKStep_c_interface/User_callable:main-solver-optional-output-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepmainoutputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Size of ARKStep real and integer workspaces
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKStepGetWorkSpace()}}}}
\\
\hline
Cumulative number of internal steps
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumSteps}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumSteps()}}}}
\\
\hline
Actual initial time step size used
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetActualInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetActualInitStep()}}}}
\\
\hline
Step size used for the last successful step
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetLastStep()}}}}
\\
\hline
Step size to be attempted on the next step
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentStep()}}}}
\\
\hline
Current internal time reached by the solver
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}}
\\
\hline
Current internal solution reached by the solver
&
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentState}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentState()}}}}
\\
\hline
Current \(\gamma\) value used by the solver
&
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentGamma}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentGamma()}}}}
\\
\hline
Suggested factor for tolerance scaling
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetTolScaleFactor}]{\sphinxcrossref{\sphinxcode{ARKStepGetTolScaleFactor()}}}}
\\
\hline
Error weight vector for state variables
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetErrWeights()}}}}
\\
\hline
Residual weight vector
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetResWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetResWeights()}}}}
\\
\hline
Single accessor to many statistics at once
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetStepStats}]{\sphinxcrossref{\sphinxcode{ARKStepGetStepStats()}}}}
\\
\hline
Name of constant associated with a return flag
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetReturnFlagName}]{\sphinxcrossref{\sphinxcode{ARKStepGetReturnFlagName()}}}}
\\
\hline
No. of explicit stability-limited steps
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumExpSteps}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumExpSteps()}}}}
\\
\hline
No. of accuracy-limited steps
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumAccSteps}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumAccSteps()}}}}
\\
\hline
No. of attempted steps
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumStepAttempts}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumStepAttempts()}}}}
\\
\hline
No. of calls to \sphinxstyleemphasis{fe} and \sphinxstyleemphasis{fi} functions
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumRhsEvals()}}}}
\\
\hline
No. of local error test failures that have occurred
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumErrTestFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumErrTestFails()}}}}
\\
\hline
Current ERK and DIRK Butcher tables
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentButcherTables}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentButcherTables()}}}}
\\
\hline
Estimated local truncation error vector
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetEstLocalErrors}]{\sphinxcrossref{\sphinxcode{ARKStepGetEstLocalErrors()}}}}
\\
\hline
Single accessor to many statistics at once
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetTimestepperStats}]{\sphinxcrossref{\sphinxcode{ARKStepGetTimestepperStats()}}}}
\\
\hline
Number of constraint test failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumConstrFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumConstrFails()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrw}, long int*\sphinxstyleemphasis{ leniw}}{}
Returns the ARKStep real and integer workspace sizes.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lenrw} \textendash{} the number of \sphinxcode{realtype} values in the ARKStep workspace.

\item {} 
\sphinxstyleemphasis{leniw} \textendash{} the number of integer values in the ARKStep workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumSteps}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nsteps}}{}
Returns the cumulative number of internal steps taken by
the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nsteps} \textendash{} number of steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetActualInitStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetActualInitStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetActualInitStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hinused}}{}
Returns the value of the integration step size used on the first step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hinused} \textendash{} actual value of initial step size.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Even if the value of the initial integration step was
specified by the user through a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetInitStep()}}}}, this value may have been changed by
ARKStep to ensure that the step size fell within the prescribed
bounds \((h_{min} \le h_0 \le h_{max})\), or to satisfy the
local error test condition, or to ensure convergence of the
nonlinear solver.

\end{fulllineitems}

\index{ARKStepGetLastStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetLastStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hlast}}{}
Returns the integration step size taken on the last successful
internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hlast} \textendash{} step size taken on the last internal step.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetCurrentStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hcur}}{}
Returns the integration step size to be attempted on the next internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{hcur} \textendash{} step size to be attempted on the next internal step.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetCurrentTime (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentTime}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ tcur}}{}
Returns the current internal time reached by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} current internal time reached.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetCurrentState (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentState}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentState}}{void\sphinxstyleemphasis{ *arkode\_mem}, N\_Vector\sphinxstyleemphasis{ *ycur}}{}
Returns the current internal solution reached by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ycur} \textendash{} current internal solution.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Users should exercise extreme caution when using this function,
as altering values of \sphinxstyleemphasis{ycur} may lead to undesirable behavior, depending
on the particular use case and on when this routine is called.

\end{fulllineitems}

\index{ARKStepGetCurrentGamma (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentGamma}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentGamma}}{void\sphinxstyleemphasis{ *arkode\_mem}, realtype\sphinxstyleemphasis{ *gamma}}{}
Returns the current internal value of \(\gamma\) used in the implicit
solver Newton matrix (see equation \eqref{equation:Mathematics:NewtonMatrix}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} current step size scaling factor in the Newton system.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetTolScaleFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetTolScaleFactor}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetTolScaleFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ tolsfac}}{}
Returns a suggested factor by which the user’s
tolerances should be scaled when too much accuracy has been
requested for some internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{tolsfac} \textendash{} suggested scaling factor for user-supplied tolerances.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetErrWeights (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetErrWeights}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ eweight}}{}
Returns the current error weight vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{eweight} \textendash{} solution error weights at the current time.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{eweight}, that will be
filled in by this function.

\end{fulllineitems}

\index{ARKStepGetResWeights (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetResWeights}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetResWeights}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ rweight}}{}
Returns the current residual weight vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rweight} \textendash{} residual error weights at the current time.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{rweight}, that will be
filled in by this function.

\end{fulllineitems}

\index{ARKStepGetStepStats (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetStepStats}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetStepStats}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nsteps}, realtype*\sphinxstyleemphasis{ hinused}, realtype*\sphinxstyleemphasis{ hlast}, realtype*\sphinxstyleemphasis{ hcur}, realtype*\sphinxstyleemphasis{ tcur}}{}
Returns many of the most useful optional outputs in a single call.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nsteps} \textendash{} number of steps taken in the solver.

\item {} 
\sphinxstyleemphasis{hinused} \textendash{} actual value of initial step size.

\item {} 
\sphinxstyleemphasis{hlast} \textendash{} step size taken on the last internal step.

\item {} 
\sphinxstyleemphasis{hcur} \textendash{} step size to be attempted on the next internal step.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} current internal time reached.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetReturnFlagName}}\pysiglinewithargsret{char *\sphinxbfcode{ARKStepGetReturnFlagName}}{long int\sphinxstyleemphasis{ flag}}{}
Returns the name of the ARKStep constant corresponding to \sphinxstyleemphasis{flag}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{flag} \textendash{} a return flag from an ARKStep function.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The return value is a string containing the name of
the corresponding constant.

\end{fulllineitems}

\index{ARKStepGetNumExpSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumExpSteps}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumExpSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ expsteps}}{}
Returns the cumulative number of stability-limited steps
taken by the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{expsteps} \textendash{} number of stability-limited steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetNumAccSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumAccSteps}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumAccSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ accsteps}}{}
Returns the cumulative number of accuracy-limited steps
taken by the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{accsteps} \textendash{} number of accuracy-limited steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetNumStepAttempts (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumStepAttempts}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumStepAttempts}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ step\_attempts}}{}
Returns the cumulative number of steps attempted by the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{step\_attempts} \textendash{} number of steps attempted by solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumRhsEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumRhsEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nfe\_evals}, long int*\sphinxstyleemphasis{ nfi\_evals}}{}
Returns the number of calls to the user’s right-hand
side functions, \(f^E\) and \(f^I\) (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nfe\_evals} \textendash{} number of calls to the user’s \(f^E(t,y)\) function.

\item {} 
\sphinxstyleemphasis{nfi\_evals} \textendash{} number of calls to the user’s \(f^I(t,y)\) function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{nfi\_evals} value does not account for calls made to
\(f^I\) by a linear solver or preconditioner module.

\end{fulllineitems}

\index{ARKStepGetNumErrTestFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumErrTestFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumErrTestFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ netfails}}{}
Returns the number of local error test failures that
have occurred (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{netfails} \textendash{} number of error test failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetCurrentButcherTables (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentButcherTables}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentButcherTables}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ *Bi}, ARKodepButcherTable\sphinxstyleemphasis{ *Be}}{}
Returns the explicit and implicit Butcher tables
currently in use by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{Bi} \textendash{} pointer to implicit Butcher table structure.

\item {} 
\sphinxstyleemphasis{Be} \textendash{} pointer to explicit Butcher table structure.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} data structure is defined as a
pointer to the following C structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{ARKStepButcherTableMem} \PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{q}\PYG{p}{;}           \PYG{c+cm}{/* method order of accuracy       */}
  \PYG{k+kt}{int} \PYG{n}{p}\PYG{p}{;}           \PYG{c+cm}{/* embedding order of accuracy    */}
  \PYG{k+kt}{int} \PYG{n}{stages}\PYG{p}{;}      \PYG{c+cm}{/* number of stages               */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{A}\PYG{p}{;}    \PYG{c+cm}{/* Butcher table coefficients     */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{c}\PYG{p}{;}     \PYG{c+cm}{/* canopy node coefficients       */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{b}\PYG{p}{;}     \PYG{c+cm}{/* root node coefficients         */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{d}\PYG{p}{;}     \PYG{c+cm}{/* embedding coefficients         */}

\PYG{p}{\PYGZcb{}} \PYG{o}{*}\PYG{n}{ARKStepButcherTable}\PYG{p}{;}
\end{sphinxVerbatim}

For more details see {\hyperref[\detokenize{ARKodeButcherTable:arkodebutchertable}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher Table Data Structure}}}}.

\end{fulllineitems}

\index{ARKStepGetEstLocalErrors (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetEstLocalErrors}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetEstLocalErrors}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ ele}}{}
Returns the vector of estimated local truncation errors
for the current step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ele} \textendash{} vector of estimated local truncation errors.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The user must allocate space for \sphinxstyleemphasis{ele}, that will be
filled in by this function.

The values returned in \sphinxstyleemphasis{ele} are valid only after a successful call
to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} (i.e. it returned a non-negative value).

The \sphinxstyleemphasis{ele} vector, together with the \sphinxstyleemphasis{eweight} vector from
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetErrWeights()}}}}, can be used to determine how the
various components of the system contributed to the estimated local
error test.  Specifically, that error test uses the WRMS norm of a
vector whose components are the products of the components of these
two vectors.  Thus, for example, if there were recent error test
failures, the components causing the failures are those with largest
values for the products, denoted loosely as \sphinxcode{eweight{[}i{]}*ele{[}i{]}}.

\end{fulllineitems}

\index{ARKStepGetTimestepperStats (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetTimestepperStats}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetTimestepperStats}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ expsteps}, long int*\sphinxstyleemphasis{ accsteps}, long int*\sphinxstyleemphasis{ step\_attempts}, long int*\sphinxstyleemphasis{ nfe\_evals}, long int*\sphinxstyleemphasis{ nfi\_evals}, long int*\sphinxstyleemphasis{ nlinsetups}, long int*\sphinxstyleemphasis{ netfails}}{}
Returns many of the most useful time-stepper statistics in a single call.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{expsteps} \textendash{} number of stability-limited steps taken in the solver.

\item {} 
\sphinxstyleemphasis{accsteps} \textendash{} number of accuracy-limited steps taken in the solver.

\item {} 
\sphinxstyleemphasis{step\_attempts} \textendash{} number of steps attempted by the solver.

\item {} 
\sphinxstyleemphasis{nfe\_evals} \textendash{} number of calls to the user’s \(f^E(t,y)\) function.

\item {} 
\sphinxstyleemphasis{nfi\_evals} \textendash{} number of calls to the user’s \(f^I(t,y)\) function.

\item {} 
\sphinxstyleemphasis{nlinsetups} \textendash{} number of linear solver setup calls made.

\item {} 
\sphinxstyleemphasis{netfails} \textendash{} number of error test failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetNumConstrFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumConstrFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumConstrFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nconstrfails}}{}
Returns the cumulative number of constraint test failures (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nconstrfails} \textendash{} number of constraint test failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Implicit solver optional output functions}
\label{\detokenize{ARKStep_c_interface/User_callable:implicit-solver-optional-output-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepimplicitsolveroutputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
No. of calls to linear solver setup function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinSolvSetups}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumLinSolvSetups()}}}}
\\
\hline
No. of nonlinear solver iterations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvIters}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumNonlinSolvIters()}}}}
\\
\hline
No. of nonlinear solver convergence failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumNonlinSolvConvFails()}}}}
\\
\hline
Single accessor to all nonlinear solver statistics
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNonlinSolvStats}]{\sphinxcrossref{\sphinxcode{ARKStepGetNonlinSolvStats()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepGetNumLinSolvSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinSolvSetups}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumLinSolvSetups}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nlinsetups}}{}
Returns the number of calls made to the linear solver’s
setup routine (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nlinsetups} \textendash{} number of linear solver setup calls made.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the nonlinear
solver object; the counter is reset whenever a new nonlinear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumNonlinSolvIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvIters}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumNonlinSolvIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nniters}}{}
Returns the number of nonlinear solver iterations
performed (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nniters} \textendash{} number of nonlinear iterations performed.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NLS\_OP\_ERR} if the SUNNONLINSOL object returned a failure flag

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the nonlinear
solver object; the counter is reset whenever a new nonlinear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumNonlinSolvConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvConvFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumNonlinSolvConvFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nncfails}}{}
Returns the number of nonlinear solver convergence
failures that have occurred (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nncfails} \textendash{} number of nonlinear convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the nonlinear
solver object; the counter is reset whenever a new nonlinear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNonlinSolvStats (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNonlinSolvStats}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNonlinSolvStats}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nniters}, long int*\sphinxstyleemphasis{ nncfails}}{}
Returns all of the nonlinear solver statistics in a single call.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nniters} \textendash{} number of nonlinear iterations performed.

\item {} 
\sphinxstyleemphasis{nncfails} \textendash{} number of nonlinear convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NLS\_OP\_ERR} if the SUNNONLINSOL object returned a failure flag

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} These are only accumulated for the ‘life’ of the
nonlinear solver object; the counters are reset whenever a new
nonlinear solver module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}



\subsubsection{Rootfinding optional output functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arksteprootoutputs}}\label{\detokenize{ARKStep_c_interface/User_callable:rootfinding-optional-output-functions}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Array showing roots found
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{ARKStepGetRootInfo()}}}}
\\
\hline
No. of calls to user root function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumGEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumGEvals()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepGetRootInfo (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetRootInfo}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetRootInfo}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ rootsfound}}{}
Returns an array showing which functions were found to
have a root.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{rootsfound} \textendash{} array of length \sphinxstyleemphasis{nrtfn} with the indices of the
user functions \(g_i\) found to have a root (the value of
\sphinxstyleemphasis{nrtfn} was supplied in the call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}}).  For \(i = 0 \ldots\)
\sphinxstyleemphasis{nrtfn}-1, \sphinxcode{rootsfound{[}i{]}} is nonzero if \(g_i\) has a
root, and 0 if not.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{rootsfound} prior to
calling this function.

For the components of \(g_i\) for which a root was found, the
sign of \sphinxcode{rootsfound{[}i{]}} indicates the direction of
zero-crossing.  A value of +1 indicates that \(g_i\) is
increasing, while a value of -1 indicates a decreasing \(g_i\).

\end{fulllineitems}

\index{ARKStepGetNumGEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumGEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumGEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ ngevals}}{}
Returns the cumulative number of calls made to the
user’s root function \(g\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ngevals} \textendash{} number of calls made to \(g\) so far.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Linear solver interface optional output functions}
\label{\detokenize{ARKStep_c_interface/User_callable:linear-solver-interface-optional-output-functions}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsoutputs}}
The following optional outputs are available from the ARKLS
modules:
workspace requirements,
number of calls to the Jacobian routine,
number of calls to the mass matrix routine,
number of calls to the implicit right-hand side routine for finite-difference Jacobian approximation or Jacobian-vector product approximation,
number of linear iterations,
number of linear convergence failures,
number of calls to the preconditioner setup and solve routines,
number of calls to the Jacobian-vector setup and product routines,
number of calls to the mass-matrix-vector setup and product routines,
and last return value from an ARKLS function.
Note that, where the name of an output would otherwise conflict with the
name of an optional output from the main solver, a suffix LS (for
Linear Solver) or MLS (for Mass Linear Solver) has been added here
(e.g. \sphinxstyleemphasis{lenrwLS}).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Size of real and integer workspaces
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLinWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKStepGetLinWorkSpace()}}}}
\\
\hline
No. of Jacobian evaluations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumJacEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumJacEvals()}}}}
\\
\hline
No. of preconditioner evaluations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumPrecEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumPrecEvals()}}}}
\\
\hline
No. of preconditioner solves
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumPrecSolves}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumPrecSolves()}}}}
\\
\hline
No. of linear iterations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinIters}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumLinIters()}}}}
\\
\hline
No. of linear convergence failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumLinConvFails()}}}}
\\
\hline
No. of Jacobian-vector setup evaluations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumJTSetupEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumJTSetupEvals()}}}}
\\
\hline
No. of Jacobian-vector product evaluations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumJtimesEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumJtimesEvals()}}}}
\\
\hline
No. of \sphinxstyleemphasis{fi} calls for finite diff. \(J\) or \(Jv\) evals.
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumLinRhsEvals()}}}}
\\
\hline
Last return from a linear solver function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastLinFlag}]{\sphinxcrossref{\sphinxcode{ARKStepGetLastLinFlag()}}}}
\\
\hline
Name of constant associated with a return flag
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLinReturnFlagName}]{\sphinxcrossref{\sphinxcode{ARKStepGetLinReturnFlagName()}}}}
\\
\hline
Size of real and integer mass matrix solver workspaces
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetMassWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKStepGetMassWorkSpace()}}}}
\\
\hline
No. of mass matrix solver setups (incl. \(M\) evals.)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassSetups}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassSetups()}}}}
\\
\hline
No. of mass matrix multiply setups
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassMultSetups}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassMultSetups()}}}}
\\
\hline
No. of mass matrix multiplies
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassMult}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassMult()}}}}
\\
\hline
No. of mass matrix solves
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassSolves}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassSolves()}}}}
\\
\hline
No. of mass matrix preconditioner evaluations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassPrecEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassPrecEvals()}}}}
\\
\hline
No. of mass matrix preconditioner solves
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassPrecSolves}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassPrecSolves()}}}}
\\
\hline
No. of mass matrix linear iterations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassIters}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassIters()}}}}
\\
\hline
No. of mass matrix solver convergence failures
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMassConvFails()}}}}
\\
\hline
No. of mass-matrix-vector setup evaluations
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMTSetups}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumMTSetups()}}}}
\\
\hline
Last return from a mass matrix solver function
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastMassFlag}]{\sphinxcrossref{\sphinxcode{ARKStepGetLastMassFlag()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepGetLinWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLinWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetLinWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrwLS}, long int*\sphinxstyleemphasis{ leniwLS}}{}
Returns the real and integer workspace used by the ARKLS linear solver interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lenrwLS} \textendash{} the number of \sphinxcode{realtype} values in the ARKLS workspace.

\item {} 
\sphinxstyleemphasis{leniwLS} \textendash{} the number of integer values in the ARKLS workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \sphinxcode{SUNLinearSolver} object attached
to it.  The template Jacobian matrix allocated by the user outside
of ARKLS is not included in this report.

In a parallel setting, the above values are global (i.e. summed over all
processors).

\end{fulllineitems}

\index{ARKStepGetNumJacEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumJacEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumJacEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ njevals}}{}
Returns the number of Jacobian evaluations.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{njevals} \textendash{} number of Jacobian evaluations.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumPrecEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumPrecEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumPrecEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ npevals}}{}
Returns the total number of preconditioner evaluations,
i.e. the number of calls made to \sphinxstyleemphasis{psetup} with \sphinxcode{jok} = \sphinxcode{SUNFALSE} and
that returned \sphinxcode{*jcurPtr} = \sphinxcode{SUNTRUE}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{npevals} \textendash{} the current number of calls to \sphinxstyleemphasis{psetup}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumPrecSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumPrecSolves}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumPrecSolves}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ npsolves}}{}
Returns the number of calls made to the preconditioner
solve function, \sphinxstyleemphasis{psolve}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{npsolves} \textendash{} the number of calls to \sphinxstyleemphasis{psolve}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumLinIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinIters}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumLinIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nliters}}{}
Returns the cumulative number of linear iterations.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nliters} \textendash{} the current number of linear iterations.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumLinConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinConvFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumLinConvFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nlcfails}}{}
Returns the cumulative number of linear convergence failures.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nlcfails} \textendash{} the current number of linear convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumJTSetupEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumJTSetupEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumJTSetupEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ njtsetup}}{}
Returns the cumulative number of calls made to the user-supplied
Jacobian-vector setup function, \sphinxstyleemphasis{jtsetup}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{njtsetup} \textendash{} the current number of calls to \sphinxstyleemphasis{jtsetup}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumJtimesEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumJtimesEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumJtimesEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ njvevals}}{}
Returns the cumulative number of calls made to the
Jacobian-vector product function, \sphinxstyleemphasis{jtimes}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{njvevals} \textendash{} the current number of calls to \sphinxstyleemphasis{jtimes}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetNumLinRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinRhsEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumLinRhsEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nfevalsLS}}{}
Returns the number of calls to the user-supplied implicit
right-hand side function \(f^I\) for finite difference
Jacobian or Jacobian-vector product approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nfevalsLS} \textendash{} the number of calls to the user implicit
right-hand side function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The value \sphinxstyleemphasis{nfevalsLS} is incremented only if the default
internal difference quotient function is used.

This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to ARKStep, or when ARKStep is resized.

\end{fulllineitems}

\index{ARKStepGetLastLinFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastLinFlag}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetLastLinFlag}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lsflag}}{}
Returns the last return value from an ARKLS routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lsflag} \textendash{} the value of the last return flag from an
ARKLS function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If the ARKLS setup function failed when using the
\sphinxcode{SUNLINSOL\_DENSE} or \sphinxcode{SUNLINSOL\_BAND} modules, then the value
of \sphinxstyleemphasis{lsflag} is equal to the column index (numbered from one) at
which a zero diagonal element was encountered during the LU
factorization of the (dense or banded) Jacobian matrix.  For all
other failures, \sphinxstyleemphasis{lsflag} is negative.

Otherwise, if the ARKLS setup function failed
({\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} returned \sphinxstyleemphasis{ARK\_LSETUP\_FAIL}), then
\sphinxstyleemphasis{lsflag} will be \sphinxstyleemphasis{SUNLS\_PSET\_FAIL\_UNREC}, \sphinxstyleemphasis{SUNLS\_ASET\_FAIL\_UNREC}
or \sphinxstyleemphasis{SUNLS\_PACKAGE\_FAIL\_UNREC}.

If the ARKLS solve function failed ({\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}
returned \sphinxstyleemphasis{ARK\_LSOLVE\_FAIL}), then \sphinxstyleemphasis{lsflag} contains the error
return flag from the \sphinxcode{SUNLinearSolver} object, which will
be one of:
\sphinxstyleemphasis{SUNLS\_MEM\_NULL}, indicating that the \sphinxcode{SUNLinearSolver}
memory is \sphinxcode{NULL};
\sphinxstyleemphasis{SUNLS\_ATIMES\_NULL}, indicating that a matrix-free iterative solver
was provided, but is missing a routine for the matrix-vector product
approximation,
\sphinxstyleemphasis{SUNLS\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in
the \(Jv\) function;
\sphinxstyleemphasis{SUNLS\_PSOLVE\_NULL}, indicating that an iterative linear solver was
configured to use preconditioning, but no preconditioner solve
routine was provided,
\sphinxstyleemphasis{SUNLS\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
function failed unrecoverably;
\sphinxstyleemphasis{SUNLS\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure
(SPGMR and SPFGMR only);
\sphinxstyleemphasis{SUNLS\_QRSOL\_FAIL}, indicating that the matrix \(R\) was found
to be singular during the QR solve phase (SPGMR and SPFGMR only); or
\sphinxstyleemphasis{SUNLS\_PACKAGE\_FAIL\_UNREC}, indicating an unrecoverable failure in
an external iterative linear solver package.

\end{fulllineitems}

\index{ARKStepGetLinReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLinReturnFlagName}}\pysiglinewithargsret{char *\sphinxbfcode{ARKStepGetLinReturnFlagName}}{long int\sphinxstyleemphasis{ lsflag}}{}
Returns the name of the ARKLS constant corresponding to \sphinxstyleemphasis{lsflag}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{lsflag} \textendash{} a return flag from an ARKLS function.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  The return value is a string containing the name of
the corresponding constant. If using the \sphinxcode{SUNLINSOL\_DENSE} or
\sphinxcode{SUNLINSOL\_BAND} modules, then if  1 \(\le\) \sphinxtitleref{lsflag}
\(\le n\) (LU factorization failed), this routine returns “NONE”.

\end{fulllineitems}

\index{ARKStepGetMassWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetMassWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetMassWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrwMLS}, long int*\sphinxstyleemphasis{ leniwMLS}}{}
Returns the real and integer workspace used by the ARKLS mass matrix linear solver interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lenrwMLS} \textendash{} the number of \sphinxcode{realtype} values in the ARKLS mass solver workspace.

\item {} 
\sphinxstyleemphasis{leniwMLS} \textendash{} the number of integer values in the ARKLS mass solver workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \sphinxcode{SUNLinearSolver} object attached
to it.  The template mass matrix allocated by the user outside
of ARKLS is not included in this report.

In a parallel setting, the above values are global (i.e. summed over all
processors).

\end{fulllineitems}

\index{ARKStepGetNumMassSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassSetups}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassSetups}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmsetups}}{}
Returns the number of calls made to the ARKLS mass matrix solver
‘setup’ routine; these include all calls to the user-supplied
mass-matrix constructor function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmsetups} \textendash{} number of calls to the mass matrix solver setup routine.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassMultSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassMultSetups}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassMultSetups}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmvsetups}}{}
Returns the number of calls made to the ARKLS mass matrix ‘matvec setup’
(matrix-based solvers) routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmvsetups} \textendash{} number of calls to the mass matrix matrix-times-vector setup routine.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassMult (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassMult}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassMult}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmmults}}{}
Returns the number of calls made to the ARKLS mass matrix ‘matvec’
routine (matrix-based solvers) or the user-supplied \sphinxstyleemphasis{mtimes}
routine (matris-free solvers).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmmults} \textendash{} number of calls to the mass matrix solver matrix-times-vector routine.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassSolves}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassSolves}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmsolves}}{}
Returns the number of calls made to the ARKLS mass matrix solver ‘solve’ routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmsolves} \textendash{} number of calls to the mass matrix solver solve routine.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassPrecEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassPrecEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassPrecEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmpevals}}{}
Returns the total number of mass matrix preconditioner evaluations,
i.e. the number of calls made to \sphinxstyleemphasis{psetup}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmpevals} \textendash{} the current number of calls to \sphinxstyleemphasis{psetup}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassPrecSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassPrecSolves}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassPrecSolves}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmpsolves}}{}
Returns the number of calls made to the mass matrix preconditioner
solve function, \sphinxstyleemphasis{psolve}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmpsolves} \textendash{} the number of calls to \sphinxstyleemphasis{psolve}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassIters}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmiters}}{}
Returns the cumulative number of mass matrix solver iterations.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmiters} \textendash{} the current number of mass matrix solver linear iterations.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMassConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMassConvFails}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMassConvFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmcfails}}{}
Returns the cumulative number of mass matrix solver convergence failures.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmcfails} \textendash{} the current number of mass matrix solver convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetNumMTSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumMTSetups}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNumMTSetups}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nmtsetup}}{}
Returns the cumulative number of calls made to the user-supplied
mass-matrix-vector product setup function, \sphinxstyleemphasis{mtsetup}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nmtsetup} \textendash{} the current number of calls to \sphinxstyleemphasis{mtsetup}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new mass-matrix
linear solver module is ‘attached’ to ARKStep, or when ARKStep is
resized.

\end{fulllineitems}

\index{ARKStepGetLastMassFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastMassFlag}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetLastMassFlag}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ mlsflag}}{}
Returns the last return value from an ARKLS mass matrix interface routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mlsflag} \textendash{} the value of the last return flag from an ARKLS
mass matrix solver interface function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The values of \sphinxstyleemphasis{msflag} for each of the various solvers
will match those described above for the function
\sphinxcode{ARKStepGetLastLSFlag()}.

\end{fulllineitems}



\subsubsection{General usability functions}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arkstepextraoutputs}}\label{\detokenize{ARKStep_c_interface/User_callable:general-usability-functions}}
The following optional routines may be called by a user to inquire
about existing solver parameters or write the current Butcher table(s). While
neither of these would typically be called during the course of solving an
initial value problem, they may be useful for users wishing to better
understand ARKStep and/or specific Runge-Kutta methods.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional routine
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Output all ARKStep solver parameters
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWriteParameters}]{\sphinxcrossref{\sphinxcode{ARKStepWriteParameters()}}}}
\\
\hline
Output the current Butcher table(s)
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWriteButcher}]{\sphinxcrossref{\sphinxcode{ARKStepWriteButcher()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKStepWriteParameters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWriteParameters}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepWriteParameters}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE\sphinxstyleemphasis{ *fp}}{}
Outputs all ARKStep solver parameters to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{fp} \textendash{} pointer to use for printing the solver parameters.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{fp} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

When run in parallel, only one process should set a non-NULL value
for this pointer, since parameters for all processes would be
identical.

\end{fulllineitems}

\index{ARKStepWriteButcher (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWriteButcher}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepWriteButcher}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE\sphinxstyleemphasis{ *fp}}{}
Outputs the current Butcher table(s) to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{fp} \textendash{} pointer to use for printing the Butcher table(s).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{fp} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

If ARKStep is currently configured to run in purely explicit or
purely implicit mode, this will output a single Butcher table;  if
configured to run an ImEx method then both tables will be output.

When run in parallel, only one process should set a non-NULL value
for this pointer, since tables for all processes would be
identical.

\end{fulllineitems}



\subsection{ARKStep re-initialization function}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-re-initialization-function}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-reinitialization}}
To reinitialize the ARKStep module for the solution of a new problem,
where a prior call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} has been made, the
user must call the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}.  The new
problem must have the same size as the previous one.  This routine
retains the current settings for all ARKstep module options and
performs the same input checking and initializations that are done in
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}, but it performs no memory allocation as it
assumes that the existing internal memory is sufficient for the new
problem.  A call to this re-initialization routine deletes the
solution history that was stored internally during the previous
integration.  Following a successful call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}, call {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} again for
the solution of the new problem.

The use of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} requires that the number of Runge
Kutta stages, denoted by \sphinxstyleemphasis{s}, be no larger for the new problem than
for the previous problem.  This condition is automatically fulfilled
if the method order \sphinxstyleemphasis{q} and the problem type (explicit, implicit,
ImEx) are left unchanged.

When using the ARKStep time-stepping module, if there are changes to
the linear solver specifications, the user should make the appropriate
calls to either the linear solver objects themselves, or to the
ARKLS interface routines, as described in the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface functions}}}}. Otherwise, all solver inputs set
previously remain in effect.

One important use of the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} function is in the
treating of jump discontinuities in the RHS functions.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}.  To stop when
the location of the discontinuity is known, simply make that location
a value of \sphinxcode{tout}.  To stop when the location of the discontinuity
is determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS functions \sphinxstyleemphasis{not} incorporate the
discontinuity, but rather have a smooth extension over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
functions (communicated through \sphinxcode{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{ARKStepReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepReInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ fe}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ fi}, realtype\sphinxstyleemphasis{ t0}, N\_Vector\sphinxstyleemphasis{ y0}}{}
Provides required problem specifications and re-initializes the
ARKStep time-stepper module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{fe} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the explicit portion of the right-hand side function in
\(M\, \dot{y} = f^E(t,y) + f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{fi} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the implicit portion of the right-hand side function in
\(M\, \dot{y} = f^E(t,y) + f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the initial value of \(t\).

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the initial condition vector \(y(t_0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
All previously set options are retained but may be updated by calling
the appropriate “Set” functions.

If an error occurred, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} also
sends an error message to the error handler function.

\end{fulllineitems}



\subsection{ARKStep reset function}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-reset}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-reset-function}}
To reset the ARKStep module to a particular independent variable value and
dependent variable vector for the continued solution of a problem, where a prior
call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} has been made, the user must call the function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}}.  Like {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} this routine retains
the current settings for all ARKStep module options and performs no memory
allocations but, unlike {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}, this routine performs only a
\sphinxstyleemphasis{subset} of the input checking and initializations that are done in
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}. In particular this routine retains all internal
counter values and the step size/error history and does not reinitialize the
linear and/or nonlinear solver but it does indicate that a linear solver setup
is necessary in the next step. Following a successful call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}}, call {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} again to continue
solving the problem. By default the next call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} will
use the step size computed by ARKStep prior to calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}}.
To set a different step size or have ARKStep estimate a new step size use
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetInitStep()}}}}.

One important use of the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}} function is in the
treating of jump discontinuities in the RHS functions.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}}.  To stop when
the location of the discontinuity is known, simply make that location
a value of \sphinxcode{tout}.  To stop when the location of the discontinuity
is determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS functions \sphinxstyleemphasis{not} incorporate the
discontinuity, but rather have a smooth extension over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
functions (communicated through \sphinxcode{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{ARKStepReset (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepReset}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tR}, N\_Vector\sphinxstyleemphasis{ yR}}{}
Resets the current ARKStep time-stepper module state to the provided
independent variable value and dependent variable vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{tR} \textendash{} the value of the independent variable \(t\).

\item {} 
\sphinxstyleemphasis{yR} \textendash{} the value of the dependent variable vector \(y(t_R)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
By default the next call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} will use the step size
computed by ARKStep prior to calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}}. To set a
different step size or have ARKStep estimate a new step size use
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetInitStep()}}}}.

All previously set options are retained but may be updated by calling the
appropriate “Set” functions.

If an error occurred, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReset}]{\sphinxcrossref{\sphinxcode{ARKStepReset()}}}} also sends an error message to
the error handler function.

\end{fulllineitems}



\subsection{ARKStep system resize function}
\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-resizing}}\label{\detokenize{ARKStep_c_interface/User_callable:arkstep-system-resize-function}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatially-adaptive
PDE simulations under a method-of-lines approach), the ARKStep
integrator may be “resized” between integration steps, through calls
to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} function. This function modifies
ARKStep’s internal memory structures to use the new problem size,
without destruction of the temporal adaptivity heuristics.  It is
assumed that the dynamical time scales before and after the vector
resize will be comparable, so that all time-stepping heuristics prior
to calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} remain valid after the call.  If
instead the dynamics should be recomputed from scratch, the ARKStep
memory structure should be deleted with a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepFree}]{\sphinxcrossref{\sphinxcode{ARKStepFree()}}}}, and recreated with a calls to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}.

To aid in the vector resize operation, the user can supply a vector
resize function that will take as input a vector with the previous
size, and transform it in-place to return a corresponding vector of
the new size.  If this function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn()}}}})
is not supplied (i.e. is set to \sphinxcode{NULL}), then all existing vectors
internal to ARKStep will be destroyed and re-cloned from the new input
vector.

In the case that the dynamical time scale should be modified slightly
from the previous time scale, an input \sphinxstyleemphasis{hscale} is allowed, that will
rescale the upcoming time step by the specified factor.  If a value
\sphinxstyleemphasis{hscale} \(\le 0\) is specified, the default of 1.0 will be used.
\index{ARKStepResize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepResize}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ ynew}, realtype\sphinxstyleemphasis{ hscale}, realtype\sphinxstyleemphasis{ t0}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{ARKVecResizeFn}}}\sphinxstyleemphasis{ resize}, void*\sphinxstyleemphasis{ resize\_data}}{}
Re-initializes ARKStep with a different state vector but with
comparable dynamical time scale.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ynew} \textendash{} the newly-sized solution vector, holding the current
dependent variable values \(y(t_0)\).

\item {} 
\sphinxstyleemphasis{hscale} \textendash{} the desired scaling factor for the dynamical time
scale (i.e. the next step will be of size \sphinxstyleemphasis{h*hscale}).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the current value of the independent variable
\(t_0\) (this must be consistent with \sphinxstyleemphasis{ynew}).

\item {} 
\sphinxstyleemphasis{resize} \textendash{} the user-supplied vector resize function (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn()}}}}.

\item {} 
\sphinxstyleemphasis{resize\_data} \textendash{} the user-supplied data structure to be passed
to \sphinxstyleemphasis{resize} when modifying internal ARKStep vectors.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ARKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC} if \sphinxstyleemphasis{arkode\_mem} was not allocated.

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If an error occurred, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} also sends an error
message to the error handler function.

If inequality constraint checking is enabled a call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} will disable constraint checking. A call
to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}} is required to re-enable constraint
checking.

\end{fulllineitems}



\subsubsection{Resizing the linear solver}
\label{\detokenize{ARKStep_c_interface/User_callable:resizing-the-linear-solver}}
When using any of the SUNDIALS-provided linear solver modules, the
linear solver memory structures must also be resized.  At present,
none of these include a solver-specific ‘resize’ function, so the linear
solver memory must be destroyed and re-allocated \sphinxstylestrong{following} each
call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}}.  Moreover, the existing ARKLS
interface should then be deleted and recreated by attaching the
updated \sphinxcode{SUNLinearSolver} (and possibly \sphinxcode{SUNMatrix}) object(s)
through calls to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}, and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

If any user-supplied routines are provided to aid the linear solver
(e.g. Jacobian construction, Jacobian-vector product,
mass-matrix-vector product, preconditioning), then the corresponding
“set” routines must be called again \sphinxstylestrong{following} the solver
re-specification.


\subsubsection{Resizing the absolute tolerance array}
\label{\detokenize{ARKStep_c_interface/User_callable:resizing-the-absolute-tolerance-array}}
If using array-valued absolute tolerances, the absolute tolerance
vector will be invalid after the call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}}, so
the new absolute tolerance vector should be re-set \sphinxstylestrong{following} each
call to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} through a new call to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSVtolerances()}}}} (and similarly to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResVtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResVtolerance()}}}} if that was used for the original
problem).

If scalar-valued tolerances or a tolerance function was specified
through either {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSStolerances()}}}} or
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepWFtolerances()}}}}, then these will remain valid and no
further action is necessary.

\begin{sphinxadmonition}{note}{Note:}
For an example of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} usage, see the
supplied serial C example problem, \sphinxcode{ark\_heat1D\_adapt.c}.
\end{sphinxadmonition}


\section{User-supplied functions}
\label{\detokenize{ARKStep_c_interface/User_supplied:user-supplied-functions}}\label{\detokenize{ARKStep_c_interface/User_supplied::doc}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-usersupplied}}
The user-supplied functions for ARKStep consist of:
\begin{itemize}
\item {} 
at least one function defining the ODE (required),

\item {} 
a function that handles error and warning messages (optional),

\item {} 
a function that provides the error weight vector (optional),

\item {} 
a function that provides the residual weight vector (optional),

\item {} 
a function that handles adaptive time step error control (optional),

\item {} 
a function that handles explicit time step stability (optional),

\item {} 
a function that updates the implicit stage prediction (optional),

\item {} 
a function that defines the root-finding problem(s) to solve
(optional),

\item {} 
one or two functions that provide Jacobian-related information for
the linear solver, if a Newton-based nonlinear iteration is chosen
(optional),

\item {} 
one or two functions that define the preconditioner for use in any
of the Krylov iterative algorithms, if a Newton-based nonlinear
iteration and iterative linear solver are chosen (optional), and

\item {} 
if the problem involves a non-identity mass matrix \(M\ne I\):
\begin{itemize}
\item {} 
one or two functions that provide mass-matrix-related information
for the linear and mass matrix solvers (required),

\item {} 
one or two functions that define the mass matrix preconditioner
for use in an iterative mass matrix solver is chosen (optional), and

\end{itemize}

\item {} 
a function that handles vector resizing operations, if the
underlying vector structure supports resizing (as opposed to
deletion/recreation), and if the user plans to call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} (optional).

\end{itemize}


\subsection{ODE right-hand side}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-oderhs}}\label{\detokenize{ARKStep_c_interface/User_supplied:ode-right-hand-side}}
The user must supply at least one function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} to
specify the explicit and/or implicit portions of the ODE system:
\index{ARKRhsFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKRhsFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRhsFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ydot}, void*\sphinxstyleemphasis{ user\_data}}{}
These functions compute the ODE right-hand side for a given
value of the independent variable \(t\) and state vector \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{ydot} \textendash{} the output vector that forms a portion of the ODE RHS \(f^E(t,y) + f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} the \sphinxtitleref{user\_data} pointer that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRhsFn} should return 0 if successful, a positive value if a
recoverable error occurred (in which case ARKStep will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and \sphinxstyleemphasis{ARK\_RHSFUNC\_FAIL} is returned).

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxtitleref{ydot} is handled within the
ARKStep module.

The vector \sphinxstyleemphasis{ydot} may be uninitialized on input; it is the user’s
responsibility to fill this entire vector with meaningful values.

A recoverable failure error return from the \sphinxstyleemphasis{ARKRhsFn} is typically
used to flag a value of the dependent variable \(y\) that is
“illegal” in some way (e.g., negative where only a
non-negative value is physically meaningful).  If such a return is
made, ARKStep will attempt to recover (possibly repeating the
nonlinear iteration, or reducing the step size) in order to avoid
this recoverable error return.  There are some situations in which
recovery is not possible even if the right-hand side function
returns a recoverable error flag.  One is when this occurs at the
very first call to the \sphinxstyleemphasis{ARKRhsFn} (in which case
ARKStep returns \sphinxstyleemphasis{ARK\_FIRST\_RHSFUNC\_ERR}).  Another is when a
recoverable error is reported by \sphinxstyleemphasis{ARKRhsFn} after the integrator
completes a successful stage, in which case ARKStep returns
\sphinxstyleemphasis{ARK\_UNREC\_RHSFUNC\_ERR}).

\end{fulllineitems}



\subsection{Error message handler function}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-errorhandler}}\label{\detokenize{ARKStep_c_interface/User_supplied:error-message-handler-function}}
As an alternative to the default behavior of directing error and
warning messages to the file pointed to by \sphinxtitleref{errfp} (see
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrFile}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrFile()}}}}), the user may provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ARKErrHandlerFn}}}} to process any such messages.
\index{ARKErrHandlerFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKErrHandlerFn}}\pysiglinewithargsret{typedef void \sphinxbfcode{(*ARKErrHandlerFn)}}{int\sphinxstyleemphasis{ error\_code}, const char*\sphinxstyleemphasis{ module}, const char*\sphinxstyleemphasis{ function}, char*\sphinxstyleemphasis{ msg}, void*\sphinxstyleemphasis{ user\_data}}{}
This function processes error and warning messages from
ARKStep and its sub-modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{error\_code} \textendash{} the error code.

\item {} 
\sphinxstyleemphasis{module} \textendash{} the name of the ARKStep module reporting the error.

\item {} 
\sphinxstyleemphasis{function} \textendash{} the name of the function in which the error occurred.

\item {} 
\sphinxstyleemphasis{msg} \textendash{} the error message.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{eh\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrHandlerFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKErrHandlerFn} function has no return value.

\sphinxstylestrong{Notes:} \sphinxstyleemphasis{error\_code} is negative for errors and positive
(\sphinxstyleemphasis{ARK\_WARNING}) for warnings.  If a function that returns a
pointer to memory encounters an error, it sets \sphinxstyleemphasis{error\_code} to
0.

\end{fulllineitems}



\subsection{Error weight function}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-errorweight}}\label{\detokenize{ARKStep_c_interface/User_supplied:error-weight-function}}
As an alternative to providing the relative and absolute tolerances,
the user may provide a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn}}}} to compute a
vector \sphinxstyleemphasis{ewt} containing the weights in the WRMS norm
\(\|v\|_{WRMS} = \left(\frac{1}{n} \sum_{i=1}^n \left(ewt_i\; v_i\right)^2
\right)^{1/2}\).  These weights will be used in place of those defined
in the section {\hyperref[\detokenize{Mathematics:mathematics-error-norm}]{\sphinxcrossref{\DUrole{std,std-ref}{Error norms}}}}.
\index{ARKEwtFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKEwtFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKEwtFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ewt}, void*\sphinxstyleemphasis{ user\_data}}{}
This function computes the WRMS error weights for the vector
\(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the dependent variable vector at which the
weight vector is to be computed.

\item {} 
\sphinxstyleemphasis{ewt} \textendash{} the output vector containing the error weights.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKEwtFn} function must return 0 if it
successfully set the error weights, and -1 otherwise.

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{ewt} is handled within ARKStep.

The error weight vector must have all components positive.  It is
the user’s responsibility to perform this test and return -1 if it
is not satisfied.

\end{fulllineitems}



\subsection{Residual weight function}
\label{\detokenize{ARKStep_c_interface/User_supplied:residual-weight-function}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-residualweight}}
As an alternative to providing the scalar or vector absolute residual
tolerances (when the IVP units differ from the solution units), the
user may provide a function of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKRwtFn}]{\sphinxcrossref{\sphinxcode{ARKRwtFn}}}} to compute a
vector \sphinxstyleemphasis{rwt} containing the weights in the WRMS norm
\(\|v\|_{WRMS} = \left(\frac{1}{n} \sum_{i=1}^n \left(rwt_i\; v_i\right)^2
\right)^{1/2}\).  These weights will be used in place of those defined
in the section {\hyperref[\detokenize{Mathematics:mathematics-error-norm}]{\sphinxcrossref{\DUrole{std,std-ref}{Error norms}}}}.
\index{ARKRwtFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKRwtFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRwtFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ rwt}, void*\sphinxstyleemphasis{ user\_data}}{}
This function computes the WRMS residual weights for the vector
\(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the dependent variable vector at which the
weight vector is to be computed.

\item {} 
\sphinxstyleemphasis{rwt} \textendash{} the output vector containing the residual weights.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRwtFn} function must return 0 if it
successfully set the residual weights, and -1 otherwise.

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{rwt} is handled within ARKStep.

The residual weight vector must have all components positive.  It is
the user’s responsibility to perform this test and return -1 if it
is not satisfied.

\end{fulllineitems}



\subsection{Time step adaptivity function}
\label{\detokenize{ARKStep_c_interface/User_supplied:time-step-adaptivity-function}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-adaptivityfn}}
As an alternative to using one of the built-in time step adaptivity
methods for controlling solution error, the user may provide a
function of type {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}]{\sphinxcrossref{\sphinxcode{ARKAdaptFn}}}} to compute a target step size
\(h\) for the next integration step.  These steps should be chosen
as the maximum value such that the error estimates remain below 1.
\index{ARKAdaptFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKAdaptFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKAdaptFn)}}{N\_Vector\sphinxstyleemphasis{ y}, realtype\sphinxstyleemphasis{ t}, realtype\sphinxstyleemphasis{ h1}, realtype\sphinxstyleemphasis{ h2}, realtype\sphinxstyleemphasis{ h3}, realtype\sphinxstyleemphasis{ e1}, realtype\sphinxstyleemphasis{ e2}, realtype\sphinxstyleemphasis{ e3}, int\sphinxstyleemphasis{ q}, int\sphinxstyleemphasis{ p}, realtype*\sphinxstyleemphasis{ hnew}, void*\sphinxstyleemphasis{ user\_data}}{}
This function implements a time step adaptivity algorithm
that chooses \(h\) satisfying the error tolerances.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{h1} \textendash{} the current step size, \(t_n - t_{n-1}\).

\item {} 
\sphinxstyleemphasis{h2} \textendash{} the previous step size, \(t_{n-1} - t_{n-2}\).

\item {} 
\sphinxstyleemphasis{h3} \textendash{} the step size \(t_{n-2}-t_{n-3}\).

\item {} 
\sphinxstyleemphasis{e1} \textendash{} the error estimate from the current step, \(n\).

\item {} 
\sphinxstyleemphasis{e2} \textendash{} the error estimate from the previous step, \(n-1\).

\item {} 
\sphinxstyleemphasis{e3} \textendash{} the error estimate from the step \(n-2\).

\item {} 
\sphinxstyleemphasis{q} \textendash{} the global order of accuracy for the method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} the global order of accuracy for the embedded method.

\item {} 
\sphinxstyleemphasis{hnew} \textendash{} the output value of the next step size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{h\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKAdaptFn} function should return 0 if it
successfully set the next step size, and a non-zero value otherwise.

\end{fulllineitems}



\subsection{Explicit stability function}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-stabilityfn}}\label{\detokenize{ARKStep_c_interface/User_supplied:explicit-stability-function}}
A user may supply a function to predict the maximum stable step size
for the explicit portion of the ImEx system, \(f^E(t,y)\).  While
the accuracy-based time step adaptivity algorithms may be sufficient
for retaining a stable solution to the ODE system, these may be
inefficient if \(f^E(t,y)\) contains moderately stiff terms.  In
this scenario, a user may provide a function of type {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}]{\sphinxcrossref{\sphinxcode{ARKExpStabFn}}}}
to provide this stability information to ARKStep.  This function
must set the scalar step size satisfying the stability restriction for
the upcoming time step.  This value will subsequently be bounded by
the user-supplied values for the minimum and maximum allowed time
step, and the accuracy-based time step.
\index{ARKExpStabFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKExpStabFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKExpStabFn)}}{N\_Vector\sphinxstyleemphasis{ y}, realtype\sphinxstyleemphasis{ t}, realtype*\sphinxstyleemphasis{ hstab}, void*\sphinxstyleemphasis{ user\_data}}{}
This function predicts the maximum stable step size for the
explicit portions of the ImEx ODE system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{hstab} \textendash{} the output value with the absolute value of the
maximum stable step size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{estab\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStabilityFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKExpStabFn} function should return 0 if it
successfully set the upcoming stable step size, and a non-zero
value otherwise.

\sphinxstylestrong{Notes:}  If this function is not supplied, or if it returns
\sphinxstyleemphasis{hstab} \(\le 0.0\), then ARKStep will assume that there is no explicit
stability restriction on the time step size.

\end{fulllineitems}



\subsection{Implicit stage prediction function}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-stagepredictfn}}\label{\detokenize{ARKStep_c_interface/User_supplied:implicit-stage-prediction-function}}
A user may supply a function to update the prediction for each implicit stage solution.
If supplied, this routine will be called \sphinxstyleemphasis{after} any existing ARKStep predictor
algorithm completes, so that the predictor may be modified by the user as desired.
In this scenario, a user may provide a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKStagePredictFn}]{\sphinxcrossref{\sphinxcode{ARKStagePredictFn}}}}
to provide this implicit predictor to ARKStep.  This function takes as input the
already-predicted implicit stage solution and the corresponding ‘time’ for that prediction;
it then updates the prediction vector as desired.  If the user-supplied routine will
construct a full prediction (and thus the ARKStep prediction is irrelevant), it is
recommended that the user \sphinxstyleemphasis{not} call {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPredictorMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetPredictorMethod()}}}}, thereby leaving
the default trivial predictor in place.
\index{ARKStagePredictFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKStagePredictFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKStagePredictFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ zpred}, void*\sphinxstyleemphasis{ user\_data}}{}
This function updates the prediction for the implicit stage solution.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{zpred} \textendash{} the ARKStep-predicted stage solution on input, and the user-modified
predicted stage solution on output.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKStagePredictFn} function should return 0 if it
successfully set the upcoming stable step size, and a non-zero
value otherwise.

\sphinxstylestrong{Notes:}  This may be useful if there are bound constraints on the solution,
and these should be enforced prior to beginning the nonlinear or linear implicit solver
algorithm.

This routine is incompatible with the “minimum correction predictor” \textendash{} option 5 to the
routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPredictorMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetPredictorMethod()}}}}.  If both are selected, then ARKStep will
override its built-in implicit predictor routine to instead use option 0 (trivial predictor).

\end{fulllineitems}



\subsection{Rootfinding function}
\label{\detokenize{ARKStep_c_interface/User_supplied:rootfinding-function}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-rootfindingfn}}
If a rootfinding problem is to be solved during the integration of the
ODE system, the user must supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{\sphinxcode{ARKRootFn}}}}.
\index{ARKRootFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKRootFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRootFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, realtype*\sphinxstyleemphasis{ gout}, void*\sphinxstyleemphasis{ user\_data}}{}
This function implements a vector-valued function
\(g(t,y)\) such that the roots of the \sphinxstyleemphasis{nrtfn} components
\(g_i(t,y)\) are sought.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{gout} \textendash{} the output array, of length \sphinxstyleemphasis{nrtfn}, with components \(g_i(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRootFn} function should return 0 if successful
or a non-zero value if an error occurred (in which case the
integration is halted and ARKStep returns \sphinxstyleemphasis{ARK\_RTFUNC\_FAIL}).

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{gout} is handled within ARKStep.

\end{fulllineitems}



\subsection{Jacobian construction (matrix-based linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:jacobian-construction-matrix-based-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-jacobianfn}}
If a matrix-based linear solver module is used (i.e., a non-NULL \sphinxcode{SUNMatrix}
object was supplied to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}} in section
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}), the user may provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn}}}} to provide the Jacobian approximation or
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn}}}} to provide an approximation of the linear system
\(\mathcal{A(t,y)} = M(t) - \gamma J(t,y)\).
\index{ARKLsJacFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsJacFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsJacFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, SUNMatrix\sphinxstyleemphasis{ Jac}, void*\sphinxstyleemphasis{ user\_data}, N\_Vector\sphinxstyleemphasis{ tmp1}, N\_Vector\sphinxstyleemphasis{ tmp2}, N\_Vector\sphinxstyleemphasis{ tmp3}}{}
This function computes the Jacobian matrix \(J(t,y) =
\frac{\partial f^I}{\partial y}(t,y)\) (or an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector, namely
the predicted value of \(y(t)\).

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{Jac} \textendash{} the output Jacobian matrix.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp1}, \sphinxstyleemphasis{tmp2}, \sphinxstyleemphasis{tmp3} \textendash{} pointers to memory allocated to
variables of type \sphinxcode{N\_Vector} which can be used by an
ARKLsJacFn as temporary storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKLsJacFn} function should return 0 if successful, a positive
value if a recoverable error occurred (in which case ARKStep will
attempt to correct, while ARKLS sets \sphinxstyleemphasis{last\_flag} to
\sphinxstyleemphasis{ARKLS\_JACFUNC\_RECVR}), or a negative value if it failed
unrecoverably (in which case the integration is halted,
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} returns \sphinxstyleemphasis{ARK\_LSETUP\_FAIL} and ARKLS sets
\sphinxstyleemphasis{last\_flag} to \sphinxstyleemphasis{ARKLS\_JACFUNC\_UNRECVR}).

\sphinxstylestrong{Notes:} Information regarding the structure of the specific
\sphinxcode{SUNMatrix} structure (e.g.\textasciitilde{}number of rows, upper/lower
bandwidth, sparsity type) may be obtained through using the
implementation-specific \sphinxcode{SUNMatrix} interface functions
(see the section {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} for details).

When using a linear solver of type \sphinxcode{SUNLINEARSOLVER\_DIRECT}, prior
to calling the user-supplied Jacobian function, the Jacobian
matrix \(J(t,y)\) is zeroed out, so only nonzero elements need
to be loaded into \sphinxstyleemphasis{Jac}.

With the default nonlinear solver (the native SUNDIALS Netwon method), each
call to the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}} function is preceded by a call to the
implicit {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}} user function with the same \((t,y)\)
arguments. Thus, the Jacobian function can use any auxiliary data that is
computed and saved during the evaluation of the implicit ODE right-hand side.
In the case of a user-supplied or external nonlinear solver, this is also
true if the nonlinear system function is evaluated prior to calling the
linear solver setup function (see {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for more
information).

If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn}}}} function uses difference
quotient approximations, then it may need to access quantities not
in the argument list.  These include the current step size, the
error weights, etc.  To obtain these, the user will need to add a
pointer to the \sphinxcode{ark\_mem} structure to their \sphinxcode{user\_data}, and
then use the ARKStepGet* functions listed in
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\sphinxstylestrong{dense}:

A user-supplied dense Jacobian function must load the
\sphinxstyleemphasis{N} by \sphinxstyleemphasis{N} dense matrix \sphinxstyleemphasis{Jac} with an approximation to the Jacobian
matrix \(J(t,y)\) at the point \((t,y)\). The accessor
macros \sphinxcode{SM\_ELEMENT\_D} and \sphinxcode{SM\_COLUMN\_D} allow the user to read
and write dense matrix elements without making explicit references
to the underlying representation of the SUNMATRIX\_DENSE type.
\sphinxcode{SM\_ELEMENT\_D(J, i, j)} references the \sphinxcode{(i,j)}-th element of
the dense matrix \sphinxcode{J} (for \sphinxcode{i}, \sphinxcode{j} between 0 and
N-1). This macro is meant for small problems for which
efficiency of access is not a major concern. Thus, in terms of the
indices \(m\) and \(n\) ranging from 1 to \sphinxstyleemphasis{N}, the
Jacobian element \(J_{m,n}\) can be set using the statement
\sphinxcode{SM\_ELEMENT\_D(J, m-1, n-1) =} \(J_{m,n}\).  Alternatively,
\sphinxcode{SM\_COLUMN\_D(J, j)} returns a pointer to the first element of the
\sphinxcode{j}-th column of \sphinxcode{J} (for \sphinxcode{j} ranging from 0 to \sphinxtitleref{N}-1),
and the elements of the \sphinxcode{j}-th column can then be accessed using
ordinary array indexing. Consequently, \(J_{m,n}\) can be
loaded using the statements
\sphinxcode{col\_n = SM\_COLUMN\_D(J, n-1); col\_n{[}m-1{]} =} \(J_{m,n}\).
For large problems, it is more efficient to use \sphinxcode{SM\_COLUMN\_D}
than to use \sphinxcode{SM\_ELEMENT\_D}.  Note that both of these macros
number rows and columns starting from 0.  The SUNMATRIX\_DENSE type
and accessor macros are documented in section
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Dense:sunmatrix-dense}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_DENSE Module}}}}.

\sphinxstylestrong{band}:

A user-supplied banded Jacobian function must load the band
matrix \sphinxstyleemphasis{Jac} with the elements of the Jacobian
\(J(t,y)\) at the point \((t,y)\). The accessor macros
\sphinxcode{SM\_ELEMENT\_B}, \sphinxcode{SM\_COLUMN\_B}, and \sphinxcode{SM\_COLUMN\_ELEMENT\_B}
allow the user to read and write band matrix elements without
making specific references to the underlying representation of the
SUNMATRIX\_BAND type.  \sphinxcode{SM\_ELEMENT\_B(J, i, j)} references the
\sphinxcode{(i,j)}-th element of the band matrix \sphinxcode{J}, counting
from 0. This macro is meant for use in small problems for
which efficiency of access is not a major concern. Thus, in terms
of the indices \(m\) and \(n\) ranging from 1 to \sphinxstyleemphasis{N} with
\((m, n)\) within the band defined by \sphinxstyleemphasis{mupper} and
\sphinxstyleemphasis{mlower}, the Jacobian element \(J_{m,n}\) can be loaded
using the statement \sphinxcode{SM\_ELEMENT\_B(J, m-1, n-1)} \(=
J_{m,n}\). The elements within the band are those with \sphinxstyleemphasis{-mupper}
\(\le m-n \le\) \sphinxstyleemphasis{mlower}.  Alternatively, \sphinxcode{SM\_COLUMN\_B(J, j)}
returns a pointer to the diagonal element of the \sphinxcode{j}-th column of
\sphinxcode{J}, and if we assign this address to \sphinxcode{realtype *col\_j}, then
the \sphinxcode{i}-th element of the \sphinxcode{j}-th column is given by
\sphinxcode{SM\_COLUMN\_ELEMENT\_B(col\_j, i, j)}, counting from 0. Thus, for
\((m,n)\) within the band, \(J_{m,n}\) can be loaded by
setting \sphinxcode{col\_n = SM\_COLUMN\_B(J, n-1); SM\_COLUMN\_ELEMENT\_B(col\_n, m-1,
n-1)} \(= J_{m,n}\) . The elements of the \sphinxcode{j}-th column can
also be accessed via ordinary array indexing, but this approach
requires knowledge of the underlying storage for a band matrix of
type SUNMATRIX\_BAND. The array \sphinxcode{col\_n} can be indexed from
\sphinxstyleemphasis{-mupper} to \sphinxstyleemphasis{mlower}. For large problems, it is more efficient
to use \sphinxcode{SM\_COLUMN\_B} and \sphinxcode{SM\_COLUMN\_ELEMENT\_B} than to use the
\sphinxcode{SM\_ELEMENT\_B} macro. As in the dense case, these macros all
number rows and columns starting from 0. The SUNMATRIX\_BAND type
and accessor macros are documented in section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:sunmatrix-band}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_BAND Module}}}}.

\sphinxstylestrong{sparse}:

A user-supplied sparse Jacobian function must load the
compressed-sparse-column (CSC) or compressed-sparse-row (CSR)
matrix \sphinxstyleemphasis{Jac} with an approximation to the Jacobian matrix
\(J(t,y)\) at the point \((t,y)\).  Storage for \sphinxstyleemphasis{Jac}
already exists on entry to this function, although the user should
ensure that sufficient space is allocated in \sphinxstyleemphasis{Jac} to hold the
nonzero values to be set; if the existing space is insufficient the
user may reallocate the data and index arrays as needed.  The
amount of allocated space in a SUNMATRIX\_SPARSE object may be
accessed using the macro \sphinxcode{SM\_NNZ\_S} or the routine
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ}]{\sphinxcrossref{\sphinxcode{SUNSparseMatrix\_NNZ()}}}}.  The SUNMATRIX\_SPARSE type is
further documented in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_SPARSE Module}}}}.

\end{fulllineitems}

\index{ARKLsLinSysFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsLinSysFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsLinSysFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, SUNMatrix\sphinxstyleemphasis{ A}, SUNMatrix\sphinxstyleemphasis{ M}, booleantype\sphinxstyleemphasis{ jok}, booleantype\sphinxstyleemphasis{ *jcur}, realtype\sphinxstyleemphasis{ gamma}, void\sphinxstyleemphasis{ *user\_data}, N\_Vector\sphinxstyleemphasis{ tmp1}, N\_Vector\sphinxstyleemphasis{ tmp2}, N\_Vector\sphinxstyleemphasis{ tmp3}}{}
This function computes the linear system matrix \(\mathcal{A}(t,y) = M(t) - \gamma J(t,y)\) (or
an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector, namely the
predicted value of \(y(t)\).

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{A} \textendash{} the output linear system matrix.

\item {} 
\sphinxstyleemphasis{M} \textendash{} the current mass matrix (this input is \sphinxcode{NULL} if \(M = I\)).

\item {} 
\sphinxstyleemphasis{jok} \textendash{} is an input flag indicating whether the Jacobian-related data
needs to be updated. The \sphinxstyleemphasis{jok} argument provides for the reuse of
Jacobian data. When \sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}, the Jacobian-related data
should be recomputed from scratch. When \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} the Jacobian
data, if saved from the previous call to this function, can be reused
(with the current value of \sphinxstyleemphasis{gamma}). A call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} can
only occur after a call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}.

\item {} 
\sphinxstyleemphasis{jcur} \textendash{} is a pointer to a flag which should be set to \sphinxcode{SUNTRUE} if
Jacobian data was recomputed, or set to \sphinxcode{SUNFALSE} if Jacobian data
was not recomputed, but saved data was still reused.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the scalar \(\gamma\) appearing in the Newton matrix
given by \(\mathcal{A}=M(t)-\gamma J(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the \sphinxstyleemphasis{user\_data}
parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp1}, \sphinxstyleemphasis{tmp2}, \sphinxstyleemphasis{tmp3} \textendash{} pointers to memory allocated to variables of
type \sphinxcode{N\_Vector} which can be used by an ARKLsLinSysFn as temporary
storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKLsLinSysFn} function should return 0 if successful, a positive value
if a recoverable error occurred (in which case ARKStep will attempt to
correct, while ARKLS sets \sphinxstyleemphasis{last\_flag} to \sphinxstyleemphasis{ARKLS\_JACFUNC\_RECVR}), or a
negative value if it failed unrecoverably (in which case the integration is
halted, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} returns \sphinxstyleemphasis{ARK\_LSETUP\_FAIL} and ARKLS sets
\sphinxstyleemphasis{last\_flag} to \sphinxstyleemphasis{ARKLS\_JACFUNC\_UNRECVR}).

\end{fulllineitems}



\subsection{Jacobian-vector product (matrix-free linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-jtimesfn}}\label{\detokenize{ARKStep_c_interface/User_supplied:jacobian-vector-product-matrix-free-linear-solvers}}
When using a matrix-free linear solver module for the implicit
stage solves (i.e., a NULL-valued SUNMATRIX argument was supplied to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}} in the section
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}), the user may provide a function
of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} in the following form, to compute
matrix-vector products \(Jv\). If such a function is not supplied,
the default is a difference quotient approximation to these products.
\index{ARKLsJacTimesVecFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsJacTimesVecFn)}}{N\_Vector\sphinxstyleemphasis{ v}, N\_Vector\sphinxstyleemphasis{ Jv}, realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, void*\sphinxstyleemphasis{ user\_data}, N\_Vector\sphinxstyleemphasis{ tmp}}{}
This function computes the product \(Jv\) where \(J(t,y) \approx
\frac{\partial f^I}{\partial y}(t,y)\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{v} \textendash{} the vector to multiply.

\item {} 
\sphinxstyleemphasis{Jv} \textendash{} the output vector computed.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp} \textendash{} pointer to memory allocated to a variable of type
\sphinxcode{N\_Vector} which can be used as temporary storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the Jacobian-vector product
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the generic Krylov solver,
in which case the integration is halted.

\sphinxstylestrong{Notes:} If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} function
uses difference quotient approximations, it may need to access
quantities not in the argument list.  These include the current
step size, the error weights, etc.  To obtain these, the
user will need to add a pointer to the \sphinxcode{ark\_mem} structure to
their \sphinxcode{user\_data}, and then use the ARKStepGet* functions listed
in {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\end{fulllineitems}



\subsection{Jacobian-vector product setup (matrix-free linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:jacobian-vector-product-setup-matrix-free-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-jtsetupfn}}
If the user’s Jacobian-times-vector routine requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}},
defined as follows:
\index{ARKLsJacTimesSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsJacTimesSetupFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, void*\sphinxstyleemphasis{ user\_data}}{}
This function preprocesses and/or evaluates any Jacobian-related
data needed by the Jacobian-times-vector routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the Jacobian-vector setup
function should be 0 if successful, positive for a recoverable
error (in which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\sphinxstylestrong{Notes:}    Each call to the Jacobian-vector setup function is
preceded by a call to the implicit {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} user
function with the same \((t,y)\) arguments.  Thus, the setup
function can use any auxiliary data that is computed and saved
during the evaluation of the implicit ODE right-hand side.

If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}} function uses
difference quotient approximations, it may need to access
quantities not in the argument list.  These include the current
step size, the error weights, etc.  To obtain these, the
user will need to add a pointer to the \sphinxcode{ark\_mem} structure to
their \sphinxcode{user\_data}, and then use the ARKStepGet* functions listed
in {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\end{fulllineitems}



\subsection{Preconditioner solve (iterative linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-precsolvefn}}\label{\detokenize{ARKStep_c_interface/User_supplied:preconditioner-solve-iterative-linear-solvers}}
If a user-supplied preconditioner is to be used with a SUNLinSol
solver module, then the user must provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSolveFn}}}} to solve the linear system \(Pz=r\),
where \(P\) corresponds to either a left or right
preconditioning matrix.  Here \(P\) should approximate (at least
crudely) the Newton matrix \(\mathcal{A}(t,y)=M(t)-\gamma J(t,y)\),
where \(M(t)\) is the mass matrix and \(J(t,y) = \frac{\partial f^I}{\partial
y}(t,y)\)  If preconditioning is done on both sides, the product of the two
preconditioner matrices should approximate \(\mathcal{A}\).
\index{ARKLsPrecSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsPrecSolveFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, N\_Vector\sphinxstyleemphasis{ r}, N\_Vector\sphinxstyleemphasis{ z}, realtype\sphinxstyleemphasis{ gamma}, realtype\sphinxstyleemphasis{ delta}, int\sphinxstyleemphasis{ lr}, void*\sphinxstyleemphasis{ user\_data}}{}
This function solves the preconditioner system \(Pz=r\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{r} \textendash{} the right-hand side vector of the linear system.

\item {} 
\sphinxstyleemphasis{z} \textendash{} the computed output solution vector.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the scalar \(\gamma\) appearing in the Newton
matrix given by \(\mathcal{A}=M(t)-\gamma J(t,y)\).

\item {} 
\sphinxstyleemphasis{delta} \textendash{} an input tolerance to be used if an iterative method
is employed in the solution.  In that case, the residual vector
\(Res = r-Pz\) of the system should be made to be less than \sphinxstyleemphasis{delta}
in the weighted \(l_2\) norm, i.e. \(\left(\sum_{i=1}^n
\left(Res_i * ewt_i\right)^2 \right)^{1/2} < \delta\), where \(\delta =\)
\sphinxtitleref{delta}.  To obtain the \sphinxcode{N\_Vector} \sphinxstyleemphasis{ewt}, call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetErrWeights()}}}}.

\item {} 
\sphinxstyleemphasis{lr} \textendash{} an input flag indicating whether the preconditioner
solve is to use the left preconditioner (\sphinxstyleemphasis{lr} = 1) or the right
preconditioner (\sphinxstyleemphasis{lr} = 2).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the preconditioner solve
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\end{fulllineitems}



\subsection{Preconditioner setup (iterative linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:preconditioner-setup-iterative-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-precsetupfn}}
If the user’s preconditioner routine requires that any data be
preprocessed or evaluated, then these actions need to occur within a
user-supplied function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn}}}}.
\index{ARKLsPrecSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsPrecSetupFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, booleantype\sphinxstyleemphasis{ jok}, booleantype*\sphinxstyleemphasis{ jcurPtr}, realtype\sphinxstyleemphasis{ gamma}, void*\sphinxstyleemphasis{ user\_data}}{}
This function preprocesses and/or evaluates Jacobian-related
data needed by the preconditioner.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{jok} \textendash{} is an input flag indicating whether the Jacobian-related
data needs to be updated. The \sphinxstyleemphasis{jok} argument provides for the
reuse of Jacobian data in the preconditioner solve function. When
\sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}, the Jacobian-related data should be recomputed
from scratch. When \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} the Jacobian data, if saved from the
previous call to this function, can be reused (with the current
value of \sphinxstyleemphasis{gamma}). A call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} can only occur
after a call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}.

\item {} 
\sphinxstyleemphasis{jcurPtr} \textendash{} is a pointer to a flag which should be set to
\sphinxcode{SUNTRUE} if Jacobian data was recomputed, or set to \sphinxcode{SUNFALSE} if
Jacobian data was not recomputed, but saved data was still reused.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the scalar \(\gamma\) appearing in the Newton
matrix given by \(\mathcal{A}=M(t)-\gamma J(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the preconditioner setup
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\sphinxstylestrong{Notes:}  The operations performed by this function might include
forming a crude approximate Jacobian, and performing an LU
factorization of the resulting approximation to \(\mathcal{A} = M(t) -
\gamma J(t,y)\).

With the default nonlinear solver (the native SUNDIALS Netwon method), each
call to the preconditioner setup function is preceded by a call to the
implicit {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} user function with the same \((t,y)\)
arguments.  Thus, the preconditioner setup function can use any auxiliary
data that is computed and saved during the evaluation of the implicit ODE
right-hand side. In the case of a user-supplied or external nonlinear solver,
this is also true if the nonlinear system function is evaluated prior to
calling the linear solver setup function (see
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for more information).

This function is not called in advance of every call to the
preconditioner solve function, but rather is called only as often
as needed to achieve convergence in the Newton iteration.

If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn}}}} function uses
difference quotient approximations, it may need to access
quantities not in the call list. These include the current step
size, the error weights, etc.  To obtain these, the user will need
to add a pointer to the \sphinxcode{ark\_mem} structure to their
\sphinxcode{user\_data}, and then use the ARKStepGet* functions listed in
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\end{fulllineitems}



\subsection{Mass matrix construction (matrix-based linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:mass-matrix-construction-matrix-based-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-massfn}}
If a matrix-based mass-matrix linear solver is used (i.e., a non-NULL
SUNMATRIX was supplied to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}} in
the section {\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}), the user must provide a function
of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn}}}} to provide the mass matrix
approximation.
\index{ARKLsMassFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsMassFn)}}{realtype\sphinxstyleemphasis{ t}, SUNMatrix\sphinxstyleemphasis{ M}, void*\sphinxstyleemphasis{ user\_data}, N\_Vector\sphinxstyleemphasis{ tmp1}, N\_Vector\sphinxstyleemphasis{ tmp2}, N\_Vector\sphinxstyleemphasis{ tmp3}}{}
This function computes the mass matrix \(M(t)\) (or an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{M} \textendash{} the output mass matrix.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp1}, \sphinxstyleemphasis{tmp2}, \sphinxstyleemphasis{tmp3} \textendash{} pointers to memory allocated to
variables of type \sphinxcode{N\_Vector} which can be used by an
ARKLsMassFn as temporary storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKLsMassFn} function should return 0 if successful, or a
negative value if it failed unrecoverably (in which case the
integration is halted, {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} returns
\sphinxstyleemphasis{ARK\_MASSSETUP\_FAIL} and ARKLS sets \sphinxstyleemphasis{last\_flag} to
\sphinxstyleemphasis{ARKLS\_MASSFUNC\_UNRECVR}).

\sphinxstylestrong{Notes:} Information regarding the structure of the specific
\sphinxcode{SUNMatrix} structure (e.g.\textasciitilde{}number of rows, upper/lower
bandwidth, sparsity type) may be obtained through using the
implementation-specific \sphinxcode{SUNMatrix} interface functions
(see the section {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} for details).

Prior to calling the user-supplied mass matrix function, the mass
matrix \(M(t)\) is zeroed out, so only nonzero elements need to
be loaded into \sphinxstyleemphasis{M}.

\sphinxstylestrong{dense}:

A user-supplied dense mass matrix function must load the \sphinxstyleemphasis{N} by \sphinxstyleemphasis{N}
dense matrix \sphinxstyleemphasis{M} with an approximation to the mass matrix
\(M(t)\). As discussed above in section {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-jacobianfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobian construction (matrix-based linear solvers)}}}},
the accessor macros \sphinxcode{SM\_ELEMENT\_D} and \sphinxcode{SM\_COLUMN\_D} allow the user
to read and write dense matrix elements without making explicit
references to the underlying representation of the SUNMATRIX\_DENSE
type. Similarly, the SUNMATRIX\_DENSE type and accessor macros
\sphinxcode{SM\_ELEMENT\_D} and \sphinxcode{SM\_COLUMN\_D} are documented in the section
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Dense:sunmatrix-dense}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_DENSE Module}}}}.

\sphinxstylestrong{band}:

A user-supplied banded mass matrix function must load
the band matrix \sphinxstyleemphasis{M} with the elements of the mass matrix
\(M(t)\). As discussed above in section
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-jacobianfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Jacobian construction (matrix-based linear solvers)}}}}, the accessor macros \sphinxcode{SM\_ELEMENT\_B},
\sphinxcode{SM\_COLUMN\_B}, and \sphinxcode{SM\_COLUMN\_ELEMENT\_B} allow the user to read
and write band matrix elements without making specific references
to the underlying representation of the SUNMATRIX\_BAND type.
Similarly, the SUNMATRIX\_BAND type and the accessor macros \sphinxcode{SM\_ELEMENT\_B},
\sphinxcode{SM\_COLUMN\_B}, and \sphinxcode{SM\_COLUMN\_ELEMENT\_B} are documented in the section
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:sunmatrix-band}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_BAND Module}}}}.

\sphinxstylestrong{sparse}:

A user-supplied sparse mass matrix function must load the
compressed-sparse-column (CSR) or compressed-sparse-row (CSR)
matrix \sphinxstyleemphasis{M} with an approximation to the mass matrix \(M(t)\).
Storage for \sphinxstyleemphasis{M} already exists on entry to this function, although
the user should ensure that sufficient space is allocated in \sphinxstyleemphasis{M}
to hold the nonzero values to be set; if the existing space is
insufficient the user may reallocate the data and row index arrays
as needed.  The type of \sphinxstyleemphasis{M} is SUNMATRIX\_SPARSE, and the amount of
allocated space in a SUNMATRIX\_SPARSE object may be
accessed using the macro \sphinxcode{SM\_NNZ\_S} or the routine
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ}]{\sphinxcrossref{\sphinxcode{SUNSparseMatrix\_NNZ()}}}}.  The SUNMATRIX\_SPARSE type is
further documented in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_SPARSE Module}}}}.

\end{fulllineitems}



\subsection{Mass matrix-vector product (matrix-free linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-mtimesfn}}\label{\detokenize{ARKStep_c_interface/User_supplied:mass-matrix-vector-product-matrix-free-linear-solvers}}
If a matrix-free linear solver is to be used for mass-matrix linear
systems (i.e., a NULL-valued SUNMATRIX argument was supplied to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}} in the section
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}), the user \sphinxstyleemphasis{must} provide a
function of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesVecFn}}}} in the following form, to
compute matrix-vector products \(M(t)\, v\).
\index{ARKLsMassTimesVecFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsMassTimesVecFn)}}{N\_Vector\sphinxstyleemphasis{ v}, N\_Vector\sphinxstyleemphasis{ Mv}, realtype\sphinxstyleemphasis{ t}, void*\sphinxstyleemphasis{ mtimes\_data}}{}
This function computes the product \(M(t)\, v\) (or an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{v} \textendash{} the vector to multiply.

\item {} 
\sphinxstyleemphasis{Mv} \textendash{} the output vector computed.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{mtimes\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{mtimes\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the mass-matrix-vector product
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the generic Krylov solver,
in which case the integration is halted.

\end{fulllineitems}



\subsection{Mass matrix-vector product setup (matrix-free linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:mass-matrix-vector-product-setup-matrix-free-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-mtsetupfn}}
If the user’s mass-matrix-times-vector routine requires that any mass
matrix-related data be preprocessed or evaluated, then this needs to
be done in a user-supplied function of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn}}}}, defined as follows:
\index{ARKLsMassTimesSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsMassTimesSetupFn)}}{realtype\sphinxstyleemphasis{ t}, void*\sphinxstyleemphasis{ mtimes\_data}}{}
This function preprocesses and/or evaluates any mass-matrix-related
data needed by the mass-matrix-times-vector routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{mtimes\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{mtimes\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the mass-matrix-vector setup
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the ARKLS mass matrix solver
interface, in which case the integration is halted.

\end{fulllineitems}



\subsection{Mass matrix preconditioner solve (iterative linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:mass-matrix-preconditioner-solve-iterative-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-massprecsolvefn}}
If a user-supplied preconditioner is to be used with a SUNLINEAR
solver module for mass matrix linear systems, then the user must
provide a function of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSolveFn}}}} to solve the
linear system \(Pz=r\), where \(P\) may be either a left or right
preconditioning matrix.  Here \(P\) should approximate (at least
crudely) the mass matrix \(M(t)\).  If preconditioning is done on
both sides, the product of the two preconditioner matrices should
approximate \(M(t)\).
\index{ARKLsMassPrecSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSolveFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsMassPrecSolveFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ r}, N\_Vector\sphinxstyleemphasis{ z}, realtype\sphinxstyleemphasis{ delta}, int\sphinxstyleemphasis{ lr}, void*\sphinxstyleemphasis{ user\_data}}{}
This function solves the preconditioner system \(Pz=r\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{r} \textendash{} the right-hand side vector of the linear system.

\item {} 
\sphinxstyleemphasis{z} \textendash{} the computed output solution vector.

\item {} 
\sphinxstyleemphasis{delta} \textendash{} an input tolerance to be used if an iterative method
is employed in the solution.  In that case, the residual vector
\(Res = r-Pz\) of the system should be made to be less than \sphinxstyleemphasis{delta}
in the weighted \(l_2\) norm, i.e. \(\left(\sum_{i=1}^n
\left(Res_i * ewt_i\right)^2 \right)^{1/2} < \delta\), where \(\delta =\)
\sphinxstyleemphasis{delta}.  To obtain the \sphinxcode{N\_Vector} \sphinxstyleemphasis{ewt}, call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetErrWeights()}}}}.

\item {} 
\sphinxstyleemphasis{lr} \textendash{} an input flag indicating whether the preconditioner
solve is to use the left preconditioner (\sphinxstyleemphasis{lr} = 1) or the right
preconditioner (\sphinxstyleemphasis{lr} = 2).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the preconditioner solve
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\end{fulllineitems}



\subsection{Mass matrix preconditioner setup (iterative linear solvers)}
\label{\detokenize{ARKStep_c_interface/User_supplied:mass-matrix-preconditioner-setup-iterative-linear-solvers}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-massprecsetupfn}}
If the user’s mass matrix preconditioner above requires that any
problem data be preprocessed or evaluated, then these actions need to
occur within a user-supplied function of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSetupFn}}}}.
\index{ARKLsMassPrecSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsMassPrecSetupFn)}}{realtype\sphinxstyleemphasis{ t}, void*\sphinxstyleemphasis{ user\_data}}{}
This function preprocesses and/or evaluates mass-matrix-related
data needed by the preconditioner.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the mass matrix preconditioner setup
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\sphinxstylestrong{Notes:}  The operations performed by this function might include
forming a mass matrix and performing an incomplete
factorization of the result.  Although such operations would
typically be performed only once at the beginning of a simulation,
these may be required if the mass matrix can change as a function
of time.

If both this function and a {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn}}}} are
supplied, all calls to this function will be preceded by a call to
the {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn}}}}, so any setup performed
there may be reused.

\end{fulllineitems}



\subsection{Vector resize function}
\label{\detokenize{ARKStep_c_interface/User_supplied:vector-resize-function}}\label{\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-vecresizefn}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatial adaptivity in a
PDE simulation), the ARKStep integrator may be “resized” between
integration steps, through calls to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}}
function. Typically, when performing adaptive simulations the solution
is stored in a customized user-supplied data structure, to enable
adaptivity without repeated allocation/deallocation of memory.  In
these scenarios, it is recommended that the user supply a customized
vector kernel to interface between SUNDIALS and their problem-specific
data structure.  If this vector kernel includes a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn}}}} to resize a given vector implementation, then
this function may be supplied to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} so that all
internal ARKStep vectors may be resized, instead of deleting and
re-creating them at each call.  This resize function should have the
following form:
\index{ARKVecResizeFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/User_supplied:c.ARKVecResizeFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKVecResizeFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ytemplate}, void*\sphinxstyleemphasis{ user\_data}}{}
This function resizes the vector \sphinxstyleemphasis{y} to match the dimensions of the
supplied vector, \sphinxstyleemphasis{ytemplate}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the vector to resize.

\item {} 
\sphinxstyleemphasis{ytemplate} \textendash{} a vector of the desired size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{resize\_data} parameter that was passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKVecResizeFn} function should return 0 if it successfully
resizes the vector \sphinxstyleemphasis{y}, and a non-zero value otherwise.

\sphinxstylestrong{Notes:}  If this function is not supplied, then ARKStep will
instead destroy the vector \sphinxstyleemphasis{y} and clone a new vector \sphinxstyleemphasis{y} off of
\sphinxstyleemphasis{ytemplate}.

\end{fulllineitems}



\section{Preconditioner modules}
\label{\detokenize{ARKStep_c_interface/Preconditioners:preconditioner-modules}}\label{\detokenize{ARKStep_c_interface/Preconditioners::doc}}\label{\detokenize{ARKStep_c_interface/Preconditioners:arkstep-cinterface-preconditionermodules}}
The efficiency of Krylov iterative methods for the solution of linear
systems can be greatly enhanced through preconditioning.  For problems
in which the user cannot define a more effective, problem-specific
preconditioner, ARKode provides two internal preconditioner modules
that may be used by ARKStep: a banded preconditioner for serial and
threaded problems (ARKBANDPRE) and a band-block-diagonal
preconditioner for parallel problems (ARKBBDPRE).


\subsection{A serial banded preconditioner module}
\label{\detokenize{ARKStep_c_interface/Preconditioners:a-serial-banded-preconditioner-module}}\label{\detokenize{ARKStep_c_interface/Preconditioners:arkstep-cinterface-bandpre}}
This preconditioner provides a band matrix preconditioner for use with
iterative SUNLINSOL modules through the ARKLS linear solver interface,
in a serial or threaded setting. It requires that the problem be set
up using either the
NVECTOR\_SERIAL, NVECTOR\_OPENMP or NVECTOR\_PTHREADS module, due to data
access patterns.  It also currently requires that the problem involve
an identity mass matrix, i.e. \(M = I\).

This module uses difference quotients of the ODE right-hand
side function \(f^I\) to generate a band matrix of bandwidth
\sphinxcode{ml + mu + 1}, where the number of super-diagonals (\sphinxcode{mu}, the
upper half-bandwidth) and sub-diagonals (\sphinxcode{ml}, the lower
half-bandwidth) are specified by the user.  This band matrix is used
to to form a preconditioner the Krylov linear solver.  Although this
matrix is intended to approximate the Jacobian
\(J = \frac{\partial f^I}{\partial y}\), it may be a very crude
approximation, since the true Jacobian may not be banded, or its true
bandwidth may be larger than \sphinxcode{ml + mu + 1}.  However, as long as the
banded approximation generated for the preconditioner is sufficiently
accurate, it may speed convergence of the Krylov iteration.


\subsubsection{ARKBANDPRE usage}
\label{\detokenize{ARKStep_c_interface/Preconditioners:arkbandpre-usage}}
In order to use the ARKBANDPRE module, the user need not define
any additional functions.  In addition to the header files required
for the integration of the ODE problem (see the section
{\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-headers}]{\sphinxcrossref{\DUrole{std,std-ref}{Access to library and header files}}}}), to use the ARKBANDPRE module, the user’s
program must include the header file \sphinxcode{arkode\_bandpre.h} which
declares the needed function prototypes.  The following is a summary
of the usage of this module.  Steps that are unchanged from the
skeleton program presented in {\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}} are
\sphinxstyleemphasis{italicized}.
\begin{enumerate}
\item {} 
\sphinxstyleemphasis{Initialize multi-threaded environment (if appropriate)}

\item {} 
\sphinxstyleemphasis{Set problem dimensions}

\item {} 
\sphinxstyleemphasis{Set vector of initial values}

\item {} 
\sphinxstyleemphasis{Create ARKStep object}

\item {} 
\sphinxstyleemphasis{Specify integration tolerances}

\item {} 
Create iterative linear solver object

When creating the iterative linear solver object, specify the type
of preconditioning (\sphinxcode{PREC\_LEFT} or \sphinxcode{PREC\_RIGHT}) to use.

\item {} 
\sphinxstyleemphasis{Set linear solver optional inputs}

\item {} 
\sphinxstyleemphasis{Attach linear solver module}

\item {} 
Initialize the ARKBANDPRE preconditioner module
\begin{quote}

Specify the upper and lower half-bandwidths (\sphinxcode{mu} and \sphinxcode{ml},
respectively) and call

\sphinxcode{ier = ARKBandPrecInit(arkode\_mem, N, mu, ml);}

to allocate memory and initialize the internal preconditioner
data.
\end{quote}

\item {} 
\sphinxstyleemphasis{Set optional inputs}

Note that the user should not call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetPreconditioner()}}}} as it will overwrite the
preconditioner setup and solve functions.

\item {} 
\sphinxstyleemphasis{Create nonlinear solver object}

\item {} 
\sphinxstyleemphasis{Attach nonlinear solver module}

\item {} 
\sphinxstyleemphasis{Set nonlinear solver optional inputs}

\item {} 
\sphinxstyleemphasis{Specify rootfinding problem}

\item {} 
\sphinxstyleemphasis{Advance solution in time}

\item {} 
Get optional outputs

Additional optional outputs associated with ARKBANDPRE are
available by way of the two routines described below,
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetWorkSpace()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetNumRhsEvals()}}}}.

\item {} 
\sphinxstyleemphasis{Deallocate memory for solution vector}

\item {} 
\sphinxstyleemphasis{Free solver memory}

\item {} 
\sphinxstyleemphasis{Free linear solver memory}

\end{enumerate}


\subsubsection{ARKBANDPRE user-callable functions}
\label{\detokenize{ARKStep_c_interface/Preconditioners:arkbandpre-user-callable-functions}}
The ARKBANDPRE preconditioner module is initialized and attached
by calling the following function:
\index{ARKBandPrecInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecInit}}\pysiglinewithargsret{int \sphinxbfcode{ARKBandPrecInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, sunindextype\sphinxstyleemphasis{ N}, sunindextype\sphinxstyleemphasis{ mu}, sunindextype\sphinxstyleemphasis{ ml}}{}
Initializes the ARKBANDPRE preconditioner and
allocates required (internal) memory for it.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{N} \textendash{} problem dimension (size of ODE system).

\item {} 
\sphinxstyleemphasis{mu} \textendash{} upper half-bandwidth of the Jacobian approximation.

\item {} 
\sphinxstyleemphasis{ml} \textendash{} lower half-bandwidth of the Jacobian approximation.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_FAIL} if a memory allocation request failed

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The banded approximate Jacobian will have nonzero elements
only in locations \((i,j)\) with \sphinxstyleemphasis{ml} \(\le j-i \le\) \sphinxstyleemphasis{mu}.

\end{fulllineitems}


The following two optional output functions are available for use with
the ARKBANDPRE module:
\index{ARKBandPrecGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{ARKBandPrecGetWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrwLS}, long int*\sphinxstyleemphasis{ leniwLS}}{}
Returns the sizes of the ARKBANDPRE real and integer
workspaces.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lenrwLS} \textendash{} the number of \sphinxcode{realtype} values in the
ARKBANDPRE workspace.

\item {} 
\sphinxstyleemphasis{leniwLS} \textendash{} the number of integer values in the  ARKBANDPRE workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_PMEM\_NULL} if the preconditioner memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within the ARKBANDPRE module
(the banded matrix approximation, banded \sphinxcode{SUNLinearSolver}
object, and temporary vectors).

The workspaces referred to here exist in addition to those given by
the corresponding function \sphinxcode{ARKStepGetLSWorkspace()}.

\end{fulllineitems}

\index{ARKBandPrecGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKBandPrecGetNumRhsEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nfevalsBP}}{}
Returns the number of calls made to the user-supplied
right-hand side function \(f^I\) for constructing the
finite-difference banded Jacobian approximation used within the
preconditioner setup function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{nfevalsBP} \textendash{} number of calls to \(f^I\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_PMEM\_NULL} if the preconditioner memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The counter \sphinxstyleemphasis{nfevalsBP} is distinct from the counter
\sphinxstyleemphasis{nfevalsLS} returned by the corresponding function
\sphinxcode{ARKStepGetNumLSRhsEvals()} and also from \sphinxstyleemphasis{nfi\_evals} returned by
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumRhsEvals()}}}}.  The total number of right-hand
side function evaluations is the sum of all three of these
counters, plus the \sphinxstyleemphasis{nfe\_evals} counter for \(f^E\) calls
returned by {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumRhsEvals()}}}}.

\end{fulllineitems}



\subsection{A parallel band-block-diagonal preconditioner module}
\label{\detokenize{ARKStep_c_interface/Preconditioners:arkstep-cinterface-bbdpre}}\label{\detokenize{ARKStep_c_interface/Preconditioners:a-parallel-band-block-diagonal-preconditioner-module}}
A principal reason for using a parallel ODE solver (such as ARKode)
lies in the solution of partial differential equations
(PDEs). Moreover, Krylov iterative methods are used on many such
problems due to the nature of the underlying linear system of
equations that needs to solved at each time step.  For many PDEs, the
linear algebraic system is large, sparse and structured.  However, if
a Krylov iterative method is to be effective in this setting, then a
nontrivial preconditioner is required.  Otherwise, the rate of
convergence of the Krylov iterative method is usually slow, and
degrades as the PDE mesh is refined.  Typically, an effective
preconditioner must be problem-specific.

However, we have developed one type of preconditioner that treats a
rather broad class of PDE-based problems.  It has been successfully
used with CVODE for several realistic, large-scale problems \phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:id1}}{\hyperref[\detokenize{References:ht1998}]{\sphinxcrossref{{[}HT1998{]}}}}.
It is included in a software module within the ARKode package, and is
accessible within the ARKStep time stepping module.  This
preconditioning module works with the parallel vector module
NVECTOR\_PARALLEL and is usable with any of the Krylov iterative linear
solvers through the ARKLS interface. It generates a preconditioner
that is a block-diagonal matrix with each block being a band
matrix. The blocks need not have the same number of super- and
sub-diagonals and these numbers may vary from block to block. This
Band-Block-Diagonal Preconditioner module is called ARKBBDPRE.

One way to envision these preconditioners is to think of the
computational PDE domain as being subdivided into \(Q\)
non-overlapping subdomains, where each subdomain is assigned to one of
the \(Q\) MPI tasks used to solve the ODE system.  The basic idea
is to isolate the preconditioning so that it is local to each process,
and also to use a (possibly cheaper) approximate right-hand side
function for construction of this preconditioning matrix.  This
requires the definition of a new function \(g(t,y) \approx
f^I(t,y)\) that will be used to construct the BBD preconditioner
matrix.  At present, we assume that the ODE be written in explicit
form as
\begin{equation*}
\begin{split}\dot{y} = f^E(t,y) + f^I(t,y),\end{split}
\end{equation*}
where \(f^I\) corresponds to the ODE components to be treated
implicitly, i.e. this preconditioning module does not support problems
with non-identity mass matrices.  The user may set \(g = f^I\), if
no less expensive approximation is desired.

Corresponding to the domain decomposition, there is a decomposition of
the solution vector \(y\) into \(Q\) disjoint blocks
\(y_q\), and a decomposition of \(g\) into blocks
\(g_q\). The block \(g_q\) depends both on \(y_p\) and on
components of blocks \(y_{q'}\) associated with neighboring
subdomains (so-called ghost-cell data).  If we let \(\bar{y}_q\)
denote \(y_q\) augmented with those other components on which
\(g_q\) depends, then we have
\begin{equation*}
\begin{split}g(t,y) = \left[ g_1(t,\bar{y}_1), g_2(t,\bar{y}_2), \ldots , g_Q(t,\bar{y}_Q) \right]^T,\end{split}
\end{equation*}
and each of the blocks \(g_q(t,\bar{y}_q)\) is decoupled from one another.

The preconditioner associated with this decomposition has the form
\begin{equation*}
\begin{split}P = \text{diag}[P_1, P_2, \ldots, P_Q]\end{split}
\end{equation*}
where
\begin{equation*}
\begin{split}P_q \approx I - \gamma J_q\end{split}
\end{equation*}
and where \(J_q\) is a difference quotient approximation to
\(\frac{\partial g_q}{\partial \bar{y}_q}\).  This matrix is taken
to be banded, with upper and lower half-bandwidths \sphinxstyleemphasis{mudq} and
\sphinxstyleemphasis{mldq} defined as the number of non-zero diagonals above and below
the main diagonal, respectively.  The difference quotient
approximation is computed using \sphinxstyleemphasis{mudq} + \sphinxstyleemphasis{mldq} + 2 evaluations of
\(g_m\), but only a matrix of bandwidth \sphinxstyleemphasis{mukeep} + \sphinxstyleemphasis{mlkeep} + 1 is
retained. Neither pair of parameters need be the true half-bandwidths
of the Jacobian of the local block of \(g\), if smaller values
provide a more efficient preconditioner. The solution of the complete
linear system
\begin{equation*}
\begin{split}Px = b\end{split}
\end{equation*}
reduces to solving each of the distinct equations
\begin{equation*}
\begin{split}P_q x_q = b_q, \quad q=1,\ldots,Q,\end{split}
\end{equation*}
and this is done by banded LU factorization of \(P_q\) followed by
a banded backsolve.

Similar block-diagonal preconditioners could be considered with
different treatments of the blocks \(P_q\).  For example,
incomplete LU factorization or an iterative method could be used
instead of banded LU factorization.


\subsubsection{ARKBBDPRE user-supplied functions}
\label{\detokenize{ARKStep_c_interface/Preconditioners:arkbbdpre-user-supplied-functions}}
The ARKBBDPRE module calls two user-provided functions to construct
\(P\): a required function \sphinxstyleemphasis{gloc} (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{\sphinxcode{ARKLocalFn()}}}})
which approximates the right-hand side function \(g(t,y) \approx
f^I(t,y)\) and which is computed locally, and an optional function
\sphinxstyleemphasis{cfn} (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}]{\sphinxcrossref{\sphinxcode{ARKCommFn()}}}}) which performs all inter-process
communication necessary to evaluate the approximate right-hand side
\(g\). These are in addition to the user-supplied right-hand side
function \(f^I\). Both functions take as input the same pointer
\sphinxstyleemphasis{user\_data} that is passed by the user to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}} and that was passed to the user’s
function \(f^I\). The user is responsible for providing space
(presumably within \sphinxstyleemphasis{user\_data}) for components of \(y\) that are
communicated between processes by \sphinxstyleemphasis{cfn}, and that are then used by
\sphinxstyleemphasis{gloc}, which should not do any communication.
\index{ARKLocalFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLocalFn)}}{sunindextype\sphinxstyleemphasis{ Nlocal}, realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ glocal}, void*\sphinxstyleemphasis{ user\_data}}{}
This \sphinxstyleemphasis{gloc} function computes \(g(t,y)\).  It
fills the vector \sphinxstyleemphasis{glocal} as a function of \sphinxstyleemphasis{t} and \sphinxstyleemphasis{y}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Nlocal} \textendash{} the local vector length.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the value of the dependent variable vector on this process.

\item {} 
\sphinxstyleemphasis{glocal} \textendash{} the output vector of \(g(t,y)\) on this process.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKLocalFn} should return 0 if successful, a positive value if
a recoverable error occurred (in which case ARKStep will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} will return
\sphinxstyleemphasis{ARK\_LSETUP\_FAIL}).

\sphinxstylestrong{Notes:}  This function should assume that all inter-process
communication of data needed to calculate \sphinxstyleemphasis{glocal} has already been
done, and that this data is accessible within user data.

The case where \(g\) is mathematically identical to \(f^I\)
is allowed.

\end{fulllineitems}

\index{ARKCommFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKCommFn)}}{sunindextype\sphinxstyleemphasis{ Nlocal}, realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, void*\sphinxstyleemphasis{ user\_data}}{}
This \sphinxstyleemphasis{cfn} function performs all inter-process
communication necessary for the execution of the \sphinxstyleemphasis{gloc} function
above, using the input vector \sphinxstyleemphasis{y}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Nlocal} \textendash{} the local vector length.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the value of the dependent variable vector on this process.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter passed to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKCommFn} should return 0 if successful, a positive value if a
recoverable error occurred (in which case ARKStep will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} will return
\sphinxstyleemphasis{ARK\_LSETUP\_FAIL}).

\sphinxstylestrong{Notes:}  The \sphinxstyleemphasis{cfn} function is expected to save communicated data in
space defined within the data structure \sphinxstyleemphasis{user\_data}.

Each call to the \sphinxstyleemphasis{cfn} function is preceded by a call to the
right-hand side function \(f^I\) with the same \((t,y)\)
arguments. Thus, \sphinxstyleemphasis{cfn} can omit any communication done by
\(f^I\) if relevant to the evaluation of \sphinxstyleemphasis{glocal}. If all
necessary communication was done in \(f^I\), then \sphinxstyleemphasis{cfn} =
\sphinxcode{NULL} can be passed in the call to {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecInit()}}}}
(see below).

\end{fulllineitems}



\subsubsection{ARKBBDPRE usage}
\label{\detokenize{ARKStep_c_interface/Preconditioners:arkbbdpre-usage}}
In addition to the header files required for the integration of the
ODE problem (see the section {\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-headers}]{\sphinxcrossref{\DUrole{std,std-ref}{Access to library and header files}}}}), to use the
ARKBBDPRE module, the user’s program must include the header file
\sphinxcode{arkode\_bbdpre.h} which declares the needed function prototypes.

The following is a summary of the proper usage of this module. Steps
that are unchanged from the skeleton program presented in
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}} are \sphinxstyleemphasis{italicized}.
\begin{enumerate}
\item {} 
\sphinxstyleemphasis{Initialize MPI}

\item {} 
\sphinxstyleemphasis{Set problem dimensions}

\item {} 
\sphinxstyleemphasis{Set vector of initial values}

\item {} 
\sphinxstyleemphasis{Create ARKStep object}

\item {} 
\sphinxstyleemphasis{Specify integration tolerances}

\item {} 
Create iterative linear solver object

When creating the iterative linear solver object, specify the type
of preconditioning (\sphinxcode{PREC\_LEFT} or \sphinxcode{PREC\_RIGHT}) to use.

\item {} 
\sphinxstyleemphasis{Set linear solver optional inputs}

\item {} 
\sphinxstyleemphasis{Attach linear solver module}

\item {} 
Initialize the ARKBBDPRE preconditioner module

Specify the upper and lower half-bandwidths for computation
\sphinxcode{mudq} and \sphinxcode{mldq}, the upper and lower half-bandwidths for
storage \sphinxcode{mukeep} and \sphinxcode{mlkeep}, and call

\sphinxcode{ier = ARKBBDPrecInit(arkode\_mem, Nlocal, mudq, mldq, mukeep, mlkeep, dqrely, gloc, cfn);}

to allocate memory and initialize the internal preconditioner
data. The last two arguments of {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecInit()}}}} are the
two user-supplied functions of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{\sphinxcode{ARKLocalFn()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}]{\sphinxcrossref{\sphinxcode{ARKCommFn()}}}} described above, respectively.

\item {} 
\sphinxstyleemphasis{Set optional inputs}

Note that the user should not call
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetPreconditioner()}}}} as it will overwrite the
preconditioner setup and solve functions.

\item {} 
\sphinxstyleemphasis{Create nonlinear solver object}

\item {} 
\sphinxstyleemphasis{Attach nonlinear solver module}

\item {} 
\sphinxstyleemphasis{Set nonlinear solver optional inputs}

\item {} 
\sphinxstyleemphasis{Specify rootfinding problem}

\item {} 
\sphinxstyleemphasis{Advance solution in time}

\item {} 
\sphinxstyleemphasis{Get optional outputs}

Additional optional outputs associated with ARKBBDPRE are
available through the routines
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecGetWorkSpace()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetNumGfnEvals}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecGetNumGfnEvals()}}}}.

\item {} 
\sphinxstyleemphasis{Deallocate memory for solution vector}

\item {} 
\sphinxstyleemphasis{Free solver memory}

\item {} 
\sphinxstyleemphasis{Free linear solver memory}

\item {} 
\sphinxstyleemphasis{Finalize MPI}

\end{enumerate}


\subsubsection{ARKBBDPRE user-callable functions}
\label{\detokenize{ARKStep_c_interface/Preconditioners:arkbbdpre-user-callable-functions}}
The ARKBBDPRE preconditioner module is initialized (or re-initialized)
and attached to the integrator by calling the following functions:
\index{ARKBBDPrecInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecInit}}\pysiglinewithargsret{int \sphinxbfcode{ARKBBDPrecInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, sunindextype\sphinxstyleemphasis{ Nlocal}, sunindextype\sphinxstyleemphasis{ mudq}, sunindextype\sphinxstyleemphasis{ mldq}, sunindextype\sphinxstyleemphasis{ mukeep}, sunindextype\sphinxstyleemphasis{ mlkeep}, realtype\sphinxstyleemphasis{ dqrely}, {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{ARKLocalFn}}}\sphinxstyleemphasis{ gloc}, {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}]{\sphinxcrossref{ARKCommFn}}}\sphinxstyleemphasis{ cfn}}{}
Initializes and allocates (internal) memory for the
ARKBBDPRE preconditioner.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{Nlocal} \textendash{} local vector length.

\item {} 
\sphinxstyleemphasis{mudq} \textendash{} upper half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\sphinxstyleemphasis{mldq} \textendash{} lower half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\sphinxstyleemphasis{mukeep} \textendash{} upper half-bandwidth of the retained banded
approximate Jacobian block.

\item {} 
\sphinxstyleemphasis{mlkeep} \textendash{} lower half-bandwidth of the retained banded
approximate Jacobian block.

\item {} 
\sphinxstyleemphasis{dqrely} \textendash{} the relative increment in components of \sphinxstyleemphasis{y} used in
the difference quotient approximations.  The default is \sphinxstyleemphasis{dqrely}
= \(\sqrt{\text{unit roundoff}}\), which can be specified by
passing \sphinxstyleemphasis{dqrely} = 0.0.

\item {} 
\sphinxstyleemphasis{gloc} \textendash{} the name of the C function (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{\sphinxcode{ARKLocalFn()}}}})
which computes the approximation \(g(t,y) \approx f^I(t,y)\).

\item {} 
\sphinxstyleemphasis{cfn} \textendash{} the name of the C function (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}]{\sphinxcrossref{\sphinxcode{ARKCommFn()}}}}) which
performs all inter-process communication required for the
computation of \(g(t,y)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_FAIL} if a memory allocation request failed

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  If one of the half-bandwidths \sphinxstyleemphasis{mudq} or \sphinxstyleemphasis{mldq} to be used
in the difference quotient calculation of the approximate Jacobian is
negative or exceeds the value \sphinxstyleemphasis{Nlocal}-1, it is replaced by 0 or
\sphinxstyleemphasis{Nlocal}-1 accordingly.

The half-bandwidths \sphinxstyleemphasis{mudq} and \sphinxstyleemphasis{mldq} need not be the true
half-bandwidths of the Jacobian of the local block of \(g\)
when smaller values may provide a greater efficiency.

Also, the half-bandwidths \sphinxstyleemphasis{mukeep} and \sphinxstyleemphasis{mlkeep} of the retained
banded approximate Jacobian block may be even smaller than
\sphinxstyleemphasis{mudq} and \sphinxstyleemphasis{mldq}, to reduce storage and computational costs
further.

For all four half-bandwidths, the values need not be the same on
every processor.

\end{fulllineitems}


The ARKBBDPRE module also provides a re-initialization function to
allow solving a sequence of problems of the same size, with the same
linear solver choice, provided there is no change in \sphinxstyleemphasis{Nlocal},
\sphinxstyleemphasis{mukeep}, or \sphinxstyleemphasis{mlkeep}. After solving one problem, and after
calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}} to re-initialize ARKStep for a
subsequent problem, a call to {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecReInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecReInit()}}}} can be made
to change any of the following: the half-bandwidths \sphinxstyleemphasis{mudq} and
\sphinxstyleemphasis{mldq} used in the difference-quotient Jacobian approximations, the
relative increment \sphinxstyleemphasis{dqrely}, or one of the user-supplied functions
\sphinxstyleemphasis{gloc} and \sphinxstyleemphasis{cfn}. If there is a change in any of the linear solver
inputs, an additional call to the “Set” routines provided by the
SUNLINSOL module, and/or one or more of the corresponding
\sphinxcode{ARKStepSet***} functions, must also be made (in the proper order).
\index{ARKBBDPrecReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecReInit}}\pysiglinewithargsret{int \sphinxbfcode{ARKBBDPrecReInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, sunindextype\sphinxstyleemphasis{ mudq}, sunindextype\sphinxstyleemphasis{ mldq}, realtype\sphinxstyleemphasis{ dqrely}}{}
Re-initializes the ARKBBDPRE preconditioner module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{mudq} \textendash{} upper half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\sphinxstyleemphasis{mldq} \textendash{} lower half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\sphinxstyleemphasis{dqrely} \textendash{} the relative increment in components of \sphinxstyleemphasis{y} used in
the difference quotient approximations.  The default is \sphinxstyleemphasis{dqrely}
= \(\sqrt{\text{unit roundoff}}\), which can be specified by
passing \sphinxstyleemphasis{dqrely} = 0.0.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_PMEM\_NULL} if the preconditioner memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  If one of the half-bandwidths \sphinxstyleemphasis{mudq} or \sphinxstyleemphasis{mldq} is
negative or exceeds the value \sphinxstyleemphasis{Nlocal}-1, it is replaced by 0 or
\sphinxstyleemphasis{Nlocal}-1 accordingly.

\end{fulllineitems}


The following two optional output functions are available for use with
the ARKBBDPRE module:
\index{ARKBBDPrecGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{ARKBBDPrecGetWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrwBBDP}, long int*\sphinxstyleemphasis{ leniwBBDP}}{}
Returns the processor-local ARKBBDPRE real and
integer workspace sizes.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{lenrwBBDP} \textendash{} the number of \sphinxcode{realtype} values in the
ARKBBDPRE workspace.

\item {} 
\sphinxstyleemphasis{leniwBBDP} \textendash{} the number of integer values in the  ARKBBDPRE workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_PMEM\_NULL} if the preconditioner memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The workspace requirements reported by this routine
correspond only to memory allocated within the ARKBBDPRE module
(the banded matrix approximation, banded \sphinxcode{SUNLinearSolver}
object, temporary vectors). These values are local to each process.

The workspaces referred to here exist in addition to those given by
the corresponding function \sphinxcode{ARKStepGetLSWorkSpace()}.

\end{fulllineitems}

\index{ARKBBDPrecGetNumGfnEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetNumGfnEvals}}\pysiglinewithargsret{int \sphinxbfcode{ARKBBDPrecGetNumGfnEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ ngevalsBBDP}}{}
Returns the number of calls made to the user-supplied
\sphinxstyleemphasis{gloc} function (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{\sphinxcode{ARKLocalFn()}}}}) due to the finite
difference approximation of the Jacobian blocks used within the
preconditioner setup function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{ngevalsBBDP} \textendash{} the number of calls made to the user-supplied
\sphinxstyleemphasis{gloc} function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if no errors occurred

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the ARKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_PMEM\_NULL} if the preconditioner memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}


In addition to the \sphinxstyleemphasis{ngevalsBBDP} \sphinxstyleemphasis{gloc} evaluations, the costs
associated with ARKBBDPRE also include \sphinxstyleemphasis{nlinsetups} LU
factorizations, \sphinxstyleemphasis{nlinsetups} calls to \sphinxstyleemphasis{cfn}, \sphinxstyleemphasis{npsolves} banded
backsolve calls, and \sphinxstyleemphasis{nfevalsLS} right-hand side function
evaluations, where \sphinxstyleemphasis{nlinsetups} is an optional ARKStep output and
\sphinxstyleemphasis{npsolves} and \sphinxstyleemphasis{nfevalsLS} are linear solver optional outputs (see
the table {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-arklsoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface optional output functions}}}}).


\section{Multigrid Reduction in Time with XBraid}
\label{\detokenize{ARKStep_c_interface/XBraid::doc}}\label{\detokenize{ARKStep_c_interface/XBraid:multigrid-reduction-in-time-with-xbraid}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-xbraid}}
The prior sections discuss using ARKStep in a traditional sequential
time integration setting i.e., the solution is advanced from one time to the
next where all parallelism resides within the evaluation of a step e.g., the
computation of the right-hand side, (non)linear solves, vector operations etc.
For example, when discretizing a partial differential equation using a method
of lines approach the spatially-discretized equations comprise a large set
of ordinary differential equations that can be evolved with ARKStep. In this
case the parallelization lies in decomposing the spatial domain unknowns across
distributed computational nodes. Considering the strong scaling case at a given
spatial resolution, as the problem is spread across greater numbers of
computational nodes scalability in the spatial dimension is exhausted and
sequential time integration becomes a bottleneck. This bottleneck is largely
driven by the hardware shift from faster clock speeds to greater concurrency to
achieve performance gains. In this case, at the spatial scaling limit and with
stagnant clock speeds, more time steps will lead to an increased runtime.

An alternative approach to sequential time integration is to solve for all time
values simultaneously. One such approach is multigrid reduction in time \phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:id1}}{\hyperref[\detokenize{References:f2014}]{\sphinxcrossref{{[}F2014{]}}}}
(MGRIT) which uses a highly parallel iterative method to expose parallelism in
the time domain in addition to the spatial parallelization. Starting with an
initial temporal grid the multilevel algorithm constructs successively coarser
time grids and uses each coarse grid solution to improve the solution at the
next finer scale. In the two level case the MGRIT algorithm is as follows:
\begin{enumerate}
\item {} 
Relax the solution on the fine grid (parallel-in-time)

\item {} 
Restrict the solution to the fine grid (time re-discretization).

\item {} 
Solve the residual equation on the coarse grid (serial-in-time).

\item {} 
Correct the fine grid solution (parallel-in-time).

\end{enumerate}

Applying this algorithm recursively for the solve step above leads to the
multilevel algorithm.

The XBraid library \phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:id2}}{\hyperref[\detokenize{References:xbraid}]{\sphinxcrossref{{[}XBraid{]}}}} implements in the MGRIT algorithm in a
non-intrusive manner, enabling the reuse of existing software for sequential
time integration. The following sections describe the ARKStep + XBraid interface
and the steps necessary to modify an existing code using ARKStep to also use
XBraid.


\subsection{SUNBraid Interface}
\label{\detokenize{ARKStep_c_interface/XBraid:sunbraid-interface}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidinterface}}
Interfacing ARKStep with XBraid requires defining two data structures. The
first is the XBraid application data structure that contains the data necessary
for carrying out a time step and is passed to every interface function (much
like the user data pointer in SUNDIALS packages). For this structure the
SUNBraid interface defines the generic SUNBraidApp structure described below
that serves as the basis for creating integrator-specific or user-defined
interfaces to XBraid. The second structure holds the problem state data at a
certain time value. This structure is defined by the SUNBraidVector structure
and simply contains an N\_Vector. In addition to the two data structures several
functions defined by the XBraid API are required. These functions include vector
operations (e.g., computing vector sums or norms) as well as functions to
initialize the problem state, access the current solution, and take a time step.

The ARKBraid interface, built on the SUNBraidApp and SUNBraidVector structures,
provides all the functionaly needed combine ARKStep and XBraid for
parallel-in-time integration. As such only a minimal number of changes are
necessary to update an exsting code that uses ARKStep to also use XBraid.


\subsubsection{SUNBraidApp}
\label{\detokenize{ARKStep_c_interface/XBraid:sunbraidapp}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidapp}}
As mentioned above the SUNBraid interface defines the SUNBraidApp structure to
hold the data necessary to compute a time step. This structure, like other
SUNDIALS generic objects, is defined as a structure consisting of an
implementation specific \sphinxstyleemphasis{content} field and an operations structure comprised
of a set of function pointers for implmentation-defined operations on the
object. Specifically the SUNBraidApp type is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Define XBraid App structure */}
\PYG{k}{struct} \PYG{n}{\PYGZus{}braid\PYGZus{}App\PYGZus{}struct}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void}        \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
  \PYG{n}{SUNBraidOps} \PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Pointer to the interface object (same as braid\PYGZus{}App) */}
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}braid\PYGZus{}App\PYGZus{}struct} \PYG{o}{*}\PYG{n}{SUNBraidApp}\PYG{p}{;}
\end{sphinxVerbatim}

Here, the SUNBraidOps structure is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Structure containing function pointers to operations */}
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNBraidOps}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{p}{(}\PYG{o}{*}\PYG{n}{getvectmpl}\PYG{p}{)}\PYG{p}{(}\PYG{n}{braid\PYGZus{}App} \PYG{n}{app}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{tmpl}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Pointer to operations structure */}
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}SUNBraidOps} \PYG{o}{*}\PYG{n}{SUNBraidOps}\PYG{p}{;}
\end{sphinxVerbatim}

The generic SUNBraidApp defines and implements the generic operations acting on
a SUNBraidApp obejct. These generic functions are nothing but wrappers to access
the specific implementation through the object’s operations structure. To
illustrate this point we show below the implementation of the
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_GetVecTmpl()}}}} function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Get a template vector from the integrator */}
\PYG{k+kt}{int} \PYG{n+nf}{SUNBraidApp\PYGZus{}GetVecTmpl}\PYG{p}{(}\PYG{n}{braid\PYGZus{}App} \PYG{n}{app}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{y}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{app}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getvectmpl} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)} \PYG{k}{return} \PYG{n}{SUNBRAID\PYGZus{}OPNULL}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{app}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{getvectmpl}\PYG{p}{(}\PYG{n}{app}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The SUNBraidApp operations are define below in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidops}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNBraidOps}}}}.


\subsubsection{SUNBraidOps}
\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidops}}\label{\detokenize{ARKStep_c_interface/XBraid:sunbraidops}}
In this section we define the SUNBraidApp operations and, for each operation, we
give the function signature, a description of the expected behavior, and an
example usage of the function.
\index{SUNBraidApp\_GetVecTmpl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidApp\_GetVecTmpl}}{braid\_App\sphinxstyleemphasis{ app}, N\_Vector\sphinxstyleemphasis{ *y}}{}
This function returns a vector to use as a template for creating new vectors
with {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{y} \textendash{} output, the template vector.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{quote}

If this function is not implemented by the SUNBraidApp
implementation (i.e., the function pointer is \sphinxcode{NULL}) then this function
will return \sphinxstyleemphasis{SUNBRAID\_OPNULL}. Otherwise the return value depends on the
particular SUNBraidApp implementation. Users are encouraged to utilize the
return codes  defined in \sphinxcode{sundials/sundials\_xbraid.h} and listed in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNBraid Return Codes}}}}.
\end{quote}

\sphinxstylestrong{Usage:}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Get template vector */}
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{SUNBraidApp\PYGZus{}GetVecTmpl}\PYG{p}{(}\PYG{n}{app}\PYG{p}{,} \PYG{n}{y\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{flag} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SUNBRAID\PYGZus{}SUCCESS}\PYG{p}{)} \PYG{k}{return} \PYG{n}{flag}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\end{fulllineitems}



\subsubsection{SUNBraidApp Utility Functions}
\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidapp-utilities}}\label{\detokenize{ARKStep_c_interface/XBraid:sunbraidapp-utility-functions}}
In addition to the generic SUNBraidApp operations the following utility
functions are provided to assist in creating and destroying a SUNBraidApp
instance.
\index{SUNBraidApp\_NewEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_NewEmpty}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidApp\_NewEmpty}}{braid\_App\sphinxstyleemphasis{ *app}}{}
This function creates a new SUNBraidApp instance with the content and
operations initialized to \sphinxcode{NULL}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} output, an empty SUNBraidApp instance (XBraid app structure).

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if a memory allocation failed.

\end{itemize}

\sphinxstylestrong{Usage:}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Create empty XBraid interface object */}
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{SUNBraidApp\PYGZus{}NewEmpty}\PYG{p}{(}\PYG{n}{app\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{flag} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SUNBRAID\PYGZus{}SUCCESS}\PYG{p}{)} \PYG{k}{return} \PYG{n}{flag}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\end{fulllineitems}

\index{SUNBraidApp\_FreeEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_FreeEmpty}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidApp\_FreeEmpty}}{braid\_App\sphinxstyleemphasis{ *app}}{}
This function destroys an empty SUNBraidApp instance.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an empty SUNBraidApp instance (XBraid app structure).

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\end{itemize}

\sphinxstylestrong{Usage:}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Free empty XBraid interface object */}
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{SUNBraidApp\PYGZus{}FreeEmpty}\PYG{p}{(}\PYG{n}{app\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
This function does not free the SUNBraidApp object’s content structure. An
implementation should free its content before calling
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_FreeEmpty}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_FreeEmpty()}}}} to deallocate the base SUNBraidApp
structure.
\end{sphinxadmonition}

\end{fulllineitems}



\subsubsection{SUNBraidVector}
\label{\detokenize{ARKStep_c_interface/XBraid:sunbraidvector}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidvector}}
As mentioned above the SUNBraid interface defines the SUNBraidVector structure
to store a snapshot of solution data at a single point in time and this
structure simply contains an N\_Vector. Specifically, the structure is defined
as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}braid\PYGZus{}Vector\PYGZus{}struct}
\PYG{p}{\PYGZob{}}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{y}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Poiner to vector wrapper (same as braid\PYGZus{}Vector) */}
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}braid\PYGZus{}Vector\PYGZus{}struct} \PYG{o}{*}\PYG{n}{SUNBraidVector}\PYG{p}{;}
\end{sphinxVerbatim}

To assist in creating creating and destroying this structure the following
utility functions are provided.
\index{SUNBraidVector\_New (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_New}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_New}}{N\_Vector\sphinxstyleemphasis{ y}, SUNBraidVector\sphinxstyleemphasis{ *u}}{}
This function creates a new SUNBraidVector wrapping the N\_Vector y.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} input, the N\_Vector to wrap.

\item {} 
\sphinxstyleemphasis{u} \textendash{} output, the SUNBraidVector wrapping \sphinxstyleemphasis{y}.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{y} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if a memory allocation fails.

\end{itemize}

\sphinxstylestrong{Usage:}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Create new vector wrapper */}
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{SUNBraidVector\PYGZus{}New}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{u\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{flag} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SUNBRAID\PYGZus{}SUCCESS}\PYG{p}{)} \PYG{k}{return} \PYG{n}{flag}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
The SUNBraidVector takes ownership of the wrapped N\_Vector and as such the
wrapped N\_Vector is destroyed when the SUNBraidVector is freed with
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_Free}]{\sphinxcrossref{\sphinxcode{SUNBraidVector\_Free()}}}}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{SUNBraidVector\_GetNVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_GetNVector}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_GetNVector}}{SUNBraidVector\sphinxstyleemphasis{ u}, N\_Vector\sphinxstyleemphasis{ *y}}{}
This function retrieves the wrapped N\_Vector from the SUNBraidVector.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{u} \textendash{} input, the SUNBraidVector wrapping \sphinxstyleemphasis{y}.

\item {} 
\sphinxstyleemphasis{y} \textendash{} output, the wrapped N\_Vector.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{u} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if \sphinxstyleemphasis{y} is \sphinxcode{NULL}.

\end{itemize}

\sphinxstylestrong{Usage:}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Create new vector wrapper */}
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{SUNBraidVector\PYGZus{}GetNVector}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{y\PYGZus{}ptr}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{flag} \PYG{o}{!}\PYG{o}{=} \PYG{n}{SUNBRAID\PYGZus{}SUCCESS}\PYG{p}{)} \PYG{k}{return} \PYG{n}{flag}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\end{fulllineitems}


Finally, the SUNBraid interface defines the following vector operations acting
on SUNBraidVectors, that consist of then wrappers to compatible SUNDIALS
N\_Vector operations.
\index{SUNBraidVector\_Clone (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_Clone}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_Clone}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Vector\sphinxstyleemphasis{ u}, braid\_Vector\sphinxstyleemphasis{ *v\_ptr}}{}
This function creates a clone of the input SUNBraidVector and copies the
values of the input vector \sphinxstyleemphasis{u} into the output vector \sphinxstyleemphasis{v\_ptr} using
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}} and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScale}]{\sphinxcrossref{\sphinxcode{N\_VScale()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{u} \textendash{} input, the SUNBraidVector to clone.

\item {} 
\sphinxstyleemphasis{v\_ptr} \textendash{} output, the new SUNBraidVector.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{u} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the N\_Vector \sphinxstyleemphasis{y} wrapped by \sphinxstyleemphasis{u} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if a memory allocation fails.

\end{itemize}

\end{fulllineitems}

\index{SUNBraidVector\_Free (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_Free}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_Free}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Vector\sphinxstyleemphasis{ u}}{}
This function destroys the SUNBraidVector and the wrapped N\_Vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{u} \textendash{} input, the SUNBraidVector to destroy.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\end{itemize}

\end{fulllineitems}

\index{SUNBraidVector\_Sum (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_Sum}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_Sum}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Real\sphinxstyleemphasis{ alpha}, braid\_Vector\sphinxstyleemphasis{ x}, braid\_Real\sphinxstyleemphasis{ beta}, braid\_Vector\sphinxstyleemphasis{ y}}{}
This function computes the vector sum
\(\alpha x + \beta y \rightarrow y\) using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{alpha} \textendash{} input, the constant \(\alpha\).

\item {} 
\sphinxstyleemphasis{x} \textendash{} input, the vector \(x\).

\item {} 
\sphinxstyleemphasis{beta} \textendash{} input, the constant \(\beta\).

\item {} 
\sphinxstyleemphasis{y} \textendash{} input/output, the vector \(y\).

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{x} or \sphinxstyleemphasis{y} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if either of the wrapped N\_Vectors are \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{SUNBraidVector\_SpatialNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_SpatialNorm}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_SpatialNorm}}{braid\_App, braid\_Vector\sphinxstyleemphasis{ u}, braid\_Real\sphinxstyleemphasis{ *norm\_ptr}}{}
This function computes the 2-norm of the vector \sphinxstyleemphasis{u} using
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{u} \textendash{} input, the vector \sphinxstyleemphasis{u}.

\item {} 
\sphinxstyleemphasis{norm\_ptr} \textendash{} output, the L2 norm of \sphinxstyleemphasis{u}.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{u} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the wrapped N\_Vector is \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{SUNBraidVector\_BufSize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_BufSize}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_BufSize}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Int\sphinxstyleemphasis{ *size\_ptr}, braid\_BufferStatus\sphinxstyleemphasis{ bstatus}}{}
This function returns the buffer size for messages to exchange vector data
using {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_GetVecTmpl()}}}} and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufSize}]{\sphinxcrossref{\sphinxcode{N\_VBufSize()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{size\_ptr} \textendash{} output, the buffer size.

\item {} 
\sphinxstyleemphasis{bstatus} \textendash{} input, a status object to query for information on the message
type.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
An error flag from {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_GetVecTmpl()}}}} or
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufSize}]{\sphinxcrossref{\sphinxcode{N\_VBufSize()}}}}.

\end{itemize}

\end{fulllineitems}

\index{SUNBraidVector\_BufPack (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_BufPack}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_BufPack}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Vector\sphinxstyleemphasis{ u}, void\sphinxstyleemphasis{ *buffer}, braid\_BufferStatus\sphinxstyleemphasis{ bstatus}}{}
This function packs the message buffer for exchanging vector data using
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufPack}]{\sphinxcrossref{\sphinxcode{N\_VBufPack()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{u} \textendash{} input, the vector to pack into the exchange buffer.

\item {} 
\sphinxstyleemphasis{buffer} \textendash{} output, the packed exchange buffer to pack.

\item {} 
\sphinxstyleemphasis{bstatus} \textendash{} input, a status object to query for information on the message
type.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{u} is \sphinxcode{NULL}.

\item {} 
An error flag from {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufPack}]{\sphinxcrossref{\sphinxcode{N\_VBufPack()}}}}.

\end{itemize}

\end{fulllineitems}

\index{SUNBraidVector\_BufUnpack (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_BufUnpack}}\pysiglinewithargsret{int \sphinxbfcode{SUNBraidVector\_BufUnpack}}{braid\_App\sphinxstyleemphasis{ app}, void\sphinxstyleemphasis{ *buffer}, braid\_Vector\sphinxstyleemphasis{ *u\_ptr}, braid\_BufferStatus\sphinxstyleemphasis{ bstatus}}{}
This function unpacks the message buffer and creates a new N\_Vector and
SUNBraidVector with the buffer data using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufUnpack}]{\sphinxcrossref{\sphinxcode{N\_VBufUnpack()}}}},
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_GetVecTmpl()}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a SUNBraidApp instance (XBraid app structure).

\item {} 
\sphinxstyleemphasis{buffer} \textendash{} input, the exchange buffer to unpack.

\item {} 
\sphinxstyleemphasis{u\_ptr} \textendash{} output, a new SUNBraidVector containing the buffer data.

\item {} 
\sphinxstyleemphasis{bstatus} \textendash{} input, a status object to query for information on the message
type.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{buffer} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if a memory allocation fails.

\item {} 
An error flag from {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_GetVecTmpl()}}}} and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VBufUnpack}]{\sphinxcrossref{\sphinxcode{N\_VBufUnpack()}}}}.

\end{itemize}

\end{fulllineitems}



\subsubsection{SUNBraid Return Codes}
\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes}}\label{\detokenize{ARKStep_c_interface/XBraid:sunbraid-return-codes}}
The SUNBraid interface return values are given in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNBraid Return Codes}}}}.

\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{SUNBraid Return Codes}\label{\detokenize{ARKStep_c_interface/XBraid:id3}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|L|C|L|}
\hline

Return value name
&
Value
&
Meaning
\\
\hline
\sphinxcode{SUNBRAID\_SUCCESS}
&
\(0\)
&
The call/operation was successful.
\\
\hline
\sphinxcode{SUNBRAID\_ALLOCFAIL}
&
\(-1\)
&
A memory allocation failed.
\\
\hline
\sphinxcode{SUNBRAID\_MEMFAIL}
&
\(-2\)
&
A memory access fail.
\\
\hline
\sphinxcode{SUNBRAID\_OPNULL}
&
\(-3\)
&
The SUNBraid operation is \sphinxcode{NULL}.
\\
\hline
\sphinxcode{SUNBRAID\_ILLINPUT}
&
\(-4\)
&
An invalid input was provided.
\\
\hline
\sphinxcode{SUNBRAID\_BRAIDFAIL}
&
\(-5\)
&
An XBraid function failed.
\\
\hline
\sphinxcode{SUNBRAID\_SUNFAIL}
&
\(-6\)
&
A SUNDIALS function failed.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{ARKBraid Interface}
\label{\detokenize{ARKStep_c_interface/XBraid:arkbraid-interface}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid}}
This section describes the ARKBraid implementation of a SUNBraidApp for using
the ARKStep integration module with XBraid. The following section describes
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-initdealloc}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Initialization and Deallocation Functions}}}} for creating, initializing, and
destroying the ARKStep + XBraid interface,
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-set}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Set Functions}}}} for setting optional inputs, and
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-get}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Get Functions}}}} for retrieving data from an ARKBraid
instance. As noted above, interfacing with XBraid requires providing functions
to initialize the problem state, access the current solution, and take a time
step. The default ARKBraid functions for each of these actions are defined in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-interface}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Interface Functions}}}} and may be overridden by
user-defined if desired. A skeleton of the user’s main or calling program for
using the ARKBraid interface is given in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program with XBraid}}}}. Finally, for advanced users that
wish to create their own SUNBraidApp implementation using ARKStep the
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-utility}]{\sphinxcrossref{\DUrole{std,std-ref}{Advanced ARKBraid Utility Functions}}}} section describes some helpful
functions available to the user.


\subsubsection{ARKBraid Initialization and Deallocation Functions}
\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-initdealloc}}\label{\detokenize{ARKStep_c_interface/XBraid:arkbraid-initialization-and-deallocation-functions}}
This section describes the functions that are called by the user to create,
initialize, and destroy an ARKBraid instance. Each user-callable function
returns \sphinxcode{SUNBRAID\_SUCCESS} (i.e., 0) on a successful call and a negative value
if an error occurred. The possible return codes are given in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNBraid Return Codes}}}}.
\index{ARKBraid\_Create (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Create}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_Create}}{void\sphinxstyleemphasis{ *arkode\_mem}, braid\_App\sphinxstyleemphasis{ *app}}{}
This function creates a SUNBraidApp object, sets the content pointer to the
private ARKBraid interface structure, and attaches the necessary SUNBraidOps
implementations.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} input, a pointer to an ARKStep memory structure.

\item {} 
\sphinxstyleemphasis{app} \textendash{} output, an ARKBraid instance (XBraid app structure).

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} \sphinxstyleemphasis{arkode\_mem} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if a memory allocation failed.

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
The ARKBraid interface is ARKStep-specific. Although one could eventually
construct an XBraid interface to either ERKStep or MRIStep, those are not
supported by this implementation.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_BraidInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_BraidInit}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_BraidInit}}{MPI\_Comm\sphinxstyleemphasis{ comm\_w}, MPI\_Comm\sphinxstyleemphasis{ comm\_t}, realtype\sphinxstyleemphasis{ tstart}, realtype\sphinxstyleemphasis{ tstop}, sunindextype\sphinxstyleemphasis{ ntime}, braid\_App\sphinxstyleemphasis{ app}, braid\_Core\sphinxstyleemphasis{ *core}}{}
This function wraps the XBraid \sphinxcode{braid\_Init()} function to create the
XBraid core memory structure and initializes XBraid with the ARKBraid and
SUNBraidVector interface functions.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{comm\_w} \textendash{} input,  the global MPI communicator for space and time.

\item {} 
\sphinxstyleemphasis{comm\_t} \textendash{} input,  the MPI communicator for the time dimension.

\item {} 
\sphinxstyleemphasis{tstart} \textendash{} input,  the initial time value.

\item {} 
\sphinxstyleemphasis{tstop}  \textendash{} input,  the final time value.

\item {} 
\sphinxstyleemphasis{ntime}  \textendash{} input,  the initial number of grid points in time.

\item {} 
\sphinxstyleemphasis{app}    \textendash{} input,  an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{core}   \textendash{} output, the XBraid core memory structure.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if either MPI communicator is \sphinxcode{MPI\_COMM\_NULL},
if \sphinxstyleemphasis{ntime} \textless{} 2, or if \sphinxstyleemphasis{app} or its content is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_BRAIDFAIL} if the \sphinxcode{braid\_Init()} call fails. The XBraid return
value can be retrieved with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetLastBraidFlag}]{\sphinxcrossref{\sphinxcode{ARKBraid\_GetLastBraidFlag()}}}}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
If desired, the default functions for vector initialization, accessing the
solution, taking a time step, and computing the spatial norm should be
overridden before calling this function.
See {\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-set}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Set Functions}}}} for more details.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
The user is responsible for deallocating the XBraid core memory structure
with the XBraid function \sphinxcode{braid\_Destroy()}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_Free (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Free}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_Free}}{braid\_App\sphinxstyleemphasis{ *app}}{}
This function deallocates an ARKBraid instance.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, a pointer to an ARKBraid instance.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\end{itemize}

\end{fulllineitems}



\subsubsection{ARKBraid Set Functions}
\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-set}}\label{\detokenize{ARKStep_c_interface/XBraid:arkbraid-set-functions}}
This section describes the functions that are called by the user to set optional
inputs to control the behavior of an ARKBraid instance or to provide alternative
XBraid interface functions. Each user-callable function returns
\sphinxcode{SUNBRAID\_SUCCESS} (i.e., 0) on a successful call and a negative value if an
error occurred. The possible return codes are given in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNBraid Return Codes}}}}.
\index{ARKBraid\_SetStepFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetStepFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_SetStepFn}}{braid\_App\sphinxstyleemphasis{ app}, braid\_PtFcnStep\sphinxstyleemphasis{ step}}{}
This function sets the step function provided to XBraid (default
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Step}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Step()}}}}).

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{step} \textendash{} input, an XBraid step function. If \sphinxstyleemphasis{step} is \sphinxcode{NULL}, the
default function will be used.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content is \sphinxcode{NULL}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This function must be called prior to {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_BraidInit}]{\sphinxcrossref{\sphinxcode{ARKBraid\_BraidInit()}}}}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_SetInitFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetInitFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_SetInitFn}}{braid\_App\sphinxstyleemphasis{ app}, braid\_PtFcnInit\sphinxstyleemphasis{ init}}{}
This function sets the vector initialization function provided to XBraid
(default {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Init}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Init()}}}}).

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{init} \textendash{} input, an XBraid vector initialization function. If \sphinxstyleemphasis{init} is
\sphinxcode{NULL}, the default function will be used.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content is \sphinxcode{NULL}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This function must be called prior to {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_BraidInit}]{\sphinxcrossref{\sphinxcode{ARKBraid\_BraidInit()}}}}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_SetSpatialNormFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetSpatialNormFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_SetSpatialNormFn}}{braid\_App\sphinxstyleemphasis{ app}, braid\_PtFcnSpatialNorm\sphinxstyleemphasis{ snorm}}{}
This function sets the spatial norm function provided to XBraid (default
\sphinxcode{SUNBraid\_SpatialNorm()}).

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{snorm} \textendash{} input, an XBraid spatial norm function. If \sphinxstyleemphasis{snorm} is \sphinxcode{NULL},
the default function will be used.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content is \sphinxcode{NULL}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This function must be called prior to {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_BraidInit}]{\sphinxcrossref{\sphinxcode{ARKBraid\_BraidInit()}}}}.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_SetAccessFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetAccessFn}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_SetAccessFn}}{braid\_App\sphinxstyleemphasis{ app}, braid\_PtFcnAccess\sphinxstyleemphasis{ access}}{}
This function sets the user access function provided to XBraid (default
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Access}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Access()}}}}).

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{init} \textendash{} input, an XBraid user access function. If \sphinxstyleemphasis{access} is \sphinxcode{NULL},
the default function will be used.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content is \sphinxcode{NULL}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This function must be called prior to {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_BraidInit}]{\sphinxcrossref{\sphinxcode{ARKBraid\_BraidInit()}}}}.
\end{sphinxadmonition}

\end{fulllineitems}



\subsubsection{ARKBraid Get Functions}
\label{\detokenize{ARKStep_c_interface/XBraid:arkbraid-get-functions}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-get}}
This section describes the functions that are called by the user to retrieve
data from an ARKBraid instance. Each user-callable function returns
\sphinxcode{SUNBRAID\_SUCCESS} (i.e., 0) on a successful call and a negative value if an
error occurred. The possible return codes are given in
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNBraid Return Codes}}}}.
\index{ARKBraid\_GetVecTmpl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetVecTmpl}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_GetVecTmpl}}{braid\_App\sphinxstyleemphasis{ app}, N\_Vector\sphinxstyleemphasis{ *tmpl}}{}
This function returns a vector from the ARKStep memory to use as a template
for creating new vectors with {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}} i.e., this is the ARKBraid
implementation of \sphinxcode{SUNBraidVector\_GetVecTmpl()}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{tmpl} \textendash{} output, a template vector.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content or ARKStep memory is \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{ARKBraid\_GetARKStepMem (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetARKStepMem}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_GetARKStepMem}}{braid\_App\sphinxstyleemphasis{ app}, void\sphinxstyleemphasis{ **arkode\_mem}}{}
This function returns the ARKStep memory structure pointer attached with
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Create}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Create()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} output, a pointer to the ARKStep memory structure.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content or ARKStep memory is \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{ARKBraid\_GetUserData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetUserData}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_GetUserData}}{braid\_App\sphinxstyleemphasis{ app}, void\sphinxstyleemphasis{ **user\_data}}{}
This function returns the user data pointer attached with
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} output, a pointer to the user data structure.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content or ARKStep memory is \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{ARKBraid\_GetLastBraidFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetLastBraidFlag}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_GetLastBraidFlag}}{braid\_App\sphinxstyleemphasis{ app}, int\sphinxstyleemphasis{ *last\_flag}}{}
This function returns the return value from the most recent XBraid function
call.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{last\_flag} \textendash{} output, the XBraid return value.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content is \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{ARKBraid\_GetLastARKStepFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetLastARKStepFlag}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_GetLastARKStepFlag}}{braid\_App\sphinxstyleemphasis{ app}, int\sphinxstyleemphasis{ *last\_flag}}{}
This function returns the return value from the most recent ARKStep function
call.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{last\_flag} \textendash{} output, the ARKStep return value.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content is \sphinxcode{NULL}.

\end{itemize}

\end{fulllineitems}

\index{ARKBraid\_GetSolution (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetSolution}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_GetSolution}}{braid\_App\sphinxstyleemphasis{ app}, realtype\sphinxstyleemphasis{ *tout}, N\_Vector\sphinxstyleemphasis{ yout}}{}
This function returns final time and state stored with the default access
function {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Access}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Access()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{last\_flag} \textendash{} output, the ARKStep return value.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content or the stored vector is \sphinxcode{NULL}.

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
If providing a non-default access function the final time and state are
not stored within the ARKBraid structure and this function will return an
error. In this case the user should allocate space to store any desired
output within the user data pointer attached to ARKStep with
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}. This user data pointer can be retrieved
from the ARKBraid structure with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetUserData}]{\sphinxcrossref{\sphinxcode{ARKBraid\_GetUserData()}}}}.
\end{sphinxadmonition}

\end{fulllineitems}



\subsubsection{ARKBraid Interface Functions}
\label{\detokenize{ARKStep_c_interface/XBraid:arkbraid-interface-functions}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-interface}}
This section describes the default XBraid interface functions provided by
ARKBraid and called by XBraid to preform certain actions. Any or all of these
functions may be overridden by supplying a user-defined function through the set
functions defined in {\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-set}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Set Functions}}}}. Each default
interface function returns \sphinxcode{SUNBRAID\_SUCCESS} (i.e., 0) on a successful call
and a negative value if an error occurred. The possible return codes are given
in {\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-sunbraidreturncodes-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNBraid Return Codes}}}}.
\index{ARKBraid\_Step (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Step}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_Step}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Vector\sphinxstyleemphasis{ ustop}, braid\_Vector\sphinxstyleemphasis{ fstop}, braid\_Vector\sphinxstyleemphasis{ u}, braid\_StepStatus\sphinxstyleemphasis{ status}}{}
This is the default step function provided to XBraid. The step function is
called by XBraid to advance the vector \sphinxstyleemphasis{u} from one time to the next using
the ARStep memory structure provided to {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Create}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Create()}}}}. A
user-defined step function may be set with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetStepFn}]{\sphinxcrossref{\sphinxcode{ARKBraid\_SetStepFn()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{ustop} \textendash{} input, \sphinxstyleemphasis{u} vector at the new time \sphinxstyleemphasis{tstop}.

\item {} 
\sphinxstyleemphasis{fstop} \textendash{} input, the right-hand side vector at the new time \sphinxstyleemphasis{tstop}.

\item {} 
\sphinxstyleemphasis{u} - input/output, on input the vector at the start time and on return the
vector at the new time.

\item {} 
\sphinxstyleemphasis{status} \textendash{} input, a status object to query for information about \sphinxstyleemphasis{u} and
to steer XBraid e.g., for temporal refinement.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content or ARKStep memory is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_BRAIDFAIL} if an XBraid function fails. The return value can be
retrieved with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetLastBraidFlag}]{\sphinxcrossref{\sphinxcode{ARKBraid\_GetLastBraidFlag()}}}}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUNFAIL} if a SUNDIALS function fails. The return value can be
retrieved with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetLastARKStepFlag}]{\sphinxcrossref{\sphinxcode{ARKBraid\_GetLastARKStepFlag()}}}}.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
If providing a non-default implemenation of the step function the utility
function {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_TakeStep}]{\sphinxcrossref{\sphinxcode{ARKBraid\_TakeStep()}}}} should be used to advance the input
vector \sphinxstyleemphasis{u} to the new time.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_Init (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Init}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_Init}}{braid\_App\sphinxstyleemphasis{ app}, realtype\sphinxstyleemphasis{ t}, braid\_Vector\sphinxstyleemphasis{ *u\_ptr}}{}
This is the default vector initialization function provided to XBraid. The
initialization function is called by XBraid to create a new vector and set
the initial guess for the solution at time \(t\). When using this default
function the initial guess at all time values is the initial condition
provided to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}. A user-defined init function may be
set with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetInitFn}]{\sphinxcrossref{\sphinxcode{ARKBraid\_SetInitFn()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{t} \textendash{} input, the initialization time for the output vector.

\item {} 
\sphinxstyleemphasis{u\_ptr} \textendash{} output, the new and initialized SUNBraidVector.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if \sphinxstyleemphasis{app} is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content or ARKStep memory is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if a memory allocation failed.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
If providing a non-default implementation of the vector initialization
function the utility functions {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidApp_GetVecTmpl}]{\sphinxcrossref{\sphinxcode{SUNBraidApp\_GetVecTmpl()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.SUNBraidVector_New}]{\sphinxcrossref{\sphinxcode{SUNBraidVector\_New()}}}} can be helpful when creating the new vector
returned by this function.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKBraid\_Access (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Access}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_Access}}{braid\_App\sphinxstyleemphasis{ app}, braid\_Vector\sphinxstyleemphasis{ u}, braid\_AccessStatus\sphinxstyleemphasis{ astatus}}{}
This is the default access function provided to XBraid. The access function
is called by XBraid to retrieve the current solution. When using this default
function the final solution time and state are stored within the ARKBraid
structure. This information can be retrieved with
{\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetSolution}]{\sphinxcrossref{\sphinxcode{ARKBraid\_GetSolution()}}}}. A user-defined access function may be
set with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_SetAccessFn}]{\sphinxcrossref{\sphinxcode{ARKBraid\_SetAccessFn()}}}}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{app} \textendash{} input, an ARKBraid instance.

\item {} 
\sphinxstyleemphasis{u} \textendash{} input, the vector to be accessed.

\item {} 
\sphinxstyleemphasis{status} \textendash{} input, a status object to query for information about \sphinxstyleemphasis{u}.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNBRAID\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ILLINPUT} if any of the inputs are \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_MEMFAIL} if the \sphinxstyleemphasis{app} content, the wrapped N\_Vector, or the
ARKStep memory is \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_ALLOCFAIL} if allocating storage for the final solution fails.

\item {} 
\sphinxstyleemphasis{SUNBRAID\_BRAIDFAIL} if an XBraid function fails. The return value can be
retrieved with {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_GetLastBraidFlag}]{\sphinxcrossref{\sphinxcode{ARKBraid\_GetLastBraidFlag()}}}}.

\end{itemize}

\end{fulllineitems}



\subsection{A skeleton of the user’s main program with XBraid}
\label{\detokenize{ARKStep_c_interface/XBraid:a-skeleton-of-the-user-s-main-program-with-xbraid}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-skeleton}}
In addition to the header files required for the integration of the ODE problem
(see the section {\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-headers}]{\sphinxcrossref{\DUrole{std,std-ref}{Access to library and header files}}}}), to use the ARKBraid
interace, the user’s program must include the header file
\sphinxcode{arkode/arkode\_xbraid.h} which declares the needed function prototypes.

The following is a skeleton of the user’s main program (or calling program) for
the integration of an ODE IVP using ARKStep with XBraid for parallel-in-time
integration. Most steps are unchanged from the skeleton program presented in
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}. New or updated steps are \sphinxstylestrong{bold}.
\begin{enumerate}
\item {} 
\sphinxstylestrong{Initialize MPI}

If parallelizing in space and time split the global communicator into
communicators for space and time with \sphinxcode{braid\_SplitCommworld()}.

\item {} 
\sphinxstyleemphasis{Set problem dimensions}

\item {} 
\sphinxstyleemphasis{Set vector of initial values}

\item {} 
\sphinxstyleemphasis{Create ARKStep object}

\item {} 
\sphinxstyleemphasis{Specify integration tolerances}

\item {} 
\sphinxstyleemphasis{Create matrix object}

\item {} 
\sphinxstyleemphasis{Create linear solver object}

\item {} 
\sphinxstyleemphasis{Set linear solver optional inputs}

\item {} 
\sphinxstyleemphasis{Attach linear solver module}

\item {} 
\sphinxstyleemphasis{Create nonlinear solver object}

\item {} 
\sphinxstyleemphasis{Attach nonlinear solver module}

\item {} 
\sphinxstyleemphasis{Set nonlinear solver optional inputs}

\item {} 
\sphinxstyleemphasis{Set optional inputs}

\item {} 
\sphinxstylestrong{Create ARKBraid interface}

Call the constructor {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Create}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Create()}}}} to create the XBraid app
structure.

\item {} 
\sphinxstylestrong{Set optional ARKBraid inputs}

See {\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-set}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Set Functions}}}} for ARKBraid inputs.

\item {} 
\sphinxstylestrong{Initialize the ARKBraid interface}

Call the initialization function \sphinxcode{ARKBraid\_Braid()} to create the
XBraid core memory structure and attach the ARKBraid interface app and
functions.

\item {} 
\sphinxstylestrong{Set optional XBraid inputs}

See the XBraid documentation for available XBraid options.

\item {} 
\sphinxstylestrong{Evolve the problem}

Call \sphinxcode{braid\_Drive()} to evolve the problem with MGRIT.

\item {} 
\sphinxstylestrong{Get optional outputs}

See {\hyperref[\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-get}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKBraid Get Functions}}}} for ARKBraid outputs.

\item {} 
\sphinxstyleemphasis{Deallocate memory for solution vector}

\item {} 
\sphinxstyleemphasis{Free solver memory}

\item {} 
\sphinxstyleemphasis{Free linear solver memory}

\item {} 
\sphinxstylestrong{Free ARKBraid and XBraid memory}

Call {\hyperref[\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_Free}]{\sphinxcrossref{\sphinxcode{ARKBraid\_Free()}}}} and \sphinxcode{braid\_Destroy} to deallocate the
ARKBraid interface and and XBraid core memory structures respectively.

\item {} 
\sphinxstyleemphasis{Finalize MPI}

\end{enumerate}


\subsection{Advanced ARKBraid Utility Functions}
\label{\detokenize{ARKStep_c_interface/XBraid:advanced-arkbraid-utility-functions}}\label{\detokenize{ARKStep_c_interface/XBraid:arkstep-cinterface-arkbraid-utility}}
This section describes utility functions utilized in the ARKStep + XBraid
interfacing. These functions are used internally by the above ARKBraid interface
functions but are exposed to the user to assist in advanced usage of
ARKODE and XBraid that requries defining a custom SUNBraidApp implementation.
\index{ARKBraid\_TakeStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKStep_c_interface/XBraid:c.ARKBraid_TakeStep}}\pysiglinewithargsret{int \sphinxbfcode{ARKBraid\_TakeStep}}{void\sphinxstyleemphasis{ *arkode\_mem}, realtype\sphinxstyleemphasis{ tstart}, realtype\sphinxstyleemphasis{ tstop}, N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ *ark\_flag}}{}
This function advances the vector \sphinxstyleemphasis{y} from \sphinxstyleemphasis{tstart} to \sphinxstyleemphasis{tstop} using a
single ARKStep time step with step size \sphinxstyleemphasis{h = tstop - start}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} input, the ARKStep memory structure pointer.

\item {} 
\sphinxstyleemphasis{tstart} \textendash{} input, the step start time.

\item {} 
\sphinxstyleemphasis{tstop} \textendash{} input, the step stop time.

\item {} 
\sphinxstyleemphasis{y} \textendash{} input/output, on input the solution a \sphinxstyleemphasis{tstop} and on return, the
solution at time \sphinxstyleemphasis{tstop} if the step was successful (\sphinxstyleemphasis{ark\_flag}
\(\geq 0\)) or the solution at time \sphinxstyleemphasis{tstart} if the step failed
(\sphinxstyleemphasis{ark\_flag} \textless{} 0).

\item {} 
\sphinxstyleemphasis{ark\_flag} \textendash{} output, the step status flag. If \sphinxstyleemphasis{ark\_flag} is:

\(= 0\) then the step succeeded and, if applicable, met the
requested temporal accuracy.

\(> 0\) then the step succeeded but failed to meet the requested
temporal accuracy.

\(< 0\) then the step failed e.g., a solver failure occurred.

\end{itemize}

\sphinxstylestrong{Return value:}
\begin{quote}

If all ARKStep function calls are successful the return
value is \sphinxstyleemphasis{ARK\_SUCCESS}, otherwise the return value is the error flag
returned from the function that failed.
\end{quote}

\end{fulllineitems}



\chapter{Using ERKStep for C and C++ Applications}
\label{\detokenize{ERKStep_c_interface/index::doc}}\label{\detokenize{ERKStep_c_interface/index:using-erkstep-for-c-and-c-applications}}\label{\detokenize{ERKStep_c_interface/index:erkstep-cinterface}}
This chapter is concerned with the use of the ERKStep time-stepping
module for the solution of nonstiff initial value problems (IVPs) in a
C or C++ language setting.  The following sections discuss the header
files and the layout of the user’s main program, and provide
descriptions of the ERKStep user-callable functions and user-supplied
functions.

The example programs described in the companion document \phantomsection\label{\detokenize{ERKStep_c_interface/index:id1}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}} may
be helpful. Those codes may be used as templates for new codes and are
included in the ARKode package \sphinxcode{examples} subdirectory.

ERKStep uses the input and output constants from the shared ARKode
infrastructure. These are defined as needed in this chapter, but for
convenience the full list is provided separately in the section
{\hyperref[\detokenize{Constants:constants}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: ARKode Constants}}}}.

The relevant information on using ERKStep’s C and C++ interfaces is
detailed in the following sub-sections.


\section{Access to library and header files}
\label{\detokenize{ERKStep_c_interface/General::doc}}\label{\detokenize{ERKStep_c_interface/General:erkstep-cinterface-headers}}\label{\detokenize{ERKStep_c_interface/General:access-to-library-and-header-files}}
At this point, it is assumed that the installation of ARKode,
following the procedure described in the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}},
has been completed successfully.

Regardless of where the user’s application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
ARKode. The relevant library files are
\begin{itemize}
\item {} 
\sphinxcode{libdir/libsundials\_arkode.lib},

\item {} 
\sphinxcode{libdir/libsundials\_nvec*.lib},

\end{itemize}

where the file extension \sphinxcode{.lib} is typically \sphinxcode{.so} for shared
libraries and \sphinxcode{.a} for static libraries.  The relevant header files
are located in the subdirectories
\begin{itemize}
\item {} 
\sphinxcode{incdir/include/arkode}

\item {} 
\sphinxcode{incdir/include/sundials}

\item {} 
\sphinxcode{incdir/include/nvector}

\end{itemize}

The directories \sphinxcode{libdir} and \sphinxcode{incdir} are the installation library
and include directories, respectively.  For a default installation,
these are \sphinxcode{instdir/lib} and \sphinxcode{instdir/include}, respectively, where
\sphinxcode{instdir} is the directory where SUNDIALS was installed (see the
section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}} for further details).


\section{Data Types}
\label{\detokenize{ERKStep_c_interface/General:data-types}}\label{\detokenize{ERKStep_c_interface/General:erkstep-cinterface-datatypes}}
The \sphinxcode{sundials\_types.h} file contains the definition of the variable
type \sphinxcode{realtype}, which is used by the SUNDIALS solvers for all
floating-point data, the definition of the integer type
\sphinxcode{sunindextype}, which is used for vector and matrix indices, and
\sphinxcode{booleantype}, which is used for certain logic operations within
SUNDIALS.


\subsection{Floating point types}
\label{\detokenize{ERKStep_c_interface/General:floating-point-types}}
The type “\index{realtype}realtype” can be set to
\sphinxcode{float}, \sphinxcode{double}, or \sphinxcode{long double}, depending on how SUNDIALS
was installed (with the default being \sphinxcode{double}). The user can change
the precision of the SUNDIALS solvers’ floating-point arithmetic at the
configuration stage (see the section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}}).

Additionally, based on the current precision, \sphinxcode{sundials\_types.h}
defines the values \index{BIG\_REAL}BIG\_REAL to be the largest value
representable as a \sphinxcode{realtype}, \index{SMALL\_REAL}SMALL\_REAL to be the
smallest positive value representable as a \sphinxcode{realtype}, and
\index{UNIT\_ROUNDOFF}UNIT\_ROUNDOFF to be the smallest realtype number,
\(\varepsilon\), such that \(1.0 + \varepsilon \ne 1.0\).

Within SUNDIALS, real constants may be set to have the appropriate
precision by way of a macro called \index{RCONST}RCONST.  It is this macro
that needs the ability to branch on the definition \sphinxcode{realtype}.  In
ANSI C, a floating-point constant with no suffix is stored as a
\sphinxcode{double}. Placing the suffix “F” at the end of a floating point
constant makes it a \sphinxcode{float}, whereas using the suffix “L” makes it a
\sphinxcode{long double}. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define A 1.0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define B 1.0F}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define C 1.0L}
\end{sphinxVerbatim}

defines \sphinxcode{A} to be a \sphinxcode{double} constant equal to 1.0, \sphinxcode{B} to be a
\sphinxcode{float} constant equal to 1.0, and \sphinxcode{C} to be a \sphinxcode{long double} constant
equal to 1.0.  The macro call \sphinxcode{RCONST(1.0)} automatically expands to
1.0 if \sphinxcode{realtype} is \sphinxcode{double}, to \sphinxcode{1.0F} if \sphinxcode{realtype} is \sphinxcode{float}, or
to \sphinxcode{1.0L} if \sphinxcode{realtype} is \sphinxcode{long double}. SUNDIALS uses the \sphinxcode{RCONST}
macro internally to declare all of its floating-point constants.

A user program which uses the type \sphinxcode{realtype} and the \sphinxcode{RCONST} macro
to handle floating-point constants is precision-independent, except for
any calls to precision-specific standard math library functions.
Users can, however, use the types \sphinxcode{double}, \sphinxcode{float}, or \sphinxcode{long
double} in their code (assuming that this usage is consistent with
the size of \sphinxcode{realtype} values that are passed to and from SUNDIALS).
Thus, a previously existing piece of ANSI C code can use SUNDIALS
without modifying the code to use \sphinxcode{realtype}, so long as the
SUNDIALS libraries have been compiled using the same precision (for
details see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\subsection{Integer types used for vector and matrix indices}
\label{\detokenize{ERKStep_c_interface/General:integer-types-used-for-vector-and-matrix-indices}}
The type \sphinxcode{sunindextype} can be either a 32- or 64-bit \sphinxstyleemphasis{signed} integer.
The default is the portable \sphinxcode{int64\_t} type, and the user can change it
to \sphinxcode{int32\_t} at the configuration stage. The configuration system
will detect if the compiler does not support portable types, and will
replace \sphinxcode{int32\_t} and \sphinxcode{int64\_t} with \sphinxcode{int} and \sphinxcode{long int},
respectively, to ensure use of the desired sizes on Linux, Mac OS X, and Windows
platforms. SUNDIALS currently does not support \sphinxstyleemphasis{unsigned} integer types
for vector and matrix indices, although these could be added in the future if there
is sufficient demand.

A user program which uses \sphinxcode{sunindextype} to handle vector and matrix indices
will work with both index storage types except for any calls to index storage-specific
external libraries. (Our \sphinxcode{C} and \sphinxcode{C++} example programs use \sphinxcode{sunindextype}.)
Users can, however, use any one of \sphinxcode{int}, \sphinxcode{long int}, \sphinxcode{int32\_t}, \sphinxcode{int64\_t} or
\sphinxcode{long long int} in their code, assuming that this usage is consistent with the typedef
for \sphinxcode{sunindextype} on their architecture. Thus, a previously existing piece of ANSI
C code can use SUNDIALS without modifying the code to use \sphinxcode{sunindextype},
so long as the SUNDIALS libraries use the appropriate index storage type (for details
see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\section{Header Files}
\label{\detokenize{ERKStep_c_interface/General:header-files}}
When using ERKStep, the calling program must include several header
files so that various macros and data types can be used. The header
file that is always required is:
\begin{itemize}
\item {} 
\sphinxcode{arkode/arkode\_erkstep.h}, the main header file for the ERKStep
time-stepping module, which defines the several types and various
constants, includes function prototypes, and includes the shared
\sphinxcode{arkode/arkode.h} header file.

\end{itemize}

Note that \sphinxcode{arkode.h} includes \sphinxcode{sundials\_types.h} directly, which
defines the types \sphinxcode{realtype},  \sphinxcode{sunindextype} and \sphinxcode{booleantype}
and the constants \sphinxcode{SUNFALSE} and \sphinxcode{SUNTRUE}, so a user program does
not need to include \sphinxcode{sundials\_types.h} directly.

Additionally, the calling program must also include an NVECTOR
implementation header file, of the form \sphinxcode{nvector/nvector\_***.h},
corresponding to the user’s preferred data layout and form of
parallelism.  See the section {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}} for details for the
appropriate name.  This file in turn includes the header file
\sphinxcode{sundials\_nvector.h} which defines the abstract \sphinxcode{N\_Vector} data
type.

If the user wishes to manually select between any of the pre-defined
ERK Butcher tables, these are defined through a set of constants
that are enumerated in the header file \sphinxcode{arkode/arkode\_butcher\_erk.h},
or if a user wishes to manually specify a Butcher table, the
corresponding \sphinxcode{ARKodeButcherTable} structure is defined in
\sphinxcode{arkode/arkode\_butcher.h}.


\section{A skeleton of the user’s main program}
\label{\detokenize{ERKStep_c_interface/Skeleton::doc}}\label{\detokenize{ERKStep_c_interface/Skeleton:a-skeleton-of-the-user-s-main-program}}\label{\detokenize{ERKStep_c_interface/Skeleton:erkstep-cinterface-skeleton}}
The following is a skeleton of the user’s main program (or calling
program) for the integration of an ODE IVP using the ERKStep module.
Most of the steps are independent of the NVECTOR implementation used.
For the steps that are not, refer to the section {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}} for
the specific name of the function to be called or macro to be
referenced.

\index{User main program}\ignorespaces \begin{enumerate}
\item {} 
Initialize parallel or multi-threaded environment, if appropriate.

For example, call \sphinxcode{MPI\_Init} to initialize MPI if used, or set
\sphinxcode{num\_threads}, the number of threads to use within the threaded
vector functions, if used.

\item {} 
Set problem dimensions, etc.

This generally includes the problem size, \sphinxcode{N}, and may include
the local vector length \sphinxcode{Nlocal}.

\begin{sphinxadmonition}{note}{Note:}
The variables \sphinxcode{N} and \sphinxcode{Nlocal} should be of type
\sphinxcode{sunindextype}.
\end{sphinxadmonition}

\item {} 
Set vector of initial values

To set the vector \sphinxcode{y0} of initial values, use the appropriate
functions defined by the particular NVECTOR implementation.

For native SUNDIALS vector implementations (except the CUDA and
RAJA based ones), use a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

if the \sphinxcode{realtype} array \sphinxcode{ydata} containing the initial values of
\(y\) already exists.  Otherwise, create a new vector by making
a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNew\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and then set its elements by accessing the underlying data where it
is located with a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

See the sections {\hyperref[\detokenize{nvectors/NVector_Serial:nvectors-nvserial}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_SERIAL Module}}}} through
{\hyperref[\detokenize{nvectors/NVector_Pthreads:nvectors-pthreads}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PTHREADS Module}}}} for details.

For the HYPRE and PETSc vector wrappers, first create and initialize
the underlying vector, and then create the NVECTOR wrapper with a call
of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{yvec}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{yvec} is a HYPRE or PETSc vector.  Note that calls like
\sphinxcode{N\_VNew\_***(...)} and \sphinxcode{N\_VGetArrayPointer\_***(...)} are not
available for these vector wrappers.  See the sections
{\hyperref[\detokenize{nvectors/NVector_ParHyp:nvectors-parhyp}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PARHYP Module}}}} and {\hyperref[\detokenize{nvectors/NVector_PETSc:nvectors-nvpetsc}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PETSC Module}}}} for details.

If using either the CUDA- or RAJA-based vector implementations use
a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{c} is a pointer to a \sphinxcode{suncudavec} or \sphinxcode{sunrajavec}
vector class if this class already exists.  Otherwise, create a new
vector by making a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VGetDeviceArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VGetHostArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\end{sphinxVerbatim}

Note that the vector class will allocate memory on both the host
and device when instantiated.  See the sections
{\hyperref[\detokenize{nvectors/NVector_CUDA:nvectors-cuda}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_CUDA Module}}}} and {\hyperref[\detokenize{nvectors/NVector_RAJA:nvectors-raja}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_RAJA Module}}}} for details.

\item {} 
Create ERKStep object

Call \sphinxcode{arkode\_mem = ERKStepCreate(...)} to create the ERKStep memory
block. {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}} returns a \sphinxcode{void*} pointer to
this memory structure. See the section
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-initialization}]{\sphinxcrossref{\DUrole{std,std-ref}{ERKStep initialization and deallocation functions}}}} for details.

\item {} 
Specify integration tolerances

Call {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ERKStepSStolerances()}}}} or
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ERKStepSVtolerances()}}}} to specify either a scalar relative
tolerance and scalar absolute tolerance, or a scalar relative
tolerance and a vector of absolute tolerances,
respectively.  Alternatively, call {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ERKStepWFtolerances()}}}}
to specify a function which sets directly the weights used in
evaluating WRMS vector norms. See the section
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-tolerances}]{\sphinxcrossref{\DUrole{std,std-ref}{ERKStep tolerance specification functions}}}} for details.

\item {} 
Set optional inputs

Call \sphinxcode{ERKStepSet*} functions to change any optional inputs that
control the behavior of ERKStep from their default values. See the
section {\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details.

\item {} 
Specify rootfinding problem

Optionally, call {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepRootInit}]{\sphinxcrossref{\sphinxcode{ERKStepRootInit()}}}} to initialize a rootfinding
problem to be solved during the integration of the ODE system. See
the section {\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding initialization function}}}} for general details, and
the section {\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for relevant optional
input calls.

\item {} 
Advance solution in time

For each point at which output is desired, call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ERKStepEvolve}\PYG{p}{(}\PYG{n}{arkode\PYGZus{}mem}\PYG{p}{,} \PYG{n}{tout}\PYG{p}{,} \PYG{n}{yout}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tret}\PYG{p}{,} \PYG{n}{itask}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{itask} specifies the return mode. The vector \sphinxcode{yout}
(which can be the same as the vector \sphinxcode{y0} above) will contain
\(y(t_\text{out})\). See the section
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{ERKStep solver function}}}} for details.

\item {} 
Get optional outputs

Call \sphinxcode{ERKStepGet*} functions to obtain optional output. See
the section {\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}} for details.

\item {} 
Deallocate memory for solution vector

Upon completion of the integration, deallocate memory for the
vector \sphinxcode{y} (or \sphinxcode{yout}) by calling the NVECTOR destructor
function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDestroy}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Free solver memory

Call \sphinxcode{ERKStepFree(\&arkode\_mem)} to free the memory allocated for
the ERKStep module.

\item {} 
Finalize MPI, if used

Call \sphinxcode{MPI\_Finalize} to terminate MPI.

\end{enumerate}


\section{ERKStep User-callable functions}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-usercallable}}\label{\detokenize{ERKStep_c_interface/User_callable::doc}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-user-callable-functions}}
This section describes the functions that are called by the
user to setup and then solve an IVP using the ERKStep time-stepping
module. Some of these are required; however, starting with the section
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs may be
skipped for a casual use of ARKode’s ERKStep module. In any case,
refer to the preceding section, {\hyperref[\detokenize{ERKStep_c_interface/Skeleton:erkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}},
for the correct order of these calls.

On an error, each user-callable function returns a negative value  (or
\sphinxcode{NULL} if the function returns a pointer) and sends an error message
to the error handler routine, which prints the message to \sphinxcode{stderr}
by default. However, the user can set a file as error output or can
provide her own error handler function (see the section
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details).


\subsection{ERKStep initialization and deallocation functions}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-initialization-and-deallocation-functions}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-initialization}}\index{ERKStepCreate (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}}\pysiglinewithargsret{void* \sphinxbfcode{ERKStepCreate}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ f}, realtype\sphinxstyleemphasis{ t0}, N\_Vector\sphinxstyleemphasis{ y0}}{}
This function allocates and initializes memory for a problem to
be solved using the ERKStep time-stepping module in ARKode.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{f} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the right-hand side function in
\(\dot{y} = f(t,y)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the initial value of \(t\).

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the initial condition vector \(y(t_0)\).

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  If successful, a pointer to initialized problem memory
of type \sphinxcode{void*}, to be passed to all user-facing ERKStep routines
listed below.  If unsuccessful, a \sphinxcode{NULL} pointer will be
returned, and an error message will be printed to \sphinxcode{stderr}.

\end{fulllineitems}

\index{ERKStepFree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepFree}}\pysiglinewithargsret{void \sphinxbfcode{ERKStepFree}}{void**\sphinxstyleemphasis{ arkode\_mem}}{}
This function frees the problem memory \sphinxstyleemphasis{arkode\_mem} created by
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  None

\end{fulllineitems}



\subsection{ERKStep tolerance specification functions}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-tolerances}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-tolerance-specification-functions}}
These functions specify the integration tolerances. One of them
\sphinxstylestrong{should} be called before the first call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}; otherwise default values of \sphinxcode{reltol =
1e-4} and \sphinxcode{abstol = 1e-9} will be used, which may be entirely
incorrect for a specific problem.

The integration tolerances \sphinxcode{reltol} and \sphinxcode{abstol} define a vector
of error weights, \sphinxcode{ewt}.  In the case of
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ERKStepSStolerances()}}}}, this vector has components

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

whereas in the case of {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ERKStepSVtolerances()}}}} the vector components
are given by

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This vector is used in all error tests, which use a weighted RMS norm
on all error-like vectors v:
\begin{equation*}
\begin{split}\|v\|_{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N (v_i\; ewt_i)^2 \right)^{1/2},\end{split}
\end{equation*}
where \(N\) is the problem dimension.

Alternatively, the user may supply a custom function to supply the
\sphinxcode{ewt} vector, through a call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ERKStepWFtolerances()}}}}.
\index{ERKStepSStolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSStolerances}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSStolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ reltol}, realtype\sphinxstyleemphasis{ abstol}}{}
This function specifies scalar relative and absolute tolerances.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{reltol} \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{abstol} \textendash{} scalar absolute tolerance.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ERKStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepSVtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSVtolerances}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSVtolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ reltol}, N\_Vector\sphinxstyleemphasis{ abstol}}{}
This function specifies a scalar relative tolerance and a vector
absolute tolerance (a potentially different absolute tolerance for
each vector component).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{reltol} \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{abstol} \textendash{} vector containing the absolute tolerances for each
solution component.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ERKStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepWFtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWFtolerances}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepWFtolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{ARKEwtFn}}}\sphinxstyleemphasis{ efun}}{}
This function specifies a user-supplied function \sphinxstyleemphasis{efun} to compute
the error weight vector \sphinxcode{ewt}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{efun} \textendash{} the name of the function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn()}}}})
that implements the error weight vector computation.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the ERKStep memory was not allocated by the time-stepping module

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{General advice on the choice of tolerances}
\label{\detokenize{ERKStep_c_interface/User_callable:general-advice-on-the-choice-of-tolerances}}
For many users, the appropriate choices for tolerance values in
\sphinxcode{reltol} and \sphinxcode{abstol} are a concern. The following pieces
of advice are relevant.
\begin{enumerate}
\item {} 
The scalar relative tolerance \sphinxcode{reltol} is to be set to control
relative errors. So a value of \(10^{-4}\) means that errors
are controlled to .01\%. We do not recommend using \sphinxcode{reltol} larger
than \(10^{-3}\). On the other hand, \sphinxcode{reltol} should not be so
small that it is comparable to the unit roundoff of the machine
arithmetic (generally around \(10^{-15}\) for double-precision).

\item {} 
The absolute tolerances \sphinxcode{abstol} (whether scalar or vector) need
to be set to control absolute errors when any components of the
solution vector \(y\) may be so small that pure relative error
control is meaningless.  For example, if \(y_i\) starts at some
nonzero value, but in time decays to zero, then pure relative
error control on \(y_i\) makes no sense (and is overly costly)
after \(y_i\) is below some noise level. Then \sphinxcode{abstol} (if
scalar) or \sphinxcode{abstol{[}i{]}} (if a vector) needs to be set to that
noise level. If the different components have different noise
levels, then \sphinxcode{abstol} should be a vector.  For example, see the
example problem \sphinxcode{ark\_robertson.c}, and the discussion
of it in the ARKode Examples Documentation \phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:id1}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}}.  In that
problem, the three components vary between 0 and 1, and have
different noise levels; hence the \sphinxcode{atols} vector therein. It is
impossible to give any general advice on \sphinxcode{abstol} values,
because the appropriate noise levels are completely
problem-dependent. The user or modeler hopefully has some idea as
to what those noise levels are.

\item {} 
Finally, it is important to pick all the tolerance values
conservatively, because they control the error committed on each
individual step. The final (global) errors are an accumulation of
those per-step errors, where that accumulation factor is
problem-dependent.  A general rule of thumb is to reduce the
tolerances by a factor of 10 from the actual desired limits on
errors.  So if you want .01\% relative accuracy (globally), a good
choice for \sphinxcode{reltol} is \(10^{-5}\).  In any case, it is
a good idea to do a few experiments with the tolerances to see how
the computed solution values vary as tolerances are reduced.

\end{enumerate}


\subsubsection{Advice on controlling nonphysical negative values}
\label{\detokenize{ERKStep_c_interface/User_callable:advice-on-controlling-nonphysical-negative-values}}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the
numerical solution, however, small negative (nonphysical) values
can then occur. In most cases, these values are harmless, and simply
need to be controlled, not eliminated, but in other cases any value
that violates a constraint may cause a simulation to halt. For both of
these scenarios the following pieces of advice are relevant.
\begin{enumerate}
\item {} 
The best way to control the size of unwanted negative computed
values is with tighter absolute tolerances.  Again this requires
some knowledge of the noise level of these components, which may
or may not be different for different components. Some
experimentation may be needed.

\item {} 
If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of
avoiding a long explanation of them, if nothing else), then
eliminate them, but only in the context of the output medium. Then
the internal values carried by the solver are unaffected. Remember
that a small negative value in \(y\) returned by ERKStep, with
magnitude comparable to \sphinxcode{abstol} or less, is equivalent to zero
as far as the computation is concerned.

\item {} 
The user’s right-hand side routine \(f\)
should never change a negative value in the solution vector \(y\)
to a non-negative value in attempt to “fix” this problem,
since this can lead to numerical instability.  If the \(f\)
routine cannot tolerate a zero or negative value (e.g. because
there is a square root or log), then the offending value should be
changed to zero or a tiny positive number in a temporary variable
(not in the input \(y\) vector) for the purposes of computing
\(f(t, y)\).

\item {} 
Positivity and non-negativity constraints on components can be
enforced by use of the recoverable error return feature in the
user-supplied right-hand side function, \(f\). When a
recoverable error is encountered, ERKStep will retry the step with
a smaller step size, which typically alleviates the problem.
However, because this option involves some additional overhead
cost, it should only be exercised if the use of absolute
tolerances to control the computed values is unsuccessful.

\end{enumerate}


\subsection{Rootfinding initialization function}
\label{\detokenize{ERKStep_c_interface/User_callable:rootfinding-initialization-function}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-rootfinding}}
As described in the section {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding}}}}, while
solving the IVP, ARKode’s time-stepping modules have the capability to
find the roots of a set of user-defined functions.  To activate the
root-finding algorithm, call the following function.  This is normally
called only once, prior to the first call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}, but if the rootfinding problem is to be
changed during the solution, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepRootInit}]{\sphinxcrossref{\sphinxcode{ERKStepRootInit()}}}} can also be
called prior to a continuation call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}.
\index{ERKStepRootInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepRootInit}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepRootInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ nrtfn}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{ARKRootFn}}}\sphinxstyleemphasis{ g}}{}
Initializes a rootfinding problem to be solved during the
integration of the ODE system.  It must be called after
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}, and before {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{nrtfn} \textendash{} number of functions \(g_i\), an integer \(\ge\) 0.

\item {} 
\sphinxstyleemphasis{g} \textendash{} name of user-supplied function, of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{\sphinxcode{ARKRootFn()}}}},
defining the functions \(g_i\) whose roots are sought.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if \sphinxstyleemphasis{nrtfn} is greater than zero but \sphinxstyleemphasis{g} = \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} To disable the rootfinding feature after it has already
been initialized, or to free memory associated with ERKStep’s
rootfinding module, call \sphinxstyleemphasis{ERKStepRootInit} with \sphinxstyleemphasis{nrtfn = 0}.

Similarly, if a new IVP is to be solved with a call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}}, where the new IVP has no rootfinding
problem but the prior one did, then call \sphinxstyleemphasis{ERKStepRootInit} with
\sphinxstyleemphasis{nrtfn = 0}.

\end{fulllineitems}



\subsection{ERKStep solver function}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-integration}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-solver-function}}
This is the central step in the solution process \textendash{} the call to perform
the integration of the IVP.  One of the input arguments (\sphinxstyleemphasis{itask})
specifies one of two modes as to where ERKStep is to return a
solution.  These modes are modified if the user has set a stop time
(with a call to the optional input function {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ERKStepSetStopTime()}}}}) or
has requested rootfinding.
\index{ERKStepEvolve (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepEvolve}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tout}, N\_Vector\sphinxstyleemphasis{ yout}, realtype\sphinxstyleemphasis{ *tret}, int\sphinxstyleemphasis{ itask}}{}
Integrates the ODE over an interval in \(t\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{tout} \textendash{} the next time at which a computed solution is desired.

\item {} 
\sphinxstyleemphasis{yout} \textendash{} the computed solution vector.

\item {} 
\sphinxstyleemphasis{tret} \textendash{} the time corresponding to \sphinxstyleemphasis{yout} (output).

\item {} 
\sphinxstyleemphasis{itask} \textendash{} a flag indicating the job of the solver for the next
user step.

The \sphinxstyleemphasis{ARK\_NORMAL} option causes the solver to take internal
steps until it has just overtaken a user-specified output
time, \sphinxstyleemphasis{tout}, in the direction of integration,
i.e. \(t_{n-1} <\) \sphinxstyleemphasis{tout} \(\le t_{n}\) for forward
integration, or \(t_{n} \le\) \sphinxstyleemphasis{tout} \(< t_{n-1}\) for
backward integration.  It will then compute an approximation
to the solution \(y(tout)\) by interpolation (using one
of the dense output routines described in the section
{\hyperref[\detokenize{Mathematics:mathematics-interpolation}]{\sphinxcrossref{\DUrole{std,std-ref}{Interpolation}}}}).

The \sphinxstyleemphasis{ARK\_ONE\_STEP} option tells the solver to only take a
single internal step \(y_{n-1} \to y_{n}\) and then return
control back to the calling program.  If this step will
overtake \sphinxstyleemphasis{tout} then the solver will again return an
interpolated result; otherwise it will return a copy of the
internal solution \(y_{n}\) in the vector \sphinxstyleemphasis{yout}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_ROOT\_RETURN} if {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} succeeded, and
found one or more roots.  If the number of root functions,
\sphinxstyleemphasis{nrtfn}, is greater than 1, call
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{ERKStepGetRootInfo()}}}} to see which \(g_i\) were
found to have a root at (\sphinxstyleemphasis{*tret}).

\item {} 
\sphinxstyleemphasis{ARK\_TSTOP\_RETURN} if {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} succeeded and
returned at \sphinxstyleemphasis{tstop}.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the \sphinxstyleemphasis{arkode\_mem} argument was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC} if \sphinxstyleemphasis{arkode\_mem} was not allocated.

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if one of the inputs to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} is illegal, or some other input to
the solver was either illegal or missing.  Details will be
provided in the error message.  Typical causes of this failure:
\begin{enumerate}
\item {} 
A component of the error weight vector became zero during
internal time-stepping.

\item {} 
A root of one of the root functions was found both at a
point \(t\) and also very near \(t\).

\item {} 
The initial condition violates the inequality constraints.

\end{enumerate}

\item {} 
\sphinxstyleemphasis{ARK\_TOO\_MUCH\_WORK} if the solver took \sphinxstyleemphasis{mxstep} internal steps
but could not reach \sphinxstyleemphasis{tout}.  The default value for \sphinxstyleemphasis{mxstep} is
\sphinxstyleemphasis{MXSTEP\_DEFAULT = 500}.

\item {} 
\sphinxstyleemphasis{ARK\_TOO\_MUCH\_ACC} if the solver could not satisfy the accuracy
demanded by the user for some internal step.

\item {} 
\sphinxstyleemphasis{ARK\_ERR\_FAILURE} if error test failures occurred either too many
times (\sphinxstyleemphasis{ark\_maxnef}) during one internal time step or occurred
with \(|h| = h_{min}\).

\item {} 
\sphinxstyleemphasis{ARK\_VECTOROP\_ERR} a vector operation error occured.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The input vector \sphinxstyleemphasis{yout} can use the same memory as the
vector \sphinxstyleemphasis{y0} of initial conditions that was passed to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}.

In \sphinxstyleemphasis{ARK\_ONE\_STEP} mode, \sphinxstyleemphasis{tout} is used only on the first call, and
only to get the direction and a rough scale of the independent
variable. All failure return values are negative and so testing the
return argument for negative values will trap all
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} failures.

Since interpolation may reduce the accuracy in the reported
solution, if full method accuracy is desired the user should issue
a call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ERKStepSetStopTime()}}}} before the call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} to specify a fixed stop time to
end the time step and return to the user.  Upon return from
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}, a copy of the internal solution
\(y_{n}\) will be returned in the vector \sphinxstyleemphasis{yout}.  Once the
integrator returns at a \sphinxstyleemphasis{tstop} time, any future testing for
\sphinxstyleemphasis{tstop} is disabled (and can be re-enabled only though a new call
to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ERKStepSetStopTime()}}}}).

On any error return in which one or more internal steps were taken
by {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}, the returned values of \sphinxstyleemphasis{tret} and
\sphinxstyleemphasis{yout} correspond to the farthest point reached in the integration.
On all other error returns, \sphinxstyleemphasis{tret} and \sphinxstyleemphasis{yout} are left unchanged
from those provided to the routine.

\end{fulllineitems}



\subsection{Optional input functions}
\label{\detokenize{ERKStep_c_interface/User_callable:optional-input-functions}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionalinputs}}
There are numerous optional input parameters that control the behavior
of the ERKStep solver, each of which may be modified from its default
value through calling an appropriate input function.  The following
tables list all optional input functions, grouped by which aspect of
ERKStep they control.  Detailed information on the calling syntax and
arguments for each function are then provided following each table.

The optional inputs are grouped into the following categories:
\begin{itemize}
\item {} 
General ERKStep options ({\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for ERKStep}}}}),

\item {} 
IVP method solver options ({\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepmethodinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for IVP method selection}}}}),

\item {} 
Step adaptivity solver options ({\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepadaptivityinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for time step adaptivity}}}}), and

\item {} 
Rootfinding options ({\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erksteprootfindinginputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding optional input functions}}}}).

\end{itemize}

For the most casual use of ERKStep, relying on the default set of
solver parameters, the reader can skip to the following section,
{\hyperref[\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

We note that, on an error return, all of the optional input functions send an
error message to the error handler function. All error return values are
negative, so a test on the return arguments for negative values will catch all
errors. Finally, a call to an \sphinxcode{ERKStepSet***} function can generally be made
from the user’s calling program at any time and, if successful, takes effect
immediately. \sphinxcode{ERKStepSet***} functions that cannot be called at any time note
this in the “\sphinxstylestrong{Notes}:” section of the function documentation.


\subsubsection{Optional inputs for ERKStep}
\label{\detokenize{ERKStep_c_interface/User_callable:optional-inputs-for-erkstep}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepinputtable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Return ERKStep solver parameters to their defaults
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetDefaults}]{\sphinxcrossref{\sphinxcode{ERKStepSetDefaults()}}}}
&
internal
\\
\hline
Set dense output interpolation type
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantType()}}}}
&
\sphinxcode{ARK\_INTERP\_HERMITE}
\\
\hline
Set dense output polynomial degree
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantDegree()}}}}
&
5
\\
\hline
Supply a pointer to a diagnostics output file
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetDiagnostics}]{\sphinxcrossref{\sphinxcode{ERKStepSetDiagnostics()}}}}
&
\sphinxcode{NULL}
\\
\hline
Supply a pointer to an error output file
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrFile}]{\sphinxcrossref{\sphinxcode{ERKStepSetErrFile()}}}}
&
\sphinxcode{stderr}
\\
\hline
Supply a custom error handler function
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetErrHandlerFn()}}}}
&
internal fn
\\
\hline
Disable time step adaptivity (fixed-step mode)
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}}
&
disabled
\\
\hline
Supply an initial step size to attempt
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetInitStep()}}}}
&
estimated
\\
\hline
Maximum no. of warnings for \(t_n+h = t_n\)
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxHnilWarns}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxHnilWarns()}}}}
&
10
\\
\hline
Maximum no. of internal steps before \sphinxstyleemphasis{tout}
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxNumSteps}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxNumSteps()}}}}
&
500
\\
\hline
Maximum absolute step size
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxStep()}}}}
&
\(\infty\)
\\
\hline
Minimum absolute step size
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetMinStep()}}}}
&
0.0
\\
\hline
Set a value for \(t_{stop}\)
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ERKStepSetStopTime()}}}}
&
\(\infty\)
\\
\hline
Supply a pointer for user data
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ERKStepSetUserData()}}}}
&
\sphinxcode{NULL}
\\
\hline
Maximum no. of ERKStep error test failures
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxErrTestFails}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxErrTestFails()}}}}
&
7
\\
\hline
Set inequality constraints on solution
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ERKStepSetConstraints()}}}}
&
\sphinxcode{NULL}
\\
\hline
Set max number of constraint failures
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxNumConstrFails}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxNumConstrFails()}}}}
&
10
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepSetDefaults (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetDefaults}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetDefaults}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Resets all optional input parameters to ERKStep’s original
default values.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Does not change problem-defining function pointer \sphinxstyleemphasis{f}
or the \sphinxstyleemphasis{user\_data} pointer.

Also leaves alone any data structures or options related to
root-finding (those can be reset using {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepRootInit}]{\sphinxcrossref{\sphinxcode{ERKStepRootInit()}}}}).

\end{fulllineitems}

\index{ERKStepSetInterpolantType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantType}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetInterpolantType}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ itype}}{}
Specifies use of the Lagrange or Hermite interpolation modules (used for
dense output \textendash{} interpolation of solution output values and implicit
method predictors).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{itype} \textendash{} requested interpolant type (\sphinxcode{ARK\_INTERP\_HERMITE} or \sphinxcode{ARK\_INTERP\_LAGRANGE})

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL} if the interpolation module cannot be allocated

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if the \sphinxstyleemphasis{itype} argument is not recognized or the
interpolation module has already been initialized

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The Hermite interpolation module is described in the Section
{\hyperref[\detokenize{Mathematics:mathematics-interpolation-hermite}]{\sphinxcrossref{\DUrole{std,std-ref}{Hermite interpolation module}}}}, and the Lagrange interpolation module
is described in the Section {\hyperref[\detokenize{Mathematics:mathematics-interpolation-lagrange}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagrange interpolation module}}}}.

This routine frees any previously-allocated interpolation module, and re-creates
one according to the specified argument.  Thus any previous calls to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantDegree()}}}} will be nullified.

This routine must be called \sphinxstyleemphasis{after} the call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}.
After the first call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} the interpolation type may
not be changed without first calling {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}}.

If this routine is not called, the Hermite interpolation module will be used.

\end{fulllineitems}

\index{ERKStepSetInterpolantDegree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantDegree}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetInterpolantDegree}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ degree}}{}
Specifies the degree of the polynomial interpolant
used for dense output (i.e. interpolation of solution output values
and implicit method predictors).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{degree} \textendash{} requested polynomial degree.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory or interpolation module are \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_INTERP\_FAIL} if this is called after {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value or the
interpolation module has already been initialized

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Allowed values are between 0 and 5.

This routine should be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}} and \sphinxstyleemphasis{before}
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}. After the first call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}
the interpolation degree may not be changed without first calling
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}}.

If a user calls both this routine and {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantType()}}}}, then
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantType()}}}} must be called first.

Since the accuracy of any polynomial interpolant is limited by the accuracy of
the time-step solutions on which it is based, the \sphinxstyleemphasis{actual} polynomial degree that
is used by ERKStep will be the minimum of \(q-1\) and the input \sphinxstyleemphasis{degree},
where \(q\) is the order of accuracy for the time integration method.

\end{fulllineitems}

\index{ERKStepSetDenseOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetDenseOrder}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetDenseOrder}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ dord}}{}
\sphinxstyleemphasis{This function is deprecated, and will be removed in a future release.
Users should transition to calling} {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantDegree()}}}}
\sphinxstyleemphasis{instead.}

\end{fulllineitems}

\index{ERKStepSetDiagnostics (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetDiagnostics}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetDiagnostics}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE*\sphinxstyleemphasis{ diagfp}}{}
Specifies the file pointer for a diagnostics file where
all ERKStep step adaptivity and solver information is written.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{diagfp} \textendash{} pointer to the diagnostics output file.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This parameter can be \sphinxcode{stdout} or \sphinxcode{stderr}, although the
suggested approach is to specify a pointer to a unique file opened
by the user and returned by \sphinxcode{fopen}.  If not called, or if called
with a \sphinxcode{NULL} file pointer, all diagnostics output is disabled.

When run in parallel, only one process should set a non-NULL value
for this pointer, since statistics from all processes would be
identical.

\end{fulllineitems}

\index{ERKStepSetErrFile (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrFile}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetErrFile}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE*\sphinxstyleemphasis{ errfp}}{}
Specifies a pointer to the file where all ERKStep warning and error
messages will be written if the default internal error handling
function is used.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{errfp} \textendash{} pointer to the output file.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value for \sphinxstyleemphasis{errfp} is \sphinxcode{stderr}.

Passing a \sphinxcode{NULL} value disables all future error message output
(except for the case wherein the ERKStep memory pointer is
\sphinxcode{NULL}).  This use of the function is strongly discouraged.

If used, this routine should be called before any other
optional input functions, in order to take effect for subsequent
error messages.

\end{fulllineitems}

\index{ERKStepSetErrHandlerFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrHandlerFn}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetErrHandlerFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}]{\sphinxcrossref{ARKErrHandlerFn}}}\sphinxstyleemphasis{ ehfun}, void*\sphinxstyleemphasis{ eh\_data}}{}
Specifies the optional user-defined function to be used
in handling error messages.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{ehfun} \textendash{} name of user-supplied error handler function.

\item {} 
\sphinxstyleemphasis{eh\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{ehfun} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Error messages indicating that the ERKStep solver memory is
\sphinxcode{NULL} will always be directed to \sphinxcode{stderr}.

\end{fulllineitems}

\index{ERKStepSetFixedStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetFixedStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hfixed}}{}
Disabled time step adaptivity within ERKStep, and specifies the
fixed time step size to use for all internal steps.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hfixed} \textendash{} value of the fixed step size to use.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass 0.0 to return ERKStep to the default (adaptive-step) mode.

Use of this function is not recommended, since we it gives no
assurance of the validity of the computed solutions.  It is
primarily provided for code-to-code verification testing purposes.

When using {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}}, any values provided to
the functions
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetInitStep()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetAdaptivityFn()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxErrTestFails}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxErrTestFails()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityMethod}]{\sphinxcrossref{\sphinxcode{ERKStepSetAdaptivityMethod()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetCFLFraction}]{\sphinxcrossref{\sphinxcode{ERKStepSetCFLFraction()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrorBias}]{\sphinxcrossref{\sphinxcode{ERKStepSetErrorBias()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStepBounds}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStepBounds()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxEFailGrowth()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxFirstGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxFirstGrowth()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxGrowth()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ERKStepSetMinReduction()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetSafetyFactor}]{\sphinxcrossref{\sphinxcode{ERKStepSetSafetyFactor()}}}},
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetSmallNumEFails}]{\sphinxcrossref{\sphinxcode{ERKStepSetSmallNumEFails()}}}} and
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetStabilityFn()}}}}
will be ignored, since temporal adaptivity is disabled.

If both {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}} and
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ERKStepSetStopTime()}}}} are used, then the fixed step size
will be used for all steps until the final step preceding the
provided stop time (which may be shorter).  To resume use of the
previous fixed step size, another call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}} must be made prior to calling
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} to resume integration.

It is \sphinxstyleemphasis{not} recommended that {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}} be used
in concert with {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxStep()}}}} or
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetMinStep()}}}}, since at best those latter two
routines will provide no useful information to the solver, and at
worst they may interfere with the desired fixed step size.

\end{fulllineitems}

\index{ERKStepSetInitStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInitStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetInitStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hin}}{}
Specifies the initial time step size ERKStep should use after
initialization, re-initialization, or resetting.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hin} \textendash{} value of the initial step to be attempted \((\ne 0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass 0.0 to use the default value.

By default, ERKStep estimates the initial step size to be the
solution \(h\) of the equation \(\left\| \frac{h^2
\ddot{y}}{2}\right\| = 1\), where \(\ddot{y}\) is an estimated
value of the second derivative of the solution at \sphinxstyleemphasis{t0}.

This routine will also reset the step size and error history.

\end{fulllineitems}

\index{ERKStepSetMaxHnilWarns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxHnilWarns}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxHnilWarns}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ mxhnil}}{}
Specifies the maximum number of messages issued by the
solver to warn that \(t+h=t\) on the next internal step, before
ERKStep will instead return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{mxhnil} \textendash{} maximum allowed number of warning messages \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 10; set \sphinxstyleemphasis{mxhnil} to zero to specify
this default.

A negative value indicates that no warning messages should be issued.

\end{fulllineitems}

\index{ERKStepSetMaxNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxNumSteps}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxNumSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int\sphinxstyleemphasis{ mxsteps}}{}
Specifies the maximum number of steps to be taken by the
solver in its attempt to reach the next output time, before ERKStep
will return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{mxsteps} \textendash{} maximum allowed number of internal steps.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing \sphinxstyleemphasis{mxsteps} = 0 results in ERKStep using the
default value (500).

Passing \sphinxstyleemphasis{mxsteps} \textless{} 0 disables the test (not recommended).

\end{fulllineitems}

\index{ERKStepSetMaxStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hmax}}{}
Specifies the upper bound on the magnitude of the time step size.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hmax} \textendash{} maximum absolute value of the time step size \((\ge 0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass \sphinxstyleemphasis{hmax} \(\le 0.0\) to set the default value of \(\infty\).

\end{fulllineitems}

\index{ERKStepSetMinStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMinStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hmin}}{}
Specifies the lower bound on the magnitude of the time step size.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hmin} \textendash{} minimum absolute value of the time step size \((\ge 0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Pass \sphinxstyleemphasis{hmin} \(\le 0.0\) to set the default value of 0.

\end{fulllineitems}

\index{ERKStepSetStopTime (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStopTime}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetStopTime}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tstop}}{}
Specifies the value of the independent variable
\(t\) past which the solution is not to proceed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{tstop} \textendash{} stopping time for the integrator.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is that no stop time is imposed.

\end{fulllineitems}

\index{ERKStepSetUserData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetUserData}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetUserData}}{void*\sphinxstyleemphasis{ arkode\_mem}, void*\sphinxstyleemphasis{ user\_data}}{}
Specifies the user data block \sphinxstyleemphasis{user\_data} and
attaches it to the main ERKStep memory block.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} pointer to the user data.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If specified, the pointer to \sphinxstyleemphasis{user\_data} is passed to all
user-supplied functions for which it is an argument; otherwise
\sphinxcode{NULL} is passed.

\end{fulllineitems}

\index{ERKStepSetMaxErrTestFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxErrTestFails}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxErrTestFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxnef}}{}
Specifies the maximum number of error test failures
permitted in attempting one step, before returning with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{maxnef} \textendash{} maximum allowed number of error test failures \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 7; set \sphinxstyleemphasis{maxnef} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ERKStepSetConstraints (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetConstraints}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ constraints}}{}
Specifies a vector defining inequality constraints for each component of the
solution vector \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{constraints} \textendash{} vector of constraint flags. If \sphinxcode{constraints{[}i{]}} is
\begin{itemize}
\item {} 
0.0 then no constraint is imposed on \(y_i\)

\item {} 
1.0 then \(y_i\) will be constrained to be \(y_i \geq 0.0\)

\item {} 
-1.0 then \(y_i\) will be constrained to be \(y_i \leq 0.0\)

\item {} 
2.0 then \(y_i\) will be constrained to be \(y_i > 0.0\)

\item {} 
-2.0 then \(y_i\) will be constrained to be \(y_i < 0.0\)

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if the constraints vector contains illegal values

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The presence of a non-\sphinxcode{NULL} constraints vector that is not 0.0
in all components will cause constraint checking to be performed. However, a
call with 0.0 in all components of \sphinxcode{constraints} will result in an illegal
input return. A \sphinxcode{NULL} constraints vector will disable constraint checking.

After a call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} inequality constraint checking
will be disabled and a call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ERKStepSetConstraints()}}}} is
required to re-enable constraint checking.

Since constraint-handling is performed through cutting time steps that would
violate the constraints, it is possible that this feature will cause some
problems to fail due to an inability to enforce constraints even at the
minimum time step size.  Additionally, the features {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ERKStepSetConstraints()}}}}
and {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}} are incompatible, and should not be used
simultaneously.

\end{fulllineitems}

\index{ERKStepSetMaxNumConstrFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxNumConstrFails}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxNumConstrFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxfails}}{}
Specifies the maximum number of constraint failures in a step before ERKStep
will return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{maxfails} \textendash{} maximum allowed number of constrain failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing \sphinxstyleemphasis{maxfails} \textless{}= 0 results in ERKStep using the
default value (10).

\end{fulllineitems}



\subsubsection{Optional inputs for IVP method selection}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepmethodinputtable}}\label{\detokenize{ERKStep_c_interface/User_callable:optional-inputs-for-ivp-method-selection}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Set integrator method order
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetOrder}]{\sphinxcrossref{\sphinxcode{ERKStepSetOrder()}}}}
&
4
\\
\hline
Set explicit RK table
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTable}]{\sphinxcrossref{\sphinxcode{ERKStepSetTable()}}}}
&
internal
\\
\hline
Specify explicit RK table number
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
&
internal
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepSetOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetOrder}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetOrder}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ ord}}{}
Specifies the order of accuracy for the ERK integration method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{ord} \textendash{} requested order of accuracy.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The allowed values are \(2 \le\) \sphinxstyleemphasis{ord} \(\le
8\).  Any illegal input will result in the default value of 4.

Since \sphinxstyleemphasis{ord} affects the memory requirements for the internal
ERKStep memory block, it cannot be changed after the first call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}, unless {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}} is called.

\end{fulllineitems}

\index{ERKStepSetTable (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTable}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetTable}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}}{}
Specifies a customized Butcher table for the ERK method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table for the explicit RK method.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}

For a description of the {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} type and related
functions for creating Butcher tables see {\hyperref[\detokenize{ARKodeButcherTable:arkodebutchertable}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher Table Data Structure}}}}.

No error checking is performed to ensure that either the method order \sphinxstyleemphasis{p} or
the embedding order \sphinxstyleemphasis{q} specified in the Butcher table structure correctly
describe the coefficients in the Butcher table.

Error checking is performed to ensure that the Butcher table is strictly
lower-triangular (i.e. that it specifies an ERK method).

If the Butcher table does not contain an embedding, the user \sphinxstyleemphasis{must} call
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStep()}}}} to enable fixed-step mode and set the desired
time step size.

\end{fulllineitems}

\index{ERKStepSetTableNum (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetTableNum}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ etable}}{}
Indicates to use a specific built-in Butcher table for the ERK method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{etable} \textendash{} index of the Butcher table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} \sphinxstyleemphasis{etable} should match an existing explicit method from
the section {\hyperref[\detokenize{Butcher:butcher-explicit}]{\sphinxcrossref{\DUrole{std,std-ref}{Explicit Butcher tables}}}}.  Error-checking is performed
to ensure that the table exists, and is not implicit.

\end{fulllineitems}



\subsubsection{Optional inputs for time step adaptivity}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepadaptivityinputtable}}\label{\detokenize{ERKStep_c_interface/User_callable:optional-inputs-for-time-step-adaptivity}}
The mathematical explanation of ARKode’s time step adaptivity
algorithm, including how each of the parameters below is used within
the code, is provided in the section {\hyperref[\detokenize{Mathematics:mathematics-adaptivity}]{\sphinxcrossref{\DUrole{std,std-ref}{Time step adaptivity}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Set a custom time step adaptivity function
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetAdaptivityFn()}}}}
&
internal
\\
\hline
Choose an existing time step adaptivity method
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityMethod}]{\sphinxcrossref{\sphinxcode{ERKStepSetAdaptivityMethod()}}}}
&
0
\\
\hline
Explicit stability safety factor
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetCFLFraction}]{\sphinxcrossref{\sphinxcode{ERKStepSetCFLFraction()}}}}
&
0.5
\\
\hline
Time step error bias factor
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrorBias}]{\sphinxcrossref{\sphinxcode{ERKStepSetErrorBias()}}}}
&
1.5
\\
\hline
Bounds determining no change in step size
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStepBounds}]{\sphinxcrossref{\sphinxcode{ERKStepSetFixedStepBounds()}}}}
&
1.0  1.5
\\
\hline
Maximum step growth factor on error test fail
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxEFailGrowth()}}}}
&
0.3
\\
\hline
Maximum first step growth factor
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxFirstGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxFirstGrowth()}}}}
&
10000.0
\\
\hline
Maximum allowed general step growth factor
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxGrowth()}}}}
&
20.0
\\
\hline
Minimum allowed step reduction factor on error test fail
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinReduction}]{\sphinxcrossref{\sphinxcode{ERKStepSetMinReduction()}}}}
&
0.1
\\
\hline
Time step safety factor
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetSafetyFactor}]{\sphinxcrossref{\sphinxcode{ERKStepSetSafetyFactor()}}}}
&
0.96
\\
\hline
Error fails before MaxEFailGrowth takes effect
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetSmallNumEFails}]{\sphinxcrossref{\sphinxcode{ERKStepSetSmallNumEFails()}}}}
&
2
\\
\hline
Explicit stability function
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetStabilityFn()}}}}
&
none
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepSetAdaptivityFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityFn}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetAdaptivityFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}]{\sphinxcrossref{ARKAdaptFn}}}\sphinxstyleemphasis{ hfun}, void*\sphinxstyleemphasis{ h\_data}}{}
Sets a user-supplied time-step adaptivity function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hfun} \textendash{} name of user-supplied adaptivity function.

\item {} 
\sphinxstyleemphasis{h\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{hfun} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This function should focus on accuracy-based time step
estimation; for stability based time steps the function
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetStabilityFn()}}}} should be used instead.

\end{fulllineitems}

\index{ERKStepSetAdaptivityMethod (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityMethod}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetAdaptivityMethod}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ imethod}, int\sphinxstyleemphasis{ idefault}, int\sphinxstyleemphasis{ pq}, realtype*\sphinxstyleemphasis{ adapt\_params}}{}
Specifies the method (and associated parameters) used for time step adaptivity.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{imethod} \textendash{} accuracy-based adaptivity method choice
(0 \(\le\) \sphinxtitleref{imethod} \(\le\) 5):
0 is PID, 1 is PI, 2 is I, 3 is explicit Gustafsson, 4 is
implicit Gustafsson, and 5 is the ImEx Gustafsson.

\item {} 
\sphinxstyleemphasis{idefault} \textendash{} flag denoting whether to use default adaptivity
parameters (1), or that they will be supplied in the
\sphinxstyleemphasis{adapt\_params} argument (0).

\item {} 
\sphinxstyleemphasis{pq} \textendash{} flag denoting whether to use the embedding order of
accuracy \sphinxstyleemphasis{p} (0) or the method order of accuracy \sphinxstyleemphasis{q} (1)
within the adaptivity algorithm.  \sphinxstyleemphasis{p} is the default.

\item {} 
\sphinxstyleemphasis{adapt\_params{[}0{]}} \textendash{} \(k_1\) parameter within accuracy-based adaptivity algorithms.

\item {} 
\sphinxstyleemphasis{adapt\_params{[}1{]}} \textendash{} \(k_2\) parameter within accuracy-based adaptivity algorithms.

\item {} 
\sphinxstyleemphasis{adapt\_params{[}2{]}} \textendash{} \(k_3\) parameter within accuracy-based adaptivity algorithms.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If custom parameters are supplied, they will be checked
for validity against published stability intervals.  If other
parameter values are desired, it is recommended to instead provide
a custom function through a call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetAdaptivityFn()}}}}.

\end{fulllineitems}

\index{ERKStepSetCFLFraction (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetCFLFraction}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetCFLFraction}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ cfl\_frac}}{}
Specifies the fraction of the estimated explicitly stable step to use.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{cfl\_frac} \textendash{} maximum allowed fraction of explicitly stable step (default is 0.5).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default
value.

\end{fulllineitems}

\index{ERKStepSetErrorBias (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrorBias}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetErrorBias}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ bias}}{}
Specifies the bias to be applied to the error estimates within
accuracy-based adaptivity strategies.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{bias} \textendash{} bias applied to error in accuracy-based time
step estimation (default is 1.5).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value below 1.0 will imply a reset to the default value.

\end{fulllineitems}

\index{ERKStepSetFixedStepBounds (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetFixedStepBounds}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetFixedStepBounds}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ lb}, realtype\sphinxstyleemphasis{ ub}}{}
Specifies the step growth interval in which the step size will remain unchanged.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{lb} \textendash{} lower bound on window to leave step size fixed (default is 1.0).

\item {} 
\sphinxstyleemphasis{ub} \textendash{} upper bound on window to leave step size fixed (default is 1.5).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any interval \sphinxstyleemphasis{not} containing 1.0 will imply a reset to the default values.

\end{fulllineitems}

\index{ERKStepSetMaxEFailGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxEFailGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxEFailGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ etamxf}}{}
Specifies the maximum step size growth factor upon multiple successive
accuracy-based error failures in the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{etamxf} \textendash{} time step reduction factor on multiple error fails (default is 0.3).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value outside the interval \((0,1]\) will imply a reset to the default value.

\end{fulllineitems}

\index{ERKStepSetMaxFirstGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxFirstGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxFirstGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ etamx1}}{}
Specifies the maximum allowed growth factor in step size following the very
first integration step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{etamx1} \textendash{} maximum allowed growth factor after the first time
step (default is 10000.0).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value \(\le 1.0\) will imply a reset to the default value.

\end{fulllineitems}

\index{ERKStepSetMaxGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxGrowth}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMaxGrowth}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ mx\_growth}}{}
Specifies the maximum allowed growth factor in step size between
consecutive steps in the integration process.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{mx\_growth} \textendash{} maximum allowed growth factor between consecutive time steps (default is 20.0).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value \(\le 1.0\) will imply a reset to the default
value.

\end{fulllineitems}

\index{ERKStepSetMinReduction (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMinReduction}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetMinReduction}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ eta\_min}}{}
Specifies the minimum allowed reduction factor in step size between
step attempts, resulting from a temporal error failure in the integration
process.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{eta\_min} \textendash{} minimum allowed reduction factor time step after an error
test failure (default is 0.1).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any value \(\ge 1.0\) or \(\le 0.0\) will imply a reset to
the default value.

\end{fulllineitems}

\index{ERKStepSetSafetyFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetSafetyFactor}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetSafetyFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ safety}}{}
Specifies the safety factor to be applied to the accuracy-based
estimated step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{safety} \textendash{} safety factor applied to accuracy-based time step (default is 0.96).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default
value.

\end{fulllineitems}

\index{ERKStepSetSmallNumEFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetSmallNumEFails}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetSmallNumEFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ small\_nef}}{}
Specifies the threshold for “multiple” successive error failures
before the \sphinxstyleemphasis{etamxf} parameter from
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ERKStepSetMaxEFailGrowth()}}}} is applied.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{small\_nef} \textendash{} bound to determine ‘multiple’ for \sphinxstyleemphasis{etamxf} (default is 2).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ERKStepSetStabilityFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStabilityFn}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetStabilityFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}]{\sphinxcrossref{ARKExpStabFn}}}\sphinxstyleemphasis{ EStab}, void*\sphinxstyleemphasis{ estab\_data}}{}
Sets the problem-dependent function to estimate a stable
time step size for the explicit portion of the ODE system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{EStab} \textendash{} name of user-supplied stability function.

\item {} 
\sphinxstyleemphasis{estab\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{EStab} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This function should return an estimate of the absolute
value of the maximum stable time step for the the ODE system.  It
is not required, since accuracy-based adaptivity may be sufficient
for retaining stability, but this can be quite useful for problems
where the right-hand side function \(f(t,y)\) may contain stiff
terms.

\end{fulllineitems}



\subsubsection{Rootfinding optional input functions}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erksteprootfindinginputtable}}\label{\detokenize{ERKStep_c_interface/User_callable:rootfinding-optional-input-functions}}
The following functions can be called to set optional inputs to
control the rootfinding algorithm, the mathematics of which are
described in the section {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Direction of zero-crossings to monitor
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetRootDirection}]{\sphinxcrossref{\sphinxcode{ERKStepSetRootDirection()}}}}
&
both
\\
\hline
Disable inactive root warnings
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetNoInactiveRootWarn}]{\sphinxcrossref{\sphinxcode{ERKStepSetNoInactiveRootWarn()}}}}
&
enabled
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepSetRootDirection (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetRootDirection}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetRootDirection}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ rootdir}}{}
Specifies the direction of zero-crossings to be located and returned.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{rootdir} \textendash{} state array of length \sphinxstyleemphasis{nrtfn}, the number of root
functions \(g_i\)  (the value of \sphinxstyleemphasis{nrtfn} was supplied in
the call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepRootInit}]{\sphinxcrossref{\sphinxcode{ERKStepRootInit()}}}}).  If \sphinxcode{rootdir{[}i{]} ==
0} then crossing in either direction for \(g_i\) should be
reported.  A value of +1 or -1 indicates that the solver
should report only zero-crossings where \(g_i\) is
increasing or decreasing, respectively.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The default behavior is to monitor for both zero-crossing directions.

\end{fulllineitems}

\index{ERKStepSetNoInactiveRootWarn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetNoInactiveRootWarn}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepSetNoInactiveRootWarn}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Disables issuing a warning if some root function appears
to be identically zero at the beginning of the integration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} ERKStep will not report the initial conditions as a
possible zero-crossing (assuming that one or more components
\(g_i\) are zero at the initial time).  However, if it appears
that some \(g_i\) is identically zero at the initial time
(i.e., \(g_i\) is zero at the initial time \sphinxstyleemphasis{and} after the
first step), ERKStep will issue a warning which can be disabled with
this optional input function.

\end{fulllineitems}



\subsection{Interpolated output function}
\label{\detokenize{ERKStep_c_interface/User_callable:interpolated-output-function}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-interpolatedoutput}}
An optional function {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetDky}]{\sphinxcrossref{\sphinxcode{ERKStepGetDky()}}}} is available to obtain
additional values of solution-related quantities.  This function
should only be called after a successful return from
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}, as it provides interpolated values either of
\(y\) or of its derivatives (up to the 5th derivative)
interpolated to any value of \(t\) in the last internal step taken
by {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}.  Internally, this \sphinxstyleemphasis{dense output} algorithm is
identical to the algorithm used for the maximum order implicit
predictors, described in the section
{\hyperref[\detokenize{Mathematics:mathematics-predictors-max}]{\sphinxcrossref{\DUrole{std,std-ref}{Maximum order predictor}}}}, except that derivatives of the
polynomial model may be evaluated upon request.
\index{ERKStepGetDky (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetDky}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetDky}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ t}, int\sphinxstyleemphasis{ k}, N\_Vector\sphinxstyleemphasis{ dky}}{}
Computes the \sphinxstyleemphasis{k}-th derivative of the function
\(y\) at the time \sphinxstyleemphasis{t},
i.e. \(\frac{d^{(k)}}{dt^{(k)}}y(t)\), for values of the
independent variable satisfying \(t_n-h_n \le t \le t_n\), with
\(t_n\) as current internal time reached, and \(h_n\) is
the last internal step size successfully used by the solver.  This
routine uses an interpolating polynomial of degree \sphinxstyleemphasis{min(degree, 5)},
where \sphinxstyleemphasis{degree} is the argument provided to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{ERKStepSetInterpolantDegree()}}}}.  The user may request \sphinxstyleemphasis{k} in the
range \{0,…,*min(degree, kmax)*\} where \sphinxstyleemphasis{kmax} depends on the choice of
interpolation module. For Hermite interpolants \sphinxstyleemphasis{kmax = 5} and for Lagrange
interpolants \sphinxstyleemphasis{kmax = 3}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the value of the independent variable at which the
derivative is to be evaluated.

\item {} 
\sphinxstyleemphasis{k} \textendash{} the derivative order requested.

\item {} 
\sphinxstyleemphasis{dky} \textendash{} output vector (must be allocated by the user).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_K} if \sphinxstyleemphasis{k} is not in the range \{0,…,*min(degree, kmax)*\}.

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_T} if \sphinxstyleemphasis{t} is not in the interval \([t_n-h_n, t_n]\)

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_DKY} if the \sphinxstyleemphasis{dky} vector was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} It is only legal to call this function after a successful
return from {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}}.

A user may access the values \(t_n\) and \(h_n\) via the
functions {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ERKStepGetCurrentTime()}}}} and
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetLastStep}]{\sphinxcrossref{\sphinxcode{ERKStepGetLastStep()}}}}, respectively.

\end{fulllineitems}



\subsection{Optional output functions}
\label{\detokenize{ERKStep_c_interface/User_callable:optional-output-functions}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-optionaloutputs}}
ERKStep provides an extensive set of functions that can be used to
obtain solver performance information.  We organize these into groups:
\begin{enumerate}
\item {} 
SUNDIALS version information accessor routines are in the subsection
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-sunversioninfo}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS version information}}}},

\item {} 
General ERKStep output routines are in the subsection
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepmainoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Main solver optional output functions}}}},

\item {} 
Output routines regarding root-finding results are in the subsection
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erksteprootoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding optional output functions}}}},

\item {} 
General usability routines (e.g. to print the current ERKStep
parameters, or output the current Butcher table) are in the
subsection {\hyperref[\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepextraoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{General usability functions}}}}.

\end{enumerate}

Following each table, we elaborate on each function.

Some of the optional outputs, especially the various counters, can be
very useful in determining the efficiency of various methods inside
ERKStep.  For example:
\begin{itemize}
\item {} 
The counters \sphinxstyleemphasis{nsteps} and \sphinxstyleemphasis{nf\_evals} provide a rough measure of the
overall cost of a given run, and can be compared between runs with
different solver options to suggest which set of options is the most
efficient.

\item {} 
The ratio \sphinxstyleemphasis{nsteps/step\_attempts} can measure the quality of the
time step adaptivity algorithm, since a poor algorithm will result
in more failed steps, and hence a lower ratio.

\end{itemize}

It is therefore recommended that users retrieve and output these
statistics following each run, and take some time to investigate
alternate solver options that will be more optimal for their
particular problem of interest.


\subsubsection{SUNDIALS version information}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-sunversioninfo}}\label{\detokenize{ERKStep_c_interface/User_callable:sundials-version-information}}
The following functions provide a way to get SUNDIALS version
information at runtime.
\index{SUNDIALSGetVersion (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.SUNDIALSGetVersion}}\pysiglinewithargsret{int \sphinxbfcode{SUNDIALSGetVersion}}{char\sphinxstyleemphasis{ *version}, int\sphinxstyleemphasis{ len}}{}
This routine fills a string with SUNDIALS version information.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{version} \textendash{} character array to hold the SUNDIALS version information.

\item {} 
\sphinxstyleemphasis{len} \textendash{} allocated length of the \sphinxstyleemphasis{version} character array.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS version

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} An array of 25 characters should be sufficient to hold
the version information.

\end{fulllineitems}

\index{SUNDIALSGetVersionNumber (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.SUNDIALSGetVersionNumber}}\pysiglinewithargsret{int \sphinxbfcode{SUNDIALSGetVersionNumber}}{int\sphinxstyleemphasis{ *major}, int\sphinxstyleemphasis{ *minor}, int\sphinxstyleemphasis{ *patch}, char\sphinxstyleemphasis{ *label}, int\sphinxstyleemphasis{ len}}{}
This routine sets integers for the SUNDIALS major,
minor, and patch release numbers and fills a string with the
release label if applicable.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{major} \textendash{} SUNDIALS release major version number.

\item {} 
\sphinxstyleemphasis{minor} \textendash{} SUNDIALS release minor version number.

\item {} 
\sphinxstyleemphasis{patch} \textendash{} SUNDIALS release patch version number.

\item {} 
\sphinxstyleemphasis{label} \textendash{} string to hold the SUNDIALS release label.

\item {} 
\sphinxstyleemphasis{len} \textendash{} allocated length of the \sphinxstyleemphasis{label} character array.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS label

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} An array of 10 characters should be sufficient to hold
the label information. If a label is not used in the release
version, no information is copied to \sphinxstyleemphasis{label}.

\end{fulllineitems}



\subsubsection{Main solver optional output functions}
\label{\detokenize{ERKStep_c_interface/User_callable:main-solver-optional-output-functions}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepmainoutputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Size of ERKStep real and integer workspaces
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ERKStepGetWorkSpace()}}}}
\\
\hline
Cumulative number of internal steps
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumSteps}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumSteps()}}}}
\\
\hline
Actual initial time step size used
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetActualInitStep}]{\sphinxcrossref{\sphinxcode{ERKStepGetActualInitStep()}}}}
\\
\hline
Step size used for the last successful step
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetLastStep}]{\sphinxcrossref{\sphinxcode{ERKStepGetLastStep()}}}}
\\
\hline
Step size to be attempted on the next step
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentStep}]{\sphinxcrossref{\sphinxcode{ERKStepGetCurrentStep()}}}}
\\
\hline
Current internal time reached by the solver
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ERKStepGetCurrentTime()}}}}
\\
\hline
Suggested factor for tolerance scaling
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetTolScaleFactor}]{\sphinxcrossref{\sphinxcode{ERKStepGetTolScaleFactor()}}}}
\\
\hline
Error weight vector for state variables
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ERKStepGetErrWeights()}}}}
\\
\hline
Single accessor to many statistics at once
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetStepStats}]{\sphinxcrossref{\sphinxcode{ERKStepGetStepStats()}}}}
\\
\hline
Name of constant associated with a return flag
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetReturnFlagName}]{\sphinxcrossref{\sphinxcode{ERKStepGetReturnFlagName()}}}}
\\
\hline
No. of explicit stability-limited steps
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumExpSteps}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumExpSteps()}}}}
\\
\hline
No. of accuracy-limited steps
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumAccSteps}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumAccSteps()}}}}
\\
\hline
No. of attempted steps
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumStepAttempts}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumStepAttempts()}}}}
\\
\hline
No. of calls to \sphinxstyleemphasis{f} function
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumRhsEvals()}}}}
\\
\hline
No. of local error test failures that have occurred
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumErrTestFails}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumErrTestFails()}}}}
\\
\hline
Current ERK Butcher table
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentButcherTable}]{\sphinxcrossref{\sphinxcode{ERKStepGetCurrentButcherTable()}}}}
\\
\hline
Estimated local truncation error vector
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetEstLocalErrors}]{\sphinxcrossref{\sphinxcode{ERKStepGetEstLocalErrors()}}}}
\\
\hline
Single accessor to many statistics at once
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetTimestepperStats}]{\sphinxcrossref{\sphinxcode{ERKStepGetTimestepperStats()}}}}
\\
\hline
Number of constraint test failures
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumConstrFails}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumConstrFails()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrw}, long int*\sphinxstyleemphasis{ leniw}}{}
Returns the ERKStep real and integer workspace sizes.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{lenrw} \textendash{} the number of \sphinxcode{realtype} values in the ERKStep workspace.

\item {} 
\sphinxstyleemphasis{leniw} \textendash{} the number of integer values in the ERKStep workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumSteps}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nsteps}}{}
Returns the cumulative number of internal steps taken by
the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{nsteps} \textendash{} number of steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetActualInitStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetActualInitStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetActualInitStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hinused}}{}
Returns the value of the integration step size used on the first step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hinused} \textendash{} actual value of initial step size.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Even if the value of the initial integration step was
specified by the user through a call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetInitStep()}}}}, this value may have been changed by
ERKStep to ensure that the step size fell within the prescribed
bounds \((h_{min} \le h_0 \le h_{max})\), or to satisfy the
local error test condition.

\end{fulllineitems}

\index{ERKStepGetLastStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetLastStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetLastStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hlast}}{}
Returns the integration step size taken on the last successful
internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hlast} \textendash{} step size taken on the last internal step.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetCurrentStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentStep}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetCurrentStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hcur}}{}
Returns the integration step size to be attempted on the next internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{hcur} \textendash{} step size to be attempted on the next internal step.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetCurrentTime (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentTime}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetCurrentTime}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ tcur}}{}
Returns the current internal time reached by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} current internal time reached.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetTolScaleFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetTolScaleFactor}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetTolScaleFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ tolsfac}}{}
Returns a suggested factor by which the user’s
tolerances should be scaled when too much accuracy has been
requested for some internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{tolsfac} \textendash{} suggested scaling factor for user-supplied tolerances.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetErrWeights (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetErrWeights}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetErrWeights}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ eweight}}{}
Returns the current error weight vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{eweight} \textendash{} solution error weights at the current time.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{eweight}, that will be
filled in by this function.

\end{fulllineitems}

\index{ERKStepGetStepStats (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetStepStats}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetStepStats}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nsteps}, realtype*\sphinxstyleemphasis{ hinused}, realtype*\sphinxstyleemphasis{ hlast}, realtype*\sphinxstyleemphasis{ hcur}, realtype*\sphinxstyleemphasis{ tcur}}{}
Returns many of the most useful optional outputs in a single call.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{nsteps} \textendash{} number of steps taken in the solver.

\item {} 
\sphinxstyleemphasis{hinused} \textendash{} actual value of initial step size.

\item {} 
\sphinxstyleemphasis{hlast} \textendash{} step size taken on the last internal step.

\item {} 
\sphinxstyleemphasis{hcur} \textendash{} step size to be attempted on the next internal step.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} current internal time reached.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetReturnFlagName}}\pysiglinewithargsret{char *\sphinxbfcode{ERKStepGetReturnFlagName}}{long int\sphinxstyleemphasis{ flag}}{}
Returns the name of the ERKStep constant corresponding to \sphinxstyleemphasis{flag}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{flag} \textendash{} a return flag from an ERKStep function.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The return value is a string containing the name of
the corresponding constant.

\end{fulllineitems}

\index{ERKStepGetNumExpSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumExpSteps}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumExpSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ expsteps}}{}
Returns the cumulative number of stability-limited steps
taken by the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{expsteps} \textendash{} number of stability-limited steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetNumAccSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumAccSteps}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumAccSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ accsteps}}{}
Returns the cumulative number of accuracy-limited steps
taken by the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{accsteps} \textendash{} number of accuracy-limited steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetNumStepAttempts (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumStepAttempts}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumStepAttempts}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ step\_attempts}}{}
Returns the cumulative number of steps attempted by the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{step\_attempts} \textendash{} number of steps attempted by solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumRhsEvals}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumRhsEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nf\_evals}}{}
Returns the number of calls to the user’s right-hand
side function, \(f\) (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{nf\_evals} \textendash{} number of calls to the user’s \(f(t,y)\) function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetNumErrTestFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumErrTestFails}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumErrTestFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ netfails}}{}
Returns the number of local error test failures that
have occurred (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{netfails} \textendash{} number of error test failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetCurrentButcherTable (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetCurrentButcherTable}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetCurrentButcherTable}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ *B}}{}
Returns the Butcher table currently in use by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{B} \textendash{} pointer to Butcher table structure.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} data structure is defined as a
pointer to the following C structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{ARKodeButcherTableMem} \PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{q}\PYG{p}{;}           \PYG{c+cm}{/* method order of accuracy       */}
  \PYG{k+kt}{int} \PYG{n}{p}\PYG{p}{;}           \PYG{c+cm}{/* embedding order of accuracy    */}
  \PYG{k+kt}{int} \PYG{n}{stages}\PYG{p}{;}      \PYG{c+cm}{/* number of stages               */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{A}\PYG{p}{;}    \PYG{c+cm}{/* Butcher table coefficients     */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{c}\PYG{p}{;}     \PYG{c+cm}{/* canopy node coefficients       */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{b}\PYG{p}{;}     \PYG{c+cm}{/* root node coefficients         */}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{d}\PYG{p}{;}     \PYG{c+cm}{/* embedding coefficients         */}

\PYG{p}{\PYGZcb{}} \PYG{o}{*}\PYG{n}{ARKodeButcherTable}\PYG{p}{;}
\end{sphinxVerbatim}

For more details see {\hyperref[\detokenize{ARKodeButcherTable:arkodebutchertable}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher Table Data Structure}}}}.

\end{fulllineitems}

\index{ERKStepGetEstLocalErrors (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetEstLocalErrors}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetEstLocalErrors}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ ele}}{}
Returns the vector of estimated local truncation errors
for the current step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{ele} \textendash{} vector of estimated local truncation errors.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The user must allocate space for \sphinxstyleemphasis{ele}, that will be
filled in by this function.

The values returned in \sphinxstyleemphasis{ele} are valid only after a successful call
to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} (i.e. it returned a non-negative value).

The \sphinxstyleemphasis{ele} vector, together with the \sphinxstyleemphasis{eweight} vector from
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ERKStepGetErrWeights()}}}}, can be used to determine how the
various components of the system contributed to the estimated local
error test.  Specifically, that error test uses the WRMS norm of a
vector whose components are the products of the components of these
two vectors.  Thus, for example, if there were recent error test
failures, the components causing the failures are those with largest
values for the products, denoted loosely as \sphinxcode{eweight{[}i{]}*ele{[}i{]}}.

\end{fulllineitems}

\index{ERKStepGetTimestepperStats (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetTimestepperStats}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetTimestepperStats}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ expsteps}, long int*\sphinxstyleemphasis{ accsteps}, long int*\sphinxstyleemphasis{ step\_attempts}, long int*\sphinxstyleemphasis{ nf\_evals}, long int*\sphinxstyleemphasis{ netfails}}{}
Returns many of the most useful time-stepper statistics in a single call.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{expsteps} \textendash{} number of stability-limited steps taken in the solver.

\item {} 
\sphinxstyleemphasis{accsteps} \textendash{} number of accuracy-limited steps taken in the solver.

\item {} 
\sphinxstyleemphasis{step\_attempts} \textendash{} number of steps attempted by the solver.

\item {} 
\sphinxstyleemphasis{nf\_evals} \textendash{} number of calls to the user’s \(f(t,y)\) function.

\item {} 
\sphinxstyleemphasis{netfails} \textendash{} number of error test failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ERKStepGetNumConstrFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumConstrFails}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumConstrFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nconstrfails}}{}
Returns the cumulative number of constraint test failures (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{nconstrfails} \textendash{} number of constraint test failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Rootfinding optional output functions}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erksteprootoutputs}}\label{\detokenize{ERKStep_c_interface/User_callable:rootfinding-optional-output-functions}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Array showing roots found
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{ERKStepGetRootInfo()}}}}
\\
\hline
No. of calls to user root function
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumGEvals}]{\sphinxcrossref{\sphinxcode{ERKStepGetNumGEvals()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepGetRootInfo (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetRootInfo}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetRootInfo}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ rootsfound}}{}
Returns an array showing which functions were found to
have a root.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{rootsfound} \textendash{} array of length \sphinxstyleemphasis{nrtfn} with the indices of the
user functions \(g_i\) found to have a root (the value of
\sphinxstyleemphasis{nrtfn} was supplied in the call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepRootInit}]{\sphinxcrossref{\sphinxcode{ERKStepRootInit()}}}}).  For \(i = 0 \ldots\)
\sphinxstyleemphasis{nrtfn}-1, \sphinxcode{rootsfound{[}i{]}} is nonzero if \(g_i\) has a
root, and 0 if not.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{rootsfound} prior to
calling this function.

For the components of \(g_i\) for which a root was found, the
sign of \sphinxcode{rootsfound{[}i{]}} indicates the direction of
zero-crossing.  A value of +1 indicates that \(g_i\) is
increasing, while a value of -1 indicates a decreasing \(g_i\).

\end{fulllineitems}

\index{ERKStepGetNumGEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepGetNumGEvals}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepGetNumGEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ ngevals}}{}
Returns the cumulative number of calls made to the
user’s root function \(g\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{ngevals} \textendash{} number of calls made to \(g\) so far.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{General usability functions}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-erkstepextraoutputs}}\label{\detokenize{ERKStep_c_interface/User_callable:general-usability-functions}}
The following optional routines may be called by a user to inquire
about existing solver parameters, to retrieve stored Butcher tables,
write the current Butcher table, or even to test a provided Butcher
table to determine its analytical order of accuracy.  While none of
these would typically be called during the course of solving an
initial value problem, these may be useful for users wishing to better
understand ERKStep and/or specific Runge-Kutta methods.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional routine
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Output all ERKStep solver parameters
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWriteParameters}]{\sphinxcrossref{\sphinxcode{ERKStepWriteParameters()}}}}
\\
\hline
Output the current Butcher table
&
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWriteButcher}]{\sphinxcrossref{\sphinxcode{ERKStepWriteButcher()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ERKStepWriteParameters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWriteParameters}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepWriteParameters}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE\sphinxstyleemphasis{ *fp}}{}
Outputs all ERKStep solver parameters to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{fp} \textendash{} pointer to use for printing the solver parameters.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{fp} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

When run in parallel, only one process should set a non-NULL value
for this pointer, since parameters for all processes would be
identical.

\end{fulllineitems}

\index{ERKStepWriteButcher (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWriteButcher}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepWriteButcher}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE\sphinxstyleemphasis{ *fp}}{}
Outputs the current Butcher table to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{fp} \textendash{} pointer to use for printing the Butcher table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ERKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{fp} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

When run in parallel, only one process should set a non-NULL value
for this pointer, since tables for all processes would be
identical.

\end{fulllineitems}



\subsection{ERKStep re-initialization function}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-re-initialization-function}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-reinitialization}}
To reinitialize the ERKStep module for the solution of a new problem,
where a prior call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}} has been made, the
user must call the function {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}}.  The new
problem must have the same size as the previous one.  This routine
retains the current settings for all ERKstep module options and
performs the same input checking and initializations that are done in
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}, but it performs no memory allocation as is
assumes that the existing internal memory is sufficient for the new
problem.  A call to this re-initialization routine deletes the
solution history that was stored internally during the previous
integration.  Following a successful call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}}, call {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} again for the
solution of the new problem.

The use of {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}} requires that the number of Runge
Kutta stages, denoted by \sphinxstyleemphasis{s}, be no larger for the new problem than
for the previous problem.  This condition is automatically fulfilled
if the method order \sphinxstyleemphasis{q} is left unchanged.

One important use of the {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}} function is in the
treating of jump discontinuities in the RHS function.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to this routine.  To stop when the location
of the discontinuity is known, simply make that location a value of
\sphinxcode{tout}.  To stop when the location of the discontinuity is
determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS function \sphinxstyleemphasis{not} incorporate the
discontinuity, but rather have a smooth extension over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
function (communicated through \sphinxcode{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{ERKStepReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepReInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ f}, realtype\sphinxstyleemphasis{ t0}, N\_Vector\sphinxstyleemphasis{ y0}}{}
Provides required problem specifications and re-initializes the
ERKStep time-stepper module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{f} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the right-hand side function in \(\dot{y} = f(t,y)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the initial value of \(t\).

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the initial condition vector \(y(t_0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
All previously set options are retained but may be updated by calling
the appropriate “Set” functions.

If an error occurred, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}} also
sends an error message to the error handler function.

\end{fulllineitems}



\subsection{ERKStep reset function}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-reset-function}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-reset}}
To reset the ERKStep module to a particular independent variable value and
dependent variable vector for the continued solution of a problem, where a prior
call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}} has been made, the user must call the function
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}}.  Like {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}} this routine retains
the current settings for all ERKStep module options and performs no memory
allocations but, unlike {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReInit}]{\sphinxcrossref{\sphinxcode{ERKStepReInit()}}}}, this routine performs only a
\sphinxstyleemphasis{subset} of the input checking and initializations that are done in
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}. In particular this routine retains all internal
counter values and the step size/error history. Following a successful call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}}, call {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} again to continue
solving the problem. By default the next call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} will
use the step size computed by ERKStep prior to calling {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}}.
To set a different step size or have ERKStep estimate a new step size use
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetInitStep()}}}}.

One important use of the {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}} function is in the
treating of jump discontinuities in the RHS functions.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}}.  To stop when
the location of the discontinuity is known, simply make that location
a value of \sphinxcode{tout}.  To stop when the location of the discontinuity
is determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS functions \sphinxstyleemphasis{not} incorporate the
discontinuity, but rather have a smooth extension over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
functions (communicated through \sphinxcode{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{ERKStepReset (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepReset}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tR}, N\_Vector\sphinxstyleemphasis{ yR}}{}
Resets the current ERKStep time-stepper module state to the provided
independent variable value and dependent variable vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{tR} \textendash{} the value of the independent variable \(t\).

\item {} 
\sphinxstyleemphasis{yR} \textendash{} the value of the dependent variable vector \(y(t_R)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
By default the next call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepEvolve}]{\sphinxcrossref{\sphinxcode{ERKStepEvolve()}}}} will use the step size
computed by ERKStep prior to calling {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}}. To set a
different step size or have ERKStep estimate a new step size use
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ERKStepSetInitStep()}}}}.

All previously set options are retained but may be updated by calling the
appropriate “Set” functions.

If an error occurred, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepReset}]{\sphinxcrossref{\sphinxcode{ERKStepReset()}}}} also sends an error message to
the error handler function.

\end{fulllineitems}



\subsection{ERKStep system resize function}
\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-cinterface-resizing}}\label{\detokenize{ERKStep_c_interface/User_callable:erkstep-system-resize-function}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatially-adaptive
PDE simulations under a method-of-lines approach), the ERKStep
integrator may be “resized” between integration steps, through calls
to the {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} function. This function modifies
ERKStep’s internal memory structures to use the new problem size,
without destruction of the temporal adaptivity heuristics.  It is
assumed that the dynamical time scales before and after the vector
resize will be comparable, so that all time-stepping heuristics prior
to calling {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} remain valid after the call.  If
instead the dynamics should be recomputed from scratch, the ERKStep
memory structure should be deleted with a call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepFree}]{\sphinxcrossref{\sphinxcode{ERKStepFree()}}}}, and recreated with a call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepCreate}]{\sphinxcrossref{\sphinxcode{ERKStepCreate()}}}}.

To aid in the vector resize operation, the user can supply a vector
resize function that will take as input a vector with the previous
size, and transform it in-place to return a corresponding vector of
the new size.  If this function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn()}}}})
is not supplied (i.e. is set to \sphinxcode{NULL}), then all existing vectors
internal to ERKStep will be destroyed and re-cloned from the new input
vector.

In the case that the dynamical time scale should be modified slightly
from the previous time scale, an input \sphinxstyleemphasis{hscale} is allowed, that will
rescale the upcoming time step by the specified factor.  If a value
\sphinxstyleemphasis{hscale} \(\le 0\) is specified, the default of 1.0 will be used.
\index{ERKStepResize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}}\pysiglinewithargsret{int \sphinxbfcode{ERKStepResize}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ ynew}, realtype\sphinxstyleemphasis{ hscale}, realtype\sphinxstyleemphasis{ t0}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{ARKVecResizeFn}}}\sphinxstyleemphasis{ resize}, void*\sphinxstyleemphasis{ resize\_data}}{}
Re-initializes ERKStep with a different state vector but with
comparable dynamical time scale.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ERKStep memory block.

\item {} 
\sphinxstyleemphasis{ynew} \textendash{} the newly-sized solution vector, holding the current
dependent variable values \(y(t_0)\).

\item {} 
\sphinxstyleemphasis{hscale} \textendash{} the desired scaling factor for the dynamical time
scale (i.e. the next step will be of size \sphinxstyleemphasis{h*hscale}).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the current value of the independent variable
\(t_0\) (this must be consistent with \sphinxstyleemphasis{ynew}).

\item {} 
\sphinxstyleemphasis{resize} \textendash{} the user-supplied vector resize function (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn()}}}}.

\item {} 
\sphinxstyleemphasis{resize\_data} \textendash{} the user-supplied data structure to be passed
to \sphinxstyleemphasis{resize} when modifying internal ERKStep vectors.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the ERKStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC} if \sphinxstyleemphasis{arkode\_mem} was not allocated.

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If an error occurred, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} also sends an error
message to the error handler function.

If inequality constraint checking is enabled a call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} will disable constraint checking. A call
to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ERKStepSetConstraints()}}}} is required to re-enable constraint
checking.

\end{fulllineitems}



\subsubsection{Resizing the absolute tolerance array}
\label{\detokenize{ERKStep_c_interface/User_callable:resizing-the-absolute-tolerance-array}}
If using array-valued absolute tolerances, the absolute tolerance
vector will be invalid after the call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}}, so
the new absolute tolerance vector should be re-set \sphinxstylestrong{following} each
call to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} through a new call to
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ERKStepSVtolerances()}}}}.

If scalar-valued tolerances or a tolerance function was specified
through either {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ERKStepSStolerances()}}}} or
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ERKStepWFtolerances()}}}}, then these will remain valid and no
further action is necessary.

\begin{sphinxadmonition}{note}{Note:}
For an example showing usage of the similar
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} routine, see the supplied serial C
example problem, \sphinxcode{ark\_heat1D\_adapt.c}.
\end{sphinxadmonition}


\section{User-supplied functions}
\label{\detokenize{ERKStep_c_interface/User_supplied:user-supplied-functions}}\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-usersupplied}}\label{\detokenize{ERKStep_c_interface/User_supplied::doc}}
The user-supplied functions for ERKStep consist of:
\begin{itemize}
\item {} 
a function that defines the ODE (required),

\item {} 
a function that handles error and warning messages (optional),

\item {} 
a function that provides the error weight vector (optional),

\item {} 
a function that handles adaptive time step error control (optional),

\item {} 
a function that handles explicit time step stability (optional),

\item {} 
a function that defines the root-finding problem(s) to solve
(optional),

\item {} 
a function that handles vector resizing operations, if the
underlying vector structure supports resizing (as opposed to
deletion/recreation), and if the user plans to call
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} (optional).

\end{itemize}


\subsection{ODE right-hand side}
\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-oderhs}}\label{\detokenize{ERKStep_c_interface/User_supplied:ode-right-hand-side}}
The user must supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} to
specify the right-hand side of the ODE system:
\index{ARKRhsFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKRhsFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRhsFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ydot}, void*\sphinxstyleemphasis{ user\_data}}{}
This function computes the ODE right-hand side for a given
value of the independent variable \(t\) and state vector \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{ydot} \textendash{} the output vector that forms the ODE RHS \(f(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} the \sphinxtitleref{user\_data} pointer that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ERKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRhsFn} should return 0 if successful, a positive value if a
recoverable error occurred (in which case ERKStep will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and \sphinxstyleemphasis{ARK\_RHSFUNC\_FAIL} is returned).

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxtitleref{ydot} is handled within the
ERKStep module.

The vector \sphinxstyleemphasis{ydot} may be uninitialized on input; it is the user’s
responsibility to fill this entire vector with meaningful values.

A recoverable failure error return from the \sphinxstyleemphasis{ARKRhsFn} is typically
used to flag a value of the dependent variable \(y\) that is
“illegal” in some way (e.g., negative where only a non-negative
value is physically meaningful).  If such a return is made, ERKStep
will attempt to recover by reducing the step size in order to avoid
this recoverable error return.  There are some situations in which
recovery is not possible even if the right-hand side function
returns a recoverable error flag.  One is when this occurs at the
very first call to the \sphinxstyleemphasis{ARKRhsFn} (in which case ERKStep returns
\sphinxstyleemphasis{ARK\_FIRST\_RHSFUNC\_ERR}).

\end{fulllineitems}



\subsection{Error message handler function}
\label{\detokenize{ERKStep_c_interface/User_supplied:error-message-handler-function}}\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-errorhandler}}
As an alternative to the default behavior of directing error and
warning messages to the file pointed to by \sphinxtitleref{errfp} (see
{\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrFile}]{\sphinxcrossref{\sphinxcode{ERKStepSetErrFile()}}}}), the user may provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ARKErrHandlerFn}}}} to process any such messages.
\index{ARKErrHandlerFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKErrHandlerFn}}\pysiglinewithargsret{typedef void \sphinxbfcode{(*ARKErrHandlerFn)}}{int\sphinxstyleemphasis{ error\_code}, const char*\sphinxstyleemphasis{ module}, const char*\sphinxstyleemphasis{ function}, char*\sphinxstyleemphasis{ msg}, void*\sphinxstyleemphasis{ user\_data}}{}
This function processes error and warning messages from
ERKStep and its sub-modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{error\_code} \textendash{} the error code.

\item {} 
\sphinxstyleemphasis{module} \textendash{} the name of the ERKStep module reporting the error.

\item {} 
\sphinxstyleemphasis{function} \textendash{} the name of the function in which the error occurred.

\item {} 
\sphinxstyleemphasis{msg} \textendash{} the error message.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{eh\_data} parameter that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetErrHandlerFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKErrHandlerFn} function has no return value.

\sphinxstylestrong{Notes:} \sphinxstyleemphasis{error\_code} is negative for errors and positive
(\sphinxstyleemphasis{ARK\_WARNING}) for warnings.  If a function that returns a
pointer to memory encounters an error, it sets \sphinxstyleemphasis{error\_code} to
0.

\end{fulllineitems}



\subsection{Error weight function}
\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-errorweight}}\label{\detokenize{ERKStep_c_interface/User_supplied:error-weight-function}}
As an alternative to providing the relative and absolute tolerances,
the user may provide a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn}}}} to compute a
vector \sphinxstyleemphasis{ewt} containing the weights in the WRMS norm
\(\|v\|_{WRMS} = \left(\frac{1}{n} \sum_{i=1}^n \left(ewt_i\; v_i\right)^2
\right)^{1/2}\).  These weights will be used in place of those defined
in the section {\hyperref[\detokenize{Mathematics:mathematics-error-norm}]{\sphinxcrossref{\DUrole{std,std-ref}{Error norms}}}}.
\index{ARKEwtFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKEwtFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKEwtFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ewt}, void*\sphinxstyleemphasis{ user\_data}}{}
This function computes the WRMS error weights for the vector
\(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the dependent variable vector at which the
weight vector is to be computed.

\item {} 
\sphinxstyleemphasis{ewt} \textendash{} the output vector containing the error weights.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ERKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKEwtFn} function must return 0 if it
successfully set the error weights, and -1 otherwise.

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{ewt} is handled within ERKStep.

The error weight vector must have all components positive.  It is
the user’s responsibility to perform this test and return -1 if it
is not satisfied.

\end{fulllineitems}



\subsection{Time step adaptivity function}
\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-adaptivityfn}}\label{\detokenize{ERKStep_c_interface/User_supplied:time-step-adaptivity-function}}
As an alternative to using one of the built-in time step adaptivity
methods for controlling solution error, the user may provide a
function of type {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}]{\sphinxcrossref{\sphinxcode{ARKAdaptFn}}}} to compute a target step size
\(h\) for the next integration step.  These steps should be chosen
as the maximum value such that the error estimates remain below 1.
\index{ARKAdaptFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKAdaptFn)}}{N\_Vector\sphinxstyleemphasis{ y}, realtype\sphinxstyleemphasis{ t}, realtype\sphinxstyleemphasis{ h1}, realtype\sphinxstyleemphasis{ h2}, realtype\sphinxstyleemphasis{ h3}, realtype\sphinxstyleemphasis{ e1}, realtype\sphinxstyleemphasis{ e2}, realtype\sphinxstyleemphasis{ e3}, int\sphinxstyleemphasis{ q}, int\sphinxstyleemphasis{ p}, realtype*\sphinxstyleemphasis{ hnew}, void*\sphinxstyleemphasis{ user\_data}}{}
This function implements a time step adaptivity algorithm
that chooses \(h\) satisfying the error tolerances.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{h1} \textendash{} the current step size, \(t_n - t_{n-1}\).

\item {} 
\sphinxstyleemphasis{h2} \textendash{} the previous step size, \(t_{n-1} - t_{n-2}\).

\item {} 
\sphinxstyleemphasis{h3} \textendash{} the step size \(t_{n-2}-t_{n-3}\).

\item {} 
\sphinxstyleemphasis{e1} \textendash{} the error estimate from the current step, \(n\).

\item {} 
\sphinxstyleemphasis{e2} \textendash{} the error estimate from the previous step, \(n-1\).

\item {} 
\sphinxstyleemphasis{e3} \textendash{} the error estimate from the step \(n-2\).

\item {} 
\sphinxstyleemphasis{q} \textendash{} the global order of accuracy for the method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} the global order of accuracy for the embedded method.

\item {} 
\sphinxstyleemphasis{hnew} \textendash{} the output value of the next step size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{h\_data} parameter that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetAdaptivityFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKAdaptFn} function should return 0 if it
successfully set the next step size, and a non-zero value otherwise.

\end{fulllineitems}



\subsection{Explicit stability function}
\label{\detokenize{ERKStep_c_interface/User_supplied:explicit-stability-function}}\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-stabilityfn}}
A user may supply a function to predict the maximum stable step size
for the explicit Runge Kutta method on this problem.  While the
accuracy-based time step adaptivity algorithms may be sufficient
for retaining a stable solution to the ODE system, these may be
inefficient if \(f(t,y)\) contains moderately stiff terms.  In
this scenario, a user may provide a function of type {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}]{\sphinxcrossref{\sphinxcode{ARKExpStabFn}}}}
to provide this stability information to ERKStep.  This function
must set the scalar step size satisfying the stability restriction for
the upcoming time step.  This value will subsequently be bounded by
the user-supplied values for the minimum and maximum allowed time
step, and the accuracy-based time step.
\index{ARKExpStabFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKExpStabFn)}}{N\_Vector\sphinxstyleemphasis{ y}, realtype\sphinxstyleemphasis{ t}, realtype*\sphinxstyleemphasis{ hstab}, void*\sphinxstyleemphasis{ user\_data}}{}
This function predicts the maximum stable step size for the ODE system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{hstab} \textendash{} the output value with the absolute value of the
maximum stable step size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{estab\_data} parameter that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ERKStepSetStabilityFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKExpStabFn} function should return 0 if it
successfully set the upcoming stable step size, and a non-zero
value otherwise.

\sphinxstylestrong{Notes:}  If this function is not supplied, or if it returns
\sphinxstyleemphasis{hstab} \(\le 0.0\), then ERKStep will assume that there is no explicit
stability restriction on the time step size.

\end{fulllineitems}



\subsection{Rootfinding function}
\label{\detokenize{ERKStep_c_interface/User_supplied:rootfinding-function}}\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-rootfindingfn}}
If a rootfinding problem is to be solved during the integration of the
ODE system, the user must supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{\sphinxcode{ARKRootFn}}}}.
\index{ARKRootFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKRootFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRootFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, realtype*\sphinxstyleemphasis{ gout}, void*\sphinxstyleemphasis{ user\_data}}{}
This function implements a vector-valued function
\(g(t,y)\) such that the roots of the \sphinxstyleemphasis{nrtfn} components
\(g_i(t,y)\) are sought.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{gout} \textendash{} the output array, of length \sphinxstyleemphasis{nrtfn}, with components \(g_i(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ERKStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRootFn} function should return 0 if successful
or a non-zero value if an error occurred (in which case the
integration is halted and ERKStep returns \sphinxstyleemphasis{ARK\_RTFUNC\_FAIL}).

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{gout} is handled within ERKStep.

\end{fulllineitems}



\subsection{Vector resize function}
\label{\detokenize{ERKStep_c_interface/User_supplied:vector-resize-function}}\label{\detokenize{ERKStep_c_interface/User_supplied:erkstep-cinterface-vecresizefn}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatial adaptivity in a
PDE simulation), the ERKStep integrator may be “resized” between
integration steps, through calls to the {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}}
function. Typically, when performing adaptive simulations the solution
is stored in a customized user-supplied data structure, to enable
adaptivity without repeated allocation/deallocation of memory.  In
these scenarios, it is recommended that the user supply a customized
vector kernel to interface between SUNDIALS and their problem-specific
data structure.  If this vector kernel includes a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn}}}} to resize a given vector implementation, then
this function may be supplied to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}} so that all
internal ERKStep vectors may be resized, instead of deleting and
re-creating them at each call.  This resize function should have the
following form:
\index{ARKVecResizeFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ERKStep_c_interface/User_supplied:c.ARKVecResizeFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKVecResizeFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ytemplate}, void*\sphinxstyleemphasis{ user\_data}}{}
This function resizes the vector \sphinxstyleemphasis{y} to match the dimensions of the
supplied vector, \sphinxstyleemphasis{ytemplate}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the vector to resize.

\item {} 
\sphinxstyleemphasis{ytemplate} \textendash{} a vector of the desired size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{resize\_data} parameter that was passed to {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepResize}]{\sphinxcrossref{\sphinxcode{ERKStepResize()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKVecResizeFn} function should return 0 if it successfully
resizes the vector \sphinxstyleemphasis{y}, and a non-zero value otherwise.

\sphinxstylestrong{Notes:}  If this function is not supplied, then ERKStep will
instead destroy the vector \sphinxstyleemphasis{y} and clone a new vector \sphinxstyleemphasis{y} off of
\sphinxstyleemphasis{ytemplate}.

\end{fulllineitems}



\chapter{Using MRIStep for C and C++ Applications}
\label{\detokenize{MRIStep_c_interface/index::doc}}\label{\detokenize{MRIStep_c_interface/index:using-mristep-for-c-and-c-applications}}\label{\detokenize{MRIStep_c_interface/index:mristep-cinterface}}
This chapter is concerned with the use of the MRIStep time-stepping
module for the solution of two-rate initial value problems (IVPs) in a
C or C++ language setting. The following sections discuss the header
files and the layout of the user’s main program, and provide
descriptions of the MRIStep user-callable functions and user-supplied
functions.

The example programs described in the companion document \phantomsection\label{\detokenize{MRIStep_c_interface/index:id1}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}} may
be helpful. Those codes may be used as templates for new codes and are
included in the ARKode package \sphinxcode{examples} subdirectory.

MRIStep uses the input and output constants from the shared ARKode
infrastructure. These are defined as needed in this chapter, but for
convenience the full list is provided separately in the section
{\hyperref[\detokenize{Constants:constants}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: ARKode Constants}}}}.

The relevant information on using MRIStep’s C and C++ interfaces is
detailed in the following sub-sections.


\section{Access to library and header files}
\label{\detokenize{MRIStep_c_interface/General:mristep-cinterface-headers}}\label{\detokenize{MRIStep_c_interface/General::doc}}\label{\detokenize{MRIStep_c_interface/General:access-to-library-and-header-files}}
At this point, it is assumed that the installation of ARKode,
following the procedure described in the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}},
has been completed successfully.

Regardless of where the user’s application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
ARKode. The relevant library files are
\begin{itemize}
\item {} 
\sphinxcode{libdir/libsundials\_arkode.lib},

\item {} 
\sphinxcode{libdir/libsundials\_nvec*.lib},

\end{itemize}

where the file extension \sphinxcode{.lib} is typically \sphinxcode{.so} for shared
libraries and \sphinxcode{.a} for static libraries.  The relevant header files
are located in the subdirectories
\begin{itemize}
\item {} 
\sphinxcode{incdir/include/arkode}

\item {} 
\sphinxcode{incdir/include/sundials}

\item {} 
\sphinxcode{incdir/include/nvector}

\item {} 
\sphinxcode{incdir/include/sunmatrix}

\item {} 
\sphinxcode{incdir/include/sunlinsol}

\item {} 
\sphinxcode{incdir/include/sunnonlinsol}

\end{itemize}

The directories \sphinxcode{libdir} and \sphinxcode{incdir} are the installation library
and include directories, respectively.  For a default installation,
these are \sphinxcode{instdir/lib} and \sphinxcode{instdir/include}, respectively, where
\sphinxcode{instdir} is the directory where SUNDIALS was installed (see the
section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}} for further details).


\section{Data Types}
\label{\detokenize{MRIStep_c_interface/General:mristep-cinterface-datatypes}}\label{\detokenize{MRIStep_c_interface/General:data-types}}
The \sphinxcode{sundials\_types.h} file contains the definition of the variable
type \sphinxcode{realtype}, which is used by the SUNDIALS solvers for all
floating-point data, the definition of the integer type
\sphinxcode{sunindextype}, which is used for vector and matrix indices, and
\sphinxcode{booleantype}, which is used for certain logic operations within
SUNDIALS.


\subsection{Floating point types}
\label{\detokenize{MRIStep_c_interface/General:floating-point-types}}
The type “\index{realtype}realtype” can be set to
\sphinxcode{float}, \sphinxcode{double}, or \sphinxcode{long double}, depending on how SUNDIALS
was installed (with the default being \sphinxcode{double}). The user can change
the precision of the SUNDIALS solvers’ floating-point arithmetic at the
configuration stage (see the section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}}).

Additionally, based on the current precision, \sphinxcode{sundials\_types.h}
defines the values \index{BIG\_REAL}BIG\_REAL to be the largest value
representable as a \sphinxcode{realtype}, \index{SMALL\_REAL}SMALL\_REAL to be the
smallest positive value representable as a \sphinxcode{realtype}, and
\index{UNIT\_ROUNDOFF}UNIT\_ROUNDOFF to be the smallest realtype number,
\(\varepsilon\), such that \(1.0 + \varepsilon \ne 1.0\).

Within SUNDIALS, real constants may be set to have the appropriate
precision by way of a macro called \index{RCONST}RCONST.  It is this macro
that needs the ability to branch on the definition \sphinxcode{realtype}.  In
ANSI C, a floating-point constant with no suffix is stored as a
\sphinxcode{double}. Placing the suffix “F” at the end of a floating point
constant makes it a \sphinxcode{float}, whereas using the suffix “L” makes it a
\sphinxcode{long double}. For example,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define A 1.0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define B 1.0F}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define C 1.0L}
\end{sphinxVerbatim}

defines \sphinxcode{A} to be a \sphinxcode{double} constant equal to 1.0, \sphinxcode{B} to be a
\sphinxcode{float} constant equal to 1.0, and \sphinxcode{C} to be a \sphinxcode{long double} constant
equal to 1.0.  The macro call \sphinxcode{RCONST(1.0)} automatically expands to
1.0 if \sphinxcode{realtype} is \sphinxcode{double}, to \sphinxcode{1.0F} if \sphinxcode{realtype} is \sphinxcode{float}, or
to \sphinxcode{1.0L} if \sphinxcode{realtype} is \sphinxcode{long double}. SUNDIALS uses the \sphinxcode{RCONST}
macro internally to declare all of its floating-point constants.

A user program which uses the type \sphinxcode{realtype} and the \sphinxcode{RCONST} macro
to handle floating-point constants is precision-independent, except for
any calls to precision-specific standard math library functions.
Users can, however, use the types \sphinxcode{double}, \sphinxcode{float}, or \sphinxcode{long
double} in their code (assuming that this usage is consistent with
the size of \sphinxcode{realtype} values that are passed to and from SUNDIALS).
Thus, a previously existing piece of ANSI C code can use SUNDIALS
without modifying the code to use \sphinxcode{realtype}, so long as the
SUNDIALS libraries have been compiled using the same precision (for
details see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\subsection{Integer types used for vector and matrix indices}
\label{\detokenize{MRIStep_c_interface/General:integer-types-used-for-vector-and-matrix-indices}}
The type \sphinxcode{sunindextype} can be either a 32- or 64-bit \sphinxstyleemphasis{signed} integer.
The default is the portable \sphinxcode{int64\_t} type, and the user can change it
to \sphinxcode{int32\_t} at the configuration stage. The configuration system
will detect if the compiler does not support portable types, and will
replace \sphinxcode{int32\_t} and \sphinxcode{int64\_t} with \sphinxcode{int}, \sphinxcode{long int}, or
\sphinxcode{long long int} as appropriate, to ensure use of the desired sizes on
Linux, Mac OS X, and Windows platforms. SUNDIALS currently does not support
\sphinxstyleemphasis{unsigned} integer types for vector and matrix indices, although these could
be added in the future if there is sufficient demand.

A user program which uses \sphinxcode{sunindextype} to handle vector and matrix indices
will work with both index storage types except for any calls to index storage-specific
external libraries. (Our \sphinxcode{C} and \sphinxcode{C++} example programs use \sphinxcode{sunindextype}.)
Users can, however, use any one of \sphinxcode{int}, \sphinxcode{long int}, \sphinxcode{int32\_t}, \sphinxcode{int64\_t} or
\sphinxcode{long long int} in their code, assuming that this usage is consistent with the typedef
for \sphinxcode{sunindextype} on their architecture. Thus, a previously existing piece of ANSI
C code can use SUNDIALS without modifying the code to use \sphinxcode{sunindextype},
so long as the SUNDIALS libraries use the appropriate index storage type (for details
see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\section{Header Files}
\label{\detokenize{MRIStep_c_interface/General:header-files}}
When using MRIStep, the calling program must include several header
files so that various macros and data types can be used. The header
file that is always required is:
\begin{itemize}
\item {} 
\sphinxcode{arkode/arkode\_mristep.h}, the main header file for the MRIStep
time-stepping module, which defines the several types and various
constants, includes function prototypes, and includes the shared
\sphinxcode{arkode/arkode.h} header file.

\end{itemize}

Note that \sphinxcode{arkode.h} includes \sphinxcode{sundials\_types.h} directly, which
defines the types \sphinxcode{realtype},  \sphinxcode{sunindextype}, and \sphinxcode{booleantype}
and the constants \sphinxcode{SUNFALSE} and \sphinxcode{SUNTRUE}, so a user program does
not need to include \sphinxcode{sundials\_types.h} directly.

Additionally, the calling program must also include an NVECTOR
implementation header file, of the form \sphinxcode{nvector/nvector\_***.h},
corresponding to the user’s preferred data layout and form of
parallelism.  See the section {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}} for details for the
appropriate name.  This file in turn includes the header file
\sphinxcode{sundials\_nvector.h} which defines the abstract \sphinxcode{N\_Vector} data
type.

If the user wishes to manually select between any of the pre-defined
ERK or DIRK Butcher tables as the basis for a MIS method, these are defined
through a set of constants that are enumerated in the header files
\sphinxcode{arkode/arkode\_butcher\_erk.h} and \sphinxcode{arkode/arkode\_butcher\_dirk.h}, or if a
user wishes to manually specify a Butcher table, the corresponding
\sphinxcode{ARKodeButcherTable} structure is defined in \sphinxcode{arkode/arkode\_butcher.h}.
Alternatively, slow-to-fast coupling coefficient tables are enumerated in the
header file \sphinxcode{arkode/arkode\_mristp.h}, or if a user wishes to manually specify
a coupling table, the corresponding \sphinxcode{MRIStepCouplingMem} structure is defined
in \sphinxcode{arkode/arkode\_mristep.h}.

If the user specifies that the slow time scale should be treated
implicitly, then each implicit stage will require a nonlinear solver for
the resulting system of algebraic equations \textendash{} the default for this is a
modified or inexact Newton iteration, depending on the user’s choice of
linear solver.  If using a non-default nonlinear solver
module, or when interacting with a SUNNONLINSOL module directly, the
calling program must also include a SUNNONLINSOL header file, of the
form \sphinxcode{sunnonlinsol/sunnonlinsol\_***.h} where \sphinxcode{***} is the name of
the nonlinear solver module (see the section {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for
more information).  This file in turn includes the header file
\sphinxcode{sundials\_nonlinearsolver.h} which defines the abstract
\sphinxcode{SUNNonlinearSolver} data type.

If using a nonlinear solver that requires the solution of a linear
system of the form \(\mathcal{A}x=b\) (e.g., the default Newton
iteration), then a linear solver module header file will also
be required.  The header files corresponding to the SUNDIALS-provided
linear solver modules available for use with ARKode are:
\begin{itemize}
\item {} 
Direct linear solvers:
\begin{itemize}
\item {} 
\sphinxcode{sunlinsol/sunlinsol\_dense.h},
which is used with the dense linear solver module,
SUNLINSOL\_DENSE;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_band.h},
which is used with the banded linear solver module,
SUNLINSOL\_BAND;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_lapackdense.h},
which is used with the LAPACK dense linear solver module,
SUNLINSOL\_LAPACKDENSE;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_lapackband.h},
which is used with the LAPACK banded linear solver module,
SUNLINSOL\_LAPACKBAND;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_klu.h},
which is used with the KLU sparse linear solver module,
SUNLINSOL\_KLU;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_superlumt.h},
which is used with the SuperLU\_MT sparse linear solver module,
SUNLINSOL\_SUPERLUMT;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_superludist.h},
which is used with the SuperLU\_DIST parallel sparse linear solver module,
SUNLINSOL\_SUPERLUDIST;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_cusolversp\_batchqr.h},
which is used with the batched sparse QR factorization method provided
by the NVDIA cuSOLVER library, SUNLINSOL\_CUSOLVERSP\_BATCHQR;

\end{itemize}

\item {} 
Iterative linear solvers:
\begin{itemize}
\item {} 
\sphinxcode{sunlinsol/sunlinsol\_spgmr.h},
which is used with the scaled, preconditioned GMRES Krylov linear
solver module, SUNLINSOL\_SPGMR;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_spfgmr.h},
which is used with the scaled, preconditioned FGMRES Krylov linear
solver module, SUNLINSOL\_SPFGMR;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_spbcgs.h},
which is used with the scaled, preconditioned Bi-CGStab Krylov
linear solver module, SUNLINSOL\_SPBCGS;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_sptfqmr.h},
which is used with the scaled, preconditioned TFQMR Krylov linear
solver module, SUNLINSOL\_SPTFQMR;

\item {} 
\sphinxcode{sunlinsol/sunlinsol\_pcg.h},
which is used with the scaled, preconditioned CG Krylov linear
solver module, SUNLINSOL\_PCG;

\end{itemize}

\end{itemize}

The header files for the SUNLINSOL\_DENSE and SUNLINSOL\_LAPACKDENSE
linear solver modules include the file
\sphinxcode{sunmatrix/sunmatrix\_dense.h}, which defines the SUNMATRIX\_DENSE
matrix module, as well as various functions and macros for acting on
such matrices.

The header files for the SUNLINSOL\_BAND and SUNLINSOL\_LAPACKBAND
linear solver modules include the file \sphinxcode{sunmatrix/sunmatrix\_band.h},
which defines the SUNMATRIX\_BAND matrix module, as well as various
functions and macros for acting on such matrices.

The header files for the SUNLINSOL\_KLU and SUNLINSOL\_SUPERLUMT linear
solver modules include the file \sphinxcode{sunmatrix/sunmatrix\_sparse.h},
which defines the SUNMATRIX\_SPARSE matrix module, as well as various
functions and macros for acting on such matrices.

The header file for the SUNLINSOL\_CUSOLVERSP\_BATCHQR
linear solver module includes the file \sphinxcode{sunmatrix/sunmatrix\_cusparse.h},
which defines the SUNMATRIX\_CUSPARSE matrix module, as well as various
functions for acting on such matrices.

The header file for the SUNLINSOL\_SUPERLUDIST
linear solver module includes the file \sphinxcode{sunmatrix/sunmatrix\_slunrloc.h},
which defines the SUNMATRIX\_SLUNRLOC matrix module, as well as various
functions for acting on such matrices.

The header files for the Krylov iterative solvers include the file
\sphinxcode{sundials/sundials\_iterative.h}, which enumerates the
preconditioning type and (for the SPGMR and SPFGMR solvers) the
choices for the Gram-Schmidt orthogonalization process.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, if preconditioning for an iterative
linear solver were performed using the ARKBBDPRE module, the header
\sphinxcode{arkode/arkode\_bbdpre.h} is needed to access the preconditioner
initialization routines.


\section{A skeleton of the user’s main program}
\label{\detokenize{MRIStep_c_interface/Skeleton:mristep-cinterface-skeleton}}\label{\detokenize{MRIStep_c_interface/Skeleton::doc}}\label{\detokenize{MRIStep_c_interface/Skeleton:a-skeleton-of-the-user-s-main-program}}
The following is a skeleton of the user’s main program (or calling
program) for the integration of an ODE IVP using the MRIStep module.
Most of the steps are independent of the NVECTOR, SUNMATRIX, SUNLINSOL
and SUNNONLINSOL implementations used.
For the steps that are not, refer to the sections {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}}, {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}},
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}, and  {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for
the specific name of the function to be called or macro to be
referenced.

\index{User main program}\ignorespaces \begin{enumerate}
\item {} 
Initialize parallel or multi-threaded environment, if appropriate.

For example, call \sphinxcode{MPI\_Init} to initialize MPI if used, or set
\sphinxcode{num\_threads}, the number of threads to use within the threaded
vector functions, if used.

\item {} 
Set problem dimensions, etc.

This generally includes the problem size, \sphinxcode{N}, and may include
the local vector length \sphinxcode{Nlocal}.

\begin{sphinxadmonition}{note}{Note:}
The variables \sphinxcode{N} and \sphinxcode{Nlocal} should be of type
\sphinxcode{sunindextype}.
\end{sphinxadmonition}

\item {} 
Set vector of initial values

To set the vector \sphinxcode{y0} of initial values, use the appropriate
functions defined by the particular NVECTOR implementation.

For native SUNDIALS vector implementations (except the CUDA and
RAJA based ones), use a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

if the \sphinxcode{realtype} array \sphinxcode{ydata} containing the initial values of
\(y\) already exists.  Otherwise, create a new vector by making
a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNew\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and then set its elements by accessing the underlying data where it
is located with a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

See the sections {\hyperref[\detokenize{nvectors/NVector_Serial:nvectors-nvserial}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_SERIAL Module}}}} through
{\hyperref[\detokenize{nvectors/NVector_Pthreads:nvectors-pthreads}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PTHREADS Module}}}} for details.

For the HYPRE and PETSc vector wrappers, first create and initialize
the underlying vector, and then create the NVECTOR wrapper with a call
of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{yvec}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{yvec} is a HYPRE or PETSc vector.  Note that calls like
\sphinxcode{N\_VNew\_***(...)} and \sphinxcode{N\_VGetArrayPointer\_***(...)} are not
available for these vector wrappers.  See the sections
{\hyperref[\detokenize{nvectors/NVector_ParHyp:nvectors-parhyp}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PARHYP Module}}}} and {\hyperref[\detokenize{nvectors/NVector_PETSc:nvectors-nvpetsc}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PETSC Module}}}} for details.

If using either the CUDA- or RAJA-based vector implementations use
calls to the module-specific routines

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

as applicable.  See the sections
{\hyperref[\detokenize{nvectors/NVector_CUDA:nvectors-cuda}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_CUDA Module}}}} and {\hyperref[\detokenize{nvectors/NVector_RAJA:nvectors-raja}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_RAJA Module}}}} for details.

\item {} 
Create an ARKStep object for the fast (inner) integration

Call \sphinxcode{inner\_arkode\_mem = ARKStepCreate(...)} to create the ARKStep memory
block. {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} returns a \sphinxcode{void*} pointer to
this memory structure. See the section
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-initialization}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKStep initialization and deallocation functions}}}} for details.

\item {} 
Configure the fast (inner) integrator

Specify tolerances, create and attach matrix and/or solver objects,
or call \sphinxcode{ARKStepSet*} functions to configure the fast integrator
as desired. See sections {\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details on configuring
ARKStep.

\sphinxstyleemphasis{Notes on using ARKStep as a fast integrator:}

It is the user’s responsibility to create, configure, and attach the
\sphinxcode{inner\_arkode\_mem} to the MRIStep module.  User-specified options
regarding how this fast integration should be performed (e.g., adaptive
versus fixed time step, explicit/implicit/ImEx partitioning, algebraic
solvers, etc.) will be respected during integration of the fast time scales
during MRIStep integration.

If a \sphinxstyleemphasis{user\_data} pointer needs to be passed to user functions called by the
fast (inner) integrator then it should be attached here by calling
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}. This \sphinxstyleemphasis{user\_data} pointer will only be passed
to user-supplied functions that are attached to the fast (inner) integrator.
To supply a \sphinxstyleemphasis{user\_data} pointer to user-supplied functions called by the slow
(outer) integrator the desired pointer should be attached by calling
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}} after creating the MRIStep memory below. Note
the \sphinxstyleemphasis{user\_data} pointers attached to the inner and outer integrators may
be the same or different depending on what is required by the user code.

Specifying a rootfinding problem for the fast integration is not
supported. Rootfinding problems should be created and initialized with
the slow integrator. See the steps below and {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}]{\sphinxcrossref{\sphinxcode{MRIStepRootInit()}}}}
for more details.

We note that due to the algorithms supported in MRIStep, the
ARKStep module used for the fast time scale must be configured
with an identity mass matrix.

\item {} 
Create an MRIStep object for the slow (outer) integration

Call \sphinxcode{arkode\_mem = MRIStepCreate(..., inner\_arkode\_mem)} to create the
MRIStep memory block. {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} returns a \sphinxcode{void*} pointer
to this memory structure. See the section
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-initialization}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStep initialization and deallocation functions}}}} for details.

\item {} 
Set the slow step size

Call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{MRIStepSetFixedStep()}}}} to specify the slow time step
size.

Specifically, if MRIStep is configured to use an implicit solver for the
slow time scale, then the following steps are recommended:

\item {} 
Create and configure implicit solvers

If MRIStep is configured to use an implicit solver for the slow time scale, then:
\begin{enumerate}
\item {} 
Specify integration tolerances

Call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSStolerances}]{\sphinxcrossref{\sphinxcode{MRIStepSStolerances()}}}} or {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSVtolerances}]{\sphinxcrossref{\sphinxcode{MRIStepSVtolerances()}}}} to
specify either a scalar relative tolerance and scalar absolute tolerance,
or a scalar relative tolerance and a vector of absolute tolerances,
respectively.  Alternatively, call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWFtolerances}]{\sphinxcrossref{\sphinxcode{MRIStepWFtolerances()}}}}
to specify a function which sets directly the weights used in
evaluating WRMS vector norms. See the section
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-tolerances}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStep tolerance specification functions}}}} for details.

\item {} 
Create nonlinear solver object

If a non-default nonlinear solver object is desired for implicit
MRI stage solves (see the section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}}),
then that nonlinear solver object must be created by using
the appropriate functions defined by the particular SUNNONLINSOL
implementation (e.g., \sphinxcode{NLS = SUNNonlinSol\_***(...);} where
\sphinxcode{***} is the name of the nonlinear solver (see the section
{\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for details).

For the SUNDIALS-supplied SUNNONLINSOL implementations, the
nonlinear solver object may be created using a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNNonlinearSolver} \PYG{n}{NLS} \PYG{o}{=} \PYG{n}{SUNNonlinSol\PYGZus{}}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{*} can be replaced with “Newton”, “FixedPoint”, or other
options, as discussed in the sections
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}} and {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}}.

Note: by default, MRIStep will use the Newton nonlinear solver
(see section {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsol-newton}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNNonlinearSolver\_Newton implementation}}}}), so a custom nonlinear solver
object is only needed when using a \sphinxstyleemphasis{different} solver, or for the user
to exercise additional controls over the Newton solver.

\item {} 
Attach nonlinear solver module

If a nonlinear solver object was created above, then it must be
attached to MRIStep using the call (for details see the
section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-nonlinearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver interface functions}}}}):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{MRIStepSetNonlinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Set nonlinear solver optional inputs

Call the appropriate set functions for the selected nonlinear
solver module to change optional inputs specific to that nonlinear
solver.  These \sphinxstyleemphasis{must} be called after attaching the nonlinear
solver to MRIStep, otherwise the optional inputs will be
overridden by MRIStep defaults.  See the section
{\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} for more information on optional inputs.

\item {} 
Create matrix object

If a nonlinear solver requiring a linear solver will be used (e.g.,
a Newton iteration) and if that linear solver will be matrix-based,
then a template Jacobian matrix must be created by using the
appropriate functions defined by the particular SUNMATRIX
implementation.

For the SUNDIALS-supplied SUNMATRIX implementations, the
matrix object may be created using a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatrix} \PYG{n}{A} \PYG{o}{=} \PYG{n}{SUNBandMatrix}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatrix} \PYG{n}{A} \PYG{o}{=} \PYG{n}{SUNDenseMatrix}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatrix} \PYG{n}{A} \PYG{o}{=} \PYG{n}{SUNSparseMatrix}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or similarly for the CUDA and SuperLU\_DIST matrix modules (see the
sections {\hyperref[\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_CUSPARSE Module}}}} or {\hyperref[\detokenize{sunmatrix/SUNMatrix_SLUNRloc:sunmatrix-slunrloc}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_SLUNRLOC Module}}}} for
further information).

NOTE: The dense, banded, and sparse matrix objects are usable only in a
serial or threaded environment.

\item {} 
Create linear solver object

If a nonlinear solver requiring a linear solver will be used (e.g.,
a Newton iteration), then the desired linear solver object(s) must be
created by using the appropriate functions defined by the particular
SUNLINSOL implementation.

For any of the SUNDIALS-supplied SUNLINSOL implementations, the
linear solver object may be created using a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNLinearSolver} \PYG{n}{LS} \PYG{o}{=} \PYG{n}{SUNLinSol\PYGZus{}}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{*} can be replaced with “Dense”, “SPGMR”, or other
options, as discussed in the sections
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface functions}}}} and {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

\item {} 
Set linear solver optional inputs

Call \sphinxcode{*Set*} functions from the selected linear solver module
to change optional inputs specific to that linear solver.  See the
documentation for each SUNLINSOL module in the section
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}} for details.

\item {} 
Attach linear solver module

If a linear solver was created above for implicit MRI stage solves,
initialize the ARKLS linear solver interface by attaching the
linear solver object (and Jacobian matrix object, if applicable)
with the call (for details see the section
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-linearsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface functions}}}}):

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{MRIStepSetLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

\item {} 
Set optional inputs

Call \sphinxcode{MRIStepSet*} functions to change any optional inputs that
control the behavior of MRIStep from their default values. See the
section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details.

\item {} 
Specify rootfinding problem

Optionally, call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}]{\sphinxcrossref{\sphinxcode{MRIStepRootInit()}}}} to initialize a rootfinding
problem to be solved during the integration of the ODE system. See
the section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding initialization function}}}} for general details, and
the section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for relevant optional
input calls.

\item {} 
Advance solution in time

For each point at which output is desired, call

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{MRIStepEvolve}\PYG{p}{(}\PYG{n}{arkode\PYGZus{}mem}\PYG{p}{,} \PYG{n}{tout}\PYG{p}{,} \PYG{n}{yout}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tret}\PYG{p}{,} \PYG{n}{itask}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{itask} specifies the return mode. The vector \sphinxcode{yout}
(which can be the same as the vector \sphinxcode{y0} above) will contain
\(y(t_\text{out})\). See the section
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-integration}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStep solver function}}}} for details.

\item {} 
Get optional outputs

Call \sphinxcode{MRIStepGet*} and/or \sphinxcode{ARKStepGet*} functions to obtain optional
output from the slow or fast integrators respectively. See
the section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}} for details.

\item {} 
Deallocate memory for solution vector

Upon completion of the integration, deallocate memory for the
vector \sphinxcode{y} (or \sphinxcode{yout}) by calling the NVECTOR destructor
function:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDestroy}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
Free solver memory
\begin{quote}

Call \sphinxcode{ARKStepFree(\&inner\_arkode\_mem)} and \sphinxcode{MRIStepFree(\&arkode\_mem)} to
free the memory allocated for fast and slow integration modules respectively.
\end{quote}

\item {} 
Free linear solver and matrix memory
\begin{quote}

Call {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolFree}]{\sphinxcrossref{\sphinxcode{SUNLinSolFree()}}}} and (possibly)
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatDestroy}]{\sphinxcrossref{\sphinxcode{SUNMatDestroy()}}}} to free any memory allocated for any
linear solver and/or matrix objects created above for either the fast or
slow integrators.
\end{quote}

\item {} 
Free nonlinear solver memory

If a user-supplied \sphinxcode{SUNNonlinearSolver} was provided to MRIStep,
then call {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolFree}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolFree()}}}} to free any memory allocated
for the nonlinear solver object created above.

\item {} 
Finalize MPI, if used
\begin{quote}

Call \sphinxcode{MPI\_Finalize} to terminate MPI.
\end{quote}

\end{enumerate}

SUNDIALS provides some linear solvers only as a means for users to get
problems running and not as highly efficient solvers.  For example, if
solving a dense system, we suggest using the LAPACK solvers if the
size of the linear system is \(> 50,000\) (thanks to A. Nicolai
for his testing and recommendation).  See the table
{\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-solver-vector}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS linear solver interfaces and vector implementations that can be used for each}}}} for a listing of the
linear solver interfaces available as \sphinxcode{SUNLinearSolver} modules and
the vector implementations required for use.


\section{MRIStep User-callable functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-usercallable}}\label{\detokenize{MRIStep_c_interface/User_callable::doc}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-user-callable-functions}}
This section describes the functions that are called by the
user to setup and then solve an IVP using the MRIStep time-stepping
module. Some of these are required; however, starting with the section
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs may be
skipped for a casual use of ARKode’s MRIStep module. In any case,
refer to the preceding section, {\hyperref[\detokenize{MRIStep_c_interface/Skeleton:mristep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}},
for the correct order of these calls.

On an error, each user-callable function returns a negative value  (or
\sphinxcode{NULL} if the function returns a pointer) and sends an error message
to the error handler routine, which prints the message to \sphinxcode{stderr}
by default. However, the user can set a file as error output or can
provide her own error handler function (see the section
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} for details).


\subsection{MRIStep initialization and deallocation functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-initialization-and-deallocation-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-initialization}}\index{MRIStepCreate (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}}\pysiglinewithargsret{void* \sphinxbfcode{MRIStepCreate}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ fs}, realtype\sphinxstyleemphasis{ t0}, N\_Vector\sphinxstyleemphasis{ y0}, MRISTEP\_ID\sphinxstyleemphasis{ inner\_step\_id}, void*\sphinxstyleemphasis{ inner\_step\_mem}}{}
This function allocates and initializes memory for a problem to
be solved using the MRIStep time-stepping module in ARKode.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{fs} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the slow portion of the right-hand side function in
\(\dot{y} = f_s(t,y) + f_f(t,y)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the initial value of \(t\).

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the initial condition vector \(y(t_0)\).

\item {} 
\sphinxstyleemphasis{inner\_step\_id} \textendash{} the identifier for the inner stepper. Currently
\sphinxcode{MRISTEP\_ARKSTEP} is the only supported option.

\item {} 
\sphinxstyleemphasis{inner\_step\_mem} \textendash{} a \sphinxcode{void*} pointer to the ARKStep memory block for
integrating the fast time scale.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  If successful, a pointer to initialized problem memory
of type \sphinxcode{void*}, to be passed to all user-facing MRIStep routines
listed below.  If unsuccessful, a \sphinxcode{NULL} pointer will be
returned, and an error message will be printed to \sphinxcode{stderr}.

\end{fulllineitems}

\index{MRIStepFree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepFree}}\pysiglinewithargsret{void \sphinxbfcode{MRIStepFree}}{void**\sphinxstyleemphasis{ arkode\_mem}}{}
This function frees the problem memory \sphinxstyleemphasis{arkode\_mem} created by
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  None

\end{fulllineitems}



\subsection{MRIStep tolerance specification functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-tolerance-specification-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-tolerances}}
These functions specify the integration tolerances. One of them
\sphinxstylestrong{should} be called before the first call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}; otherwise default values of \sphinxcode{reltol =
1e-4} and \sphinxcode{abstol = 1e-9} will be used, which may be entirely
incorrect for a specific problem.

The integration tolerances \sphinxcode{reltol} and \sphinxcode{abstol} define a vector
of error weights, \sphinxcode{ewt}.  In the case of
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSStolerances}]{\sphinxcrossref{\sphinxcode{MRIStepSStolerances()}}}}, this vector has components

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

whereas in the case of {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSVtolerances}]{\sphinxcrossref{\sphinxcode{MRIStepSVtolerances()}}}} the vector components
are given by

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This vector is used in all error tests, which use a weighted RMS norm
on all error-like vectors \(v\):
\begin{equation*}
\begin{split}\|v\|_{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N (v_i\; ewt_i)^2 \right)^{1/2},\end{split}
\end{equation*}
where \(N\) is the problem dimension.

Alternatively, the user may supply a custom function to supply the
\sphinxcode{ewt} vector, through a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWFtolerances}]{\sphinxcrossref{\sphinxcode{MRIStepWFtolerances()}}}}.
\index{MRIStepSStolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSStolerances}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSStolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ reltol}, realtype\sphinxstyleemphasis{ abstol}}{}
This function specifies scalar relative and absolute tolerances.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{reltol} \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{abstol} \textendash{} scalar absolute tolerance.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the MRIStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepSVtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSVtolerances}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSVtolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ reltol}, N\_Vector\sphinxstyleemphasis{ abstol}}{}
This function specifies a scalar relative tolerance and a vector
absolute tolerance (a potentially different absolute tolerance for
each vector component).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{reltol} \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{abstol} \textendash{} vector containing the absolute tolerances for each
solution component.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the MRIStep memory was not allocated by the time-stepping module

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepWFtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWFtolerances}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepWFtolerances}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{ARKEwtFn}}}\sphinxstyleemphasis{ efun}}{}
This function specifies a user-supplied function \sphinxstyleemphasis{efun} to compute
the error weight vector \sphinxcode{ewt}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{efun} \textendash{} the name of the function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn()}}}})
that implements the error weight vector computation.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC}  if the MRIStep memory was not allocated by the time-stepping module

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{General advice on the choice of tolerances}
\label{\detokenize{MRIStep_c_interface/User_callable:general-advice-on-the-choice-of-tolerances}}
For many users, the appropriate choices for tolerance values in
\sphinxcode{reltol} and \sphinxcode{abstol} are a concern. The following pieces
of advice are relevant.
\begin{enumerate}
\item {} 
The scalar relative tolerance \sphinxcode{reltol} is to be set to control
relative errors. So a value of \(10^{-4}\) means that errors
are controlled to .01\%. We do not recommend using \sphinxcode{reltol} larger
than \(10^{-3}\). On the other hand, \sphinxcode{reltol} should not be so
small that it is comparable to the unit roundoff of the machine
arithmetic (generally around \(10^{-15}\) for double-precision).

\item {} 
The absolute tolerances \sphinxcode{abstol} (whether scalar or vector) need
to be set to control absolute errors when any components of the
solution vector \(y\) may be so small that pure relative error
control is meaningless.  For example, if \(y_i\) starts at some
nonzero value, but in time decays to zero, then pure relative
error control on \(y_i\) makes no sense (and is overly costly)
after \(y_i\) is below some noise level. Then \sphinxcode{abstol} (if
scalar) or \sphinxcode{abstol{[}i{]}} (if a vector) needs to be set to that
noise level. If the different components have different noise
levels, then \sphinxcode{abstol} should be a vector.  For example, see the
example problem \sphinxcode{ark\_robertson.c}, and the discussion
of it in the ARKode Examples Documentation \phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:id1}}{\hyperref[\detokenize{References:r2018}]{\sphinxcrossref{{[}R2018{]}}}}.  In that
problem, the three components vary between 0 and 1, and have
different noise levels; hence the \sphinxcode{atols} vector therein. It is
impossible to give any general advice on \sphinxcode{abstol} values,
because the appropriate noise levels are completely
problem-dependent. The user or modeler hopefully has some idea as
to what those noise levels are.

\item {} 
Finally, it is important to pick all the tolerance values
conservatively, because they control the error committed on each
individual step. The final (global) errors are an accumulation of
those per-step errors, where that accumulation factor is
problem-dependent.  A general rule of thumb is to reduce the
tolerances by a factor of 10 from the actual desired limits on
errors.  So if you want .01\% relative accuracy (globally), a good
choice for \sphinxcode{reltol} is \(10^{-5}\).  In any case, it is
a good idea to do a few experiments with the tolerances to see how
the computed solution values vary as tolerances are reduced.

\end{enumerate}


\subsubsection{Advice on controlling nonphysical negative values}
\label{\detokenize{MRIStep_c_interface/User_callable:advice-on-controlling-nonphysical-negative-values}}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the
numerical solution, however, small negative (nonphysical) values
can then occur. In most cases, these values are harmless, and simply
need to be controlled, not eliminated, but in other cases any value
that violates a constraint may cause a simulation to halt. For both of
these scenarios the following pieces of advice are relevant.
\begin{enumerate}
\item {} 
The best way to control the size of unwanted negative computed
values is with tighter absolute tolerances.  Again this requires
some knowledge of the noise level of these components, which may
or may not be different for different components. Some
experimentation may be needed.

\item {} 
If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of
avoiding a long explanation of them, if nothing else), then
eliminate them, but only in the context of the output medium. Then
the internal values carried by the solver are unaffected. Remember
that a small negative value in \(y\) returned by MRIStep, with
magnitude comparable to \sphinxcode{abstol} or less, is equivalent to zero
as far as the computation is concerned.

\item {} 
The user’s right-hand side routine \(f^S\)
should never change a negative value in the solution vector \(y\)
to a non-negative value in attempt to “fix” this problem,
since this can lead to numerical instability.  If the \(f^S\)
routine cannot tolerate a zero or negative value (e.g. because
there is a square root or log), then the offending value should be
changed to zero or a tiny positive number in a temporary variable
(not in the input \(y\) vector) for the purposes of computing
\(f^S(t, y)\).

\end{enumerate}


\subsection{Linear solver interface functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-linearsolvers}}\label{\detokenize{MRIStep_c_interface/User_callable:linear-solver-interface-functions}}
As previously explained, the Newton iterations used in solving
implicit systems within MRIStep require the solution of linear
systems of the form
\begin{equation*}
\begin{split}{\mathcal A}\left(z_i^{(m)}\right) \delta^{(m+1)} = -G\left(z_i^{(m)}\right)\end{split}
\end{equation*}
where
\begin{equation*}
\begin{split}{\mathcal A} \approx I - \gamma J, \qquad J = \frac{\partial f^S}{\partial y}.\end{split}
\end{equation*}
ARKode’s ARKLS linear solver interface supports all valid
\sphinxcode{SUNLinearSolver} modules for this task.

Matrix-based \sphinxcode{SUNLinearSolver} modules utilize \sphinxcode{SUNMatrix} objects
to store the approximate Jacobian matrix \(J\), the Newton matrix
\({\mathcal A}\), and, when using direct solvers, the factorizations
used throughout the solution process.

Matrix-free \sphinxcode{SUNLinearSolver} modules instead use iterative methods
to solve the Newton systems of equations, and only require the
\sphinxstyleemphasis{action} of the matrix on a vector, \({\mathcal A}v\).  With most
of these methods, preconditioning can be done on the left only, on the
right only, on both the left and the right, or not at all.  The
exceptions to this rule are SPFGMR that supports right preconditioning
only and PCG that performs symmetric preconditioning.  For the
specification of a preconditioner, see the iterative linear solver
portions of the sections {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

If preconditioning is done, user-supplied functions should be used to
define left and right preconditioner matrices \(P_1\) and
\(P_2\) (either of which could be the identity matrix), such that
the product \(P_{1}P_{2}\) approximates the Newton matrix
\({\mathcal A} = I - \gamma J\).

To specify a generic linear solver for MRIStep to use for the Newton
systems, after the call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} but before any
calls to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}, the user’s program must create the
appropriate \sphinxcode{SUNLinearSolver} object and call the function
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}, as documented below.  To create
the \sphinxcode{SUNLinearSolver} object, the user may call one of the
SUNDIALS-packaged SUNLinSol module constructor routines via a call of
the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNLinearSolver} \PYG{n}{LS} \PYG{o}{=} \PYG{n}{SUNLinSol\PYGZus{}}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The current list of such constructor routines includes
{\hyperref[\detokenize{sunlinsol/SUNLinSol_Dense:c.SUNLinSol_Dense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Dense()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_Band:c.SUNLinSol_Band}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Band()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackDense:c.SUNLinSol_LapackDense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackDense()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackBand:c.SUNLinSol_LapackBand}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackBand()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLU}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLU()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMT}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMT()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUDIST()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_cuSolverSp:c.SUNLinSol_cuSolverSp_batchQR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_cuSolverSp\_batchQR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGS()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMR()}}}}, and
{\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCG()}}}}.

Alternately, a user-supplied
\sphinxcode{SUNLinearSolver} module may be created and used instead.  The use
of each of the generic linear solvers involves certain constants,
functions and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific \sphinxcode{SUNMatrix} or \sphinxcode{SUNLinearSolver}
module in question, as described in the sections {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} and
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

Once this solver object has been constructed, the user should attach
it to MRIStep via a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}. The
first argument passed to this function is the MRIStep memory pointer
returned by {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}; the second argument is the
\sphinxcode{SUNLinearSolver} object created above.  The third argument is an
optional \sphinxcode{SUNMatrix} object to accompany matrix-based
\sphinxcode{SUNLinearSolver} inputs (for matrix-free linear solvers, the third
argument should be \sphinxcode{NULL}).  A call to this function initializes the
ARKLS linear solver interface, linking it to the MRIStep integrator,
and allows the user to specify additional parameters and routines
pertinent to their choice of linear solver.
\index{MRIStepSetLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetLinearSolver}}{void*\sphinxstyleemphasis{ arkode\_mem}, SUNLinearSolver\sphinxstyleemphasis{ LS}, SUNMatrix\sphinxstyleemphasis{ J}}{}
This function specifies the \sphinxcode{SUNLinearSolver} object that MRIStep
should use, as well as a template Jacobian \sphinxcode{SUNMatrix} object (if
applicable).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{LS} \textendash{} the \sphinxcode{SUNLinearSolver} object to use.

\item {} 
\sphinxstyleemphasis{J} \textendash{} the template Jacobian \sphinxcode{SUNMatrix} object to use (or
\sphinxcode{NULL} if not applicable).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}   if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if ARKLS is incompatible with the
provided \sphinxstyleemphasis{LS} or \sphinxstyleemphasis{J} input objects, or the current
\sphinxcode{N\_Vector} module.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  If \sphinxstyleemphasis{LS} is a matrix-free linear solver, then the \sphinxstyleemphasis{J}
argument should be \sphinxcode{NULL}.

If \sphinxstyleemphasis{LS} is a matrix-based linear solver, then the template Jacobian
matrix \sphinxstyleemphasis{J} will be used in the solve process, so if additional
storage is required within the \sphinxcode{SUNMatrix} object (e.g. for
factorization of a banded matrix), ensure that the input object is
allocated with sufficient size (see the documentation of
the particular SUNMATRIX type in the section {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} for
further information).

When using sparse linear solvers, it is typically much more
efficient to supply \sphinxstyleemphasis{J} so that it includes the full sparsity
pattern of the Newton system matrices \({\mathcal A} =
I-\gamma J\), even if \sphinxstyleemphasis{J} itself has zeros in nonzero
locations of \(I\).  The reasoning for this is
that \({\mathcal A}\) is constructed in-place, on top of the
user-specified values of \sphinxstyleemphasis{J}, so if the sparsity pattern in \sphinxstyleemphasis{J} is
insufficient to store \({\mathcal A}\) then it will need to be
resized internally by MRIStep.

\end{fulllineitems}



\subsection{Nonlinear solver interface functions}
\label{\detokenize{MRIStep_c_interface/User_callable:nonlinear-solver-interface-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-nonlinearsolvers}}
When changing the nonlinear solver in MRIStep, after the
call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} but before any calls to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}, the user’s program must create the
appropriate SUNNonlinSol object and call
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetNonlinearSolver()}}}}, as documented below.  If any
calls to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} have been made, then MRIStep will
need to be reinitialized by calling {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} to
ensure that the nonlinear solver is initialized correctly before any
subsequent calls to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}.

The first argument passed to the routine
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetNonlinearSolver()}}}} is the MRIStep memory pointer
returned by {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}; the second argument passed
to this function is the desired SUNNonlinSol object to use for solving
the nonlinear system for each implicit stage. A call to this function
attaches the nonlinear solver to the main MRIStep integrator.
\index{MRIStepSetNonlinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinearSolver}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetNonlinearSolver}}{void*\sphinxstyleemphasis{ arkode\_mem}, SUNNonlinearSolver\sphinxstyleemphasis{ NLS}}{}
This function specifies the \sphinxcode{SUNNonlinearSolver} object
that MRIStep should use for implicit stage solves.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{NLS} \textendash{} the \sphinxcode{SUNNonlinearSolver} object to use.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS}   if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if MRIStep is incompatible with the
provided \sphinxstyleemphasis{NLS} input object.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  MRIStep will use the Newton SUNNonlinSol module by
default; a call to this routine replaces that module with the
supplied \sphinxstyleemphasis{NLS} object.

\end{fulllineitems}



\subsection{Rootfinding initialization function}
\label{\detokenize{MRIStep_c_interface/User_callable:rootfinding-initialization-function}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-rootfinding}}
As described in the section {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding}}}}, while
solving the IVP, ARKode’s time-stepping modules have the capability to
find the roots of a set of user-defined functions.  In the MRIStep module root
finding is performed between slow solution time steps only (i.e., it is not
performed within the sub-stepping a fast time scales).  To activate the
root-finding algorithm, call the following function.  This is normally
called only once, prior to the first call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}, but if the rootfinding problem is to be
changed during the solution, {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}]{\sphinxcrossref{\sphinxcode{MRIStepRootInit()}}}} can also be
called prior to a continuation call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}.
\index{MRIStepRootInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepRootInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ nrtfn}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{ARKRootFn}}}\sphinxstyleemphasis{ g}}{}
Initializes a rootfinding problem to be solved during the
integration of the ODE system.  It must be called after
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}, and before {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nrtfn} \textendash{} number of functions \(g_i\), an integer \(\ge\) 0.

\item {} 
\sphinxstyleemphasis{g} \textendash{} name of user-supplied function, of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{\sphinxcode{ARKRootFn()}}}},
defining the functions \(g_i\) whose roots are sought.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if \sphinxstyleemphasis{nrtfn} is greater than zero but \sphinxstyleemphasis{g} = \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} To disable the rootfinding feature after it has already
been initialized, or to free memory associated with MRIStep’s
rootfinding module, call \sphinxstyleemphasis{MRIStepRootInit} with \sphinxstyleemphasis{nrtfn = 0}.

Similarly, if a new IVP is to be solved with a call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}}, where the new IVP has no rootfinding
problem but the prior one did, then call \sphinxstyleemphasis{MRIStepRootInit} with
\sphinxstyleemphasis{nrtfn = 0}.

Rootfinding is only supported for the slow (outer) integrator and should not
be actived for the fast (inner) integrator.

\end{fulllineitems}



\subsection{MRIStep solver function}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-solver-function}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-integration}}
This is the central step in the solution process \textendash{} the call to perform
the integration of the IVP.  The input argument \sphinxstyleemphasis{itask} specifies one of two
modes as to where MRIStep is to return a solution.  These modes are modified if
the user has set a stop time (with a call to the optional input function
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStopTime}]{\sphinxcrossref{\sphinxcode{MRIStepSetStopTime()}}}}) or has requested rootfinding.
\index{MRIStepEvolve (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepEvolve}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tout}, N\_Vector\sphinxstyleemphasis{ yout}, realtype\sphinxstyleemphasis{ *tret}, int\sphinxstyleemphasis{ itask}}{}
Integrates the ODE over an interval in \(t\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{tout} \textendash{} the next time at which a computed solution is desired.

\item {} 
\sphinxstyleemphasis{yout} \textendash{} the computed solution vector.

\item {} 
\sphinxstyleemphasis{tret} \textendash{} the time corresponding to \sphinxstyleemphasis{yout} (output).

\item {} 
\sphinxstyleemphasis{itask} \textendash{} a flag indicating the job of the solver for the next
user step.

The \sphinxstyleemphasis{ARK\_NORMAL} option causes the solver to take internal
steps until it has just overtaken a user-specified output
time, \sphinxstyleemphasis{tout}, in the direction of integration,
i.e. \(t_{n-1} <\) \sphinxstyleemphasis{tout} \(\le t_{n}\) for forward
integration, or \(t_{n} \le\) \sphinxstyleemphasis{tout} \(< t_{n-1}\) for
backward integration.  It will then compute an approximation
to the solution \(y(tout)\) by interpolation (using one
of the dense output routines described in the section
{\hyperref[\detokenize{Mathematics:mathematics-interpolation}]{\sphinxcrossref{\DUrole{std,std-ref}{Interpolation}}}}).

The \sphinxstyleemphasis{ARK\_ONE\_STEP} option tells the solver to only take a
single internal step \(y_{n-1} \to y_{n}\) and then return
control back to the calling program.  If this step will
overtake \sphinxstyleemphasis{tout} then the solver will again return an
interpolated result; otherwise it will return a copy of the
internal solution \(y_{n}\) in the vector \sphinxstyleemphasis{yout}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_ROOT\_RETURN} if {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} succeeded, and
found one or more roots.  If the number of root functions,
\sphinxstyleemphasis{nrtfn}, is greater than 1, call
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{MRIStepGetRootInfo()}}}} to see which \(g_i\) were
found to have a root at (\sphinxstyleemphasis{*tret}).

\item {} 
\sphinxstyleemphasis{ARK\_TSTOP\_RETURN} if {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} succeeded and
returned at \sphinxstyleemphasis{tstop}.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the \sphinxstyleemphasis{arkode\_mem} argument was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC} if \sphinxstyleemphasis{arkode\_mem} was not allocated.

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if one of the inputs to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} is illegal, or some other input to
the solver was either illegal or missing.  Details will be
provided in the error message.  Typical causes of this failure:
\begin{enumerate}
\item {} 
A component of the error weight vector became zero during
internal time-stepping.

\item {} 
The linear solver initialization function (called by the
user after calling {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}}) failed to set
the linear solver-specific \sphinxstyleemphasis{lsolve} field in
\sphinxstyleemphasis{arkode\_mem}.

\item {} 
A root of one of the root functions was found both at a
point \(t\) and also very near \(t\).

\end{enumerate}

\item {} 
\sphinxstyleemphasis{ARK\_TOO\_MUCH\_WORK} if the solver took \sphinxstyleemphasis{mxstep} internal steps
but could not reach \sphinxstyleemphasis{tout}.  The default value for \sphinxstyleemphasis{mxstep} is
\sphinxstyleemphasis{MXSTEP\_DEFAULT = 500}.

\item {} 
\sphinxstyleemphasis{ARK\_CONV\_FAILURE} if convergence test failures occurred
too many times (\sphinxstyleemphasis{ark\_maxncf}) during one internal time step.

\item {} 
\sphinxstyleemphasis{ARK\_LINIT\_FAIL} if the linear solver’s initialization
function failed.

\item {} 
\sphinxstyleemphasis{ARK\_LSETUP\_FAIL} if the linear solver’s setup routine failed in
an unrecoverable manner.

\item {} 
\sphinxstyleemphasis{ARK\_LSOLVE\_FAIL} if the linear solver’s solve routine failed in
an unrecoverable manner.

\item {} 
\sphinxstyleemphasis{ARK\_VECTOROP\_ERR} a vector operation error occured.

\item {} 
\sphinxstyleemphasis{ARK\_INNERSTEP\_FAILED} if the inner stepper returned with an
unrecoverable error. The value returned from the inner stepper can be
obtained with {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastInnerStepFlag}]{\sphinxcrossref{\sphinxcode{MRIStepGetLastInnerStepFlag()}}}}.

\item {} 
\sphinxstyleemphasis{ARK\_INVALID\_TABLE} if an invalid coupling table was provided.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The input vector \sphinxstyleemphasis{yout} can use the same memory as the
vector \sphinxstyleemphasis{y0} of initial conditions that was passed to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}.

In \sphinxstyleemphasis{ARK\_ONE\_STEP} mode, \sphinxstyleemphasis{tout} is used only on the first call, and
only to get the direction and a rough scale of the independent
variable.

All failure return values are negative and so testing the return argument for
negative values will trap all {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} failures.

Since interpolation may reduce the accuracy in the reported
solution, if full method accuracy is desired the user should issue
a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStopTime}]{\sphinxcrossref{\sphinxcode{MRIStepSetStopTime()}}}} before the call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} to specify a fixed stop time to
end the time step and return to the user.  Upon return from
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}, a copy of the internal solution
\(y_{n}\) will be returned in the vector \sphinxstyleemphasis{yout}.  Once the
integrator returns at a \sphinxstyleemphasis{tstop} time, any future testing for
\sphinxstyleemphasis{tstop} is disabled (and can be re-enabled only though a new call
to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStopTime}]{\sphinxcrossref{\sphinxcode{MRIStepSetStopTime()}}}}).

On any error return in which one or more internal steps were taken
by {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}, the returned values of \sphinxstyleemphasis{tret} and
\sphinxstyleemphasis{yout} correspond to the farthest point reached in the integration.
On all other error returns, \sphinxstyleemphasis{tret} and \sphinxstyleemphasis{yout} are left unchanged
from those provided to the routine.

\end{fulllineitems}



\subsection{Optional input functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionalinputs}}\label{\detokenize{MRIStep_c_interface/User_callable:optional-input-functions}}
There are numerous optional input parameters that control the behavior
of the MRIStep solver, each of which may be modified from its default
value through calling an appropriate input function.  The following
tables list all optional input functions, grouped by which aspect of
MRIStep they control.  Detailed information on the calling syntax and
arguments for each function are then provided following each table.

The optional inputs are grouped into the following categories:
\begin{itemize}
\item {} 
General MRIStep options ({\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for MRIStep}}}}), and

\item {} 
IVP method solver options ({\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepmethodinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for IVP method selection}}}})

\item {} 
Implicit stage solver options ({\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepsolverinputtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional inputs for implicit stage solves}}}}),

\item {} 
Linear solver interface options ({\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface optional input functions}}}}), and

\item {} 
Rootfinding options (\DUrole{xref,std,std-ref}{MRIStep\_CInterface.MRIStepRootfindingInputTable}).

\end{itemize}

For the most casual use of MRIStep, relying on the default set of
solver parameters, the reader can skip to the following section,
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

We note that, on an error return, all of the optional input functions send an
error message to the error handler function. All error return values are
negative, so a test on the return arguments for negative values will catch all
errors. Finally, a call to an \sphinxcode{MRIStepSet***} function can generally be made
from the user’s calling program at any time and, if successful, takes effect
immediately. \sphinxcode{MRIStepSet***} functions that cannot be called at any time note
this in the “\sphinxstylestrong{Notes}:” section of the function documentation.


\subsubsection{Optional inputs for MRIStep}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepinputtable}}\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-mristep}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Return MRIStep solver parameters to their defaults
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDefaults}]{\sphinxcrossref{\sphinxcode{MRIStepSetDefaults()}}}}
&
internal
\\
\hline
Set dense output interpolation type
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantType()}}}}
&
\sphinxcode{ARK\_INTERP\_HERMITE}
\\
\hline
Set dense output polynomial degree
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantDegree()}}}}
&
5
\\
\hline
Supply a pointer to a diagnostics output file
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDiagnostics}]{\sphinxcrossref{\sphinxcode{MRIStepSetDiagnostics()}}}}
&
\sphinxcode{NULL}
\\
\hline
Supply a pointer to an error output file
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetErrFile}]{\sphinxcrossref{\sphinxcode{MRIStepSetErrFile()}}}}
&
\sphinxcode{stderr}
\\
\hline
Supply a custom error handler function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetErrHandlerFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetErrHandlerFn()}}}}
&
internal fn
\\
\hline
Run with fixed-step sizes
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{MRIStepSetFixedStep()}}}}
&
required
\\
\hline
Maximum no. of warnings for \(t_n+h = t_n\)
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetMaxHnilWarns}]{\sphinxcrossref{\sphinxcode{MRIStepSetMaxHnilWarns()}}}}
&
10
\\
\hline
Maximum no. of internal steps before \sphinxstyleemphasis{tout}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetMaxNumSteps}]{\sphinxcrossref{\sphinxcode{MRIStepSetMaxNumSteps()}}}}
&
500
\\
\hline
Set a value for \(t_{stop}\)
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStopTime}]{\sphinxcrossref{\sphinxcode{MRIStepSetStopTime()}}}}
&
\(\infty\)
\\
\hline
Supply a pointer for user data
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}
&
\sphinxcode{NULL}
\\
\hline
Supply a function to be called prior to the inner integration
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPreInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetPreInnerFn()}}}}
&
\sphinxcode{NULL}
\\
\hline
Supply a function to be called after the inner integration
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPostInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetPostInnerFn()}}}}
&
\sphinxcode{NULL}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepSetDefaults (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDefaults}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetDefaults}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}~\begin{quote}

Resets all optional input parameters to MRIStep’s original
default values.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}
\end{quote}

\sphinxstylestrong{Notes:} This function does not change problem-defining function pointers
\sphinxstyleemphasis{fs} and \sphinxstyleemphasis{ff} or the \sphinxstyleemphasis{user\_data} pointer. It also does not affect any data
structures or options related to root-finding (those can be reset using
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}]{\sphinxcrossref{\sphinxcode{MRIStepRootInit()}}}}).

\end{fulllineitems}

\index{MRIStepSetInterpolantType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantType}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetInterpolantType}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ itype}}{}
Specifies use of the Lagrange or Hermite interpolation modules (used for
dense output \textendash{} interpolation of solution output values and implicit
method predictors).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{itype} \textendash{} requested interpolant type (\sphinxcode{ARK\_INTERP\_HERMITE} or \sphinxcode{ARK\_INTERP\_LAGRANGE})

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL} if the interpolation module cannot be allocated

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if the \sphinxstyleemphasis{itype} argument is not recognized or the
interpolation module has already been initialized

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The Hermite interpolation module is described in the Section
{\hyperref[\detokenize{Mathematics:mathematics-interpolation-hermite}]{\sphinxcrossref{\DUrole{std,std-ref}{Hermite interpolation module}}}}, and the Lagrange interpolation module
is described in the Section {\hyperref[\detokenize{Mathematics:mathematics-interpolation-lagrange}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagrange interpolation module}}}}.

This routine frees any previously-allocated interpolation module, and re-creates
one according to the specified argument.  Thus any previous calls to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantDegree()}}}} will be nullified.

This routine must be called \sphinxstyleemphasis{after} the call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}.
After the first call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} the interpolation type may
not be changed without first calling {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}}.

If this routine is not called, the Hermite interpolation module will be used.

\end{fulllineitems}

\index{MRIStepSetInterpolantDegree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantDegree}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetInterpolantDegree}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ degree}}{}
Specifies the degree of the polynomial interpolant
used for dense output (i.e. interpolation of solution output values
and implicit method predictors).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{degree} \textendash{} requested polynomial degree.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory or interpolation module are \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_INTERP\_FAIL} if this is called after {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value or the
interpolation module has already been initialized

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Allowed values are between 0 and 5.

This routine should be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} and \sphinxstyleemphasis{before}
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}. After the first call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}
the interpolation degree may not be changed without first calling
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}}.

If a user calls both this routine and {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantType()}}}}, then
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantType}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantType()}}}} must be called first.

Since the accuracy of any polynomial interpolant is limited by the accuracy of
the time-step solutions on which it is based, the \sphinxstyleemphasis{actual} polynomial degree that
is used by MRIStep will be the minimum of \(q-1\) and the input \sphinxstyleemphasis{degree},
where \(q\) is the order of accuracy for the time integration method.

\end{fulllineitems}

\index{MRIStepSetDenseOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDenseOrder}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetDenseOrder}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ dord}}{}
\sphinxstyleemphasis{This function is deprecated, and will be removed in a future release.
Users should transition to calling} {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantDegree()}}}}
\sphinxstyleemphasis{instead.}

\end{fulllineitems}

\index{MRIStepSetDiagnostics (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDiagnostics}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetDiagnostics}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE*\sphinxstyleemphasis{ diagfp}}{}
Specifies the file pointer for a diagnostics file where
all MRIStep step adaptivity and solver information is written.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{diagfp} \textendash{} pointer to the diagnostics output file.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This parameter can be \sphinxcode{stdout} or \sphinxcode{stderr}, although the
suggested approach is to specify a pointer to a unique file opened
by the user and returned by \sphinxcode{fopen}.  If not called, or if called
with a \sphinxcode{NULL} file pointer, all diagnostics output is disabled.

When run in parallel, only one process should set a non-NULL value
for this pointer, since statistics from all processes would be
identical.

\end{fulllineitems}

\index{MRIStepSetErrFile (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetErrFile}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetErrFile}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE*\sphinxstyleemphasis{ errfp}}{}
Specifies a pointer to the file where all MRIStep warning and error
messages will be written if the default internal error handling
function is used.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{errfp} \textendash{} pointer to the output file.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value for \sphinxstyleemphasis{errfp} is \sphinxcode{stderr}.

Passing a \sphinxcode{NULL} value disables all future error message output
(except for the case wherein the MRIStep memory pointer is
\sphinxcode{NULL}).  This use of the function is strongly discouraged.

If used, this routine should be called before any other
optional input functions, in order to take effect for subsequent
error messages.

\end{fulllineitems}

\index{MRIStepSetErrHandlerFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetErrHandlerFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetErrHandlerFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}]{\sphinxcrossref{ARKErrHandlerFn}}}\sphinxstyleemphasis{ ehfun}, void*\sphinxstyleemphasis{ eh\_data}}{}
Specifies the optional user-defined function to be used
in handling error messages.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{ehfun} \textendash{} name of user-supplied error handler function.

\item {} 
\sphinxstyleemphasis{eh\_data} \textendash{} pointer to user data passed to \sphinxstyleemphasis{ehfun} every time
it is called.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Error messages indicating that the MRIStep solver memory is
\sphinxcode{NULL} will always be directed to \sphinxcode{stderr}.

\end{fulllineitems}

\index{MRIStepSetFixedStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetFixedStep}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetFixedStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ hs}}{}
Set the slow step size used within MRIStep.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{hs} \textendash{} value of the outer (slow) step size.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}

The step sizes used by the inner (fast) stepper may be controlled through calling the
appropriate “Set” routines on the inner integrator.

\end{fulllineitems}

\index{MRIStepSetMaxHnilWarns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetMaxHnilWarns}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetMaxHnilWarns}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ mxhnil}}{}
Specifies the maximum number of messages issued by the
solver to warn that \(t+h=t\) on the next internal step, before
MRIStep will instead return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{mxhnil} \textendash{} maximum allowed number of warning messages \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 10; set \sphinxstyleemphasis{mxhnil} to zero to specify
this default.

A negative value indicates that no warning messages should be issued.

\end{fulllineitems}

\index{MRIStepSetMaxNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetMaxNumSteps}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetMaxNumSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int\sphinxstyleemphasis{ mxsteps}}{}
Specifies the maximum number of steps to be taken by the
solver in its attempt to reach the next output time, before MRIStep
will return with an error.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{mxsteps} \textendash{} maximum allowed number of internal steps.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing \sphinxstyleemphasis{mxsteps} = 0 results in MRIStep using the
default value (500).

Passing \sphinxstyleemphasis{mxsteps} \textless{} 0 disables the test (not recommended).

\end{fulllineitems}

\index{MRIStepSetStopTime (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStopTime}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetStopTime}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tstop}}{}
Specifies the value of the independent variable
\(t\) past which the solution is not to proceed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{tstop} \textendash{} stopping time for the integrator.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is that no stop time is imposed.

\end{fulllineitems}

\index{MRIStepSetUserData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetUserData}}{void*\sphinxstyleemphasis{ arkode\_mem}, void*\sphinxstyleemphasis{ user\_data}}{}
Specifies the user data block \sphinxstyleemphasis{user\_data} for the outer integrator and
attaches it to the main MRIStep memory block.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} pointer to the user data.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If specified, the pointer to \sphinxstyleemphasis{user\_data} is passed to all
user-supplied functions called by the outer integrator for which it is an
argument; otherwise \sphinxcode{NULL} is passed.

To attach a user data block to the inner integrator call the appropriate
\sphinxstyleemphasis{SetUserData} function for the inner integrator memory structure (e.g.,
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}} if the inner stepper is ARKStep). This pointer
may be the same as or different from the pointer attached to the outer
integrator depending on what is required by the user code.

\end{fulllineitems}

\index{MRIStepSetPreInnerFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPreInnerFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetPreInnerFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPreInnerFn}]{\sphinxcrossref{MRIStepPreInnerFn}}}\sphinxstyleemphasis{ prefn}}{}
Specifies the function called \sphinxstyleemphasis{before} each inner integration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{prefn} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPreInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepPreInnerFn()}}}})
defining pre inner integration function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepSetPostInnerFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPostInnerFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetPostInnerFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPostInnerFn}]{\sphinxcrossref{MRIStepPostInnerFn}}}\sphinxstyleemphasis{ postfn}}{}
Specifies the function called \sphinxstyleemphasis{after} each inner integration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{postfn} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPostInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepPostInnerFn()}}}})
defining post inner integration function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Optional inputs for IVP method selection}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepmethodinputtable}}\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-ivp-method-selection}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Set MRI coupling coefficients
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepSetCoupling()}}}}
&
internal
\\
\hline
Set MRI outer RK table
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTable}]{\sphinxcrossref{\sphinxcode{MRIStepSetTable()}}}}
&
internal
\\
\hline
Specify MRI outer table number
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTableNum}]{\sphinxcrossref{\sphinxcode{MRIStepSetTableNum()}}}}
&
internal
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepSetCoupling (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetCoupling}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetCoupling}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}}\sphinxstyleemphasis{ C}}{}
Specifies a customized set of slow-to-fast coupling coefficients for the MRI method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{C} \textendash{} the table of coupling coefficients for the MRI method.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}

For a description of the {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} type and related
functions for creating Butcher tables see the Section {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling}]{\sphinxcrossref{\DUrole{std,std-ref}{MRI Coupling Coefficients Data Structure}}}}.

\end{fulllineitems}

\index{MRIStepSetTable (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTable}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetTable}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ q}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}}{}
Specifies a customized slow Butcher table for a traditional MIS method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{q} \textendash{} global order of accuracy for the MRI method.

\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table for the outer (slow) RK method.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}

For a description of the {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} type and related
functions for creating Butcher tables see {\hyperref[\detokenize{ARKodeButcherTable:arkodebutchertable}]{\sphinxcrossref{\DUrole{std,std-ref}{Butcher Table Data Structure}}}}.

Internally, this function directly calls the utility routine
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_MIStoMRI}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_MIStoMRI()}}}} to convert from the input table \sphinxstyleemphasis{B} to
an MRI coupling table.  As such, all constraints on \sphinxstyleemphasis{B} stated for that function
apply here as well: it must have explicit first stage (i.e., \(c_1=0\) and
\(A_{1,j}=0\) for \(1\le j\le s\)) and sorted abcissae (i.e.,
\(c_{i} \ge  c_{i-1}\) for \(2\le i\le s\)).

The input value of \sphinxstyleemphasis{q} is used rather than the order encoded in the Butcher
table since the overall order of the MRI method may differ from the order of
the outer table (see equation \eqref{equation:Mathematics:MIS_order3} and surrounding discussion).
No error checking is performed to ensure that \sphinxstyleemphasis{q} correctly describes the
order of the overall MRI method.

\end{fulllineitems}

\index{MRIStepSetTableNum (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTableNum}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetTableNum}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ itable}}{}
Indicates to use a specific built-in Butcher table or MRI coupling table
for the MRI outer (slow) method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{itable} \textendash{} index of the outer (slow) Butcher or MRI table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Depending on the value of \sphinxstyleemphasis{itable}, this routine will do one of two
things.

If \sphinxstyleemphasis{itable} specifies a built-in ERK or DIRK Butcher table, then this will
internally retrieve the {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} corresponding to the
\sphinxstyleemphasis{itable} argument, and then immediately call the utility routine
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTable}]{\sphinxcrossref{\sphinxcode{MRIStepSetTable()}}}} to convert this to an MRI coupling table and store
the result within MRIStep.  In this case, \sphinxstyleemphasis{itable} should match one of the
methods from the section {\hyperref[\detokenize{Butcher:butcher-explicit}]{\sphinxcrossref{\DUrole{std,std-ref}{Explicit Butcher tables}}}} or the section
{\hyperref[\detokenize{Butcher:butcher-implicit}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit Butcher tables}}}}.  Error-checking is performed to ensure that this
table exists and satisfies the restrictions listed above for
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTable}]{\sphinxcrossref{\sphinxcode{MRIStepSetTable()}}}}.  This approach assumes that the overall
MRI method order equals \(min(q,2)\), where \(q\) is the order of
accuracy for the Butcher table indicated by \sphinxstyleemphasis{itable}; if in fact the overall
method differs from this assumed value, it is recommended that the user instead
call either {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepSetCoupling()}}}} or {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetTable}]{\sphinxcrossref{\sphinxcode{MRIStepSetTable()}}}}
directly.

If \sphinxstyleemphasis{itable} instead specifies a built-in MRI coupling table, then this will
internally retrieve the {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} table via the routine
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_LoadTable}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_LoadTable()}}}}, and store the result in MRIStep.  In
this case, \sphinxstyleemphasis{itable} should match one of the methods from the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling-tables}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStepCoupling tables}}}}.

\end{fulllineitems}



\paragraph{Optional inputs for implicit stage solves}
\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-implicit-stage-solves}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepsolverinputtable}}
The mathematical explanation for the nonlinear solver strategies used
by MRIStep, including how each of the parameters below is used within
the code, is provided in the section {\hyperref[\detokenize{Mathematics:mathematics-nonlinear}]{\sphinxcrossref{\DUrole{std,std-ref}{Nonlinear solver methods}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Specify linearly implicit \(f^S\)
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinear}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinear()}}}}
&
\sphinxcode{SUNFALSE}
\\
\hline
Specify nonlinearly implicit \(f^S\)
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinear}]{\sphinxcrossref{\sphinxcode{MRIStepSetNonlinear()}}}}
&
\sphinxcode{SUNTRUE}
\\
\hline
Implicit predictor method
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPredictorMethod}]{\sphinxcrossref{\sphinxcode{MRIStepSetPredictorMethod()}}}}
&
0
\\
\hline
Maximum number of nonlinear iterations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetMaxNonlinIters}]{\sphinxcrossref{\sphinxcode{MRIStepSetMaxNonlinIters()}}}}
&
3
\\
\hline
Coefficient in the nonlinear convergence test
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinConvCoef}]{\sphinxcrossref{\sphinxcode{MRIStepSetNonlinConvCoef()}}}}
&
0.1
\\
\hline
Nonlinear convergence rate constant
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinCRDown}]{\sphinxcrossref{\sphinxcode{MRIStepSetNonlinCRDown()}}}}
&
0.3
\\
\hline
Nonlinear residual divergence ratio
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinRDiv}]{\sphinxcrossref{\sphinxcode{MRIStepSetNonlinRDiv()}}}}
&
2.3
\\
\hline
User-provided implicit stage predictor
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStagePredictFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetStagePredictFn()}}}}
&
\sphinxcode{NULL}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepSetLinear (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinear}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetLinear}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ timedepend}}{}
Specifies that the implicit slow right-hand side function, \(f^S(t,y)\)
is linear in \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{timedepend} \textendash{} flag denoting whether the Jacobian of
\(f^S(t,y)\) is time-dependent (1) or not (0).
Alternately, when using a matrix-free iterative linear solver
this flag denotes time dependence of the preconditioner.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Tightens the linear solver tolerances and takes only a
single Newton iteration.  Calls {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{MRIStepSetDeltaGammaMax()}}}}
to enforce Jacobian recomputation when the step size ratio changes
by more than 100 times the unit roundoff (since nonlinear
convergence is not tested).  Only applicable when used in
combination with the modified or inexact Newton iteration (not the
fixed-point solver).

The only SUNDIALS-provided SUNNonlinearSolver module that is compatible
with the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinear}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinear()}}}} option is the Newton solver.

\end{fulllineitems}

\index{MRIStepSetNonlinear (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinear}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetNonlinear}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Specifies that the implicit slow right-hand side function, \(f^S(t,y)\)
is nonlinear in \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is the default behavior of MRIStep, so the function
is primarily useful to undo a previous call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinear}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinear()}}}}.  Calls
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{MRIStepSetDeltaGammaMax()}}}} to reset the step size ratio
threshold to the default value.

\end{fulllineitems}

\index{MRIStepSetPredictorMethod (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPredictorMethod}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetPredictorMethod}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ method}}{}
Specifies the method to use for predicting implicit solutions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{method} \textendash{} method choice (0 \(\le\) \sphinxstyleemphasis{method} \(\le\) 4):
\begin{itemize}
\item {} 
0 is the trivial predictor,

\item {} 
1 is the maximum order (dense output) predictor,

\item {} 
2 is the variable order predictor, that decreases the
polynomial degree for more distant RK stages,

\item {} 
3 is the cutoff order predictor, that uses the maximum order
for early RK stages, and a first-order predictor for distant
RK stages,

\item {} 
4 is the bootstrap predictor, that uses a second-order
predictor based on only information within the current step.

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 0.  If \sphinxstyleemphasis{method} is set to an
undefined value, this default predictor will be used.

\end{fulllineitems}

\index{MRIStepSetMaxNonlinIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetMaxNonlinIters}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetMaxNonlinIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ maxcor}}{}
Specifies the maximum number of nonlinear solver
iterations permitted per slow MRI stage within each time step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{maxcor} \textendash{} maximum allowed solver iterations per stage \((>0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value or if the SUNNONLINSOL module is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NLS\_OP\_ERR} if the SUNNONLINSOL object returned a failure flag

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 3; set \sphinxstyleemphasis{maxcor} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{MRIStepSetNonlinConvCoef (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinConvCoef}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetNonlinConvCoef}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ nlscoef}}{}
Specifies the safety factor used within the nonlinear solver convergence test.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nlscoef} \textendash{} coefficient in nonlinear solver convergence test \((>0.0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default value is 0.1; set \sphinxstyleemphasis{nlscoef} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{MRIStepSetNonlinCRDown (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinCRDown}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetNonlinCRDown}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ crdown}}{}
Specifies the constant used in estimating the nonlinear solver convergence rate.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{crdown} \textendash{} nonlinear convergence rate estimation constant (default is 0.3).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{MRIStepSetNonlinRDiv (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNonlinRDiv}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetNonlinRDiv}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ rdiv}}{}
Specifies the nonlinear correction threshold beyond which the
iteration will be declared divergent.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{rdiv} \textendash{} tolerance on nonlinear correction size ratio to
declare divergence (default is 2.3).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{MRIStepSetStagePredictFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetStagePredictFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetStagePredictFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKStagePredictFn}]{\sphinxcrossref{ARKStagePredictFn}}}\sphinxstyleemphasis{ PredictStage}}{}
Sets the user-supplied function to update the implicit stage predictor prior to
execution of the nonlinear or linear solver algorithms that compute the implicit stage solution.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{PredictStage} \textendash{} name of user-supplied predictor function.  If \sphinxcode{NULL}, then any
previously-provided stage prediction function will be disabled.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} See the section {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-stagepredictfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit stage prediction function}}}} for more information on
this user-supplied routine.

\end{fulllineitems}



\paragraph{Linear solver interface optional input functions}
\label{\detokenize{MRIStep_c_interface/User_callable:linear-solver-interface-optional-input-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsinputs}}
The mathematical explanation of the linear solver methods
available to MRIStep is provided in the section
{\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}}.  We group the user-callable routines into
four categories: general routines concerning the update frequency for
matrices and/or preconditioners, optional inputs for matrix-based
linear solvers, optional inputs for matrix-free linear solvers, and
optional inputs for iterative linear solvers.  We note that the
matrix-based and matrix-free groups are mutually exclusive, whereas the
“iterative” tag can apply to either case.

\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsinputs-general}}
\index{optional input!generic linear solver interface (MRIStep)}\ignorespaces 

\section{Optional inputs for the ARKLS linear solver interface}
\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-the-arkls-linear-solver-interface}}\label{\detokenize{MRIStep_c_interface/User_callable:index-0}}
As discussed in the section {\hyperref[\detokenize{Mathematics:mathematics-linear-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Updating the linear solver}}}}, ARKode
strives to reuse matrix and preconditioner data for as many solves as
possible to amortize the high costs of matrix construction and
factorization.  To that end, MRIStep provides user-callable
routines to modify this behavior.  Recall that the
Newton system matrices that arise within an implicit stage solve are
\({\mathcal A}(t,z) \approx I - \gamma J(t,z)\), where the
implicit right-hand side function has Jacobian matrix
\(J(t,z) = \frac{\partial f^S(t,z)}{\partial z}\).

The matrix or preconditioner for \({\mathcal A}\) can only be
updated within a call to the linear solver ‘setup’ routine.  In
general, the frequency with which the linear solver setup routine is
called may be controlled with the \sphinxstyleemphasis{msbp} argument to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{MRIStepSetLSetupFrequency()}}}}.  When this occurs, the
validity of \({\mathcal A}\) for successive time steps
intimately depends on whether the corresponding \(\gamma\) and
\(J\) inputs remain valid.

At each call to the linear solver setup routine the decision to update
\(\mathcal{A}\) with a new value of \(\gamma\), and to reuse
or reevaluate Jacobian information, depends on several factors including:
\begin{itemize}
\item {} 
the success or failure of previous solve attempts,

\item {} 
the success or failure of the previous time step attempts,

\item {} 
the change in \(\gamma\) from the value used when constructing \(\mathcal{A}\), and

\item {} 
the number of steps since Jacobian information was last evaluated.

\end{itemize}

The frequency with which to update Jacobian information can be controlled
with the \sphinxstyleemphasis{msbj} argument to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacEvalFrequency}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacEvalFrequency()}}}}.
We note that this is only checked \sphinxstyleemphasis{within} calls to the linear solver setup
routine, so values \sphinxstyleemphasis{msbj} \(<\) \sphinxstyleemphasis{msbp} do not make sense. For
linear-solvers with user-supplied preconditioning the above factors are used
to determine whether to recommend updating the Jacobian information in the
preconditioner (i.e., whether to set \sphinxstyleemphasis{jok} to \sphinxcode{SUNFALSE} in calling the
user-supplied \sphinxcode{ARKLsPrecSetupFn()}). For matrix-based linear solvers
these factors determine whether the matrix \(J(t,y) = \frac{\partial f^S(t,y)}{\partial y}\)
should be updated (either with an internal finite difference approximation or
a call to the user-supplied {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn}}}}); if not then the previous
value is reused and the system matrix \({\mathcal A}(t,y) \approx I - \gamma J(t,y)\)
is recomputed using the current \(\gamma\) value.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Max change in step signaling new \(J\)
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{MRIStepSetDeltaGammaMax()}}}}
&
0.2
\\
\hline
Linear solver setup frequency
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{MRIStepSetLSetupFrequency()}}}}
&
20
\\
\hline
Jacobian / preconditioner update frequency
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacEvalFrequency}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacEvalFrequency()}}}}
&
51
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepSetDeltaGammaMax (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetDeltaGammaMax}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetDeltaGammaMax}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ dgmax}}{}
Specifies a scaled step size ratio tolerance, beyond which the
linear solver setup routine will be signaled.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{dgmax} \textendash{} tolerance on step size ratio change before calling
linear solver setup routine (default is 0.2).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}


\index{optional input!linear solver setup frequency (MRIStep)}\ignorespaces \index{MRIStepSetLSetupFrequency (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSetupFrequency}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetLSetupFrequency}}{void*\sphinxstyleemphasis{ arkode\_mem}, int\sphinxstyleemphasis{ msbp}}{}
Specifies the frequency of calls to the linear solver setup
routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{msbp} \textendash{} the linear solver setup frequency.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Positive values of \sphinxstylestrong{msbp} specify the linear solver setup frequency. For
example, an input of 1 means the setup function will be called every time
step while an input of 2 means it will be called called every other time
step. If \sphinxstylestrong{msbp} is 0, the default value of 20 will be used. A negative
value forces a linear solver step at each implicit stage.

\end{fulllineitems}


\index{optional input!Jacobian update frequency (MRIStep)}\index{optional input!preconditioner update frequency (MRIStep)}\ignorespaces \index{MRIStepSetJacEvalFrequency (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacEvalFrequency}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetJacEvalFrequency}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int\sphinxstyleemphasis{ msbj}}{}
Specifies the frequency for recomputing the Jacobian or recommending a
preconditioner update.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{msbj} \textendash{} the Jacobian re-computation or preconditioner update frequency.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
The Jacobian update frequency is only checked \sphinxstyleemphasis{within} calls to the linear
solver setup routine, as such values of \sphinxstyleemphasis{msbj} \(<\) \sphinxstyleemphasis{msbp} will result
in recomputing the Jacobian every \sphinxstyleemphasis{msbp} steps. See
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{MRIStepSetLSetupFrequency()}}}} for setting the linear solver steup
frequency \sphinxstyleemphasis{msbp}.

Passing a value \sphinxstyleemphasis{msbj} \(\le 0\) indicates to use the
default value of 50.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver interface has
been initialized through a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

\end{fulllineitems}



\section{Optional inputs for matrix-based \sphinxstyleliteralintitle{SUNLinearSolver} modules}
\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-matrix-based-sunlinearsolver-modules}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsinputs-matrixbased}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Jacobian function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacFn()}}}}
&
\sphinxcode{DQ}
\\
\hline
Linear system function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinSysFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinSysFn()}}}}
&
internal
\\
\hline
Enable or disable linear solution scaling
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolutionScaling}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolutionScaling()}}}}
&
on
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

When using matrix-based linear solver modules, the ARKLS solver interface needs
a function to compute an approximation to the Jacobian matrix \(J(t,y)\) or
the linear system \(I - \gamma J\). The function to evaluate the Jacobian
must be of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}. The user can supply a custom Jacobian
function, or if using a dense or banded \(J\) can use the default internal
difference quotient approximation that comes with the ARKLS interface.  At
present, we do not supply a corresponding routine to approximate Jacobian
entries in sparse matrices \(J\). To specify a user-supplied Jacobian
function \sphinxstyleemphasis{jac}, MRIStep provides the function {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacFn()}}}}.
Alternatively, a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn()}}}} can be provided to
evaluate the matrix \(I - \gamma J\). By default, ARKLS uses an
internal linear system function leveraging the SUNMATRIX API to form the matrix
\(I - \gamma J\). To specify a user-supplied linear system function
\sphinxstyleemphasis{linsys}, MRIStep provides the function {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinSysFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinSysFn()}}}}. In
either case the matrix information will be updated infrequently to reduce matrix
construction and, with direct solvers, factorization costs. As a result the
value of \(\gamma\) may not be current and a scaling factor is applied to the
solution of the linear system to account for lagged value of \(\gamma\). See
{\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-lagged-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagged matrix information}}}} for more details. The function
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolutionScaling}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolutionScaling()}}}} can be used to disable this scaling
when necessary, e.g., when providing a custom linear solver that updates the
matrix using the current \(\gamma\) as part of the solve.

The ARKLS interface passes the user data pointer to the Jacobian and linear
system functions. This allows the user to create an arbitrary structure with
relevant problem data and access it during the execution of the user-supplied
Jacobian or linear system functions, without using global data in the
program. The user data pointer may be specified through
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.
\index{MRIStepSetJacFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetJacFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{ARKLsJacFn}}}\sphinxstyleemphasis{ jac}}{}
Specifies the Jacobian approximation routine to
be used for the matrix-based solver with the ARKLS interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{jac} \textendash{} name of user-supplied Jacobian approximation function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}  if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This routine must be called after the ARKLS linear
solver interface has been initialized through a call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

By default, ARKLS uses an internal difference quotient function for
dense and band matrices.  If \sphinxcode{NULL} is passed in for \sphinxstyleemphasis{jac}, this
default is used. An error will occur if no \sphinxstyleemphasis{jac} is supplied when
using other matrix types.

The function type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}} is described in the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{MRIStepSetLinSysFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinSysFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetLinSysFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{ARKLsLinSysFn}}}\sphinxstyleemphasis{ linsys}}{}
Specifies the linear system approximation routine to be used for the
matrix-based solver with the ARKLS interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{linsys} \textendash{} name of user-supplied linear system approximation function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS}  if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This routine must be called after the ARKLS linear
solver interface has been initialized through a call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

By default, ARKLS uses an internal linear system function that leverages the
SUNMATRIX API to form the system \(I - \gamma J\).  If \sphinxcode{NULL} is passed
in for \sphinxstyleemphasis{linsys}, this default is used.

The function type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn()}}}} is described in the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{MRIStepSetLinearSolutionScaling (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolutionScaling}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetLinearSolutionScaling}}{void*\sphinxstyleemphasis{ arkode\_mem}, booleantype\sphinxstyleemphasis{ onoff}}{}
Enables or disables scaling the linear system solution to account for a
change in \(\gamma\) in the linear system. For more details see
{\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-lagged-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagged matrix information}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{onoff} \textendash{} flag to enable (\sphinxcode{SUNTRUE}) or disable (\sphinxcode{SUNFALSE})
scaling

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if the attached linear solver is not matrix-based

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Linear solution scaling is enabled by default when a matrix-based
linear solver is attached.

\end{fulllineitems}



\section{Optional inputs for matrix-free \sphinxstyleliteralintitle{SUNLinearSolver} modules}
\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-matrix-free-sunlinearsolver-modules}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsinputs-matrixfree}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
\(Jv\) functions (\sphinxstyleemphasis{jtimes} and \sphinxstyleemphasis{jtsetup})
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacTimes}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacTimes()}}}}
&
DQ,  none
\\
\hline
\(Jv\) DQ rhs function (\sphinxstyleemphasis{jtimesRhsFn})
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacTimesRhsFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacTimesRhsFn()}}}}
&
fs
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

As described in the section {\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}}, when solving
the Newton linear systems with matrix-free methods, the ARKLS
interface requires a \sphinxstyleemphasis{jtimes} function to compute an approximation to
the product between the Jacobian matrix
\(J(t,y)\) and a vector \(v\). The user can supply a custom
Jacobian-times-vector approximation function, or use the default
internal difference quotient function that comes with the ARKLS
interface.

A user-defined Jacobian-vector function must be of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} and can be specified through a call
to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacTimes}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacTimes()}}}} (see the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}} for specification details).  As with the
user-supplied preconditioner functions, the evaluation and
processing of any Jacobian-related data needed by the user’s
Jacobian-times-vector function is done in the optional user-supplied
function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}} (see the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}} for specification details).  As with
the preconditioner functions, a pointer to the user-defined
data structure, \sphinxstyleemphasis{user\_data}, specified through
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}} (or a \sphinxcode{NULL} pointer otherwise) is
passed to the Jacobian-times-vector setup and product functions each
time they are called.
\index{MRIStepSetJacTimes (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacTimes}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetJacTimes}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{ARKLsJacTimesSetupFn}}}\sphinxstyleemphasis{ jtsetup}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{ARKLsJacTimesVecFn}}}\sphinxstyleemphasis{ jtimes}}{}
Specifies the Jacobian-times-vector setup and product functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{jtsetup} \textendash{} user-defined Jacobian-vector setup function.
Pass \sphinxcode{NULL} if no setup is necessary.

\item {} 
\sphinxstyleemphasis{jtimes} \textendash{} user-defined Jacobian-vector product function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\sphinxstyleemphasis{ARKLS\_SUNLS\_FAIL} if an error occurred when setting up
the Jacobian-vector product in the \sphinxcode{SUNLinearSolver}
object used by the ARKLS interface.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is to use an internal finite difference
quotient for \sphinxstyleemphasis{jtimes} and to leave out \sphinxstyleemphasis{jtsetup}.  If \sphinxcode{NULL} is
passed to \sphinxstyleemphasis{jtimes}, these defaults are used.  A user may
specify non-\sphinxcode{NULL} \sphinxstyleemphasis{jtimes} and \sphinxcode{NULL} \sphinxstyleemphasis{jtsetup} inputs.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver
interface has been initialized through a call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

The function types {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} are described in the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}


When using the internal difference quotient the user may optionally supply
an alternative implicit right-hand side function for use in the Jacobian-vector
product approximation by calling {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacTimesRhsFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetJacTimesRhsFn()}}}}. The
alternative implicit right-hand side function should compute a suitable (and
differentiable) approximation to the \(f^S\) function provided to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}. For example, as done in \phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:id2}}{\hyperref[\detokenize{References:dfwbt2010}]{\sphinxcrossref{{[}DFWBT2010{]}}}}, the alternative
function may use lagged values when evaluating a nonlinearity in \(f^S\) to
avoid differencing a potentially non-differentiable factor.
\index{MRIStepSetJacTimesRhsFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetJacTimesRhsFn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetJacTimesRhsFn}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ jtimesRhsFn}}{}
Specifies an alternative implicit right-hand side function for use in the
internal Jacobian-vector product difference quotient approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{jtimesRhsFn} \textendash{} the name of the C function (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}}) defining the alternative right-hand side function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is to use the implicit right-hand side function
provided to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} in the internal difference quotient. If
the input implicit right-hand side function is \sphinxcode{NULL}, the default is used.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver interface has
been initialized through a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

\end{fulllineitems}



\section{Optional inputs for iterative \sphinxstyleliteralintitle{SUNLinearSolver} modules}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsinputs-iterative}}\label{\detokenize{MRIStep_c_interface/User_callable:optional-inputs-for-iterative-sunlinearsolver-modules}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Newton preconditioning functions
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{MRIStepSetPreconditioner()}}}}
&
\sphinxcode{NULL}, \sphinxcode{NULL}
\\
\hline
Newton linear and nonlinear tolerance ratio
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetEpsLin}]{\sphinxcrossref{\sphinxcode{MRIStepSetEpsLin()}}}}
&
0.05
\\
\hline
Newton linear solve tolerance conversion factor
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSNormFactor}]{\sphinxcrossref{\sphinxcode{MRIStepSetLSNormFactor()}}}}
&
vector length
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

As described in the section {\hyperref[\detokenize{Mathematics:mathematics-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver methods}}}}, when using
an iterative linear solver the user may supply a preconditioning
operator to aid in solution of the system.  This operator consists of
two user-supplied functions, \sphinxstyleemphasis{psetup} and \sphinxstyleemphasis{psolve}, that are supplied
to MRIStep using the function {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{MRIStepSetPreconditioner()}}}}.
The \sphinxstyleemphasis{psetup} function supplied to these routines
should handle evaluation and preprocessing of any Jacobian data
needed by the user’s preconditioner solve function,
\sphinxstyleemphasis{psolve}.  The user data pointer received through
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}} (or a pointer to \sphinxcode{NULL} if user data
was not specified) is passed to the \sphinxstyleemphasis{psetup} and \sphinxstyleemphasis{psolve} functions.
This allows the user to create an arbitrary
structure with relevant problem data and access it during the
execution of the user-supplied preconditioner functions without using
global data in the program.

Also, as described in the section {\hyperref[\detokenize{Mathematics:mathematics-error-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear iteration error control}}}}, the
ARKLS interface requires that iterative linear solvers stop when
the norm of the preconditioned residual satisfies
\begin{equation*}
\begin{split}\|r\| \le \frac{\epsilon_L \epsilon}{10}\end{split}
\end{equation*}
where the default \(\epsilon_L = 0.05\), which may be modified by
the user through the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetEpsLin}]{\sphinxcrossref{\sphinxcode{MRIStepSetEpsLin()}}}} function.
\index{MRIStepSetPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPreconditioner}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetPreconditioner}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{ARKLsPrecSetupFn}}}\sphinxstyleemphasis{ psetup}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{ARKLsPrecSolveFn}}}\sphinxstyleemphasis{ psolve}}{}
Specifies the user-supplied preconditioner setup and solve functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{psetup} \textendash{} user defined preconditioner setup function.  Pass
\sphinxcode{NULL} if no setup is needed.

\item {} 
\sphinxstyleemphasis{psolve} \textendash{} user-defined preconditioner solve function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\sphinxstyleemphasis{ARKLS\_SUNLS\_FAIL} if an error occurred when setting up
preconditioning in the \sphinxcode{SUNLinearSolver} object used
by the ARKLS interface.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The default is \sphinxcode{NULL} for both arguments (i.e., no
preconditioning).

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver
interface has been initialized through a call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

Both of the function types {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn()}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSolveFn()}}}} are described in the section
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}]{\sphinxcrossref{\DUrole{std,std-ref}{User-supplied functions}}}}.

\end{fulllineitems}

\index{MRIStepSetEpsLin (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetEpsLin}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetEpsLin}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ eplifac}}{}
Specifies the factor by which the tolerance on the nonlinear
iteration is multiplied to get a tolerance on the linear
iteration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{eplifac} \textendash{} linear convergence safety factor.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}.

\item {} 
\sphinxstyleemphasis{ARKLS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Passing a value \sphinxstyleemphasis{eplifac} \(\le 0\) indicates to use the
default value of 0.05.

This function must be called \sphinxstyleemphasis{after} the ARKLS system solver
interface has been initialized through a call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

\end{fulllineitems}

\index{MRIStepSetLSNormFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLSNormFactor}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetLSNormFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ nrmfac}}{}
Specifies the factor to use when converting from the integrator tolerance
(WRMS norm) to the linear solver tolerance (L2 norm) for Newton linear system
solves e.g., \sphinxcode{tol\_L2 = fac * tol\_WRMS}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nrmfac} \textendash{} the norm conversion factor. If \sphinxstyleemphasis{nrmfac} is:

\(> 0\) then the provided value is used.

\(= 0\) then the conversion factor is computed using the vector
length i.e., \sphinxcode{nrmfac = sqrt(N\_VGetLength(y))} (\sphinxstyleemphasis{default}).

\(< 0\) then the conversion factor is computed using the vector dot
product i.e., \sphinxcode{nrmfac = sqrt(N\_VDotProd(v,v))} where all the entries
of \sphinxcode{v} are one.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function must be called \sphinxstyleemphasis{after} the ARKLS system solver interface has
been initialized through a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}}.

\end{fulllineitems}

\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristeprootfindinginputtable}}
The following functions can be called to set optional inputs to
control the rootfinding algorithm, the mathematics of which are
described in the section {\hyperref[\detokenize{Mathematics:mathematics-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional input
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Default
\unskip}\relax \\
\hline
Direction of zero-crossings to monitor
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetRootDirection}]{\sphinxcrossref{\sphinxcode{MRIStepSetRootDirection()}}}}
&
both
\\
\hline
Disable inactive root warnings
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNoInactiveRootWarn}]{\sphinxcrossref{\sphinxcode{MRIStepSetNoInactiveRootWarn()}}}}
&
enabled
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepSetRootDirection (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetRootDirection}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetRootDirection}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ rootdir}}{}
Specifies the direction of zero-crossings to be located and returned.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{rootdir} \textendash{} state array of length \sphinxstyleemphasis{nrtfn}, the number of root
functions \(g_i\)  (the value of \sphinxstyleemphasis{nrtfn} was supplied in
the call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}]{\sphinxcrossref{\sphinxcode{MRIStepRootInit()}}}}).  If \sphinxcode{rootdir{[}i{]} ==
0} then crossing in either direction for \(g_i\) should be
reported.  A value of +1 or -1 indicates that the solver
should report only zero-crossings where \(g_i\) is
increasing or decreasing, respectively.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The default behavior is to monitor for both zero-crossing directions.

\end{fulllineitems}

\index{MRIStepSetNoInactiveRootWarn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetNoInactiveRootWarn}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepSetNoInactiveRootWarn}}{void*\sphinxstyleemphasis{ arkode\_mem}}{}
Disables issuing a warning if some root function appears
to be identically zero at the beginning of the integration.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} MRIStep will not report the initial conditions as a
possible zero-crossing (assuming that one or more components
\(g_i\) are zero at the initial time).  However, if it appears
that some \(g_i\) is identically zero at the initial time
(i.e., \(g_i\) is zero at the initial time \sphinxstyleemphasis{and} after the
first step), MRIStep will issue a warning which can be disabled with
this optional input function.

\end{fulllineitems}



\subsection{Interpolated output function}
\label{\detokenize{MRIStep_c_interface/User_callable:interpolated-output-function}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-interpolatedoutput}}
An optional function {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetDky}]{\sphinxcrossref{\sphinxcode{MRIStepGetDky()}}}} is available to obtain
additional values of solution-related quantities.  This function
should only be called after a successful return from
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}, as it provides interpolated values either of
\(y\) or of its derivatives (up to the 3rd derivative)
interpolated to any value of \(t\) in the last internal step taken
by {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}.  Internally, this \sphinxstyleemphasis{dense output} algorithm is
identical to the algorithm used for the maximum order implicit
predictors, described in the section
{\hyperref[\detokenize{Mathematics:mathematics-predictors-max}]{\sphinxcrossref{\DUrole{std,std-ref}{Maximum order predictor}}}}, except that derivatives of the
polynomial model may be evaluated upon request.
\index{MRIStepGetDky (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetDky}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetDky}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ t}, int\sphinxstyleemphasis{ k}, N\_Vector\sphinxstyleemphasis{ dky}}{}
Computes the \sphinxstyleemphasis{k}-th derivative of the function
\(y\) at the time \sphinxstyleemphasis{t},
i.e. \(\frac{d^{(k)}}{dt^{(k)}}y(t)\), for values of the
independent variable satisfying \(t_n-h_n \le t \le t_n\), with
\(t_n\) as current internal time reached, and \(h_n\) is
the last internal step size successfully used by the solver.  This
routine uses an interpolating polynomial of degree \sphinxstyleemphasis{min(degree, 5)},
where \sphinxstyleemphasis{degree} is the argument provided to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetInterpolantDegree}]{\sphinxcrossref{\sphinxcode{MRIStepSetInterpolantDegree()}}}}.  The user may request \sphinxstyleemphasis{k} in the
range \{0,…,*min(degree, kmax)*\} where \sphinxstyleemphasis{kmax} depends on the choice of
interpolation module. For Hermite interpolants \sphinxstyleemphasis{kmax = 5} and for Lagrange
interpolants \sphinxstyleemphasis{kmax = 3}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the value of the independent variable at which the
derivative is to be evaluated.

\item {} 
\sphinxstyleemphasis{k} \textendash{} the derivative order requested.

\item {} 
\sphinxstyleemphasis{dky} \textendash{} output vector (must be allocated by the user).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_K} if \sphinxstyleemphasis{k} is not in the range \{0,…,*min(degree, kmax)*\}.

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_T} if \sphinxstyleemphasis{t} is not in the interval \([t_n-h_n, t_n]\)

\item {} 
\sphinxstyleemphasis{ARK\_BAD\_DKY} if the \sphinxstyleemphasis{dky} vector was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory is \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} It is only legal to call this function after a successful
return from {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}.

A user may access the values \(t_n\) and \(h_n\) via the
functions {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentTime()}}}} and
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastStep}]{\sphinxcrossref{\sphinxcode{MRIStepGetLastStep()}}}}, respectively.

\end{fulllineitems}



\subsection{Optional output functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionaloutputs}}\label{\detokenize{MRIStep_c_interface/User_callable:optional-output-functions}}
MRIStep provides an extensive set of functions that can be used to
obtain solver performance information.  We organize these into groups:
\begin{enumerate}
\item {} 
SUNDIALS version information accessor routines are in the subsection
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-sunversioninfo}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS version information}}}},

\item {} 
General MRIStep output routines are in the subsection
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepmainoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Main solver optional output functions}}}},

\item {} 
MRIStep implicit solver output routines are in the subsection
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepimplicitsolveroutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit solver optional output functions}}}},

\item {} 
Linear solver output routines are in the subsection
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear solver interface optional output functions}}}} and

\item {} 
General usability routines (e.g. to print the current MRIStep
parameters, or output the current coupling table) are in the
subsection {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepextraoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{General usability functions}}}}.

\item {} 
Output routines regarding root-finding results are in the subsection
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristeprootoutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Rootfinding optional output functions}}}},

\end{enumerate}

Following each table, we elaborate on each function.

Some of the optional outputs, especially the various counters, can be
very useful in determining the efficiency of various methods inside
MRIStep.  For example:
\begin{itemize}
\item {} 
The number of steps and right-hand side evaluations at both the slow and fast
time scales provide a rough measure of the overall cost of a given run, and can
be compared between runs with different solver options to suggest which set of
options is the most efficient.

\item {} 
The ratio \sphinxstyleemphasis{nniters/nsteps} measures the performance of the
nonlinear iteration in solving the nonlinear systems at each implicit stage,
providing a measure of the degree of nonlinearity in the problem.
Typical values of this for a Newton solver on a general problem
range from 1.1 to 1.8.

\item {} 
When using a Newton nonlinear solver, the ratio \sphinxstyleemphasis{njevals/nniters}
(in the case of a direct linear solver), and the ratio
\sphinxstyleemphasis{npevals/nniters} (in the case of an iterative linear solver)
can measure the overall degree of nonlinearity in the problem,
since these are updated infrequently, unless the Newton method
convergence slows.

\item {} 
When using a Newton nonlinear solver, the ratio \sphinxstyleemphasis{njevals/nniters}
(when using a direct linear solver), and the ratio
\sphinxstyleemphasis{nliters/nniters} (when using an iterative linear solver) can
indicate the quality of the approximate Jacobian or preconditioner being
used.  For example, if this ratio is larger for a user-supplied
Jacobian or Jacobian-vector product routine than for the
difference-quotient routine, it can indicate that the user-supplied
Jacobian is inaccurate.

\end{itemize}

It is therefore recommended that users retrieve and output these
statistics following each run, and take some time to investigate
alternate solver options that will be more optimal for their
particular problem of interest.


\subsubsection{SUNDIALS version information}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-sunversioninfo}}\label{\detokenize{MRIStep_c_interface/User_callable:sundials-version-information}}
The following functions provide a way to get SUNDIALS version
information at runtime.
\index{SUNDIALSGetVersion (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.SUNDIALSGetVersion}}\pysiglinewithargsret{int \sphinxbfcode{SUNDIALSGetVersion}}{char\sphinxstyleemphasis{ *version}, int\sphinxstyleemphasis{ len}}{}
This routine fills a string with SUNDIALS version information.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{version} \textendash{} character array to hold the SUNDIALS version information.

\item {} 
\sphinxstyleemphasis{len} \textendash{} allocated length of the \sphinxstyleemphasis{version} character array.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS version

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} An array of 25 characters should be sufficient to hold
the version information.

\end{fulllineitems}

\index{SUNDIALSGetVersionNumber (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.SUNDIALSGetVersionNumber}}\pysiglinewithargsret{int \sphinxbfcode{SUNDIALSGetVersionNumber}}{int\sphinxstyleemphasis{ *major}, int\sphinxstyleemphasis{ *minor}, int\sphinxstyleemphasis{ *patch}, char\sphinxstyleemphasis{ *label}, int\sphinxstyleemphasis{ len}}{}
This routine sets integers for the SUNDIALS major,
minor, and patch release numbers and fills a string with the
release label if applicable.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{major} \textendash{} SUNDIALS release major version number.

\item {} 
\sphinxstyleemphasis{minor} \textendash{} SUNDIALS release minor version number.

\item {} 
\sphinxstyleemphasis{patch} \textendash{} SUNDIALS release patch version number.

\item {} 
\sphinxstyleemphasis{label} \textendash{} string to hold the SUNDIALS release label.

\item {} 
\sphinxstyleemphasis{len} \textendash{} allocated length of the \sphinxstyleemphasis{label} character array.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS label

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} An array of 10 characters should be sufficient to hold
the label information. If a label is not used in the release
version, no information is copied to \sphinxstyleemphasis{label}.

\end{fulllineitems}



\subsubsection{Main solver optional output functions}
\label{\detokenize{MRIStep_c_interface/User_callable:main-solver-optional-output-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepmainoutputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Size of MRIStep real and integer workspaces
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetWorkSpace}]{\sphinxcrossref{\sphinxcode{MRIStepGetWorkSpace()}}}}
\\
\hline
Cumulative number of internal steps
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumSteps}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumSteps()}}}}
\\
\hline
Step size used for the last successful step
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastStep}]{\sphinxcrossref{\sphinxcode{MRIStepGetLastStep()}}}}
\\
\hline
Current internal time reached by the solver
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentTime()}}}}
\\
\hline
Current internal solution reached by the solver
&
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetCurrentState}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentState()}}}}
\\
\hline
Current \(\gamma\) value used by the solver
&
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetCurrentGamma}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentGamma()}}}}
\\
\hline
Error weight vector for state variables
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{MRIStepGetErrWeights()}}}}
\\
\hline
Suggested factor for tolerance scaling
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetTolScaleFactor}]{\sphinxcrossref{\sphinxcode{MRIStepGetTolScaleFactor()}}}}
\\
\hline
Name of constant associated with a return flag
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetReturnFlagName}]{\sphinxcrossref{\sphinxcode{MRIStepGetReturnFlagName()}}}}
\\
\hline
No. of calls to the \sphinxstyleemphasis{fs} function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumRhsEvals()}}}}
\\
\hline
Current MRI coupling tables
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentCoupling()}}}}
\\
\hline
Last inner stepper return value
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastInnerStepFlag}]{\sphinxcrossref{\sphinxcode{MRIStepGetLastInnerStepFlag()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrw}, long int*\sphinxstyleemphasis{ leniw}}{}
Returns the MRIStep real and integer workspace sizes.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{lenrw} \textendash{} the number of \sphinxcode{realtype} values in the MRIStep workspace.

\item {} 
\sphinxstyleemphasis{leniw} \textendash{} the number of integer values in the MRIStep workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumSteps}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumSteps}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nssteps}, long int*\sphinxstyleemphasis{ nfsteps}}{}
Returns the cumulative number of slow and fast internal steps taken by
the solver (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nssteps} \textendash{} number of slow steps taken in the solver.

\item {} 
\sphinxstyleemphasis{nfsteps} \textendash{} number of fast steps taken in the solver.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetLastStep (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastStep}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetLastStep}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ hlast}}{}
Returns the integration step size taken on the last successful
internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{hlast} \textendash{} step size taken on the last internal step.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetCurrentTime (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentTime}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetCurrentTime}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ tcur}}{}
Returns the current internal time reached by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} current internal time reached.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetCurrentState (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentState}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetCurrentState}}{void\sphinxstyleemphasis{ *arkode\_mem}, N\_Vector\sphinxstyleemphasis{ *ycur}}{}
Returns the current internal solution reached by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{ycur} \textendash{} current internal solution.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Users should exercise extreme caution when using this function,
as altering values of \sphinxstyleemphasis{ycur} may lead to undesirable behavior, depending
on the particular use case and on when this routine is called.

\end{fulllineitems}

\index{MRIStepGetCurrentGamma (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentGamma}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetCurrentGamma}}{void\sphinxstyleemphasis{ *arkode\_mem}, realtype\sphinxstyleemphasis{ *gamma}}{}
Returns the current internal value of \(\gamma\) used in the implicit
solver Newton matrix (see equation \eqref{equation:Mathematics:NewtonMatrix}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} current step size scaling factor in the Newton system.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetTolScaleFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetTolScaleFactor}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetTolScaleFactor}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ tolsfac}}{}
Returns a suggested factor by which the user’s
tolerances should be scaled when too much accuracy has been
requested for some internal step.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{tolsfac} \textendash{} suggested scaling factor for user-supplied tolerances.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetErrWeights (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetErrWeights}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetErrWeights}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ eweight}}{}
Returns the current error weight vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{eweight} \textendash{} solution error weights at the current time.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{eweight}, that will be
filled in by this function.

\end{fulllineitems}

\index{MRIStepGetReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetReturnFlagName}}\pysiglinewithargsret{char *\sphinxbfcode{MRIStepGetReturnFlagName}}{long int\sphinxstyleemphasis{ flag}}{}
Returns the name of the MRIStep constant corresponding to \sphinxstyleemphasis{flag}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{flag} \textendash{} a return flag from an MRIStep function.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The return value is a string containing the name of
the corresponding constant.

\end{fulllineitems}

\index{MRIStepGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumRhsEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumRhsEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nfs\_evals}}{}
Returns the number of calls to the user’s outer (slow) right-hand side function,
\(fs\) (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nfs\_evals} \textendash{} number of calls to the user’s \(fs(t,y)\) function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetCurrentCoupling (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentCoupling}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetCurrentCoupling}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}}\sphinxstyleemphasis{ *C}}{}
Returns the MRI coupling table currently in use by the solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{C} \textendash{} pointer to slow-to-fast MRI coupling structure.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}  The \sphinxstyleemphasis{MRIStepCoupling} data structure is defined in
the header file \sphinxcode{arkode/arkode\_mristep.h}.  It is defined as a
pointer to the following C structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{MRIStepCouplingMem} \PYG{p}{\PYGZob{}}

   \PYG{k+kt}{int} \PYG{n}{nmat}\PYG{p}{;}        \PYG{c+cm}{/* number of MRI coupling matrices             */}
   \PYG{k+kt}{int} \PYG{n}{stages}\PYG{p}{;}      \PYG{c+cm}{/* size of coupling matrices (stages * stages) */}
   \PYG{k+kt}{int} \PYG{n}{q}\PYG{p}{;}           \PYG{c+cm}{/* method order of accuracy                    */}
   \PYG{k+kt}{int} \PYG{n}{p}\PYG{p}{;}           \PYG{c+cm}{/* embedding order of accuracy                 */}
   \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{G}\PYG{p}{;}   \PYG{c+cm}{/* coupling matrices [nmat][stages][stages]    */}
   \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{c}\PYG{p}{;}     \PYG{c+cm}{/* abcissae                                    */}

 \PYG{p}{\PYGZcb{}}\PYG{p}{;}
 \PYG{k}{typedef} \PYG{n}{MRIStepCouplingMem} \PYG{o}{*}\PYG{n}{MRIStepCoupling}\PYG{p}{;}
\end{sphinxVerbatim}

For more details see {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling}]{\sphinxcrossref{\DUrole{std,std-ref}{MRI Coupling Coefficients Data Structure}}}}.

\end{fulllineitems}

\index{MRIStepGetLastInnerStepFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastInnerStepFlag}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetLastInnerStepFlag}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ flag}}{}
Returns the last return value from the inner stepper.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{flag} \textendash{} inner stepper return value.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Implicit solver optional output functions}
\label{\detokenize{MRIStep_c_interface/User_callable:implicit-solver-optional-output-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepimplicitsolveroutputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
No. of calls to linear solver setup function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinSolvSetups}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumLinSolvSetups()}}}}
\\
\hline
No. of nonlinear solver iterations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumNonlinSolvIters}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumNonlinSolvIters()}}}}
\\
\hline
No. of nonlinear solver convergence failures
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumNonlinSolvConvFails}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumNonlinSolvConvFails()}}}}
\\
\hline
Single accessor to all nonlinear solver statistics
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNonlinSolvStats}]{\sphinxcrossref{\sphinxcode{MRIStepGetNonlinSolvStats()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepGetNumLinSolvSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinSolvSetups}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumLinSolvSetups}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nlinsetups}}{}
Returns the number of calls made to the linear solver’s
setup routine (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nlinsetups} \textendash{} number of linear solver setup calls made.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the nonlinear
solver object; the counter is reset whenever a new nonlinear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumNonlinSolvIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumNonlinSolvIters}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumNonlinSolvIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nniters}}{}
Returns the number of nonlinear solver iterations performed (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nniters} \textendash{} number of nonlinear iterations performed.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NLS\_OP\_ERR} if the SUNNONLINSOL object returned a failure flag

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the nonlinear
solver object; the counter is reset whenever a new nonlinear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumNonlinSolvConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumNonlinSolvConvFails}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumNonlinSolvConvFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nncfails}}{}
Returns the number of nonlinear solver convergence
failures that have occurred (so far).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nncfails} \textendash{} number of nonlinear convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the nonlinear
solver object; the counter is reset whenever a new nonlinear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNonlinSolvStats (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNonlinSolvStats}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNonlinSolvStats}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nniters}, long int*\sphinxstyleemphasis{ nncfails}}{}
Returns all of the nonlinear solver statistics in a single call.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nniters} \textendash{} number of nonlinear iterations performed.

\item {} 
\sphinxstyleemphasis{nncfails} \textendash{} number of nonlinear convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NLS\_OP\_ERR} if the SUNNONLINSOL object returned a failure flag

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} These are only accumulated for the ‘life’ of the
nonlinear solver object; the counters are reset whenever a new
nonlinear solver module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}



\subsubsection{Linear solver interface optional output functions}
\label{\detokenize{MRIStep_c_interface/User_callable:linear-solver-interface-optional-output-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-arklsoutputs}}
The following optional outputs are available from the ARKLS
modules:
workspace requirements,
number of calls to the Jacobian routine,
number of calls to the implicit right-hand side routine for finite-difference Jacobian approximation or Jacobian-vector product approximation,
number of linear iterations,
number of linear convergence failures,
number of calls to the preconditioner setup and solve routines,
number of calls to the Jacobian-vector setup and product routines,
and last return value from an ARKLS function.
Note that, where the name of an output would otherwise conflict with the
name of an optional output from the main solver, a suffix LS (for
Linear Solver) has been added here (e.g. \sphinxstyleemphasis{lenrwLS}).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Size of real and integer workspaces
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLinWorkSpace}]{\sphinxcrossref{\sphinxcode{MRIStepGetLinWorkSpace()}}}}
\\
\hline
No. of Jacobian evaluations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumJacEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumJacEvals()}}}}
\\
\hline
No. of preconditioner evaluations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumPrecEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumPrecEvals()}}}}
\\
\hline
No. of preconditioner solves
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumPrecSolves}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumPrecSolves()}}}}
\\
\hline
No. of linear iterations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinIters}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumLinIters()}}}}
\\
\hline
No. of linear convergence failures
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinConvFails}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumLinConvFails()}}}}
\\
\hline
No. of Jacobian-vector setup evaluations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumJTSetupEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumJTSetupEvals()}}}}
\\
\hline
No. of Jacobian-vector product evaluations
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumJtimesEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumJtimesEvals()}}}}
\\
\hline
No. of \sphinxstyleemphasis{fs} calls for finite diff. \(J\) or \(Jv\) evals.
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinRhsEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumLinRhsEvals()}}}}
\\
\hline
Last return from a linear solver function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastLinFlag}]{\sphinxcrossref{\sphinxcode{MRIStepGetLastLinFlag()}}}}
\\
\hline
Name of constant associated with a return flag
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLinReturnFlagName}]{\sphinxcrossref{\sphinxcode{MRIStepGetLinReturnFlagName()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepGetLinWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLinWorkSpace}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetLinWorkSpace}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lenrwLS}, long int*\sphinxstyleemphasis{ leniwLS}}{}
Returns the real and integer workspace used by the ARKLS linear solver interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{lenrwLS} \textendash{} the number of \sphinxcode{realtype} values in the ARKLS workspace.

\item {} 
\sphinxstyleemphasis{leniwLS} \textendash{} the number of integer values in the ARKLS workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \sphinxcode{SUNLinearSolver} object attached
to it.  The template Jacobian matrix allocated by the user outside
of ARKLS is not included in this report.

In a parallel setting, the above values are global (i.e. summed over all
processors).

\end{fulllineitems}

\index{MRIStepGetNumJacEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumJacEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumJacEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ njevals}}{}
Returns the number of Jacobian evaluations.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{njevals} \textendash{} number of Jacobian evaluations.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumPrecEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumPrecEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumPrecEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ npevals}}{}
Returns the total number of preconditioner evaluations,
i.e. the number of calls made to \sphinxstyleemphasis{psetup} with \sphinxcode{jok} = \sphinxcode{SUNFALSE} and
that returned \sphinxcode{*jcurPtr} = \sphinxcode{SUNTRUE}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{npevals} \textendash{} the current number of calls to \sphinxstyleemphasis{psetup}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumPrecSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumPrecSolves}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumPrecSolves}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ npsolves}}{}
Returns the number of calls made to the preconditioner
solve function, \sphinxstyleemphasis{psolve}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{npsolves} \textendash{} the number of calls to \sphinxstyleemphasis{psolve}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumLinIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinIters}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumLinIters}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nliters}}{}
Returns the cumulative number of linear iterations.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nliters} \textendash{} the current number of linear iterations.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumLinConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinConvFails}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumLinConvFails}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nlcfails}}{}
Returns the cumulative number of linear convergence failures.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nlcfails} \textendash{} the current number of linear convergence failures.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumJTSetupEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumJTSetupEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumJTSetupEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ njtsetup}}{}
Returns the cumulative number of calls made to the user-supplied
Jacobian-vector setup function, \sphinxstyleemphasis{jtsetup}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{njtsetup} \textendash{} the current number of calls to \sphinxstyleemphasis{jtsetup}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumJtimesEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumJtimesEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumJtimesEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ njvevals}}{}
Returns the cumulative number of calls made to the
Jacobian-vector product function, \sphinxstyleemphasis{jtimes}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{njvevals} \textendash{} the current number of calls to \sphinxstyleemphasis{jtimes}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetNumLinRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumLinRhsEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumLinRhsEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ nfevalsLS}}{}
Returns the number of calls to the user-supplied implicit
right-hand side function \(f^S\) for finite difference
Jacobian or Jacobian-vector product approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{nfevalsLS} \textendash{} the number of calls to the user implicit
right-hand side function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The value \sphinxstyleemphasis{nfevalsLS} is incremented only if the default
internal difference quotient function is used.

This is only accumulated for the ‘life’ of the linear
solver object; the counter is reset whenever a new linear solver
module is ‘attached’ to MRIStep, or when MRIStep is resized.

\end{fulllineitems}

\index{MRIStepGetLastLinFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLastLinFlag}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetLastLinFlag}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ lsflag}}{}
Returns the last return value from an ARKLS routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{lsflag} \textendash{} the value of the last return flag from an
ARKLS function.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKLS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARKLS\_LMEM\_NULL} if the linear solver memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If the ARKLS setup function failed when using the
\sphinxcode{SUNLINSOL\_DENSE} or \sphinxcode{SUNLINSOL\_BAND} modules, then the value
of \sphinxstyleemphasis{lsflag} is equal to the column index (numbered from one) at
which a zero diagonal element was encountered during the LU
factorization of the (dense or banded) Jacobian matrix.  For all
other failures, \sphinxstyleemphasis{lsflag} is negative.

Otherwise, if the ARKLS setup function failed
({\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} returned \sphinxstyleemphasis{ARK\_LSETUP\_FAIL}), then
\sphinxstyleemphasis{lsflag} will be \sphinxstyleemphasis{SUNLS\_PSET\_FAIL\_UNREC}, \sphinxstyleemphasis{SUNLS\_ASET\_FAIL\_UNREC}
or \sphinxstyleemphasis{SUNLS\_PACKAGE\_FAIL\_UNREC}.

If the ARKLS solve function failed ({\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}}
returned \sphinxstyleemphasis{ARK\_LSOLVE\_FAIL}), then \sphinxstyleemphasis{lsflag} contains the error
return flag from the \sphinxcode{SUNLinearSolver} object, which will
be one of:
\sphinxstyleemphasis{SUNLS\_MEM\_NULL}, indicating that the \sphinxcode{SUNLinearSolver}
memory is \sphinxcode{NULL};
\sphinxstyleemphasis{SUNLS\_ATIMES\_NULL}, indicating that a matrix-free iterative solver
was provided, but is missing a routine for the matrix-vector product
approximation,
\sphinxstyleemphasis{SUNLS\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in
the \(Jv\) function;
\sphinxstyleemphasis{SUNLS\_PSOLVE\_NULL}, indicating that an iterative linear solver was
configured to use preconditioning, but no preconditioner solve
routine was provided,
\sphinxstyleemphasis{SUNLS\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
function failed unrecoverably;
\sphinxstyleemphasis{SUNLS\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure
(SPGMR and SPFGMR only);
\sphinxstyleemphasis{SUNLS\_QRSOL\_FAIL}, indicating that the matrix \(R\) was found
to be singular during the QR solve phase (SPGMR and SPFGMR only); or
\sphinxstyleemphasis{SUNLS\_PACKAGE\_FAIL\_UNREC}, indicating an unrecoverable failure in
an external iterative linear solver package.

\end{fulllineitems}

\index{MRIStepGetLinReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetLinReturnFlagName}}\pysiglinewithargsret{char *\sphinxbfcode{MRIStepGetLinReturnFlagName}}{long int\sphinxstyleemphasis{ lsflag}}{}
Returns the name of the ARKLS constant corresponding to \sphinxstyleemphasis{lsflag}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{lsflag} \textendash{} a return flag from an ARKLS function.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  The return value is a string containing the name of
the corresponding constant. If using the \sphinxcode{SUNLINSOL\_DENSE} or
\sphinxcode{SUNLINSOL\_BAND} modules, then if  1 \(\le\) \sphinxtitleref{lsflag}
\(\le n\) (LU factorization failed), this routine returns “NONE”.

\end{fulllineitems}



\subsubsection{General usability functions}
\label{\detokenize{MRIStep_c_interface/User_callable:general-usability-functions}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristepextraoutputs}}
The following optional routines may be called by a user to inquire
about existing solver parameters or write the current MRI coupling table. While
neither of these would typically be called during the course of solving an
initial value problem, these may be useful for users wishing to better
understand MRIStep.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional routine
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Output all MRIStep solver parameters
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWriteParameters}]{\sphinxcrossref{\sphinxcode{MRIStepWriteParameters()}}}}
\\
\hline
Output the current MRI coupling table
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWriteCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepWriteCoupling()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepWriteParameters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWriteParameters}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepWriteParameters}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE\sphinxstyleemphasis{ *fp}}{}
Outputs all MRIStep solver parameters to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{fp} \textendash{} pointer to use for printing the solver parameters.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARKS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARKS\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{fp} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

When run in parallel, only one process should set a non-NULL value
for this pointer, since parameters for all processes would be
identical.

\end{fulllineitems}

\index{MRIStepWriteCoupling (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWriteCoupling}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepWriteCoupling}}{void*\sphinxstyleemphasis{ arkode\_mem}, FILE\sphinxstyleemphasis{ *fp}}{}
Outputs the current MRI coupling table to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{fp} \textendash{} pointer to use for printing the Butcher tables.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{fp} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

When run in parallel, only one process should set a non-NULL value
for this pointer, since tables for all processes would be
identical.

\end{fulllineitems}



\subsubsection{Rootfinding optional output functions}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-mristeprootoutputs}}\label{\detokenize{MRIStep_c_interface/User_callable:rootfinding-optional-output-functions}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax \\
\hline
Array showing roots found
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{MRIStepGetRootInfo()}}}}
\\
\hline
No. of calls to user root function
&
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumGEvals}]{\sphinxcrossref{\sphinxcode{MRIStepGetNumGEvals()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepGetRootInfo (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetRootInfo}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetRootInfo}}{void*\sphinxstyleemphasis{ arkode\_mem}, int*\sphinxstyleemphasis{ rootsfound}}{}
Returns an array showing which functions were found to
have a root.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{rootsfound} \textendash{} array of length \sphinxstyleemphasis{nrtfn} with the indices of the
user functions \(g_i\) found to have a root (the value of
\sphinxstyleemphasis{nrtfn} was supplied in the call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepRootInit}]{\sphinxcrossref{\sphinxcode{MRIStepRootInit()}}}}).  For \(i = 0 \ldots\)
\sphinxstyleemphasis{nrtfn}-1, \sphinxcode{rootsfound{[}i{]}} is nonzero if \(g_i\) has a
root, and 0 if not.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The user must allocate space for \sphinxstyleemphasis{rootsfound} prior to
calling this function.

For the components of \(g_i\) for which a root was found, the
sign of \sphinxcode{rootsfound{[}i{]}} indicates the direction of
zero-crossing.  A value of +1 indicates that \(g_i\) is
increasing, while a value of -1 indicates a decreasing \(g_i\).

\end{fulllineitems}

\index{MRIStepGetNumGEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetNumGEvals}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNumGEvals}}{void*\sphinxstyleemphasis{ arkode\_mem}, long int*\sphinxstyleemphasis{ ngevals}}{}
Returns the cumulative number of calls made to the
user’s root function \(g\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{ngevals} \textendash{} number of calls made to \(g\) so far.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsection{MRIStep re-initialization function}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-re-initialization-function}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-reinitialization}}
To reinitialize the MRIStep module for the solution of a new problem,
where a prior call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} has been made, the
user must call the function {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}}.  The new
problem must have the same size as the previous one.  This routine
retains the current settings for all ARKstep module options and
performs the same input checking and initializations that are done in
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}, but it performs no memory allocation as is
assumes that the existing internal memory is sufficient for the new
problem.  A call to this re-initialization routine deletes the
solution history that was stored internally during the previous
integration.  Following a successful call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}}, call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} again for the
solution of the new problem.

The use of {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} requires that the number of Runge Kutta
stages for both the slow and fast methods be no larger for the new problem than
for the previous problem.

One important use of the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} function is in the
treating of jump discontinuities in the RHS functions.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to this routine.  To stop when the location
of the discontinuity is known, simply make that location a value of
\sphinxcode{tout}.  To stop when the location of the discontinuity is
determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS functions \sphinxstyleemphasis{not} incorporate the
discontinuity, but rather have a smooth extension over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
functions (communicated through \sphinxcode{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{MRIStepReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepReInit}}{void*\sphinxstyleemphasis{ arkode\_mem}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{ARKRhsFn}}}\sphinxstyleemphasis{ fs}, realtype\sphinxstyleemphasis{ t0}, N\_Vector\sphinxstyleemphasis{ y0}}{}
Provides required problem specifications and re-initializes the
MRIStep outer (slow) stepper.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{fs} \textendash{} the name of the C function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}})
defining the slow right-hand side function in \(\dot{y} = f_s(t,y) +
f_f(t,y)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the initial value of \(t\).

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the initial condition vector \(y(t_0)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
If the inner (fast) stepper also needs to be reinitialized, its
reinitialization function should be called before calling
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} to reinitialize the outer stepper.

All previously set options are retained but may be updated by calling
the appropriate “Set” functions.

If an error occurred, {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} also
sends an error message to the error handler function.

\end{fulllineitems}



\subsection{MRIStep reset function}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-reset}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-reset-function}}
To reset the MRIStep module to a particular independent variable value and
dependent variable vector for the continued solution of a problem, where a prior
call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}} has been made, the user must call the function
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}}.  Like {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}} this routine retains
the current settings for all MRIStep module options and performs no memory
allocations but, unlike {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReInit}]{\sphinxcrossref{\sphinxcode{MRIStepReInit()}}}}, this routine performs only a
\sphinxstyleemphasis{subset} of the input checking and initializations that are done in
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepCreate}]{\sphinxcrossref{\sphinxcode{MRIStepCreate()}}}}. In particular this routine retains all internal
counter values and the step size/error history and does not reinitialize the
linear and/or nonlinear solver but it does indicate that a linear solver setup
is necessary in the next step. Following a successful call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}}, call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} again to continue
solving the problem. By default the next call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} will
use the step size computed by MRIStep prior to calling {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}}.
To set a different step size or have MRIStep estimate a new step size use
\sphinxcode{MRIStepSetInitStep()}.

One important use of the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}} function is in the
treating of jump discontinuities in the RHS functions.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}}.  To stop when
the location of the discontinuity is known, simply make that location
a value of \sphinxcode{tout}.  To stop when the location of the discontinuity
is determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS functions \sphinxstyleemphasis{not} incorporate the
discontinuity, but rather have a smooth extension over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
functions (communicated through \sphinxcode{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{MRIStepReset (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepReset}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ tR}, N\_Vector\sphinxstyleemphasis{ yR}}{}
Resets the current MRIStep outer (slow) time-stepper module state to the
provided independent variable value and dependent variable vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{tR} \textendash{} the value of the independent variable \(t\).

\item {} 
\sphinxstyleemphasis{yR} \textendash{} the value of the dependent variable vector \(y(t_R)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
If the inner (fast) stepper also needs to be reset, its reset function should
be called before calling {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}} to reset the outer stepper.

All previously set options are retained but may be updated by calling the
appropriate “Set” functions.

If an error occurred, {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepReset}]{\sphinxcrossref{\sphinxcode{MRIStepReset()}}}} also sends an error message to
the error handler function.

\end{fulllineitems}



\subsection{MRIStep system resize function}
\label{\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-resizing}}\label{\detokenize{MRIStep_c_interface/User_callable:mristep-system-resize-function}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatially-adaptive
PDE simulations under a method-of-lines approach), the MRIStep
integrator may be “resized” between \sphinxstyleemphasis{slow} integration steps, through calls
to the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}} function. This function modifies
MRIStep’s internal memory structures to use the new problem size.

To aid in the vector resize operation, the user can supply a vector
resize function that will take as input a vector with the previous
size, and transform it in-place to return a corresponding vector of
the new size.  If this function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn()}}}})
is not supplied (i.e. is set to \sphinxcode{NULL}), then all existing vectors
internal to MRIStep will be destroyed and re-cloned from the new input
vector.
\index{MRIStepResize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepResize}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ ynew}, realtype\sphinxstyleemphasis{ t0}, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{ARKVecResizeFn}}}\sphinxstyleemphasis{ resize}, void*\sphinxstyleemphasis{ resize\_data}}{}
Re-initializes MRIStep with a different state vector.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{ynew} \textendash{} the newly-sized solution vector, holding the current
dependent variable values \(y(t_0)\).

\item {} 
\sphinxstyleemphasis{t0} \textendash{} the current value of the independent variable
\(t_0\) (this must be consistent with \sphinxstyleemphasis{ynew}).

\item {} 
\sphinxstyleemphasis{resize} \textendash{} the user-supplied vector resize function (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn()}}}}.

\item {} 
\sphinxstyleemphasis{resize\_data} \textendash{} the user-supplied data structure to be passed
to \sphinxstyleemphasis{resize} when modifying internal MRIStep vectors.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL}  if the MRIStep memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{ARK\_NO\_MALLOC} if \sphinxstyleemphasis{arkode\_mem} was not allocated.

\item {} 
\sphinxstyleemphasis{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If an error occurred, {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}} also sends an error
message to the error handler function.

\end{fulllineitems}



\subsubsection{Resizing the absolute tolerance array}
\label{\detokenize{MRIStep_c_interface/User_callable:resizing-the-absolute-tolerance-array}}
If using array-valued absolute tolerances, the absolute tolerance
vector will be invalid after the call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}}, so
the new absolute tolerance vector should be re-set \sphinxstylestrong{following} each
call to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}} through a new call to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSVtolerances}]{\sphinxcrossref{\sphinxcode{MRIStepSVtolerances()}}}}.

If scalar-valued tolerances or a tolerance function was specified
through either {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSStolerances}]{\sphinxcrossref{\sphinxcode{MRIStepSStolerances()}}}} or
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepWFtolerances}]{\sphinxcrossref{\sphinxcode{MRIStepWFtolerances()}}}}, then these will remain valid and no
further action is necessary.

\begin{sphinxadmonition}{note}{Note:}
For an example showing usage of the similar
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}} routine, see the supplied serial C
example problem, \sphinxcode{ark\_heat1D\_adapt.c}.
\end{sphinxadmonition}


\section{User-supplied functions}
\label{\detokenize{MRIStep_c_interface/User_supplied:user-supplied-functions}}\label{\detokenize{MRIStep_c_interface/User_supplied::doc}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-usersupplied}}
The user-supplied functions for MRIStep consist of:
\begin{itemize}
\item {} 
a function that defines the slow portion of the ODE (required),

\item {} 
a function that handles error and warning messages (optional),

\item {} 
a function that provides the error weight vector (optional),

\end{itemize}
\begin{itemize}
\item {} 
a function that updates the implicit stage prediction (optional),

\item {} 
a function that defines the root-finding problem(s) to solve
(optional),

\item {} 
one or two functions that provide Jacobian-related information for
the linear solver, if the method is implicit at the slow time scale and
a Newton-based nonlinear iteration is chosen
(optional),

\item {} 
one or two functions that define the preconditioner for use in any
of the Krylov iterative algorithms, if the method is implicit at the
slow time scale and a Newton-based nonlinear iteration and iterative
linear solver are chosen (optional),

\item {} 
a function that handles vector resizing operations, if the
underlying vector structure supports resizing (as opposed to
deletion/recreation), and if the user plans to call
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}} (optional), and

\item {} 
functions to be called before and after each inner integration to
perform any communication or memory transfers of forcing data supplied
by the outer integrator to the inner integrator, or state data supplied
by the inner integrator to the outer integrator.

\end{itemize}

Additionally, a user may supply a custom set of slow-to-fast coupling coefficients for the MRI method.


\subsection{ODE right-hand side}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-oderhs}}\label{\detokenize{MRIStep_c_interface/User_supplied:ode-right-hand-side}}
The user must supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} to
specify the “slow” right-hand side of the ODE system:
\index{ARKRhsFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRhsFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ydot}, void*\sphinxstyleemphasis{ user\_data}}{}
This function computes a portion of the ODE right-hand side for a given
value of the independent variable \(t\) and state vector \(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{ydot} \textendash{} the output vector that forms a portion the ODE RHS \(f(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} the \sphinxtitleref{user\_data} pointer that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRhsFn} should return 0 if successful, a positive value if a
recoverable error occurred (in which case MRIStep will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and \sphinxstyleemphasis{ARK\_RHSFUNC\_FAIL} is returned).

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxtitleref{ydot} is handled within the
MRIStep module.

The vector \sphinxstyleemphasis{ydot} may be uninitialized on input; it is the user’s
responsibility to fill this entire vector with meaningful values.

A recoverable failure error return from the \sphinxstyleemphasis{ARKRhsFn} is typically
used to flag a value of the dependent variable \(y\) that is
“illegal” in some way (e.g., negative where only a non-negative
value is physically meaningful).  If such a return is made within
an implicit solve, MRIStep may attempt to recover by repeating the
nonlinear iteration in order to avoid this recoverable error return.
However, since MRIStep currently requires fixed time stepping at the
slow time scale, no other recovery mechanisms are available, and
MRIStep may halt on a recoverable error flag.

\end{fulllineitems}



\subsection{Error message handler function}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-errorhandler}}\label{\detokenize{MRIStep_c_interface/User_supplied:error-message-handler-function}}
As an alternative to the default behavior of directing error and
warning messages to the file pointed to by \sphinxtitleref{errfp} (see
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetErrFile}]{\sphinxcrossref{\sphinxcode{MRIStepSetErrFile()}}}}), the user may provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}]{\sphinxcrossref{\sphinxcode{ARKErrHandlerFn}}}} to process any such messages.
\index{ARKErrHandlerFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKErrHandlerFn}}\pysiglinewithargsret{typedef void \sphinxbfcode{(*ARKErrHandlerFn)}}{int\sphinxstyleemphasis{ error\_code}, const char*\sphinxstyleemphasis{ module}, const char*\sphinxstyleemphasis{ function}, char*\sphinxstyleemphasis{ msg}, void*\sphinxstyleemphasis{ user\_data}}{}
This function processes error and warning messages from
MRIStep and its sub-modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{error\_code} \textendash{} the error code.

\item {} 
\sphinxstyleemphasis{module} \textendash{} the name of the MRIStep module reporting the error.

\item {} 
\sphinxstyleemphasis{function} \textendash{} the name of the function in which the error occurred.

\item {} 
\sphinxstyleemphasis{msg} \textendash{} the error message.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{eh\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetErrHandlerFn}]{\sphinxcrossref{\sphinxcode{MRIStepSetErrHandlerFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKErrHandlerFn} function has no return value.

\sphinxstylestrong{Notes:} \sphinxstyleemphasis{error\_code} is negative for errors and positive
(\sphinxstyleemphasis{ARK\_WARNING}) for warnings.  If a function that returns a
pointer to memory encounters an error, it sets \sphinxstyleemphasis{error\_code} to
0.

\end{fulllineitems}



\subsection{Error weight function}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-errorweight}}\label{\detokenize{MRIStep_c_interface/User_supplied:error-weight-function}}
As an alternative to providing the relative and absolute tolerances,
the user may provide a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn}}}} to compute a
vector \sphinxstyleemphasis{ewt} containing the weights in the WRMS norm
\(\|v\|_{WRMS} = \left(\frac{1}{n} \sum_{i=1}^n \left(ewt_i\; v_i\right)^2
\right)^{1/2}\).  These weights will be used in place of those defined
in the section {\hyperref[\detokenize{Mathematics:mathematics-error-norm}]{\sphinxcrossref{\DUrole{std,std-ref}{Error norms}}}}.
\index{ARKEwtFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKEwtFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ewt}, void*\sphinxstyleemphasis{ user\_data}}{}
This function computes the WRMS error weights for the vector
\(y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the dependent variable vector at which the
weight vector is to be computed.

\item {} 
\sphinxstyleemphasis{ewt} \textendash{} the output vector containing the error weights.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKEwtFn} function must return 0 if it
successfully set the error weights, and -1 otherwise.

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{ewt} is handled within MRIStep.

The error weight vector must have all components positive.  It is
the user’s responsibility to perform this test and return -1 if it
is not satisfied.

\end{fulllineitems}



\subsection{Implicit stage prediction function}
\label{\detokenize{MRIStep_c_interface/User_supplied:implicit-stage-prediction-function}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-stagepredictfn}}
A user may supply a function to update the prediction for each implicit stage solution.
If supplied, this routine will be called \sphinxstyleemphasis{after} any existing MRIStep predictor
algorithm completes, so that the predictor may be modified by the user as desired.
In this scenario, a user may provide a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKStagePredictFn}]{\sphinxcrossref{\sphinxcode{ARKStagePredictFn}}}}
to provide this implicit predictor to MRIStep.  This function takes as input the
already-predicted implicit stage solution and the corresponding ‘time’ for that prediction;
it then updates the prediction vector as desired.  If the user-supplied routine will
construct a full prediction (and thus the MRIStep prediction is irrelevant), it is
recommended that the user \sphinxstyleemphasis{not} call {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetPredictorMethod}]{\sphinxcrossref{\sphinxcode{MRIStepSetPredictorMethod()}}}}, thereby leaving
the default trivial predictor in place.
\index{ARKStagePredictFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKStagePredictFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKStagePredictFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ zpred}, void*\sphinxstyleemphasis{ user\_data}}{}
This function updates the prediction for the implicit stage solution.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{zpred} \textendash{} the MRIStep-predicted stage solution on input, and the user-modified
predicted stage solution on output.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKStagePredictFn} function should return 0 if it
successfully set the upcoming stable step size, and a non-zero
value otherwise.

\sphinxstylestrong{Notes:}  This may be useful if there are bound constraints on the solution,
and these should be enforced prior to beginning the nonlinear or linear implicit solver
algorithm.

\end{fulllineitems}



\subsection{Rootfinding function}
\label{\detokenize{MRIStep_c_interface/User_supplied:rootfinding-function}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-rootfindingfn}}
If a rootfinding problem is to be solved during the integration of the
ODE system, the user must supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}]{\sphinxcrossref{\sphinxcode{ARKRootFn}}}}.
\index{ARKRootFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKRootFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKRootFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, realtype*\sphinxstyleemphasis{ gout}, void*\sphinxstyleemphasis{ user\_data}}{}
This function implements a vector-valued function
\(g(t,y)\) such that the roots of the \sphinxstyleemphasis{nrtfn} components
\(g_i(t,y)\) are sought.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{gout} \textendash{} the output array, of length \sphinxstyleemphasis{nrtfn}, with components \(g_i(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKRootFn} function should return 0 if successful
or a non-zero value if an error occurred (in which case the
integration is halted and MRIStep returns \sphinxstyleemphasis{ARK\_RTFUNC\_FAIL}).

\sphinxstylestrong{Notes:} Allocation of memory for \sphinxstyleemphasis{gout} is handled within MRIStep.

\end{fulllineitems}



\subsection{Jacobian construction (matrix-based linear solvers)}
\label{\detokenize{MRIStep_c_interface/User_supplied:jacobian-construction-matrix-based-linear-solvers}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-jacobianfn}}
If a matrix-based linear solver module is used (i.e., a non-NULL \sphinxcode{SUNMatrix}
object was supplied to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}} in section
{\hyperref[\detokenize{MRIStep_c_interface/Skeleton:mristep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}), the user may provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn}}}} to provide the Jacobian approximation or
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}]{\sphinxcrossref{\sphinxcode{ARKLsLinSysFn}}}} to provide an approximation of the linear system
\(A = I - \gamma J\).
\index{ARKLsJacFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsJacFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, SUNMatrix\sphinxstyleemphasis{ Jac}, void*\sphinxstyleemphasis{ user\_data}, N\_Vector\sphinxstyleemphasis{ tmp1}, N\_Vector\sphinxstyleemphasis{ tmp2}, N\_Vector\sphinxstyleemphasis{ tmp3}}{}
This function computes the Jacobian matrix \(J =
\frac{\partial f^S}{\partial y}\) (or an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector, namely
the predicted value of \(y(t)\).

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^S(t,y)\).

\item {} 
\sphinxstyleemphasis{Jac} \textendash{} the output Jacobian matrix.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp1}, \sphinxstyleemphasis{tmp2}, \sphinxstyleemphasis{tmp3} \textendash{} pointers to memory allocated to
variables of type \sphinxcode{N\_Vector} which can be used by an
ARKLsJacFn as temporary storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKLsJacFn} function should return 0 if successful, a positive
value if a recoverable error occurred (in which case MRIStep will
attempt to correct, while ARKLS sets \sphinxstyleemphasis{last\_flag} to
\sphinxstyleemphasis{ARKLS\_JACFUNC\_RECVR}), or a negative value if it failed
unrecoverably (in which case the integration is halted,
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} returns \sphinxstyleemphasis{ARK\_LSETUP\_FAIL} and ARKLS sets
\sphinxstyleemphasis{last\_flag} to \sphinxstyleemphasis{ARKLS\_JACFUNC\_UNRECVR}).

\sphinxstylestrong{Notes:} Information regarding the structure of the specific
\sphinxcode{SUNMatrix} structure (e.g.\textasciitilde{}number of rows, upper/lower
bandwidth, sparsity type) may be obtained through using the
implementation-specific \sphinxcode{SUNMatrix} interface functions
(see the section {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}} for details).

When using a linear solver of type \sphinxcode{SUNLINEARSOLVER\_DIRECT}, prior
to calling the user-supplied Jacobian function, the Jacobian
matrix \(J(t,y)\) is zeroed out, so only nonzero elements need
to be loaded into \sphinxstyleemphasis{Jac}.

With the default nonlinear solver (the native SUNDIALS Netwon method), each
call to the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}} function is preceded by a call to the
implicit {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}} user function with the same \((t,y)\)
arguments. Thus, the Jacobian function can use any auxiliary data that is
computed and saved during the evaluation of the implicit ODE right-hand side.
In the case of a user-supplied or external nonlinear solver, this is also
true if the nonlinear system function is evaluated prior to calling the
linear solver setup function (see {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for more
information).

If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn}}}} function uses difference
quotient approximations, then it may need to access quantities not
in the argument list.  These include the current step size, the
error weights, etc.  To obtain these, the user will need to add a
pointer to the \sphinxcode{ark\_mem} structure to their \sphinxcode{user\_data}, and
then use the MRIStepGet* functions listed in
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\sphinxstylestrong{dense}:

A user-supplied dense Jacobian function must load the
\sphinxstyleemphasis{N} by \sphinxstyleemphasis{N} dense matrix \sphinxstyleemphasis{Jac} with an approximation to the Jacobian
matrix \(J(t,y)\) at the point \((t,y)\). The accessor
macros \sphinxcode{SM\_ELEMENT\_D} and \sphinxcode{SM\_COLUMN\_D} allow the user to read
and write dense matrix elements without making explicit references
to the underlying representation of the SUNMATRIX\_DENSE type.
\sphinxcode{SM\_ELEMENT\_D(J, i, j)} references the \sphinxcode{(i,j)}-th element of
the dense matrix \sphinxcode{J} (for \sphinxcode{i}, \sphinxcode{j} between 0 and
N-1). This macro is meant for small problems for which
efficiency of access is not a major concern. Thus, in terms of the
indices \(m\) and \(n\) ranging from 1 to \sphinxstyleemphasis{N}, the
Jacobian element \(J_{m,n}\) can be set using the statement
\sphinxcode{SM\_ELEMENT\_D(J, m-1, n-1) =} \(J_{m,n}\).  Alternatively,
\sphinxcode{SM\_COLUMN\_D(J, j)} returns a pointer to the first element of the
\sphinxcode{j}-th column of \sphinxcode{J} (for \sphinxcode{j} ranging from 0 to \sphinxtitleref{N}-1),
and the elements of the \sphinxcode{j}-th column can then be accessed using
ordinary array indexing. Consequently, \(J_{m,n}\) can be
loaded using the statements
\sphinxcode{col\_n = SM\_COLUMN\_D(J, n-1); col\_n{[}m-1{]} =} \(J_{m,n}\).
For large problems, it is more efficient to use \sphinxcode{SM\_COLUMN\_D}
than to use \sphinxcode{SM\_ELEMENT\_D}.  Note that both of these macros
number rows and columns starting from 0.  The SUNMATRIX\_DENSE type
and accessor macros are documented in section
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Dense:sunmatrix-dense}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_DENSE Module}}}}.

\sphinxstylestrong{band}:

A user-supplied banded Jacobian function must load the band
matrix \sphinxstyleemphasis{Jac} with the elements of the Jacobian
\(J(t,y)\) at the point \((t,y)\). The accessor macros
\sphinxcode{SM\_ELEMENT\_B}, \sphinxcode{SM\_COLUMN\_B}, and \sphinxcode{SM\_COLUMN\_ELEMENT\_B}
allow the user to read and write band matrix elements without
making specific references to the underlying representation of the
SUNMATRIX\_BAND type.  \sphinxcode{SM\_ELEMENT\_B(J, i, j)} references the
\sphinxcode{(i,j)}-th element of the band matrix \sphinxcode{J}, counting
from 0. This macro is meant for use in small problems for
which efficiency of access is not a major concern. Thus, in terms
of the indices \(m\) and \(n\) ranging from 1 to \sphinxstyleemphasis{N} with
\((m, n)\) within the band defined by \sphinxstyleemphasis{mupper} and
\sphinxstyleemphasis{mlower}, the Jacobian element \(J_{m,n}\) can be loaded
using the statement \sphinxcode{SM\_ELEMENT\_B(J, m-1, n-1)} \(=
J_{m,n}\). The elements within the band are those with \sphinxstyleemphasis{-mupper}
\(\le m-n \le\) \sphinxstyleemphasis{mlower}.  Alternatively, \sphinxcode{SM\_COLUMN\_B(J, j)}
returns a pointer to the diagonal element of the \sphinxcode{j}-th column of
\sphinxcode{J}, and if we assign this address to \sphinxcode{realtype *col\_j}, then
the \sphinxcode{i}-th element of the \sphinxcode{j}-th column is given by
\sphinxcode{SM\_COLUMN\_ELEMENT\_B(col\_j, i, j)}, counting from 0. Thus, for
\((m,n)\) within the band, \(J_{m,n}\) can be loaded by
setting \sphinxcode{col\_n = SM\_COLUMN\_B(J, n-1); SM\_COLUMN\_ELEMENT\_B(col\_n, m-1,
n-1)} \(= J_{m,n}\) . The elements of the \sphinxcode{j}-th column can
also be accessed via ordinary array indexing, but this approach
requires knowledge of the underlying storage for a band matrix of
type SUNMATRIX\_BAND. The array \sphinxcode{col\_n} can be indexed from
\sphinxstyleemphasis{-mupper} to \sphinxstyleemphasis{mlower}. For large problems, it is more efficient
to use \sphinxcode{SM\_COLUMN\_B} and \sphinxcode{SM\_COLUMN\_ELEMENT\_B} than to use the
\sphinxcode{SM\_ELEMENT\_B} macro. As in the dense case, these macros all
number rows and columns starting from 0. The SUNMATRIX\_BAND type
and accessor macros are documented in section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:sunmatrix-band}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_BAND Module}}}}.

\sphinxstylestrong{sparse}:

A user-supplied sparse Jacobian function must load the
compressed-sparse-column (CSC) or compressed-sparse-row (CSR)
matrix \sphinxstyleemphasis{Jac} with an approximation to the Jacobian matrix
\(J(t,y)\) at the point \((t,y)\).  Storage for \sphinxstyleemphasis{Jac}
already exists on entry to this function, although the user should
ensure that sufficient space is allocated in \sphinxstyleemphasis{Jac} to hold the
nonzero values to be set; if the existing space is insufficient the
user may reallocate the data and index arrays as needed.  The
amount of allocated space in a SUNMATRIX\_SPARSE object may be
accessed using the macro \sphinxcode{SM\_NNZ\_S} or the routine
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ}]{\sphinxcrossref{\sphinxcode{SUNSparseMatrix\_NNZ()}}}}.  The SUNMATRIX\_SPARSE type is
further documented in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_SPARSE Module}}}}.

\end{fulllineitems}

\index{ARKLsLinSysFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsLinSysFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsLinSysFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, SUNMatrix\sphinxstyleemphasis{ A}, SUNMatrix\sphinxstyleemphasis{ M}, booleantype\sphinxstyleemphasis{ jok}, booleantype\sphinxstyleemphasis{ *jcur}, realtype\sphinxstyleemphasis{ gamma}, void\sphinxstyleemphasis{ *user\_data}, N\_Vector\sphinxstyleemphasis{ tmp1}, N\_Vector\sphinxstyleemphasis{ tmp2}, N\_Vector\sphinxstyleemphasis{ tmp3}}{}
This function computes the linear system matrix \(A = I - \gamma J\) (or
an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector, namely the
predicted value of \(y(t)\).

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^S(t,y)\).

\item {} 
\sphinxstyleemphasis{A} \textendash{} the output linear system matrix.

\item {} 
\sphinxstyleemphasis{M} \textendash{} the argument will be \sphinxcode{NULL} since MRIStep does not support non-identity mass matrices.

\item {} 
\sphinxstyleemphasis{jok} \textendash{} is an input flag indicating whether the Jacobian-related data
needs to be updated. The \sphinxstyleemphasis{jok} argument provides for the reuse of
Jacobian data. When \sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}, the Jacobian-related data should
be recomputed from scratch. When \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} the Jacobian data, if
saved from the previous call to this function, can be reused (with the
current value of \sphinxstyleemphasis{gamma}). A call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} can only occur
after a call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}.

\item {} 
\sphinxstyleemphasis{jcur} \textendash{} is a pointer to a flag which should be set to \sphinxcode{SUNTRUE} if
Jacobian data was recomputed, or set to \sphinxcode{SUNFALSE} if Jacobian data
was not recomputed, but saved data was still reused.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the scalar \(\gamma\) appearing in the Newton matrix
given by \(A=I-\gamma J\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the \sphinxstyleemphasis{user\_data}
parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp1}, \sphinxstyleemphasis{tmp2}, \sphinxstyleemphasis{tmp3} \textendash{} pointers to memory allocated to variables of
type \sphinxcode{N\_Vector} which can be used by an ARKLsLinSysFn as temporary
storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKLsLinSysFn} function should return 0 if successful, a positive value
if a recoverable error occurred (in which case MRIStep will attempt to
correct, while ARKLS sets \sphinxstyleemphasis{last\_flag} to \sphinxstyleemphasis{ARKLS\_JACFUNC\_RECVR}), or a
negative value if it failed unrecoverably (in which case the integration is
halted, {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepEvolve}]{\sphinxcrossref{\sphinxcode{MRIStepEvolve()}}}} returns \sphinxstyleemphasis{ARK\_LSETUP\_FAIL} and ARKLS sets
\sphinxstyleemphasis{last\_flag} to \sphinxstyleemphasis{ARKLS\_JACFUNC\_UNRECVR}).

\end{fulllineitems}



\subsection{Jacobian-vector product (matrix-free linear solvers)}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-jtimesfn}}\label{\detokenize{MRIStep_c_interface/User_supplied:jacobian-vector-product-matrix-free-linear-solvers}}
When using a matrix-free linear solver module for the implicit
stage solves (i.e., a NULL-valued SUNMATRIX argument was supplied to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{MRIStepSetLinearSolver()}}}} in the section
{\hyperref[\detokenize{MRIStep_c_interface/Skeleton:mristep-cinterface-skeleton}]{\sphinxcrossref{\DUrole{std,std-ref}{A skeleton of the user’s main program}}}}), the user may provide a function
of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} in the following form, to compute
matrix-vector products \(Jv\). If such a function is not supplied,
the default is a difference quotient approximation to these products.
\index{ARKLsJacTimesVecFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsJacTimesVecFn)}}{N\_Vector\sphinxstyleemphasis{ v}, N\_Vector\sphinxstyleemphasis{ Jv}, realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, void*\sphinxstyleemphasis{ user\_data}, N\_Vector\sphinxstyleemphasis{ tmp}}{}
This function computes the product \(Jv =
\left(\frac{\partial f^S}{\partial y}\right)v\) (or an approximation to it).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{v} \textendash{} the vector to multiply.

\item {} 
\sphinxstyleemphasis{Jv} \textendash{} the output vector computed.

\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^S(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\item {} 
\sphinxstyleemphasis{tmp} \textendash{} pointer to memory allocated to a variable of type
\sphinxcode{N\_Vector} which can be used as temporary storage or work space.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the Jacobian-vector product
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the generic Krylov solver,
in which case the integration is halted.

\sphinxstylestrong{Notes:} If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn}}}} function
uses difference quotient approximations, it may need to access
quantities not in the argument list.  These include the current
step size, the error weights, etc.  To obtain these, the
user will need to add a pointer to the \sphinxcode{ark\_mem} structure to
their \sphinxcode{user\_data}, and then use the MRIStepGet* functions listed
in {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\end{fulllineitems}



\subsection{Jacobian-vector product setup (matrix-free linear solvers)}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-jtsetupfn}}\label{\detokenize{MRIStep_c_interface/User_supplied:jacobian-vector-product-setup-matrix-free-linear-solvers}}
If the user’s Jacobian-times-vector routine requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}},
defined as follows:
\index{ARKLsJacTimesSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsJacTimesSetupFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, void*\sphinxstyleemphasis{ user\_data}}{}
This function preprocesses and/or evaluates any Jacobian-related
data needed by the Jacobian-times-vector routine.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^S(t,y)\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the Jacobian-vector setup
function should be 0 if successful, positive for a recoverable
error (in which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\sphinxstylestrong{Notes:}    Each call to the Jacobian-vector setup function is
preceded by a call to the implicit {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} user
function with the same \((t,y)\) arguments.  Thus, the setup
function can use any auxiliary data that is computed and saved
during the evaluation of the implicit ODE right-hand side.

If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn}}}} function uses
difference quotient approximations, it may need to access
quantities not in the argument list.  These include the current
step size, the error weights, etc.  To obtain these, the
user will need to add a pointer to the \sphinxcode{ark\_mem} structure to
their \sphinxcode{user\_data}, and then use the MRIStepGet* functions listed
in {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\end{fulllineitems}



\subsection{Preconditioner solve (iterative linear solvers)}
\label{\detokenize{MRIStep_c_interface/User_supplied:preconditioner-solve-iterative-linear-solvers}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-precsolvefn}}
If a user-supplied preconditioner is to be used with a SUNLinSol
solver module, then the user must provide a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSolveFn}}}} to solve the linear system \(Pz=r\),
where \(P\) corresponds to either a left or right
preconditioning matrix.  Here \(P\) should approximate (at least
crudely) the Newton matrix \(A=I-\gamma J\), where
\(J = \frac{\partial f^S}{\partial y}\)  If preconditioning is
done on both sides, the product of the two preconditioner matrices
should approximate \(A\).
\index{ARKLsPrecSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsPrecSolveFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, N\_Vector\sphinxstyleemphasis{ r}, N\_Vector\sphinxstyleemphasis{ z}, realtype\sphinxstyleemphasis{ gamma}, realtype\sphinxstyleemphasis{ delta}, int\sphinxstyleemphasis{ lr}, void*\sphinxstyleemphasis{ user\_data}}{}
This function solves the preconditioner system \(Pz=r\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^S(t,y)\).

\item {} 
\sphinxstyleemphasis{r} \textendash{} the right-hand side vector of the linear system.

\item {} 
\sphinxstyleemphasis{z} \textendash{} the computed output solution vector.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the scalar \(\gamma\) appearing in the Newton
matrix given by \(A=I-\gamma J\).

\item {} 
\sphinxstyleemphasis{delta} \textendash{} an input tolerance to be used if an iterative method
is employed in the solution.  In that case, the residual vector
\(Res = r-Pz\) of the system should be made to be less than \sphinxstyleemphasis{delta}
in the weighted \(l_2\) norm, i.e. \(\left(\sum_{i=1}^n
\left(Res_i * ewt_i\right)^2 \right)^{1/2} < \delta\), where \(\delta =\)
\sphinxtitleref{delta}.  To obtain the \sphinxcode{N\_Vector} \sphinxstyleemphasis{ewt}, call
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{MRIStepGetErrWeights()}}}}.

\item {} 
\sphinxstyleemphasis{lr} \textendash{} an input flag indicating whether the preconditioner
solve is to use the left preconditioner (\sphinxstyleemphasis{lr} = 1) or the right
preconditioner (\sphinxstyleemphasis{lr} = 2).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the preconditioner solve
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\end{fulllineitems}



\subsection{Preconditioner setup (iterative linear solvers)}
\label{\detokenize{MRIStep_c_interface/User_supplied:preconditioner-setup-iterative-linear-solvers}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-precsetupfn}}
If the user’s preconditioner routine requires that any data be
preprocessed or evaluated, then these actions need to occur within a
user-supplied function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn}}}}.
\index{ARKLsPrecSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKLsPrecSetupFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ fy}, booleantype\sphinxstyleemphasis{ jok}, booleantype*\sphinxstyleemphasis{ jcurPtr}, realtype\sphinxstyleemphasis{ gamma}, void*\sphinxstyleemphasis{ user\_data}}{}
This function preprocesses and/or evaluates Jacobian-related
data needed by the preconditioner.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{fy} \textendash{} the current value of the vector \(f^S(t,y)\).

\item {} 
\sphinxstyleemphasis{jok} \textendash{} is an input flag indicating whether the Jacobian-related
data needs to be updated. The \sphinxstyleemphasis{jok} argument provides for the
reuse of Jacobian data in the preconditioner solve function. When
\sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}, the Jacobian-related data should be recomputed
from scratch. When \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} the Jacobian data, if saved from the
previous call to this function, can be reused (with the current
value of \sphinxstyleemphasis{gamma}). A call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNTRUE} can only occur
after a call with \sphinxstyleemphasis{jok} = \sphinxcode{SUNFALSE}.

\item {} 
\sphinxstyleemphasis{jcurPtr} \textendash{} is a pointer to a flag which should be set to
\sphinxcode{SUNTRUE} if Jacobian data was recomputed, or set to \sphinxcode{SUNFALSE} if
Jacobian data was not recomputed, but saved data was still reused.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the scalar \(\gamma\) appearing in the Newton
matrix given by \(A=I-\gamma J\).

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{user\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
The value to be returned by the preconditioner setup
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\sphinxstylestrong{Notes:}  The operations performed by this function might include
forming a crude approximate Jacobian, and performing an LU
factorization of the resulting approximation to \(A = I -
\gamma J\).

With the default nonlinear solver (the native SUNDIALS Netwon method), each
call to the preconditioner setup function is preceded by a call to the
implicit {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn}}}} user function with the same \((t,y)\)
arguments.  Thus, the preconditioner setup function can use any auxiliary
data that is computed and saved during the evaluation of the implicit ODE
right-hand side. In the case of a user-supplied or external nonlinear solver,
this is also true if the nonlinear system function is evaluated prior to
calling the linear solver setup function (see
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for more information).

This function is not called in advance of every call to the
preconditioner solve function, but rather is called only as often
as needed to achieve convergence in the Newton iteration.

If the user’s {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn}}}} function uses
difference quotient approximations, it may need to access
quantities not in the call list. These include the current step
size, the error weights, etc.  To obtain these, the user will need
to add a pointer to the \sphinxcode{ark\_mem} structure to their
\sphinxcode{user\_data}, and then use the MRIStepGet* functions listed in
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}. The unit roundoff can be
accessed as \sphinxcode{UNIT\_ROUNDOFF}, which is defined in the header
file \sphinxcode{sundials\_types.h}.

\end{fulllineitems}



\subsection{Vector resize function}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-vecresizefn}}\label{\detokenize{MRIStep_c_interface/User_supplied:vector-resize-function}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatial adaptivity in a
PDE simulation), the MRIStep integrator may be “resized” between
integration steps, through calls to the {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}}
function. Typically, when performing adaptive simulations the solution
is stored in a customized user-supplied data structure, to enable
adaptivity without repeated allocation/deallocation of memory.  In
these scenarios, it is recommended that the user supply a customized
vector kernel to interface between SUNDIALS and their problem-specific
data structure.  If this vector kernel includes a function of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}]{\sphinxcrossref{\sphinxcode{ARKVecResizeFn}}}} to resize a given vector implementation, then
this function may be supplied to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}} so that all
internal MRIStep vectors may be resized, instead of deleting and
re-creating them at each call.  This resize function should have the
following form:
\index{ARKVecResizeFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.ARKVecResizeFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ARKVecResizeFn)}}{N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ ytemplate}, void*\sphinxstyleemphasis{ user\_data}}{}
This function resizes the vector \sphinxstyleemphasis{y} to match the dimensions of the
supplied vector, \sphinxstyleemphasis{ytemplate}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} the vector to resize.

\item {} 
\sphinxstyleemphasis{ytemplate} \textendash{} a vector of the desired size.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} a pointer to user data, the same as the
\sphinxstyleemphasis{resize\_data} parameter that was passed to {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepResize}]{\sphinxcrossref{\sphinxcode{MRIStepResize()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{ARKVecResizeFn} function should return 0 if it successfully
resizes the vector \sphinxstyleemphasis{y}, and a non-zero value otherwise.

\sphinxstylestrong{Notes:}  If this function is not supplied, then MRIStep will
instead destroy the vector \sphinxstyleemphasis{y} and clone a new vector \sphinxstyleemphasis{y} off of
\sphinxstyleemphasis{ytemplate}.

\end{fulllineitems}



\subsection{Pre inner integrator communication function}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-preinnerfn}}\label{\detokenize{MRIStep_c_interface/User_supplied:pre-inner-integrator-communication-function}}
The user may supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPreInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepPreInnerFn}}}} that will be
called \sphinxstyleemphasis{before} each inner integration to perform any communication or
memory transfers of forcing data supplied by the outer integrator to the inner
integrator for the inner integration.
\index{MRIStepPreInnerFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPreInnerFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*MRIStepPreInnerFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector*\sphinxstyleemphasis{ f}, int\sphinxstyleemphasis{ num\_vecs}, void*\sphinxstyleemphasis{ user\_data}}{}~\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{f} \textendash{} an \sphinxcode{N\_Vector} array of outer forcing vectors.

\item {} 
\sphinxstyleemphasis{num\_vecs} \textendash{} the number of vectors in the \sphinxcode{N\_Vector} array.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} the \sphinxtitleref{user\_data} pointer that was passed to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{MRIStepPreInnerFn} function should return 0 if successful, a positive value
if a recoverable error occurred, or a negative value if an unrecoverable
error occurred. As the MRIStep module only supports fixed step sizes at this
time any non-zero return value will halt the integration.

\sphinxstylestrong{Notes:}
In a heterogeneous computing environment if any data copies between the host
and device vector data are necessary, this is where that should occur.

\end{fulllineitems}



\subsection{Post inner integrator communication function}
\label{\detokenize{MRIStep_c_interface/User_supplied:post-inner-integrator-communication-function}}\label{\detokenize{MRIStep_c_interface/User_supplied:mristep-cinterface-postinnerfn}}
The user may supply a function of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPostInnerFn}]{\sphinxcrossref{\sphinxcode{MRIStepPostInnerFn}}}} that will be
called \sphinxstyleemphasis{after} each inner integration to perform any communication or
memory transfers of state data supplied by the inner integrator to the
outer integrator for the outer integration.
\index{MRIStepPostInnerFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepPostInnerFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*MRIStepPostInnerFn)}}{realtype\sphinxstyleemphasis{ t}, N\_Vector\sphinxstyleemphasis{ y}, void*\sphinxstyleemphasis{ user\_data}}{}~\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{t} \textendash{} the current value of the independent variable.

\item {} 
\sphinxstyleemphasis{y} \textendash{} the current value of the dependent variable vector.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} the \sphinxtitleref{user\_data} pointer that was passed to
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}
An \sphinxstyleemphasis{MRIStepPostInnerFn} function should return 0 if successful, a positive value
if a recoverable error occurred, or a negative value if an unrecoverable
error occurred. As the MRIStep module only supports fixed step sizes at this
time any non-zero return value will halt the integration.

\sphinxstylestrong{Notes:}
In a heterogeneous computing environment if any data copies between the host
and device vector data are necessary, this is where that should occur.

\end{fulllineitems}

\begin{quote}\begin{description}
\item[{tocdepth}] \leavevmode
3

\end{description}\end{quote}


\subsection{MRI Coupling Coefficients Data Structure}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling}}\label{\detokenize{MRIStep_c_interface/User_supplied:mri-coupling-coefficients-data-structure}}
As mentioned in the section {\hyperref[\detokenize{MRIStep_c_interface/User_callable:mristep-cinterface-usercallable}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStep User-callable functions}}}}, a user may supply a custom set of coupling
coefficients between fast and slow time scales (through {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepSetCoupling()}}}}).  MRIStep uses a custom
data type, {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}}, to store these coefficients, and provides several related utility
routines.  As described in the Section {\hyperref[\detokenize{Mathematics:mathematics-mristep}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStep \textendash{} Multirate infinitesimal step methods}}}}, the coupling from slow to fast time scales
in MRI methods may be encoded by a vector of slow ‘stage time’ abcissae, \(c^S \in \mathbb{R}^{s+1}\) and a
set of coupling matrices \(\Gamma^{\{k\}}\in\mathbb{R}^{(s+1)\times(s+1)}\).  We therefore define the
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} structure to be
\index{MRIStepCoupling (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}}\pysigline{typedef MRIStepCouplingMem *\sphinxbfcode{MRIStepCoupling}}
\end{fulllineitems}


where \sphinxcode{MRIStepCouplingMem} is the structure

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{MRIStepCouplingMem} \PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{nmat}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{stages}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{q}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{n}{G}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{c}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Here,
\begin{itemize}
\item {} 
\sphinxcode{nmat} corresponds to the number of \(\Gamma^{\{k\}}\) matrices used for coupling,

\item {} 
\sphinxcode{stages} is the number of entries in \sphinxcode{c}, i.e., \(s+1\) above,

\item {} 
\sphinxcode{q} and \sphinxcode{p} indicate the orders of accuracy for both the MRI method and the embedding, respectively,

\item {} 
\sphinxcode{G} is a three-dimensional array with dimensions \sphinxcode{{[}nmat{]}{[}stages{]}{[}stages{]}} containing the set of
\(\Gamma^{\{k\}}\) matrices, and

\item {} 
\sphinxcode{c} is an array of length \sphinxcode{stages} containing slow abcissae \(c^S\) for the MRI method.

\end{itemize}


\subsubsection{MRIStepCoupling functions}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling-functions}}\label{\detokenize{MRIStep_c_interface/User_supplied:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_LoadTable}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_LoadTable()}}}}
&
Loads a pre-defined MRIStepCoupling table
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Alloc}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_Alloc()}}}}
&
Allocate an empty MRIStepCoupling table
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Create}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_Create()}}}}
&
Create a new MRIStepCoupling table from coefficients
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_MIStoMRI}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_MIStoMRI()}}}}
&
Create a new MRIStepCoupling table from a slow Butcher table
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Copy}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_Copy()}}}}
&
Create a copy of a MRIStepCoupling table
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Space}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_Space()}}}}
&
Get the MRIStepCoupling table real and integer workspace sizes
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Free}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_Free()}}}}
&
Deallocate a MRIStepCoupling table
\\
\hline
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Write}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling\_Write()}}}}
&
Write the MRIStepCoupling table to an output file
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{MRIStepCoupling\_LoadTable (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_LoadTable}}\pysiglinewithargsret{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}} \sphinxbfcode{MRIStepCoupling\_LoadTable}}{int\sphinxstyleemphasis{ imethod}}{}
Retrieves a specified MRIStepCoupling table. The prototype for this function, as well as the
integer names for each provided method, are defined in top of the header file
\sphinxcode{arkode/arkode\_mristep.h}.  For further information on the current set of coupling tables
and their corresponding identifiers, see {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling-tables}]{\sphinxcrossref{\DUrole{std,std-ref}{MRIStepCoupling tables}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{itable} \textendash{} MRIStepCoupling table identifier to load.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{itable} was invalid or an allocation error occured.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepCoupling\_Alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Alloc}}\pysiglinewithargsret{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}} \sphinxbfcode{MRIStepCoupling\_Alloc}}{int\sphinxstyleemphasis{ nmat}, int\sphinxstyleemphasis{ stages}}{}
Allocates an empty MRIStepCoupling table.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{nmat} \textendash{} number of \(\Gamma^{\{k\}}\) matrices in the coupling table.

\item {} 
\sphinxstyleemphasis{stages} \textendash{} number of stages in the coupling table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{stages} was invalid or an allocation error occured.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepCoupling\_Create (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Create}}\pysiglinewithargsret{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}} \sphinxbfcode{MRIStepCoupling\_Create}}{int\sphinxstyleemphasis{ nmat}, int\sphinxstyleemphasis{ stages}, int\sphinxstyleemphasis{ q}, int\sphinxstyleemphasis{ p}, realtype\sphinxstyleemphasis{ *G}, realtype\sphinxstyleemphasis{ *c}}{}
Allocates an MRIStepCoupling table and fills it with the given values.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{nmat} \textendash{} number of \(\Gamma^{\{k\}}\) matrices in the coupling table.

\item {} 
\sphinxstyleemphasis{stages} \textendash{} number of stages in the MRI method.

\item {} 
\sphinxstyleemphasis{q} \textendash{} global order of accuracy for the MRI method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} global order of accuracy for the embedded MRI method.

\item {} 
\sphinxstyleemphasis{G} \textendash{} array of coefficients defining the \(\Gamma^{\{k\}}\) matrices. This should be
stored as a 1D array of size \sphinxstyleemphasis{nmat*stages*stages}, in row-major order.

\item {} 
\sphinxstyleemphasis{c} \textendash{} array (of length \sphinxstyleemphasis{stages}) of slow abcissae for the MRI method.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{stages} was invalid or an allocation error occured.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} As embeddings are not currently supported in MRIStep, then \sphinxstyleemphasis{p} should be equal to zero.

\end{fulllineitems}

\index{MRIStepCoupling\_MIStoMRI (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_MIStoMRI}}\pysiglinewithargsret{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}} \sphinxbfcode{MRIStepCoupling\_MIStoMRI}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}, int\sphinxstyleemphasis{ q}, int\sphinxstyleemphasis{ p}}{}
Creates an MRI coupling table for a traditional MIS method based on the slow Butcher table \sphinxstyleemphasis{B}, following
the formula shown in \eqref{equation:Mathematics:MIS_to_MRI}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B} \textendash{} the {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} for the ‘slow’ MIS method.

\item {} 
\sphinxstyleemphasis{q} \textendash{} the overall order of the MIS/MRI method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} the overall order of the MIS/MRI embedding.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer an allocation error occured.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \(s\)-stage slow Butcher table must have an explicit first stage (i.e., \(c_1=0\)
and \(A_{1,j}=0\) for \(1\le j\le s\)) and sorted abcissae (i.e., \(c_{i} \ge  c_{i-1}\) for
\(2\le i\le s\)).

Since an MIS method is at most third order accurate, and even then only if it meets certain compatibility
criteria (see \eqref{equation:Mathematics:MIS_order3}), the values of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} may differ from the method and embedding orders
of accuracy for the Runge\textendash{}Kutta encoded in \sphinxstyleemphasis{B}, which is why these arguments should be supplied separately.

As embeddings are not currently supported in MRIStep, then \sphinxstyleemphasis{p} should be equal to zero.

\end{fulllineitems}

\index{MRIStepCoupling\_Copy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Copy}}\pysiglinewithargsret{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}} \sphinxbfcode{MRIStepCoupling\_Copy}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}}\sphinxstyleemphasis{ C}}{}
Creates copy of the given coupling table.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{C} \textendash{} the coupling table to copy.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{\sphinxcode{MRIStepCoupling}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer an allocation error occured.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepCoupling\_Space (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Space}}\pysiglinewithargsret{void \sphinxbfcode{MRIStepCoupling\_Space}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}}\sphinxstyleemphasis{ C}, sunindextype\sphinxstyleemphasis{ *liw}, sunindextype\sphinxstyleemphasis{ *lrw}}{}
Get the real and integer workspace size for an MRIStepCoupling table.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{C} \textendash{} the coupling table.

\item {} 
\sphinxstyleemphasis{lenrw} \textendash{} the number of \sphinxcode{realtype} values in the coupling table workspace.

\item {} 
\sphinxstyleemphasis{leniw} \textendash{} the number of integer values in the coupling table workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the Butcher table memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepCoupling\_Free (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Free}}\pysiglinewithargsret{void \sphinxbfcode{MRIStepCoupling\_Free}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}}\sphinxstyleemphasis{ C}}{}
Deallocate the coupling table memory.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{C} \textendash{} the MRIStepCoupling table.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepCoupling\_Write (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling_Write}}\pysiglinewithargsret{void \sphinxbfcode{MRIStepCoupling\_Write}}{{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.MRIStepCoupling}]{\sphinxcrossref{MRIStepCoupling}}}\sphinxstyleemphasis{ C}, FILE\sphinxstyleemphasis{ *outfile}}{}
Write the coupling table to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{C} \textendash{} the MRIStepCoupling table.

\item {} 
\sphinxstyleemphasis{outfile} \textendash{} pointer to use for printing the table.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{outfile} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

\end{fulllineitems}



\subsubsection{MRIStepCoupling tables}
\label{\detokenize{MRIStep_c_interface/User_supplied:mristepcoupling-tables}}\label{\detokenize{MRIStep_c_interface/User_supplied:id2}}
MRIStep currently includes two classes of MRI coupling tables: those that encode methods that are
explicit at the slow time scale, and those that are diagonally-implicit and solve-decoupled at
the slow time scale.  We list the current identifiers, multirate order of accuracy, and relevant
references for each in the tables below.  For the implicit methods, we also list the number of
implicit solves per step that are required at the slow time scale.

Explicit MRI coupling tables:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Table name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Order
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Reference
\unskip}\relax \\
\hline
\sphinxcode{MIS\_KW3}
&
3
&
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:id3}}{\hyperref[\detokenize{References:skaw2009}]{\sphinxcrossref{{[}SKAW2009{]}}}}
\\
\hline
\sphinxcode{MRI\_GARK\_ERK45a}
&
4
&
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:id4}}{\hyperref[\detokenize{References:s2019}]{\sphinxcrossref{{[}S2019{]}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Diagonally-implicit, solve-decoupled MRI coupling tables:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Table name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Order
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Implicit Solves
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Reference
\unskip}\relax \\
\hline
\sphinxcode{MRI\_GARK\_IRK21a}
&
2
&
1
&
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:id5}}{\hyperref[\detokenize{References:s2019}]{\sphinxcrossref{{[}S2019{]}}}}
\\
\hline
\sphinxcode{MRI\_GARK\_ESDIRK34a}
&
4
&
3
&
\phantomsection\label{\detokenize{MRIStep_c_interface/User_supplied:id6}}{\hyperref[\detokenize{References:s2019}]{\sphinxcrossref{{[}S2019{]}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Using ARKode for Fortran Applications}
\label{\detokenize{ARKode_f_interface/index::doc}}\label{\detokenize{ARKode_f_interface/index:using-arkode-for-fortran-applications}}\label{\detokenize{ARKode_f_interface/index:fortraninterfaces}}
Fortran 2003 interfaces to each of the time-stepping modules as well as a
Fortran 77 style interface to the ARKStep time-stepping module are
provided to support the use of ARKode, for the solution of ODE systems,
in a mixed Fortran/C setting. While ARKode is written in C, it is assumed
here that the user’s calling program and user-supplied problem-definining
rotuines are written in Fortran.


\section{ARKode Fortran 2003 Interface Modules}
\label{\detokenize{ARKode_f_interface/F2003Module:arkode-fortran-2003-interface-modules}}\label{\detokenize{ARKode_f_interface/F2003Module::doc}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003}}
The ARKode Fortran 2003 modules define interfaces to most of the ARKode C
API using the intrinsic \sphinxcode{iso\_c\_binding} module which provides a standardized
mechanism for interoperating with C. AKRode provides four Fortran 2003 modules:
\begin{itemize}
\item {} 
\sphinxcode{farkode\_arkstep\_mod}, \sphinxcode{farkode\_erkstep\_mod}, \sphinxcode{farkode\_mristep\_mod} provide
interfaces to the ARKStep, ERKStep, and MRIStep time-stepping modules respectively

\item {} 
\sphinxcode{farkode\_mod} which interfaces to the components of ARKode which are shared by the
time-stepping modules

\end{itemize}

All interfaced functions are named after the corresponding C function, but with a
leading ‘F’. For example. the ARKStep function \sphinxcode{ARKStepCreate} is interfaced as
\sphinxcode{FARKStepCreate}. Thus, the steps to use an ARKode time-stepping module from Fortran
are identical (ignoring language differences) to using it from C/C++.

The Fortran 2003 ARKode interface modules can be accessed by the \sphinxcode{use} statement,
i.e. \sphinxcode{use farkode\_mod}, and linking to the library \sphinxcode{libsundials\_farkode\_mod.lib}
in addition to \sphinxcode{libsundials\_farkode.lib}. Further information on the location of
installed modules is provided in the Chapter {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}.

The Fortran 2003 interface modules were generated with SWIG Fortran, a
fork of SWIG \phantomsection\label{\detokenize{ARKode_f_interface/F2003Module:id1}}{\hyperref[\detokenize{References:jpe2019}]{\sphinxcrossref{{[}JPE2019{]}}}}. Users who are interested in the SWIG code used
in the generation process should contact the SUNDIALS development team.


\subsection{SUNDIALS Fortran 2003 Interface Modules}
\label{\detokenize{ARKode_f_interface/F2003Module:sundials-fortran-2003-interface-modules}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-sundialsmodules}}
All of the generic SUNDIALS modules provide Fortran 2003 interface modules.
Many of the generic module implementations provide Fortran 2003 interfaces
(a complete list of modules with Fortran 2003 interfaces is given in
{\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-interfacestable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNDIALS Fortran 2003 Interface Modules}}}}. A module can be accessed with the \sphinxcode{use}
statement, e.g. \sphinxcode{use fnvector\_openmp\_mod}, and linking to the Fortran
2003 library in addition to the C library, e.g.
\sphinxcode{libsundials\_fnvecpenmp\_mod.lib} and \sphinxcode{libsundials\_nvecopenmp.lib}.

The Fortran 2003 interfaces leverage the \sphinxcode{iso\_c\_binding} module and the
\sphinxcode{bind(C)} attribute to closely follow the SUNDIALS C API (ignoring
language differences). The generic SUNDIALS structures, e.g. \sphinxcode{N\_Vector},
are interfaced as Fortran derived types, and function signatures are matched
but with an \sphinxcode{F} prepending the name, e.g. \sphinxcode{FN\_VConst} instead of
\sphinxcode{N\_VConst}. Constants are named exactly as they are in the C API.
Accordingly, using SUNDIALS via the Fortran 2003 interfaces looks just like
using it in C. Some caveats stemming from the language differences are
discussed in the section {\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences}]{\sphinxcrossref{\DUrole{std,std-ref}{Notable Fortran/C usage differences}}}}. A discussion on the
topic of equivalent data types in C and Fortran 2003 is presented in
section {\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}}.

Further information on the Fortran 2003 interfaces specific to modules is given
in the NVECTOR, SUNMatrix, SUNLinearSolver, and SUNNonlinearSolver sections
alongside the C documentation (chapters {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}}, {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}},
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}, and {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}} respectively). For details on where
the Fortran 2003 module (\sphinxcode{.mod}) files and libraries are installed see Appendix
{\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}.


\subsubsection{Table: SUNDIALS Fortran 2003 Interface Modules}
\label{\detokenize{ARKode_f_interface/F2003Module:table-sundials-fortran-2003-interface-modules}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-interfacestable}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Module}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Fortran 2003 Module Name}
\unskip}\relax \\
\hline
\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Module}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Fortran 2003 Module Name}
\unskip}\relax \\
\hline
\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

NVECTOR
&
\sphinxcode{fsundials\_nvector\_mod}
\\
\hline
NVECTOR\_SERIAL
&
\sphinxcode{fnvector\_serial\_mod}
\\
\hline
NVECTOR\_OPENMP
&
\sphinxcode{fnvector\_openmp\_mod}
\\
\hline
NVECTOR\_PTHREADS
&
\sphinxcode{fnvector\_pthreads\_mod}
\\
\hline
NVECTOR\_PARALLEL
&
\sphinxcode{fnvector\_parallel\_mod}
\\
\hline
NVECTOR\_PARHYP
&
Not interfaced
\\
\hline
NVECTOR\_PETSC
&
Not interfaced
\\
\hline
NVECTOR\_CUDA
&
Not interfaced
\\
\hline
NVECTOR\_RAJA
&
Not interfaced
\\
\hline
NVECTOR\_MANVECTOR
&
\sphinxcode{fnvector\_manyvector\_mod}
\\
\hline
NVECTOR\_MPIMANVECTOR
&
\sphinxcode{fnvector\_mpimanyvector\_mod}
\\
\hline
NVECTOR\_MPIPLUSX
&
\sphinxcode{fnvector\_mpiplusx\_mod}
\\
\hline
SUNMATRIX
&
\sphinxcode{fsundials\_matrix\_mod}
\\
\hline
SUNMATRIX\_BAND
&
\sphinxcode{fsunmatrix\_band\_mod}
\\
\hline
SUNMATRIX\_DENSE
&
\sphinxcode{fsunmatrix\_dense\_mod}
\\
\hline
SUNMATRIX\_SPARSE
&
\sphinxcode{fsunmatrix\_sparse\_mod}
\\
\hline
SUNLINSOL
&
\sphinxcode{fsundials\_linearsolver\_mod}
\\
\hline
SUNLINSOL\_BAND
&
\sphinxcode{fsunlinsol\_band\_mod}
\\
\hline
SUNLINSOL\_DENSE
&
\sphinxcode{fsunlinsol\_dense\_mod}
\\
\hline
SUNLINSOL\_LAPACKBAND
&
Not interfaced
\\
\hline
SUNLINSOL\_LAPACKDENSE
&
Not interfaced
\\
\hline
SUNLINSOL\_KLU
&
\sphinxcode{fsunlinsol\_klu\_mod}
\\
\hline
SUNLINSOL\_SLUMT
&
Not interfaced
\\
\hline
SUNLINSOL\_SLUDIST
&
Not interfaced
\\
\hline
SUNLINSOL\_SPGMR
&
\sphinxcode{fsunlinsol\_spgmr\_mod}
\\
\hline
SUNLINSOL\_SPFGMR
&
\sphinxcode{fsunlinsol\_spfgmr\_mod}
\\
\hline
SUNLINSOL\_SPBCGS
&
\sphinxcode{fsunlinsol\_spbcgs\_mod}
\\
\hline
SUNLINSOL\_SPTFQMR
&
\sphinxcode{fsunlinsol\_sptfqmr\_mod}
\\
\hline
SUNLINSOL\_PCG
&
\sphinxcode{fsunlinsol\_pcg\_mof}
\\
\hline
SUNNONLINSOL
&
\sphinxcode{fsundials\_nonlinearsolver\_mod}
\\
\hline
SUNNONLINSOL\_NEWTON
&
\sphinxcode{fsunnonlinsol\_newton\_mod}
\\
\hline
SUNNONLINSOL\_FIXEDPOINT
&
\sphinxcode{fsunnonlinsol\_fixedpoint\_mod}
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{Data Types}
\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-datatypes}}\label{\detokenize{ARKode_f_interface/F2003Module:data-types}}
Generally, the Fortran 2003 type that is equivalent to the C type is what one
would expect. Primitive types map to the \sphinxcode{iso\_c\_binding} type equivalent.
SUNDIALS generic types map to a Fortran derived type. However, the handling
of pointer types is not always clear as they can depend on the parameter direction.
ref:\sphinxtitleref{Fortran2003.DataTypesTable} presents a summary of the type equivalencies
with the parameter direction in mind.

\sphinxstyleemphasis{NOTE}: Currently, the Fortran 2003 interfaces are only compatible with SUNDIALS builds
where the \sphinxcode{realtype} is double-precision the \sphinxcode{sunindextype} size is 64-bits.


\subsubsection{Table: C/Fortran-2003 Equivalent Types}
\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-datatypestable}}\label{\detokenize{ARKode_f_interface/F2003Module:table-c-fortran-2003-equivalent-types}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|l|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{C Type}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Parameter Direction}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Fortran 2003 type}
\unskip}\relax \\
\hline
\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{C Type}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Parameter Direction}
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstylestrong{Fortran 2003 type}
\unskip}\relax \\
\hline
\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

\sphinxcode{double}
&
in, inout, out, return
&
\sphinxcode{real(c\_double)}
\\
\hline
\sphinxcode{int}
&
in, inout, out, return
&
\sphinxcode{integer(c\_int)}
\\
\hline
\sphinxcode{long}
&
in, inout, out, return
&
\sphinxcode{integer(c\_long)}
\\
\hline
\sphinxcode{booleantype}
&
in, inout, out, return
&
\sphinxcode{integer(c\_int)}
\\
\hline
\sphinxcode{realtype}
&
in, inout, out, return
&
\sphinxcode{real(c\_double)}
\\
\hline
\sphinxcode{sunindextype}
&
in, inout, out, return
&
\sphinxcode{integer(c\_long)}
\\
\hline
\sphinxcode{double*}
&
in, inout, out
&
\sphinxcode{real(c\_double), dimension(*)}
\\
\hline
\sphinxcode{double*}
&
return
&
\sphinxcode{real(c\_double), pointer, dimension(:)}
\\
\hline
\sphinxcode{int*}
&
in, inout, out
&
\sphinxcode{real(c\_int), dimension(*)}
\\
\hline
\sphinxcode{int*}
&
return
&
\sphinxcode{real(c\_int), pointer, dimension(:)}
\\
\hline
\sphinxcode{long*}
&
in, inout, out
&
\sphinxcode{real(c\_long), dimension(*)}
\\
\hline
\sphinxcode{long*}
&
return
&
\sphinxcode{real(c\_long), pointer, dimension(:)}
\\
\hline
\sphinxcode{realtype*}
&
in, inout, out
&
\sphinxcode{real(c\_double), dimension(*)}
\\
\hline
\sphinxcode{realtype*}
&
return
&
\sphinxcode{real(c\_double), pointer, dimension(:)}
\\
\hline
\sphinxcode{sunindextype*}
&
in, inout, out
&
\sphinxcode{real(c\_long), dimension(*)}
\\
\hline
\sphinxcode{sunindextype*}
&
return
&
\sphinxcode{real(c\_long), pointer, dimension(:)}
\\
\hline
\sphinxcode{realtype{[}{]}}
&
in, inout, out
&
\sphinxcode{real(c\_double), dimension(*)}
\\
\hline
\sphinxcode{sunindextype{[}{]}}
&
in, inout, out
&
\sphinxcode{integer(c\_long), dimension(*)}
\\
\hline
\sphinxcode{N\_Vector}
&
in, inout, out
&
\sphinxcode{type(N\_Vector)}
\\
\hline
\sphinxcode{N\_Vector}
&
return
&
\sphinxcode{type(N\_Vector), pointer}
\\
\hline
\sphinxcode{SUNMatrix}
&
in, inout, out
&
\sphinxcode{type(SUNMatrix)}
\\
\hline
\sphinxcode{SUNMatrix}
&
return
&
\sphinxcode{type(SUNMatrix), pointer}
\\
\hline
\sphinxcode{SUNLinearSolver}
&
in, inout, out
&
\sphinxcode{type(SUNLinearSolver)}
\\
\hline
\sphinxcode{SUNLinearSolver}
&
return
&
\sphinxcode{type(SUNLinearSolver), pointer}
\\
\hline
\sphinxcode{SUNNonlinearSolver}
&
in, inout, out
&
\sphinxcode{type(SUNNonlinearSolver)}
\\
\hline
\sphinxcode{SUNNonlinearSolver}
&
return
&
\sphinxcode{type(SUNNonlinearSolver), pointer}
\\
\hline
\sphinxcode{FILE*}
&
in, inout, out, return
&
\sphinxcode{type(c\_ptr)}
\\
\hline
\sphinxcode{void*}
&
in, inout, out, return
&
\sphinxcode{type(c\_ptr)}
\\
\hline
\sphinxcode{T**}
&
in, inout, out, return
&
\sphinxcode{type(c\_ptr)}
\\
\hline
\sphinxcode{T***}
&
in, inout, out, return
&
\sphinxcode{type(c\_ptr)}
\\
\hline
\sphinxcode{T****}
&
in, inout, out, return
&
\sphinxcode{type(c\_ptr)}
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsection{Notable Fortran/C usage differences}
\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences}}\label{\detokenize{ARKode_f_interface/F2003Module:notable-fortran-c-usage-differences}}
While the Fortran 2003 interface to SUNDIALS closely follows the C API,
some differences are inevitable due to the differences between Fortran and C.
In this section, we note the most critical differences. Additionally, section
{\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}} discusses equivalencies of data types in the
two languages.


\subsubsection{Creating generic SUNDIALS objects}
\label{\detokenize{ARKode_f_interface/F2003Module:creating-generic-sundials-objects}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-creatingobjects}}
In the C API a generic SUNDIALS object, such as an \sphinxcode{N\_Vector}, is actually
a pointer to an underlying C struct. However, in the Fortran 2003 interface,
the derived type is bound to the C struct, not the pointer to the struct. E.g.,
\sphinxcode{type(N\_Vector)} is bound to the C struct \sphinxcode{\_generic\_N\_Vector} not the
\sphinxcode{N\_Vector} type. The consequence of this is that creating and declaring SUNDIALS
objects in Fortran is nuanced. This is illustrated in the code snippets below:

C code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{n}{x}\PYG{p}{;}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNew\PYGZus{}Serial}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Fortran code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{x}
\PYG{n}{x} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{FN\PYGZus{}VNew\PYGZus{}Serial}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\end{sphinxVerbatim}

Note that in the Fortran declaration, the vector is a \sphinxcode{type(N\_Vector), pointer},
and that the pointer assignment operator is then used.


\subsubsection{Arrays and pointers}
\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-arraysandpointers}}\label{\detokenize{ARKode_f_interface/F2003Module:arrays-and-pointers}}
Unlike in the C API, in the Fortran 2003 interface, arrays and pointers are
treated differently when they are return values versus arguments to a function.
Additionally, pointers which are meant to be out parameters, not arrays,
in the C API must still be declared as a rank-1 array in Fortran.
The reason for this is partially due to the Fortran 2003 standard for C bindings,
and partially due to the tool used to generate the interfaces. Regardless, the
code snippets below illustrate the differences.

C code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{n}{x}
\PYG{n}{realtype}\PYG{o}{*} \PYG{n}{xdata}\PYG{p}{;}
\PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{leniw}\PYG{p}{,} \PYG{n}{lenrw}\PYG{p}{;}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNew\PYGZus{}Serial}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* capturing a returned array/pointer */}
\PYG{n}{xdata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c+cm}{/* passing array/pointer to a function */}
\PYG{n}{N\PYGZus{}VSetArrayPointer}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}

\PYG{c+cm}{/* pointers that are out\PYGZhy{}parameters */}
\PYG{n}{N\PYGZus{}VSpace}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{leniw}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{lenrw}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Fortran code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{x}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}double}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{xdataptr}\PYG{p}{(}\PYG{p}{:}\PYG{p}{)}
\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}double}\PYG{p}{)}          \PYG{k+kd}{::} \PYG{n}{xdata}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
\PYG{k+kt}{integer}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}long}\PYG{p}{)}         \PYG{k+kd}{::} \PYG{n}{leniw}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lenrw}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{FN\PYGZus{}VNew\PYGZus{}Serial}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c}{! capturing a returned array/pointer}
\PYG{n}{xdataptr} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{FN\PYGZus{}VGetArrayPointer}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

\PYG{c}{! passing array/pointer to a function}
\PYG{k}{call }\PYG{n}{FN\PYGZus{}VSetArrayPointer}\PYG{p}{(}\PYG{n}{xdata}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}

\PYG{c}{! pointers that are out\PYGZhy{}parameters}
\PYG{k}{call }\PYG{n}{FN\PYGZus{}VSpace}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{leniw}\PYG{p}{,} \PYG{n}{lenrw}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Passing procedure pointers and user data}
\label{\detokenize{ARKode_f_interface/F2003Module:passing-procedure-pointers-and-user-data}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-procedurepointers}}
Since functions/subroutines passed to SUNDIALS will be called from within
C code, the Fortran procedure must have the attribute \sphinxcode{bind(C)}
Additionally, when providing them as arguments to a Fortran 2003 interface
routine, it is required to convert a procedure’s Fortran address to C with
the Fortran intrinsic \sphinxcode{c\_funloc}.

Typically when passing user data to a SUNDIALS function, a user may
simply cast some custom data structure as a \sphinxcode{void*}. When using the
Fortran 2003 interfaces, the same thing can be achieved. Note, the
custom data structure \sphinxstyleemphasis{does not} have to be \sphinxcode{bind(C)} since
it is never accessed on the C side.

C code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MyUserData}\PYG{o}{*} \PYG{n}{udata}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{cvode\PYGZus{}mem}\PYG{p}{;}

\PYG{n}{ierr} \PYG{o}{=} \PYG{n}{CVodeSetUserData}\PYG{p}{(}\PYG{n}{cvode\PYGZus{}mem}\PYG{p}{,} \PYG{n}{udata}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Fortran code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{MyUserData}\PYG{p}{)} \PYG{k+kd}{::} \PYG{n}{udata}
\PYG{k}{type}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}ptr}\PYG{p}{)}      \PYG{k+kd}{::} \PYG{n}{arkode\PYGZus{}mem}

\PYG{n}{ierr} \PYG{o}{=} \PYG{n}{FARKStepSetUserData}\PYG{p}{(}\PYG{n}{arkode\PYGZus{}mem}\PYG{p}{,} \PYG{n+nb}{c\PYGZus{}loc}\PYG{p}{(}\PYG{n}{udata}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

On the other hand, Fortran users may instead choose to store problem-specific data, e.g.
problem parameters, within modules, and thus do not need the SUNDIALS-provided \sphinxcode{user\_data}
pointers to pass such data back to user-supplied functions. These users should supply the
\sphinxcode{c\_null\_ptr} input for user\_data arguments to the relevant SUNDIALS functions.


\subsubsection{Passing NULL to optional parameters}
\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-optionalparameters}}\label{\detokenize{ARKode_f_interface/F2003Module:passing-null-to-optional-parameters}}
In the SUNDIALS C API some functions have optional parameters that a
caller can pass \sphinxcode{NULL} to. If the optional parameter is of a type that is
equivalent to a Fortran \sphinxcode{type(c\_ptr)} (see section {\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}}),
then a Fortran user can pass the intrinsic \sphinxcode{c\_null\_ptr}. However, if the
optional parameter is of a type that is not equivalent to \sphinxcode{type(c\_ptr)},
then a caller must provide a Fortran pointer that is dissociated. This
is demonstrated in the code example below.

C code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNLinearSolver} \PYG{n}{LS}\PYG{p}{;}
\PYG{n}{N\PYGZus{}Vector} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}

\PYG{o}{!} \PYG{n}{SUNLinSolSolve} \PYG{n}{expects} \PYG{n}{a} \PYG{n}{SUNMatrix} \PYG{n}{or} \PYG{n+nb}{NULL}
\PYG{o}{!} \PYG{n}{as} \PYG{n}{the} \PYG{n}{second} \PYG{n}{parameter}\PYG{p}{.}
\PYG{n}{ierr} \PYG{o}{=} \PYG{n}{SUNLinSolSolve}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Fortran code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{LS}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{A}
\PYG{k}{type}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}

\PYG{n}{A} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{null}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{! SUNLinSolSolve expects a type(SUNMatrix), pointer}
\PYG{c}{! as the second parameter. Therefore, we cannot}
\PYG{c}{! pass a c\PYGZus{}null\PYGZus{}ptr, rather we pass a disassociated A.}
\PYG{n}{ierr} \PYG{o}{=} \PYG{n}{FSUNLinSolSolve}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Working with \sphinxstyleliteralintitle{N\_Vector} arrays}
\label{\detokenize{ARKode_f_interface/F2003Module:working-with-n-vector-arrays}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-nvectorarrays}}
Arrays of \sphinxcode{N\_Vector} objects are interfaced to Fortran 2003 as opaque
\sphinxcode{type(c\_ptr)}.  As such, it is not possible to directly index an array of
\sphinxcode{N\_Vector} objects returned by the \sphinxcode{N\_Vector} “VectorArray” operations, or
packages with sensitivity capabilities.  Instead, SUNDIALS provides a utility
function \sphinxcode{FN\_VGetVecAtIndexVectorArray} that can be called for accessing a
vector in a vector array. The example below demonstrates this:

C code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{n}{x}\PYG{p}{;}
\PYG{n}{N\PYGZus{}Vector}\PYG{o}{*} \PYG{n}{vecs}\PYG{p}{;}

\PYG{n}{vecs} \PYG{o}{=} \PYG{n}{N\PYGZus{}VCloneVectorArray}\PYG{p}{(}\PYG{n}{count}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{count}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{n}{N\PYGZus{}VConst}\PYG{p}{(}\PYG{n}{vecs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Fortran code:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{,} \PYG{k}{pointer} \PYG{k+kd}{::} \PYG{n}{x}\PYG{p}{,} \PYG{n}{xi}
\PYG{k}{type}\PYG{p}{(}\PYG{k+kt}{c\PYGZus{}ptr}\PYG{p}{)}             \PYG{k+kd}{::} \PYG{n}{vecs}

\PYG{n}{vecs} \PYG{o}{=} \PYG{n}{FN\PYGZus{}VCloneVectorArray}\PYG{p}{(}\PYG{n+nb}{count}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\PYG{k}{do }\PYG{n+nb}{index}\PYG{p}{,} \PYG{n+nb}{count}
\PYG{n}{xi} \PYG{o}{=}\PYG{o}{\PYGZgt{}} \PYG{n}{FN\PYGZus{}VGetVecAtIndexVectorArray}\PYG{p}{(}\PYG{n}{vecs}\PYG{p}{,} \PYG{n+nb}{index}\PYG{p}{)}
\PYG{k}{call }\PYG{n}{FN\PYGZus{}VConst}\PYG{p}{(}\PYG{n}{xi}\PYG{p}{)}
\PYG{n}{enddo}
\end{sphinxVerbatim}

SUNDIALS also provides the functions \sphinxcode{FN\_VSetVecAtIndexVectorArray} and
\sphinxcode{FN\_VNewVectorArray} for working with \sphinxcode{N\_Vector} arrays. These functions are
particularly useful for users of the Fortran interface to the \sphinxcode{NVECTOR\_MANYVECTOR}
or \sphinxcode{NVECTOR\_MPIMANYVECTOR} when creating the subvector array.  Both of these
functions along with \sphinxcode{FN\_VGetVecAtIndexVectorArray} are further described in Chapter
{\hyperref[\detokenize{nvectors/NVector_Description:nvectors-utilities}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR Utility Functions}}}}.


\subsubsection{Providing file pointers}
\label{\detokenize{ARKode_f_interface/F2003Module:providing-file-pointers}}
Expert SUNDIALS users may notice that there are a few advanced functions in the SUNDIALS C
API which take a \sphinxcode{FILE*} argument. Since there is no portable way to convert between a
Fortran file descriptor and a C file pointer, SUNDIALS provides two utility functions
for creating a \sphinxcode{FILE*} and destroying it. These functions are defined in the module
\sphinxcode{fsundials\_futils\_mod}.
\index{FSUNDIALSFileOpen() (fortran function)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/F2003Module:f/_/FSUNDIALSFileOpen}}\pysiglinewithargsret{\sphinxbfcode{function  }\sphinxbfcode{FSUNDIALSFileOpen}}{\emph{filename}, \emph{mode}}{}
The function allocates a \sphinxcode{FILE*} by calling the C function
\sphinxcode{fopen} with the provided filename and I/O mode.

The function argument \sphinxcode{filename} is the full path to the file and has the type
\sphinxcode{character(kind=C\_CHAR, len=*)}.

The function argument \sphinxcode{mode} has the type \sphinxcode{character(kind=C\_CHAR, len=*)}.
The string begins with one of the following characters:
\begin{itemize}
\item {} 
“r”  - open text file for reading

\item {} 
“r+” - open text file for reading and writing

\item {} 
“w”  - truncate text file to zero length or create it for writing

\item {} 
“w+” - open text file for reading or writing, create it if it does not exist

\item {} 
“a”  - open for appending, see documentation of \sphinxcode{fopen} for your system/compiler

\item {} 
“a+ - open for reading and appending, see documentation for \sphinxcode{fopen} for your system/compiler

\end{itemize}

The function returns a \sphinxcode{type(C\_PTR)} which holds a C \sphinxcode{FILE*}.

\end{fulllineitems}

\index{FSUNDIALSFileClose() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/F2003Module:f/_/FSUNDIALSFileClose}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNDIALSFileClose}}{\emph{fp}}{}
The function deallocates a C \sphinxcode{FILE*} by calling the C function \sphinxcode{fclose}
with the provided pointer.

The function argument \sphinxcode{fp} has the type \sphinxcode{type(c\_ptr)} and should be
the C \sphinxcode{FILE*} obtained from \sphinxcode{fopen}.

\end{fulllineitems}



\subsection{Important notes on portability}
\label{\detokenize{ARKode_f_interface/F2003Module:important-notes-on-portability}}\label{\detokenize{ARKode_f_interface/F2003Module:fortran2003-portability}}
The SUNDIALS Fortran 2003 interface \sphinxstyleemphasis{should} be compatible with any compiler
supporting the Fortran 2003 ISO standard. However, it has only been tested
and confirmed to be working with GNU Fortran 4.9+ and Intel Fortran 18.0.1+.

Upon compilation of SUNDIALS, Fortran module (\sphinxcode{.mod}) files are generated
for each Fortran 2003 interface. These files are highly compiler specific, and
thus it is almost always necessary to compile a consuming application with the
same compiler used to generate the modules.


\section{FARKODE, an Interface Module for FORTRAN Applications}
\label{\detokenize{ARKode_f_interface/FARKODE:fortraninterface}}\label{\detokenize{ARKode_f_interface/FARKODE:farkode-an-interface-module-for-fortran-applications}}\label{\detokenize{ARKode_f_interface/FARKODE::doc}}
The FARKODE interface module is a package of C functions which
support the use of the ARKStep time-stepping module for the solution
of ODE systems
\begin{equation*}
\begin{split}M\, \dot{y} = f^E(t,y) + f^I(t,y),\end{split}
\end{equation*}
in a mixed Fortran/C setting.  While ARKode is written in C, it is
assumed here that the user’s calling program and user-supplied
problem-defining routines are written in Fortran.  We assume only
minimal Fortran capabilities; specifically that the Fortran compiler
support full Fortran77 functionality (although more modern standards
are similarly supported).  This package provides the necessary
interfaces to ARKODE for the majority of supplied serial and parallel
NVECTOR implementations.


\subsection{Important note on portability}
\label{\detokenize{ARKode_f_interface/FARKODE:finterface-portability}}\label{\detokenize{ARKode_f_interface/FARKODE:important-note-on-portability}}
In this package, the names of the interface functions, and the names
of the Fortran user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files.  By default, those mapping definitions depend in turn
on the C macro \sphinxcode{F77\_FUNC} defined in the header file
\sphinxcode{sundials\_config.h}.  The mapping defined by \sphinxcode{F77\_FUNC} in turn
transforms the C interface names to match the name-mangling approach
used by the supplied Fortran compiler.

By “name-mangling”, we mean that due to the case-independent nature of
the Fortran language, Fortran compilers convert all subroutine and
object names to use either all lower-case or all upper-case
characters, and append either zero, one or two underscores as a prefix
or suffix the the name.  For example, the Fortran subroutine
\sphinxcode{MyFunction()} will be changed to one of \sphinxcode{myfunction},
\sphinxcode{MYFUNCTION}, \sphinxcode{myfunction\_\_}, \sphinxcode{MYFUNCTION\_}, and so on,
depending on the Fortran compiler used.

SUNDIALS determines this name-mangling scheme at configuration time
(see {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).


\subsection{Fortran Data Types}
\label{\detokenize{ARKode_f_interface/FARKODE:fortran-data-types}}\label{\detokenize{ARKode_f_interface/FARKODE:finterface-datatypes}}
Throughout this documentation, we will refer to data types according
to their usage in C.  The equivalent types to these may vary,
depending on your computer architecture and on how SUNDIALS was
compiled (see {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}).  A Fortran user should first
determine the equivalent types for their architecture and compiler,
and then take care that all arguments passed through this Fortran/C
interface are declared of the appropriate type.

\sphinxstylestrong{Integers}: SUNDIALS uses \sphinxcode{int}, \sphinxcode{long int} and \sphinxcode{sunindextype}
types.  As discussed in {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}, at compilation SUNDIALS
allows the configuration of the ‘index’ type, that accepts values of
32-bit signed and 64-bit signed. This choice dictates the size of a
SUNDIALS \sphinxcode{sunindextype} variable.
\begin{itemize}
\item {} 
\sphinxcode{int} \textendash{} equivalent to an \sphinxcode{INTEGER} or \sphinxcode{INTEGER*4} in Fortran

\item {} 
\sphinxcode{long int} \textendash{} this will depend on the computer architecture:
\begin{itemize}
\item {} 
32-bit architecture \textendash{} equivalent to an \sphinxcode{INTEGER} or \sphinxcode{INTEGER*4} in Fortran

\item {} 
64-bit architecture \textendash{} equivalent to an \sphinxcode{INTEGER*8} in Fortran

\end{itemize}

\item {} 
\sphinxcode{sunindextype} \textendash{} this will depend on the SUNDIALS configuration:
\begin{itemize}
\item {} 
32-bit \textendash{} equivalent to an \sphinxcode{INTEGER} or \sphinxcode{INTEGER*4} in Fortran

\item {} 
64-bit \textendash{} equivalent to an \sphinxcode{INTEGER*8} in Fortran

\end{itemize}

\end{itemize}

\sphinxstylestrong{Real numbers}:  As discussed in {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}, at compilation
SUNDIALS allows the configuration option  \sphinxcode{-{-}with-precision},
that accepts values of \sphinxcode{single}, \sphinxcode{double} or \sphinxcode{extended} (the
default is \sphinxcode{double}).  This choice dictates the size of a
\sphinxcode{realtype} variable.  The corresponding Fortran types for these
\sphinxcode{realtype} sizes are:
\begin{itemize}
\item {} 
\sphinxcode{single} \textendash{} equivalent to a \sphinxcode{REAL} or \sphinxcode{REAL*4} in Fortran

\item {} 
\sphinxcode{double} \textendash{} equivalent to a \sphinxcode{DOUBLE PRECISION} or \sphinxcode{REAL*8} in Fortran

\item {} 
\sphinxcode{extended} \textendash{} equivalent to a \sphinxcode{REAL*16} in Fortran

\end{itemize}

We note that when SUNDIALS is compiled with Fortran interfaces
enabled, a file \sphinxcode{sundials/sundials\_fconfig.h} is placed in the
installation’s \sphinxcode{include} directory, containing information about
the Fortran types that correspond to the C types of the configured
SUNDIALS installation.  This file may be “included” by Fortran
routines, as long as the compiler supports the Fortran90 standard (or
higher), as shown in the ARKode example programs \sphinxcode{ark\_bruss.f90},
\sphinxcode{ark\_bruss1D\_FEM\_klu.f90} and \sphinxcode{fark\_heat2D.f90}.

Details on the Fortran interface to ARKode are provided in the
following sub-sections:


\subsubsection{FARKODE routines}
\label{\detokenize{ARKode_f_interface/Routines:finterface-routines}}\label{\detokenize{ARKode_f_interface/Routines::doc}}\label{\detokenize{ARKode_f_interface/Routines:farkode-routines}}
In this section, we list the full set of user-callable functions
comprising the FARKODE solver interface.  For each function, we list
the corresponding ARKStep functions, to provide a mapping between the
two solver interfaces.  Further documentation on each FARKODE function
is provided in the following sections, {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-usage}]{\sphinxcrossref{\DUrole{std,std-ref}{Usage of the FARKODE interface module}}}},
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{FARKODE optional output}}}}, {\hyperref[\detokenize{ARKode_f_interface/Rootfinding:finterface-rootfinding}]{\sphinxcrossref{\DUrole{std,std-ref}{Usage of the FARKROOT interface to rootfinding}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:finterface-preconditioning}]{\sphinxcrossref{\DUrole{std,std-ref}{Usage of the FARKODE interface to built-in preconditioners}}}}.  Additionally, all Fortran and C
functions below are hyperlinked to their definitions in the
documentation, for simplified access.


\paragraph{Interface to the NVECTOR modules}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-nvector-modules}}\begin{itemize}
\item {} 
\sphinxcode{FNVINITS()} (defined by NVECTOR\_SERIAL) interfaces to
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VNewEmpty_Serial}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Serial()}}}}.

\item {} 
\sphinxcode{FNVINITP()} (defined by NVECTOR\_PARALLEL) interfaces to
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VNewEmpty_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Parallel()}}}}.

\item {} 
\sphinxcode{FNVINITOMP()} (defined by NVECTOR\_OPENMP) interfaces to
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VNewEmpty_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_OpenMP()}}}}.

\item {} 
\sphinxcode{FNVINITPTS()} (defined by NVECTOR\_PTHREADS) interfaces to
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VNewEmpty_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Pthreads()}}}}.

\item {} 
\sphinxcode{FNVINITPH()} (defined by NVECTOR\_PARHYP) interfaces to
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VNewEmpty_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_ParHyp()}}}}.

\end{itemize}


\paragraph{Interface to the SUNMATRIX modules}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-sunmatrix-modules}}\begin{itemize}
\item {} 
\sphinxcode{FSUNBANDMATINIT()} (defined by SUNMATRIX\_BAND) interfaces
to {\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix}]{\sphinxcrossref{\sphinxcode{SUNBandMatrix()}}}}.

\item {} 
\sphinxcode{FSUNDENSEMATINIT()} (defined by SUNMATRIX\_DENSE) interfaces
to {\hyperref[\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix}]{\sphinxcrossref{\sphinxcode{SUNDenseMatrix()}}}}.

\item {} 
\sphinxcode{FSUNSPARSEMATINIT()} (defined by SUNMATRIX\_SPARSE) interfaces
to {\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix}]{\sphinxcrossref{\sphinxcode{SUNSparseMatrix()}}}}.

\end{itemize}


\paragraph{Interface to the SUNLINSOL modules}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-sunlinsol-modules}}\begin{itemize}
\item {} 
\sphinxcode{FSUNBANDLINSOLINIT()} (defined by SUNLINSOL\_BAND)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_Band:c.SUNLinSol_Band}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Band()}}}}.

\item {} 
\sphinxcode{FSUNDENSELINSOLINIT()} (defined by SUNLINSOL\_DENSE)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_Dense:c.SUNLinSol_Dense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Dense()}}}}.

\item {} 
\sphinxcode{FSUNKLUINIT()} (defined by SUNLINSOL\_KLU)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLU}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLU()}}}}.

\item {} 
\sphinxcode{FSUNKLUREINIT()} (defined by SUNLINSOL\_KLU)
interfaces to \sphinxcode{SUNLinSol\_KLUReinit()}.

\item {} 
\sphinxcode{FSUNLAPACKBANDINIT()} (defined by SUNLINSOL\_LAPACKBAND)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackBand:c.SUNLinSol_LapackBand}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackBand()}}}}.

\item {} 
\sphinxcode{FSUNLAPACKDENSEINIT()} (defined by SUNLINSOL\_LAPACKDENSE)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackDense:c.SUNLinSol_LapackDense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackDense()}}}}.

\item {} 
\sphinxcode{FSUNPCGINIT()} (defined by SUNLINSOL\_PCG)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCG()}}}}.

\item {} 
\sphinxcode{FSUNSPBCGSINIT()} (defined by SUNLINSOL\_SPBCGS)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGS()}}}}.

\item {} 
\sphinxcode{FSUNSPFGMRINIT()} (defined by SUNLINSOL\_SPFGMR)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMR()}}}}.

\item {} 
\sphinxcode{FSUNSPGMRINIT()} (defined by SUNLINSOL\_SPGMR)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMR()}}}}.

\item {} 
\sphinxcode{FSUNSPTFQMRINIT()} (defined by SUNLINSOL\_SPTFQMR)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMR()}}}}.

\item {} 
\sphinxcode{FSUNSUPERLUMTINIT()} (defined by SUNLINSOL\_SUPERLUMT)
interfaces to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMT}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMT()}}}}.

\end{itemize}


\paragraph{Interface to the SUNNONLINSOL modules}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-sunnonlinsol-modules}}\begin{itemize}
\item {} 
\sphinxcode{FSUNNEWTONINIT()} (defined by SUNNONLINSOL\_NEWTON)
interfaces to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSol_Newton}]{\sphinxcrossref{\sphinxcode{SUNNonlinSol\_Newton()}}}}.

\item {} 
\sphinxcode{FSUNNEWTONSETMAXITERS()} (defined by SUNNONLINSOL\_NEWTON)
interfaces to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetMaxIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetMaxIters()}}}} for a
SUNNONLINSOL\_NEWTON object.

\item {} 
\sphinxcode{FSUNFIXEDPOINTINIT()} (defined by SUNNONLINSOL\_FIXEDPOINT)
interfaces to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSol_Newton}]{\sphinxcrossref{\sphinxcode{SUNNonlinSol\_Newton()}}}}.

\item {} 
\sphinxcode{FSUNFIXEDPOINTSETMAXITERS()} (defined by SUNNONLINSOL\_FIXEDPOINT)
interfaces to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetMaxIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetMaxIters()}}}} for a
SUNNONLINSOL\_FIXEDPOINT object.

\end{itemize}


\paragraph{Interface to the main ARKODE module}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-main-arkode-module}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}, as well as one of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSStolerances()}}}} or {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSVtolerances()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}]{\sphinxcrossref{\sphinxcode{FARKREINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepReInit}]{\sphinxcrossref{\sphinxcode{ARKStepReInit()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKRESIZE}]{\sphinxcrossref{\sphinxcode{FARKRESIZE()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETIIN}]{\sphinxcrossref{\sphinxcode{FARKSETIIN()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETRIN}]{\sphinxcrossref{\sphinxcode{FARKSETRIN()}}}} interface to the
ARKStepSet* and ARKStepSet* functions (see {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}}).

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWTSET}]{\sphinxcrossref{\sphinxcode{FARKEWTSET()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepWFtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepWFtolerances()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPTSET}]{\sphinxcrossref{\sphinxcode{FARKADAPTSET()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTABSET}]{\sphinxcrossref{\sphinxcode{FARKEXPSTABSET()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStabilityFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetStabilityFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETERKTABLE}]{\sphinxcrossref{\sphinxcode{FARKSETERKTABLE()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETIRKTABLE}]{\sphinxcrossref{\sphinxcode{FARKSETIRKTABLE()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETARKTABLES}]{\sphinxcrossref{\sphinxcode{FARKSETARKTABLES()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETRESTOLERANCE}]{\sphinxcrossref{\sphinxcode{FARKSETRESTOLERANCE()}}}} interfaces to either
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResStolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResStolerance()}}}} and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResVtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResVtolerance()}}}}

\end{itemize}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}, the
ARKStepGet* functions (see {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}),
and to the optional output functions for the selected linear
solver module (see {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}).

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDKY}]{\sphinxcrossref{\sphinxcode{FARKDKY()}}}} interfaces to the interpolated output function
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetDky}]{\sphinxcrossref{\sphinxcode{ARKStepGetDky()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} interfaces to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetErrWeights()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETESTLOCALERR}]{\sphinxcrossref{\sphinxcode{FARKGETESTLOCALERR()}}}} interfaces to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetEstLocalErrors}]{\sphinxcrossref{\sphinxcode{ARKStepGetEstLocalErrors()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKFREE}]{\sphinxcrossref{\sphinxcode{FARKFREE()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepFree}]{\sphinxcrossref{\sphinxcode{ARKStepFree()}}}}.

\end{itemize}


\paragraph{Interface to the system nonlinear solver interface}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-system-nonlinear-solver-interface}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKNLSINIT}]{\sphinxcrossref{\sphinxcode{FARKNLSINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinearSolver()}}}}.

\end{itemize}


\paragraph{Interface to the system linear solver interfaces}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-system-linear-solver-interfaces}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETJAC}]{\sphinxcrossref{\sphinxcode{FARKDENSESETJAC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETJAC}]{\sphinxcrossref{\sphinxcode{FARKBANDSETJAC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETJAC}]{\sphinxcrossref{\sphinxcode{FARKSPARSESETJAC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETEPSLIN}]{\sphinxcrossref{\sphinxcode{FARKLSSETEPSLIN()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetEpsLin()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}]{\sphinxcrossref{\sphinxcode{FARKLSSETJAC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimes()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETPREC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetPreconditioner()}}}}.

\end{itemize}


\paragraph{Interface to the mass matrix linear solver interfaces}
\label{\detokenize{ARKode_f_interface/Routines:interface-to-the-mass-matrix-linear-solver-interfaces}}\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETMASS}]{\sphinxcrossref{\sphinxcode{FARKDENSESETMASS()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETMASS}]{\sphinxcrossref{\sphinxcode{FARKBANDSETMASS()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETMASS}]{\sphinxcrossref{\sphinxcode{FARKSPARSESETMASS()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSEPSLIN}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASSEPSLIN()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassEpsLin()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASS}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASS()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASSPREC()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassPreconditioner()}}}}.

\end{itemize}


\paragraph{User-supplied routines}
\label{\detokenize{ARKode_f_interface/Routines:user-supplied-routines}}\label{\detokenize{ARKode_f_interface/Routines:finterface-usersupplied}}
As with the native C interface, the FARKODE solver interface requires
user-supplied functions to specify the ODE problem to be solved.  In
contrast to the case of direct use of ARKStep, and of most Fortran ODE
solvers, the names of all user-supplied routines here are fixed, in
order to maximize portability for the resulting mixed-language program.
As a result, whether using a purely implicit, purely explicit, or
mixed implicit-explicit solver, routines for both \(f^E(t,y)\) and
\(f^I(t,y)\) must be provided by the user (though either of which
may do nothing):


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
FARKODE routine
(FORTRAN, user-supplied)
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep interface
function type
\unskip}\relax \\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKIFUN}]{\sphinxcrossref{\sphinxcode{FARKIFUN()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEFUN}]{\sphinxcrossref{\sphinxcode{FARKEFUN()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKRhsFn}]{\sphinxcrossref{\sphinxcode{ARKRhsFn()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In addition, as with the native C interface a user may provide
additional routines to assist in the solution process.  Each of the
following user-supplied routines is activated by calling the specified
“activation” routine, with the exception of {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPJAC}]{\sphinxcrossref{\sphinxcode{FARKSPJAC()}}}}
which is required whenever a sparse matrix solver is used:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
FARKODE routine
(FORTRAN, user-supplied)
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep interface
function type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
FARKODE “activation” routine
\unskip}\relax \\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDJAC}]{\sphinxcrossref{\sphinxcode{FARKDJAC()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETJAC}]{\sphinxcrossref{\sphinxcode{FARKDENSESETJAC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBJAC}]{\sphinxcrossref{\sphinxcode{FARKBJAC()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETJAC}]{\sphinxcrossref{\sphinxcode{FARKBANDSETJAC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPJAC}]{\sphinxcrossref{\sphinxcode{FARKSPJAC()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETJAC}]{\sphinxcrossref{\sphinxcode{FARKSPARSESETJAC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDMASS}]{\sphinxcrossref{\sphinxcode{FARKDMASS()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETMASS}]{\sphinxcrossref{\sphinxcode{FARKDENSESETMASS()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBMASS}]{\sphinxcrossref{\sphinxcode{FARKBMASS()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETMASS}]{\sphinxcrossref{\sphinxcode{FARKBANDSETMASS()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPMASS}]{\sphinxcrossref{\sphinxcode{FARKSPMASS()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETMASS}]{\sphinxcrossref{\sphinxcode{FARKSPARSESETMASS()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETPREC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSolveFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETPREC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}]{\sphinxcrossref{\sphinxcode{FARKLSSETJAC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}]{\sphinxcrossref{\sphinxcode{FARKLSSETJAC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSET}]{\sphinxcrossref{\sphinxcode{FARKMASSPSET()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSetupFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASSPREC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSolveFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASSPREC()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTSETUP}]{\sphinxcrossref{\sphinxcode{FARKMTSETUP()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASS}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASS()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTIMES}]{\sphinxcrossref{\sphinxcode{FARKMTIMES()}}}}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesVecFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASS}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASS()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}]{\sphinxcrossref{\sphinxcode{FARKEWT()}}}}
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKEwtFn}]{\sphinxcrossref{\sphinxcode{ARKEwtFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWTSET}]{\sphinxcrossref{\sphinxcode{FARKEWTSET()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPT}]{\sphinxcrossref{\sphinxcode{FARKADAPT()}}}}
&
{\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}]{\sphinxcrossref{\sphinxcode{ARKAdaptFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPTSET}]{\sphinxcrossref{\sphinxcode{FARKADAPTSET()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTAB}]{\sphinxcrossref{\sphinxcode{FARKEXPSTAB()}}}}
&
{\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}]{\sphinxcrossref{\sphinxcode{ARKExpStabFn()}}}}
&
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTABSET}]{\sphinxcrossref{\sphinxcode{FARKEXPSTABSET()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Usage of the FARKODE interface module}
\label{\detokenize{ARKode_f_interface/Usage:usage-of-the-farkode-interface-module}}\label{\detokenize{ARKode_f_interface/Usage::doc}}\label{\detokenize{ARKode_f_interface/Usage:finterface-usage}}
The usage of FARKODE requires calls to a variety of interface
functions, depending on the method options selected, and two or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding C interface ARKStep functions for complete
information on the arguments of any given user-callable interface
routine, or of a given user-supplied function called by an interface
function.  The usage of FARKODE for rootfinding and with
preconditioner modules is described in later subsections.


\paragraph{Right-hand side specification}
\label{\detokenize{ARKode_f_interface/Usage:right-hand-side-specification}}\label{\detokenize{ARKode_f_interface/Usage:finterface-rhs}}
The user must in all cases supply the following Fortran routines:
\index{FARKIFUN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKIFUN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKIFUN}}{\emph{T}, \emph{Y}, \emph{YDOT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Sets the \sphinxstyleemphasis{YDOT} array to \(f^I(t,y)\), the implicit portion of
the right-hand side of the ODE system, as function of the
independent variable \sphinxstyleemphasis{T} \(=t\) and the array of dependent state
variables \sphinxstyleemphasis{Y} \(=y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing state variables.

\item {} 
\sphinxstyleemphasis{YDOT} (\sphinxcode{realtype}, output) \textendash{} array containing state derivatives.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user
data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user
data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \textgreater{}0
recoverable error, \textless{}0 unrecoverable error).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKEFUN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKEFUN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKEFUN}}{\emph{T}, \emph{Y}, \emph{YDOT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Sets the \sphinxstyleemphasis{YDOT} array to \(f^E(t,y)\), the explicit portion of
the right-hand side of the ODE system, as function of the
independent variable \sphinxstyleemphasis{T} \(=t\) and the array of dependent state
variables \sphinxstyleemphasis{Y} \(=y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing state variables.

\item {} 
\sphinxstyleemphasis{YDOT} (\sphinxcode{realtype}, output) \textendash{} array containing state derivatives.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user
data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user
data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \textgreater{}0
recoverable error, \textless{}0 unrecoverable error).

\end{itemize}

\end{description}

\end{fulllineitems}


For purely explicit problems, although the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKIFUN}]{\sphinxcrossref{\sphinxcode{FARKIFUN()}}}} must exist, it will never be called, and may
remain empty.  Similarly, for purely implicit problems,
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEFUN}]{\sphinxcrossref{\sphinxcode{FARKEFUN()}}}} will never be called and must exist and may
remain empty.


\paragraph{NVECTOR module initialization}
\label{\detokenize{ARKode_f_interface/Usage:finterface-nvector}}\label{\detokenize{ARKode_f_interface/Usage:nvector-module-initialization}}
If using one of the NVECTOR modules supplied with SUNDIALS, the user
must make a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FNVINITS}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NEQ}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITP}\PYG{p}{(}\PYG{n}{COMM}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NLOCAL}\PYG{p}{,} \PYG{n}{NGLOBAL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITOMP}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NEQ}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITPTS}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NEQ}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITPH}\PYG{p}{(}\PYG{n}{COMM}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NLOCAL}\PYG{p}{,} \PYG{n}{NGLOBAL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}}.


\paragraph{SUNMATRIX module initialization}
\label{\detokenize{ARKode_f_interface/Usage:finterface-sunmatrix}}\label{\detokenize{ARKode_f_interface/Usage:sunmatrix-module-initialization}}
In the case of using either an implicit or ImEx method, the solution
of each Runge-Kutta stage may involve the solution of linear systems
related to the Jacobian \(J = \frac{\partial f^I}{\partial y}\) of
the implicit portion of the ODE system.  If using a Newton iteration
with direct SUNLINSOL linear solver module and one of the SUNMATRIX
modules supplied with SUNDIALS, the user must make a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNBANDMATINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{MU}\PYG{p}{,} \PYG{n}{ML}\PYG{p}{,} \PYG{n}{SMU}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNDENSEMATINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPARSEMATINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{NNZ}\PYG{p}{,} \PYG{n}{SPARSETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

in which the specific arguments are as described in the appropriate
section of the Chapter {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}}.  Note that these matrix
options are usable only in a serial or multi-threaded environment.

As described in the section {\hyperref[\detokenize{Mathematics:mathematics-masssolve}]{\sphinxcrossref{\DUrole{std,std-ref}{Mass matrix solver (ARKStep only)}}}}, in the case
of using a problem with a non-identity mass matrix (no matter whether
the integrator is implicit, explicit or ImEx), linear systems of the
form \(Mx=b\) must be solved, where \(M\) is the system mass
matrix.  If these are to be solved with a direct SUNLINSOL linear
solver module and one of the SUNMATRIX modules supplied with SUNDIALS,
the user must make a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNBANDMASSMATINIT}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{MU}\PYG{p}{,} \PYG{n}{ML}\PYG{p}{,} \PYG{n}{SMU}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNDENSEMASSMATINIT}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPARSEMASSMATINIT}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{NNZ}\PYG{p}{,} \PYG{n}{SPARSETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

in which the specific arguments are as described in the appropriate
section of the Chapter {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}}, again noting that these are
only usable in a serial or multi-threaded environment.


\paragraph{SUNLINSOL module initialization}
\label{\detokenize{ARKode_f_interface/Usage:sunlinsol-module-initialization}}\label{\detokenize{ARKode_f_interface/Usage:finterface-sunlinsol}}
If using a Newton iteration with one of the SUNLINSOL linear
solver modules supplied with SUNDIALS, the user must make a call
of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNBANDLINSOLINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNDENSELINSOLINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNKLUINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNLAPACKBANDINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNLAPACKDENSEINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNPCGINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPBCGSINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPFGMRINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPGMRINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPTFQMRINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSUPERLUMTINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.  Note that the
dense, band and sparse solvers are usable only in a serial or
multi-threaded environment.

Once one of these has been initialized, its solver parameters may be
modified using a call to the functions

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNKLUSETORDERING}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSUPERLUMTSETORDERING}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNPCGSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNPCGSETMAXL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPBCGSSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPBCGSSETMAXL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPFGMRSETGSTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPFGMRSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPGMRSETGSTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPGMRSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPTFQMRSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPTFQMRSETMAXL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

where again the call sequences are described in the appropriate
sections of the Chapter {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

Similarly, in the case of using one of the SUNLINSOL linear solver
modules supplied with SUNDIALS to solve a problem with a non-identity
mass matrix, the user must make a call of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNMASSBANDLINSOLINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSDENSELINSOLINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSKLUINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSLAPACKBANDINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSLAPACKDENSEINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSPCGINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPBCGSINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPFGMRINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPGMRINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPTFQMRINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSUPERLUMTINIT}\PYG{p}{(}\PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.

Once one of these has been initialized, its solver parameters may be
modified using a call to the functions

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNMASSKLUSETORDERING}\PYG{p}{(}\PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSUPERLUMTSETORDERING}\PYG{p}{(}\PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSPCGSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSPCGSETMAXL}\PYG{p}{(}\PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPBCGSSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPBCGSSETMAXL}\PYG{p}{(}\PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPFGMRSETGSTYPE}\PYG{p}{(}\PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPFGMRSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPGMRSETGSTYPE}\PYG{p}{(}\PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPGMRSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPTFQMRSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPTFQMRSETMAXL}\PYG{p}{(}\PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

where again the call sequences are described in the appropriate
sections of the Chapter {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.


\paragraph{SUNNONLINSOL module initialization}
\label{\detokenize{ARKode_f_interface/Usage:sunnonlinsol-module-initialization}}\label{\detokenize{ARKode_f_interface/Usage:finterface-sunnonlinsol}}
If using a non-default nonlinear solver method, the user must make a call
of the form

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNNEWTONINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNFIXEDPOINTINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}}.

Once one of these has been initialized, its solver parameters may be
modified using a call to the functions

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNNEWTONSETMAXITERS}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXITERS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNFIXEDPOINTSETMAXITERS}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXITERS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{sphinxVerbatim}

where again the call sequences are described in the appropriate
sections of the Chapter {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}}.


\paragraph{Problem specification}
\label{\detokenize{ARKode_f_interface/Usage:finterface-problem}}\label{\detokenize{ARKode_f_interface/Usage:problem-specification}}
To set various problem and solution parameters and allocate internal
memory, the user must call {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.
\index{FARKMALLOC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKMALLOC}}{\emph{T0}, \emph{Y0}, \emph{IMEX}, \emph{IATOL}, \emph{RTOL}, \emph{ATOL}, \emph{IOUT}, \emph{ROUT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Initializes the Fortran interface to the ARKStep solver, providing
interfaces to the C routines {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepCreate}]{\sphinxcrossref{\sphinxcode{ARKStepCreate()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}, as well as one of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSStolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSStolerances()}}}} or
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSVtolerances}]{\sphinxcrossref{\sphinxcode{ARKStepSVtolerances()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T0} (\sphinxcode{realtype}, input) \textendash{} initial value of \(t\).

\item {} 
\sphinxstyleemphasis{Y0} (\sphinxcode{realtype}, input) \textendash{} array of initial conditions.

\item {} 
\sphinxstyleemphasis{IMEX} (\sphinxcode{int}, input) \textendash{} flag denoting basic integration
method: 0 = implicit, 1 = explicit, 2 = ImEx.

\item {} 
\sphinxstyleemphasis{IATOL} (\sphinxcode{int}, input) \textendash{} type for absolute tolerance input
\sphinxstyleemphasis{ATOL}: 1 = scalar, 2 = array, 3 = user-supplied function; the
user must subsequently call {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWTSET}]{\sphinxcrossref{\sphinxcode{FARKEWTSET()}}}} and supply
a routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}]{\sphinxcrossref{\sphinxcode{FARKEWT()}}}} to compute the error weight vector.

\item {} 
\sphinxstyleemphasis{RTOL} (\sphinxcode{realtype}, input) \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{ATOL} (\sphinxcode{realtype}, input) \textendash{} scalar or array absolute tolerance.

\item {} 
\sphinxstyleemphasis{IOUT} (\sphinxcode{long int}, input/output) \textendash{} array of length 29 for integer optional outputs.

\item {} 
\sphinxstyleemphasis{ROUT} (\sphinxcode{realtype}, input/output) \textendash{} array of length 6 for real optional outputs.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array of user integer data, which will be passed
unmodified to all user-provided routines.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array with user real data, which will be passed
unmodified to all user-provided routines.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Modifications to the user data arrays \sphinxstyleemphasis{IPAR} and \sphinxstyleemphasis{RPAR}
inside a user-provided routine will be propagated to all
subsequent calls to such routines. The optional outputs
associated with the main ARKStep integrator are listed in
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-iouttable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional FARKODE integer outputs}}}} and {\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-routtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional FARKODE real outputs}}}}, in
the section {\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{FARKODE optional output}}}}.

\end{fulllineitems}


As an alternative to providing tolerances in the call to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}, the user may provide a routine to compute the
error weights used in the WRMS norm evaluations.  If supplied, it must
have the following form:
\index{FARKEWT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKEWT}}{\emph{Y}, \emph{EWT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
It must set the positive components of the error weight
vector \sphinxstyleemphasis{EWT} for the calculation of the WRMS norm of \sphinxstyleemphasis{Y}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing state variables.

\item {} 
\sphinxstyleemphasis{EWT} (\sphinxcode{realtype}, output) \textendash{} array containing the error weight vector.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing the integer user data that was passed
to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing the real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


If the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}]{\sphinxcrossref{\sphinxcode{FARKEWT()}}}} routine is provided, then, following the
call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}, the user must call the function
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWTSET}]{\sphinxcrossref{\sphinxcode{FARKEWTSET()}}}}.
\index{FARKEWTSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKEWTSET}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKEWTSET}}{\emph{FLAG}, \emph{IER}}{}
Informs FARKODE to use the user-supplied {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}]{\sphinxcrossref{\sphinxcode{FARKEWT()}}}} function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} flag, use “1” to denoting to use {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}]{\sphinxcrossref{\sphinxcode{FARKEWT()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Setting optional inputs}
\label{\detokenize{ARKode_f_interface/Usage:finterface-optionalinputs}}\label{\detokenize{ARKode_f_interface/Usage:setting-optional-inputs}}
Unlike ARKStep’s C interface, that provides separate functions for
setting each optional input, FARKODE uses only three functions, that
accept keywords to specify which optional input should be set to the
provided value.  These routines are {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETIIN}]{\sphinxcrossref{\sphinxcode{FARKSETIIN()}}}},
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETRIN}]{\sphinxcrossref{\sphinxcode{FARKSETRIN()}}}}, and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETVIN}]{\sphinxcrossref{\sphinxcode{FARKSETVIN()}}}} and are further
described below.
\index{FARKSETIIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETIIN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETIIN}}{\emph{KEY}, \emph{IVAL}, \emph{IER}}{}
Specification routine to pass optional integer inputs
to the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{KEY} (quoted string, input) \textendash{} which optional input
is set (see {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-iinoptiontable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Keys for setting FARKODE integer optional inputs}}}}).

\item {} 
\sphinxstyleemphasis{IVAL} (\sphinxcode{long int}, input) \textendash{} the integer input value to be used.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Table: Keys for setting FARKODE integer optional inputs}
\label{\detokenize{ARKode_f_interface/Usage:finterface-iinoptiontable}}\label{\detokenize{ARKode_f_interface/Usage:table-keys-for-setting-farkode-integer-optional-inputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Key
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep routine
\unskip}\relax \\
\hline
\sphinxcode{ORDER}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetOrder}]{\sphinxcrossref{\sphinxcode{ARKStepSetOrder()}}}}
\\
\hline
\sphinxcode{DENSE\_ORDER}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDenseOrder}]{\sphinxcrossref{\sphinxcode{ARKStepSetDenseOrder()}}}}
\\
\hline
\sphinxcode{LINEAR}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinear}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinear()}}}}
\\
\hline
\sphinxcode{NONLINEAR}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinear}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinear()}}}}
\\
\hline
\sphinxcode{EXPLICIT}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetExplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetExplicit()}}}}
\\
\hline
\sphinxcode{IMPLICIT}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImplicit}]{\sphinxcrossref{\sphinxcode{ARKStepSetImplicit()}}}}
\\
\hline
\sphinxcode{IMEX}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetImEx}]{\sphinxcrossref{\sphinxcode{ARKStepSetImEx()}}}}
\\
\hline
\sphinxcode{IRK\_TABLE\_NUM}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}
\\
\hline
\sphinxcode{ERK\_TABLE\_NUM}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}
\\
\hline
\sphinxcode{ARK\_TABLE\_NUM} \sphinxstyleemphasis{(a)}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}
\\
\hline
\sphinxcode{MAX\_NSTEPS}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNumSteps}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxNumSteps()}}}}
\\
\hline
\sphinxcode{HNIL\_WARNS}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxHnilWarns}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxHnilWarns()}}}}
\\
\hline
\sphinxcode{PREDICT\_METHOD}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPredictorMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetPredictorMethod()}}}}
\\
\hline
\sphinxcode{MAX\_ERRFAIL}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxErrTestFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxErrTestFails()}}}}
\\
\hline
\sphinxcode{MAX\_CONVFAIL}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxConvFails()}}}}
\\
\hline
\sphinxcode{MAX\_NITERS}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNonlinIters}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxNonlinIters()}}}}
\\
\hline
\sphinxcode{ADAPT\_SMALL\_NEF}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSmallNumEFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetSmallNumEFails()}}}}
\\
\hline
\sphinxcode{LSETUP\_MSBP}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLSetupFrequency}]{\sphinxcrossref{\sphinxcode{ARKStepSetLSetupFrequency()}}}}
\\
\hline
\sphinxcode{MAX\_CONSTR\_FAIL}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxNumConstrFails}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxNumConstrFails()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstyleemphasis{(a)} When setting \sphinxcode{ARK\_TABLE\_NUM}, pass in \sphinxstyleemphasis{IVAL} as an array of
length 2, specifying the IRK table number first, then the ERK table
number.  The integer specifiers for each table may be found in the
section {\hyperref[\detokenize{Constants:constants}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: ARKode Constants}}}}, or in the ARKode header files
\sphinxcode{arkode\_butcher\_dirk.h} and \sphinxcode{arkode\_butcher\_erk.h}.
\index{FARKSETRIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETRIN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETRIN}}{\emph{KEY}, \emph{RVAL}, \emph{IER}}{}
Specification routine to pass optional real inputs
to the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{KEY} (quoted string, input) \textendash{} which optional input
is set (see {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-rinoptiontable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Keys for setting FARKODE real optional inputs}}}}).

\item {} 
\sphinxstyleemphasis{RVAL} (\sphinxcode{realtype}, input) \textendash{} the real input value to be used.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Table: Keys for setting FARKODE real optional inputs}
\label{\detokenize{ARKode_f_interface/Usage:finterface-rinoptiontable}}\label{\detokenize{ARKode_f_interface/Usage:table-keys-for-setting-farkode-real-optional-inputs}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Key
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep routine
\unskip}\relax \\
\hline
\sphinxcode{INIT\_STEP}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetInitStep()}}}}
\\
\hline
\sphinxcode{MAX\_STEP}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxStep()}}}}
\\
\hline
\sphinxcode{MIN\_STEP}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMinStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetMinStep()}}}}
\\
\hline
\sphinxcode{STOP\_TIME}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetStopTime}]{\sphinxcrossref{\sphinxcode{ARKStepSetStopTime()}}}}
\\
\hline
\sphinxcode{NLCONV\_COEF}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinConvCoef}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinConvCoef()}}}}
\\
\hline
\sphinxcode{ADAPT\_CFL}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetCFLFraction}]{\sphinxcrossref{\sphinxcode{ARKStepSetCFLFraction()}}}}
\\
\hline
\sphinxcode{ADAPT\_SAFETY}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetSafetyFactor}]{\sphinxcrossref{\sphinxcode{ARKStepSetSafetyFactor()}}}}
\\
\hline
\sphinxcode{ADAPT\_BIAS}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetErrorBias}]{\sphinxcrossref{\sphinxcode{ARKStepSetErrorBias()}}}}
\\
\hline
\sphinxcode{ADAPT\_GROWTH}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxGrowth()}}}}
\\
\hline
\sphinxcode{ADAPT\_ETAMX1}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxFirstGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxFirstGrowth()}}}}
\\
\hline
\sphinxcode{ADAPT\_BOUNDS}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStepBounds}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStepBounds()}}}}
\\
\hline
\sphinxcode{ADAPT\_ETAMXF}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxEFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxEFailGrowth()}}}}
\\
\hline
\sphinxcode{ADAPT\_ETACF}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMaxCFailGrowth}]{\sphinxcrossref{\sphinxcode{ARKStepSetMaxCFailGrowth()}}}}
\\
\hline
\sphinxcode{NONLIN\_CRDOWN}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinCRDown}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinCRDown()}}}}
\\
\hline
\sphinxcode{NONLIN\_RDIV}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinRDiv}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinRDiv()}}}}
\\
\hline
\sphinxcode{LSETUP\_DGMAX}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetDeltaGammaMax}]{\sphinxcrossref{\sphinxcode{ARKStepSetDeltaGammaMax()}}}}
\\
\hline
\sphinxcode{FIXED\_STEP}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetFixedStep}]{\sphinxcrossref{\sphinxcode{ARKStepSetFixedStep()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{FARKSETVIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETVIN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETVIN}}{\emph{KEY}, \emph{VVAL}, \emph{IER}}{}
Specification routine to pass optional vector inputs
to the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{KEY} (quoted string, input) \textendash{} which optional input
is set (see {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-vinoptiontable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Keys for setting FARKODE vector optional inputs}}}}).

\item {} 
\sphinxstyleemphasis{VVAL} (\sphinxcode{realtype*}, input) \textendash{} the input vector of real values to be used.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Table: Keys for setting FARKODE vector optional inputs}
\label{\detokenize{ARKode_f_interface/Usage:table-keys-for-setting-farkode-vector-optional-inputs}}\label{\detokenize{ARKode_f_interface/Usage:finterface-vinoptiontable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Key
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep routine
\unskip}\relax \\
\hline
\sphinxcode{CONSTR\_VEC}
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetConstraints}]{\sphinxcrossref{\sphinxcode{ARKStepSetConstraints()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

If a user wishes to reset all of the options to their default values,
they may call the routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETDEFAULTS}]{\sphinxcrossref{\sphinxcode{FARKSETDEFAULTS()}}}}.
\index{FARKSETDEFAULTS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETDEFAULTS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETDEFAULTS}}{\emph{IER}}{}
Specification routine to reset all FARKODE optional
inputs to their default values.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\subparagraph{Optional advanced FARKODE inputs}
\label{\detokenize{ARKode_f_interface/Usage:optional-advanced-farkode-inputs}}
FARKODE supplies additional routines to specify optional advanced
inputs to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} solver.  These are summarized below,
and the user is referred to their C routine counterparts for more
complete information.
\index{FARKSETERKTABLE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETERKTABLE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETERKTABLE}}{\emph{S}, \emph{Q}, \emph{P}, \emph{C}, \emph{A}, \emph{B}, \emph{BEMBED}, \emph{IER}}{}
Interface to the routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{S} (\sphinxcode{int}, input) \textendash{} number of stages in the table.

\item {} 
\sphinxstyleemphasis{Q} (\sphinxcode{int}, input) \textendash{} global order of accuracy of the method.

\item {} 
\sphinxstyleemphasis{P} (\sphinxcode{int}, input) \textendash{} global order of accuracy of the embedding.

\item {} 
\sphinxstyleemphasis{C} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing the stage times.

\item {} 
\sphinxstyleemphasis{A} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S*S} containing the ERK coefficients
(stored in row-major, “C”, order).

\item {} 
\sphinxstyleemphasis{B} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing the solution coefficients.

\item {} 
\sphinxstyleemphasis{BEMBED} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing the embedding
coefficients.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKSETIRKTABLE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETIRKTABLE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETIRKTABLE}}{\emph{S}, \emph{Q}, \emph{P}, \emph{C}, \emph{A}, \emph{B}, \emph{BEMBED}, \emph{IER}}{}
Interface to the routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{S} (\sphinxcode{int}, input) \textendash{} number of stages in the table.

\item {} 
\sphinxstyleemphasis{Q} (\sphinxcode{int}, input) \textendash{} global order of accuracy of the method.

\item {} 
\sphinxstyleemphasis{P} (\sphinxcode{int}, input) \textendash{} global order of accuracy of the embedding.

\item {} 
\sphinxstyleemphasis{C} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing the stage times.

\item {} 
\sphinxstyleemphasis{A} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S*S} containing the IRK coefficients
(stored in row-major, “C”, order).

\item {} 
\sphinxstyleemphasis{B} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing the solution coefficients.

\item {} 
\sphinxstyleemphasis{BEMBED} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing the embedding
coefficients.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKSETARKTABLES() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETARKTABLES}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETARKTABLES}}{\emph{S}, \emph{Q}, \emph{P}, \emph{CI}, \emph{CE}, \emph{AI}, \emph{AE}, \emph{BI}, \emph{BE}, \emph{B2I}, \emph{B2E}, \emph{IER}}{}
Interface to the routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTables}]{\sphinxcrossref{\sphinxcode{ARKStepSetTables()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{S} (\sphinxcode{int}, input) \textendash{} number of stages in the table.

\item {} 
\sphinxstyleemphasis{Q} (\sphinxcode{int}, input) \textendash{} global order of accuracy of the method.

\item {} 
\sphinxstyleemphasis{P} (\sphinxcode{int}, input) \textendash{} global order of accuracy of the embedding.

\item {} 
\sphinxstyleemphasis{CI} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing
the implicit stage times.

\item {} 
\sphinxstyleemphasis{CE} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing
the explicit stage times.

\item {} 
\sphinxstyleemphasis{AI} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S*S} containing the IRK coefficients
(stored in row-major, “C”, order).

\item {} 
\sphinxstyleemphasis{AE} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S*S} containing the ERK coefficients
(stored in row-major, “C”, order).

\item {} 
\sphinxstyleemphasis{BI} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing
the implicit solution coefficients.

\item {} 
\sphinxstyleemphasis{BE} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing
the explicit solution coefficients.

\item {} 
\sphinxstyleemphasis{B2I} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing
the implicit embedding coefficients.

\item {} 
\sphinxstyleemphasis{B2E} (\sphinxcode{realtype}, input) \textendash{} array of length \sphinxstyleemphasis{S} containing
the explicit embedding coefficients.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKSETRESTOLERANCE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETRESTOLERANCE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETRESTOLERANCE}}{\emph{IATOL}, \emph{ATOL}, \emph{IER}}{}
Interface to the routines {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResStolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResStolerance()}}}} and {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResVtolerance}]{\sphinxcrossref{\sphinxcode{ARKStepResVtolerance()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IATOL} (\sphinxcode{int}, input) \textendash{} type for absolute residual tolerance input
\sphinxstyleemphasis{ATOL}: 1 = scalar, 2 = array.

\item {} 
\sphinxstyleemphasis{ATOL} (\sphinxcode{realtype}, input) \textendash{} scalar or array absolute residual tolerance.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, a user may set the accuracy-based step size adaptivity
strategy (and it’s associated parameters) through a call to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD}]{\sphinxcrossref{\sphinxcode{FARKSETADAPTIVITYMETHOD()}}}}, as described below.
\index{FARKSETADAPTIVITYMETHOD() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSETADAPTIVITYMETHOD}}{\emph{IMETHOD}, \emph{IDEFAULT}, \emph{IPQ}, \emph{PARAMS}, \emph{IER}}{}
Specification routine to set the step size adaptivity strategy and
parameters within the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} solver.  Interfaces with
the C routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetAdaptivityMethod}]{\sphinxcrossref{\sphinxcode{ARKStepSetAdaptivityMethod()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IMETHOD} (\sphinxcode{int}, input) \textendash{} choice of adaptivity method.

\item {} 
\sphinxstyleemphasis{IDEFAULT} (\sphinxcode{int}, input) \textendash{} flag denoting whether to use
default parameters (1) or that customized parameters will be
supplied (1).

\item {} 
\sphinxstyleemphasis{IPQ} (\sphinxcode{int}, input) \textendash{} flag denoting whether to use
the embedding order of accuracy (0) or the method order of
accuracy (1) within step adaptivity algorithm.

\item {} 
\sphinxstyleemphasis{PARAMS} (\sphinxcode{realtype}, input) \textendash{} array of 3 parameters to be
used within the adaptivity strategy.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Lastly, the user may provide functions to aid/replace those within
ARKStep for handling adaptive error control and explicit stability.
The former of these is designed for advanced users who wish to
investigate custom step adaptivity approaches as opposed to using any
of those built-in to ARKStep.  In ARKStep’s C/C++ interface, this would be
provided by a function of type {\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKAdaptFn}]{\sphinxcrossref{\sphinxcode{ARKAdaptFn()}}}}; in the Fortran
interface this is provided through the user-supplied function:
\index{FARKADAPT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKADAPT}}{\emph{Y}, \emph{T}, \emph{H1}, \emph{H2}, \emph{H3}, \emph{E1}, \emph{E2}, \emph{E3}, \emph{Q}, \emph{P}, \emph{HNEW}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
It must set the new step size \sphinxstyleemphasis{HNEW} based on the three previous
steps (\sphinxstyleemphasis{H1}, \sphinxstyleemphasis{H2}, \sphinxstyleemphasis{H3}) and the three previous error estimates
(\sphinxstyleemphasis{E1}, \sphinxstyleemphasis{E2}, \sphinxstyleemphasis{E3}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing state variables.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{H1} (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{H2} (\sphinxcode{realtype}, input) \textendash{} previous step size.

\item {} 
\sphinxstyleemphasis{H3} (\sphinxcode{realtype}, input) \textendash{} previous-previous step size.

\item {} 
\sphinxstyleemphasis{E1} (\sphinxcode{realtype}, input) \textendash{} estimated temporal error in current step.

\item {} 
\sphinxstyleemphasis{E2} (\sphinxcode{realtype}, input) \textendash{} estimated temporal error in previous step.

\item {} 
\sphinxstyleemphasis{E3} (\sphinxcode{realtype}, input) \textendash{} estimated temporal error in previous-previous step.

\item {} 
\sphinxstyleemphasis{Q} (\sphinxcode{int}, input) \textendash{} global order of accuracy for RK method.

\item {} 
\sphinxstyleemphasis{P} (\sphinxcode{int}, input) \textendash{} global order of accuracy for RK embedded method.

\item {} 
\sphinxstyleemphasis{HNEW} (\sphinxcode{realtype}, output) \textendash{} array containing the error weight vector.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing the integer
user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing the real user
data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


This routine is enabled by a call to the activation routine:
\index{FARKADAPTSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPTSET}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKADAPTSET}}{\emph{FLAG}, \emph{IER}}{}
Informs FARKODE to use the user-supplied {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPT}]{\sphinxcrossref{\sphinxcode{FARKADAPT()}}}} function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} flag, use “1” to denoting to use
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPT}]{\sphinxcrossref{\sphinxcode{FARKADAPT()}}}}, or use “0” to denote a return to the
default adaptivity strategy.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne
0\) failure).

\end{itemize}

\end{description}

Note: The call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKADAPTSET}]{\sphinxcrossref{\sphinxcode{FARKADAPTSET()}}}} must occur \sphinxstyleemphasis{after} the call
to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\end{fulllineitems}


Similarly, if either an explicit or mixed implicit-explicit
integration method is to be employed, the user may specify a function
to provide the maximum explicitly-stable step for their problem.
Again, in the C/C++ interface this would be a function of type
{\hyperref[\detokenize{ERKStep_c_interface/User_supplied:c.ARKExpStabFn}]{\sphinxcrossref{\sphinxcode{ARKExpStabFn()}}}}, while in ARKStep’s Fortran interface this
must be given through the user-supplied function:
\index{FARKEXPSTAB() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTAB}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKEXPSTAB}}{\emph{Y}, \emph{T}, \emph{HSTAB}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
It must set the maximum explicitly-stable step size, \sphinxstyleemphasis{HSTAB}, based
on the current solution, \sphinxstyleemphasis{Y}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing state variables.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{HSTAB} (\sphinxcode{realtype}, output) \textendash{} maximum explicitly-stable step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing the integer user data that was passed
to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing the real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


This routine is enabled by a call to the activation routine:
\index{FARKEXPSTABSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTABSET}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKEXPSTABSET}}{\emph{FLAG}, \emph{IER}}{}
Informs FARKODE to use the user-supplied {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTAB}]{\sphinxcrossref{\sphinxcode{FARKEXPSTAB()}}}} function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} flag, use “1” to denoting to use
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTAB}]{\sphinxcrossref{\sphinxcode{FARKEXPSTAB()}}}}, or use “0” to denote a return to the
default error-based stability strategy.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne
0\) failure).

\end{itemize}

\end{description}

Note: The call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEXPSTABSET}]{\sphinxcrossref{\sphinxcode{FARKEXPSTABSET()}}}} must occur \sphinxstyleemphasis{after} the call
to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\end{fulllineitems}



\paragraph{Nonlinear solver module specification}
\label{\detokenize{ARKode_f_interface/Usage:finterface-nonlinearsolver}}\label{\detokenize{ARKode_f_interface/Usage:nonlinear-solver-module-specification}}
To use a non-default nonlinear solver algorithm, then after it has
been initialized in step {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNONLINSOL module initialization}}}} above, the
user of FARKODE must attach it to ARKSTEP by calling the
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKNLSINIT}]{\sphinxcrossref{\sphinxcode{FARKNLSINIT()}}}} routine:
\index{FARKNLSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKNLSINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKNLSINIT}}{\emph{IER}}{}
Interfaces with the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetNonlinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetNonlinearSolver()}}}} function to
specify use of a non-default nonlinear solver module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{System linear solver interface specification}
\label{\detokenize{ARKode_f_interface/Usage:finterface-linearsolver}}\label{\detokenize{ARKode_f_interface/Usage:system-linear-solver-interface-specification}}
To attach the linear solver (and optionally the matrix) object(s)
initialized in steps {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX module initialization}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL module initialization}}}} above, the user of FARKODE must
initialize the linear solver interface.  To attach any SUNLINSOL
object (and optional SUNMATRIX object) to ARKStep, following calls to
initialize the SUNLINSOL (and SUNMATRIX) object(s) in steps
{\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX module initialization}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL module initialization}}}} above, the
user must call the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}} routine:
\index{FARKLSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSINIT}}{\emph{IER}}{}
Interfaces with the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}} function to
attach a linear solver object (and optionally a matrix object) to ARKStep.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}



\subparagraph{Matrix-based linear solvers}
\label{\detokenize{ARKode_f_interface/Usage:matrix-based-linear-solvers}}\label{\detokenize{ARKode_f_interface/Usage:finterface-direct}}
As an option when using ARKSTEP with either the SUNLINSOL\_DENSE or
SUNLINSOL\_LAPACKDENSE linear solver modules, the user may supply a
routine that computes a dense approximation of the system Jacobian
\(J = \frac{\partial f^I}{\partial y}\).  If supplied, it must
have the following form:
\index{FARKDJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKDJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKDJAC}}{\emph{NEQ}, \emph{T}, \emph{Y}, \emph{FY}, \emph{DJAC}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied dense Jacobian approximation
function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}), to be used by the
SUNLINSOL\_DENSE or SUNLINSOL\_LAPACKDENSE solver modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NEQ} (\sphinxcode{long int}, input) \textendash{} size of the ODE system.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing values of the dependent state variables.

\item {} 
\sphinxstyleemphasis{FY} (\sphinxcode{realtype}, input) \textendash{} array containing values of the dependent state derivatives.

\item {} 
\sphinxstyleemphasis{DJAC} (\sphinxcode{realtype} of size (NEQ,NEQ), output) \textendash{} 2D array containing the Jacobian entries.

\item {} 
\sphinxstyleemphasis{H} (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WK1}, \sphinxstyleemphasis{WK2}, \sphinxstyleemphasis{WK3}  (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace
of same size as \sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Typically this routine will use only \sphinxstyleemphasis{NEQ}, \sphinxstyleemphasis{T}, \sphinxstyleemphasis{Y}, and
\sphinxstyleemphasis{DJAC}. It must compute the Jacobian and store it column-wise in \sphinxstyleemphasis{DJAC}.

\end{fulllineitems}


If the above routine uses difference quotient approximations, it may
need to access the error weight array \sphinxstyleemphasis{EWT} in the calculation of
suitable increments. The array \sphinxstyleemphasis{EWT} can be obtained by calling
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} using one of the work arrays as
temporary storage for \sphinxstyleemphasis{EWT}. It may also need the unit roundoff, which
can be obtained as the optional output \sphinxstyleemphasis{ROUT(6)}, passed from the
calling program to this routine using either \sphinxstyleemphasis{RPAR} or a common block.

If the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDJAC}]{\sphinxcrossref{\sphinxcode{FARKDJAC()}}}} routine is provided, then, following the
call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}, the user must call the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETJAC}]{\sphinxcrossref{\sphinxcode{FARKDENSESETJAC()}}}}:
\index{FARKDENSESETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKDENSESETJAC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}} function, specifying
to use the user-supplied routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDJAC}]{\sphinxcrossref{\sphinxcode{FARKDJAC()}}}} for the
Jacobian approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} any nonzero value specifies to use
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDJAC}]{\sphinxcrossref{\sphinxcode{FARKDJAC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


As an option when using ARKStep with either the SUNLINSOL\_BAND or
SUNLINSOL\_LAPACKBAND linear solver modules, the user may supply a
routine that computes a banded approximation of the linear system
Jacobian \(J = \frac{\partial f^I}{\partial y}\). If supplied, it
must have the following form:
\index{FARKBJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKBJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBJAC}}{\emph{NEQ}, \emph{MU}, \emph{ML}, \emph{MDIM}, \emph{T}, \emph{Y}, \emph{FY}, \emph{BJAC}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied band Jacobian approximation
function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}), to be used by the
SUNLINSOL\_BAND or SUNLINSOL\_LAPACKBAND solver modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NEQ} (\sphinxcode{long int}, input) \textendash{} size of the ODE system.

\item {} 
\sphinxstyleemphasis{MU}   (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth.

\item {} 
\sphinxstyleemphasis{ML}   (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth.

\item {} 
\sphinxstyleemphasis{MDIM} (\sphinxcode{long int}, input) \textendash{} leading dimension of \sphinxstyleemphasis{BJAC} array.

\item {} 
\sphinxstyleemphasis{T}    (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y}    (\sphinxcode{realtype}, input) \textendash{} array containing dependent state variables.

\item {} 
\sphinxstyleemphasis{FY}   (\sphinxcode{realtype}, input) \textendash{} array containing dependent state derivatives.

\item {} 
\sphinxstyleemphasis{BJAC} (\sphinxcode{realtype} of size \sphinxstyleemphasis{(MDIM,NEQ)}, output) \textendash{} 2D array
containing the Jacobian entries.

\item {} 
\sphinxstyleemphasis{H}    (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WK1}, \sphinxstyleemphasis{WK2}, \sphinxstyleemphasis{WK3}  (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace
of same size as \sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{NEQ}, \sphinxstyleemphasis{MU}, \sphinxstyleemphasis{ML}, \sphinxstyleemphasis{T}, \sphinxstyleemphasis{Y}, and
\sphinxstyleemphasis{BJAC}. It must load the \sphinxstyleemphasis{MDIM} by \sphinxstyleemphasis{N} array \sphinxstyleemphasis{BJAC} with the Jacobian
matrix at the current \((t,y)\) in band form.  Store in
\sphinxstyleemphasis{BJAC(k,j)} the Jacobian element \(J_{i,j}\) with
\sphinxstyleemphasis{k = i - j + MU + 1} (or \sphinxstyleemphasis{k = 1, …, ML+MU+1}) and \sphinxstyleemphasis{j = 1, …, N}.

\end{fulllineitems}


If the above routine uses difference quotient approximations, it may
need to use the error weight array \sphinxstyleemphasis{EWT} in the calculation of
suitable increments. The array \sphinxstyleemphasis{EWT} can be obtained by calling
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} using one of the work
arrays as temporary storage for \sphinxstyleemphasis{EWT}. It may also need the unit
roundoff, which can be obtained as the optional output \sphinxstyleemphasis{ROUT(6)},
passed from the calling program to this routine using either \sphinxstyleemphasis{RPAR}
or a common block.

If the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBJAC}]{\sphinxcrossref{\sphinxcode{FARKBJAC()}}}} routine is provided, then, following the
call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}, the user must call the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETJAC}]{\sphinxcrossref{\sphinxcode{FARKBANDSETJAC()}}}}.
\index{FARKBANDSETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBANDSETJAC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}} function, specifying
to use the user-supplied routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBJAC}]{\sphinxcrossref{\sphinxcode{FARKBJAC()}}}} for the
Jacobian approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} any nonzero value specifies to use
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBJAC}]{\sphinxcrossref{\sphinxcode{FARKBJAC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


When using ARKStep with either the SUNLINSOL\_KLU or
SUNLINSOL\_SUPERLUMT sparse direct linear solver modules, the user must
supply a routine that computes a sparse approximation of the system
Jacobian \(J = \frac{\partial f^I}{\partial y}\).  Both the KLU
and SuperLU\_MT solvers allow specification of \(J\) in either
compressed-sparse-column (CSC) format or compressed-sparse-row (CSR)
format.  The sparse Jacobian approximation function must have the
following form:
\index{FARKSPJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSPJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSPJAC}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{N}, \emph{NNZ}, \emph{JDATA}, \emph{JINDEXVALS}, \emph{JINDEXPTRS}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied sparse Jacobian approximation
function (of type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacFn()}}}}), to be used by the
SUNLINSOL\_KLU or SUNLINSOL\_SUPERLUMT solver modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} array containing values of the dependent state variables.

\item {} 
\sphinxstyleemphasis{FY} (\sphinxcode{realtype}, input) \textendash{} array containing values of the dependent state derivatives.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{sunindextype}, input) \textendash{} number of matrix rows and columns in Jacobian.

\item {} 
\sphinxstyleemphasis{NNZ} (\sphinxcode{sunindextype}, input) \textendash{} allocated length of nonzero storage in Jacobian.

\item {} 
\sphinxstyleemphasis{JDATA} (\sphinxcode{realtype} of size NNZ, output) \textendash{} nonzero values in Jacobian.

\item {} 
\sphinxstyleemphasis{JINDEXVALS} (\sphinxcode{sunindextype} of size NNZ, output) \textendash{} row \sphinxstyleemphasis{{[}CSR: column{]}} indices for each
nonzero Jacobian entry.

\item {} 
\sphinxstyleemphasis{JINDEXPTRS} (\sphinxcode{sunindextype} of size N+1, output) \textendash{} indices of where
each column’s \sphinxstyleemphasis{{[}CSR: row’s{]}} nonzeros begin in data array; last entry points
just past end of data values.

\item {} 
\sphinxstyleemphasis{H} (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WK1}, \sphinxstyleemphasis{WK2}, \sphinxstyleemphasis{WK3}  (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace
of same size as \sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} due to the internal storage format of the
SUNMATRIX\_SPARSE module, the matrix-specific integer parameters and
arrays are all of type \sphinxcode{sunindextype} \textendash{} the index precision
(32-bit vs 64-bit signed integers) specified during the SUNDIALS
build.  It is assumed that the user’s Fortran codes are constructed
to have matching type to how SUNDIALS was installed.

\end{fulllineitems}


If the above routine uses difference quotient approximations to
compute the nonzero entries, it may need to access the error weight
array \sphinxstyleemphasis{EWT} in the calculation of suitable increments. The array \sphinxstyleemphasis{EWT}
can be obtained by calling {\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} using one of
the work arrays as temporary storage for \sphinxstyleemphasis{EWT}.  It may also need the
unit roundoff, which can be obtained as the optional output \sphinxstyleemphasis{ROUT(6)},
passed from the calling program to this routine using either \sphinxstyleemphasis{RPAR} or
a common block.

When supplying the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPJAC}]{\sphinxcrossref{\sphinxcode{FARKSPJAC()}}}} routine, following the call
to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}, the user must call the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETJAC}]{\sphinxcrossref{\sphinxcode{FARKSPARSESETJAC()}}}}.
\index{FARKSPARSESETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSPARSESETJAC}}{\emph{IER}}{}
Interface to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacFn()}}}} function,
specifying that the user-supplied routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPJAC}]{\sphinxcrossref{\sphinxcode{FARKSPJAC()}}}} has
been provided for the Jacobian approximation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}



\subparagraph{Iterative linear solvers}
\label{\detokenize{ARKode_f_interface/Usage:finterface-iterative}}\label{\detokenize{ARKode_f_interface/Usage:iterative-linear-solvers}}
As described in the section {\hyperref[\detokenize{Mathematics:mathematics-error-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear iteration error control}}}}, a user
may adjust the linear solver tolerance scaling factor
\(\epsilon_L\).  Fortran users may adjust this value by calling
the function {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETEPSLIN}]{\sphinxcrossref{\sphinxcode{FARKLSSETEPSLIN()}}}}:
\index{FARKLSSETEPSLIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETEPSLIN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSSETEPSLIN}}{\emph{EPLIFAC}, \emph{IER}}{}
Interface to the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetEpsLin()}}}} to
specify the linear solver tolerance scale factor \(\epsilon_L\)
for the Newton system linear solver.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{EPLIFAC} (\sphinxcode{realtype}, input) \textendash{} value to use for
\(\epsilon_L\).  Passing a value of 0 indicates to use the
default value (0.05).

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


Optional user-supplied routines {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}} may be provided to compute the product
of the system Jacobian \(J = \frac{\partial f^I}{\partial y}\) and
a given vector \(v\).  If these are supplied, then following the
call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}, the user must call the
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}]{\sphinxcrossref{\sphinxcode{FARKLSSETJAC()}}}} routine with \sphinxstyleemphasis{FLAG} \(\ne 0\):
\index{FARKLSSETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSSETJAC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetJacTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetJacTimes()}}}} to
specify use of the user-supplied Jacobian-times-vector setup and
product functions, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}}, respectively.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} flag denoting use of user-supplied
Jacobian-times-vector routines.  A nonzero value specifies to
use these the user-supplied routines, a zero value specifies
not to use these.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


Similarly, optional user-supplied routines {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}} may be provided to perform preconditioning of the
iterative linear solver (note: the SUNLINSOL module must have been
configured with preconditioning enabled).  If these routines are
supplied, then following the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}} the
user must call the routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETPREC()}}}} with \sphinxstyleemphasis{FLAG}
\(\ne 0\):
\index{FARKLSSETPREC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETPREC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSSETPREC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetPreconditioner()}}}} to
specify use of the user-supplied preconditioner setup and solve
functions, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}}, respectively.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} flag denoting use of user-supplied
preconditioning routines.  A nonzero value specifies to
use these the user-supplied routines, a zero value specifies
not to use these.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


With treatment of the linear systems by any of the Krylov iterative
solvers, there are four optional user-supplied routines \textendash{}
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}}, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}}, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}}
and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}}. The specifications of these functions are
given below.

As an option when using iterative linear solvers, the user
may supply a routine that computes the product of the system Jacobian
\(J = \frac{\partial f^I}{\partial y}\) and a given vector
\(v\).  If supplied, it must have the following form:
\index{FARKJTIMES() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKJTIMES}}{\emph{V}, \emph{FJV}, \emph{T}, \emph{Y}, \emph{FY}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WORK}, \emph{IER}}{}
Interface to provide a user-supplied Jacobian-times-vector product
approximation function (corresponding to a C interface routine of
type {\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn()}}}}), to be used by one of the
Krylov iterative linear solvers.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{V}    (\sphinxcode{realtype}, input) \textendash{} array containing the vector to multiply.

\item {} 
\sphinxstyleemphasis{FJV}  (\sphinxcode{realtype}, output) \textendash{} array containing resulting product vector.

\item {} 
\sphinxstyleemphasis{T}    (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y}    (\sphinxcode{realtype}, input) \textendash{} array containing dependent state variables.

\item {} 
\sphinxstyleemphasis{FY}   (\sphinxcode{realtype}, input) \textendash{} array containing dependent state derivatives.

\item {} 
\sphinxstyleemphasis{H}    (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WORK} (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace of same size as
\sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{T}, \sphinxstyleemphasis{Y}, \sphinxstyleemphasis{V}, and
\sphinxstyleemphasis{FJV}.  It must compute the product vector \(Jv\), where
\(v\) is given in \sphinxstyleemphasis{V}, and the product is stored in \sphinxstyleemphasis{FJV}.

\end{fulllineitems}


If the user’s Jacobian-times-vector product routine requires that any
Jacobian related data be evaluated or preprocessed, then the following
routine can be used for the evaluation and preprocessing of this data:
\index{FARKJTSETUP() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKJTSETUP}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Interface to setup data for use in a user-supplied
Jacobian-times-vector product approximation function (corresponding
to a C interface routine of type
\sphinxcode{ARKLJacTimesSetupFn()}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T}    (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y}    (\sphinxcode{realtype}, input) \textendash{} array containing dependent state variables.

\item {} 
\sphinxstyleemphasis{FY}   (\sphinxcode{realtype}, input) \textendash{} array containing dependent state derivatives.

\item {} 
\sphinxstyleemphasis{H}    (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{T} and \sphinxstyleemphasis{Y}, and store
the results in either the arrays \sphinxstyleemphasis{IPAR} and \sphinxstyleemphasis{RPAR}, or in a Fortran
module or common block.

\end{fulllineitems}


If preconditioning is to be included, the following routine must be
supplied, for solution of the preconditioner linear system:
\index{FARKPSOL() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKPSOL}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{R}, \emph{Z}, \emph{GAMMA}, \emph{DELTA}, \emph{LR}, \emph{IPAR}, \emph{RPAR}, \emph{VT}, \emph{IER}}{}
User-supplied preconditioner solve routine (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSolveFn()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} current dependent state variable array.

\item {} 
\sphinxstyleemphasis{FY} (\sphinxcode{realtype}, input) \textendash{} current dependent state variable derivative array.

\item {} 
\sphinxstyleemphasis{R} (\sphinxcode{realtype}, input) \textendash{} right-hand side array.

\item {} 
\sphinxstyleemphasis{Z} (\sphinxcode{realtype}, output) \textendash{} solution array.

\item {} 
\sphinxstyleemphasis{GAMMA} (\sphinxcode{realtype}, input) \textendash{} Jacobian scaling factor.

\item {} 
\sphinxstyleemphasis{DELTA} (\sphinxcode{realtype}, input) \textendash{} desired residual tolerance.

\item {} 
\sphinxstyleemphasis{LR} (\sphinxcode{int}, input) \textendash{} flag denoting to solve the right or left preconditioner
system: 1 = left preconditioner, 2 = right preconditioner.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \textgreater{}0 if a recoverable
failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{T}, \sphinxstyleemphasis{Y}, \sphinxstyleemphasis{GAMMA}, \sphinxstyleemphasis{R},
\sphinxstyleemphasis{LR}, and \sphinxstyleemphasis{Z}.  It must solve the preconditioner linear system
\(Pz = r\).  The preconditioner (or the product of the left and
right preconditioners if both are nontrivial) should be an
approximation to the matrix  \(M - \gamma J\), where
\(M\) is the system mass matrix, \(\gamma\) is the input
GAMMA, and \(J = \frac{\partial f^I}{\partial y}\).

\end{fulllineitems}


If the user’s preconditioner requires that any Jacobian related data be evaluated
or preprocessed, then the following routine can be used for the evaluation and
preprocessing of the preconditioner:
\index{FARKPSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKPSET}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{JOK}, \emph{JCUR}, \emph{GAMMA}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied preconditioner setup routine (of type
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsPrecSetupFn()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} current dependent state variable array.

\item {} 
\sphinxstyleemphasis{FY} (\sphinxcode{realtype}, input) \textendash{} current dependent state variable derivative array.

\item {} 
\sphinxstyleemphasis{JOK} (\sphinxcode{int}, input) \textendash{} flag indicating whether Jacobian-related data needs to be
recomputed: 0 = recompute, 1 = reuse with the current value of \sphinxstyleemphasis{GAMMA}.

\item {} 
\sphinxstyleemphasis{JCUR} (\sphinxcode{realtype}, output) \textendash{} return flag to denote if
Jacobian data was recomputed (1=yes, 0=no).

\item {} 
\sphinxstyleemphasis{GAMMA} (\sphinxcode{realtype}, input) \textendash{} Jacobian scaling factor.

\item {} 
\sphinxstyleemphasis{H} (\sphinxcode{realtype}, input) \textendash{} current step size.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \textgreater{}0 if a recoverable
failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This routine must set up the preconditioner \(P\) to be used in
the subsequent call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}}.  The preconditioner (or
the product of the left and right preconditioners if using both)
should be an approximation to the matrix  \(M - \gamma J\),
where \(M\) is the system mass matrix, \(\gamma\) is the
input \sphinxstyleemphasis{GAMMA}, and \(J = \frac{\partial f^I}{\partial y}\).

\end{fulllineitems}


Notes:
\begin{enumerate}
\item {} 
If the user’s {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}}, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}} or
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}} routines use difference quotient
approximations, they may need to use the error weight array \sphinxstyleemphasis{EWT}
and/or the unit roundoff, in the calculation of suitable
increments.  Also, if {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}} uses an iterative
method in its solution, the residual vector \(\rho = r - Pz\)
of the system should be made less than \(\delta =\) \sphinxstyleemphasis{DELTA} in
the weighted l2 norm, i.e.
\begin{equation*}
\begin{split}\left(\sum_i \left(\rho_i\, EWT_i\right)^2 \right)^{1/2} < \delta.\end{split}
\end{equation*}
\item {} 
If needed in {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}},
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}}, or {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}}, the error weight
array \sphinxstyleemphasis{EWT} can be obtained by calling
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} using a user-allocated array as
temporary storage for \sphinxstyleemphasis{EWT}.

\item {} 
If needed in {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}},
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSOL}]{\sphinxcrossref{\sphinxcode{FARKPSOL()}}}}, or {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKPSET}]{\sphinxcrossref{\sphinxcode{FARKPSET()}}}}, the unit roundoff
can be obtained as the optional output \sphinxstyleemphasis{ROUT(6)} (available after
the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}) and can be passed using either
the \sphinxstyleemphasis{RPAR} user data array or a common block.

\end{enumerate}


\paragraph{Mass matrix linear solver interface specification}
\label{\detokenize{ARKode_f_interface/Usage:mass-matrix-linear-solver-interface-specification}}\label{\detokenize{ARKode_f_interface/Usage:finterface-masslinearsolver}}
To attach the mass matrix linear solver (and optionally the mass
matrix) object(s) initialized in steps {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX module initialization}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL module initialization}}}} above, the user of FARKODE must
initialize the mass-matrix linear solver interface.  To attach any
SUNLINSOL object (and optional SUNMATRIX object) to the mass-matrix
solver interface, following calls to initialize the SUNLINSOL (and
SUNMATRIX) object(s) in steps {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX module initialization}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL module initialization}}}} above, the user must call the
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}} routine:
\index{FARKLSMASSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSMASSINIT}}{\emph{TIME\_DEP}, \emph{IER}}{}
Interfaces with the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}} function to
attach a linear solver object (and optionally a matrix object) to
ARKStep’s mass-matrix linear solver interface.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{TIME\_DEP} (\sphinxcode{int}, input) \textendash{} flag indicating whether the
mass matrix is time-dependent (1) or not (0).
\sphinxstyleemphasis{Currently, only values of “0” are supported}

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}



\subparagraph{Matrix-based mass matrix linear solvers}
\label{\detokenize{ARKode_f_interface/Usage:matrix-based-mass-matrix-linear-solvers}}
When using the mass-matrix linear solver interface with the
SUNLINSOL\_DENSE or SUNLINSOL\_LAPACKDENSE mass matrix linear solver
modules, the user must supply a routine that computes the dense mass
matrix \(M\).  This routine must have the following form:
\index{FARKDMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKDMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKDMASS}}{\emph{NEQ}, \emph{T}, \emph{DMASS}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied dense mass matrix computation
function (of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}), to be used by the
SUNLINSOL\_DENSE or SUNLINSOL\_LAPACKDENSE solver modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NEQ} (\sphinxcode{long int}, input) \textendash{} size of the ODE system.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{DMASS} (\sphinxcode{realtype} of size (NEQ,NEQ), output) \textendash{} 2D array
containing the mass matrix entries.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WK1}, \sphinxstyleemphasis{WK2}, \sphinxstyleemphasis{WK3}  (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace
of same size as \sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} Typically this routine will use only \sphinxstyleemphasis{NEQ}, \sphinxstyleemphasis{T}, and
\sphinxstyleemphasis{DMASS}. It must compute the mass matrix and store it column-wise in \sphinxstyleemphasis{DMASS}.

\end{fulllineitems}


To indicate that the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDMASS}]{\sphinxcrossref{\sphinxcode{FARKDMASS()}}}} routine has been provided, then,
following the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}, the user must call
the routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETMASS}]{\sphinxcrossref{\sphinxcode{FARKDENSESETMASS()}}}}:
\index{FARKDENSESETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKDENSESETMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKDENSESETMASS}}{\emph{IER}}{}
Interface to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}} function,
specifying to use the user-supplied routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDMASS}]{\sphinxcrossref{\sphinxcode{FARKDMASS()}}}}
for the mass matrix calculation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


When using the mass-matrix linear solver interface with the
SUNLINSOL\_BAND or SUNLINSOL\_LAPACKBAND mass matrix linear solver
modules, the user must supply a routine that computes the banded mass
matrix \(M\).  This routine must have the following form:
\index{FARKBMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKBMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBMASS}}{\emph{NEQ}, \emph{MU}, \emph{ML}, \emph{MDIM}, \emph{T}, \emph{BMASS}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied band mass matrix calculation
function (of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}), to be used by the
SUNLINSOL\_BAND or SUNLINSOL\_LAPACKBAND solver modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NEQ} (\sphinxcode{long int}, input) \textendash{} size of the ODE system.

\item {} 
\sphinxstyleemphasis{MU}   (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth.

\item {} 
\sphinxstyleemphasis{ML}   (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth.

\item {} 
\sphinxstyleemphasis{MDIM} (\sphinxcode{long int}, input) \textendash{} leading dimension of \sphinxstyleemphasis{BMASS} array.

\item {} 
\sphinxstyleemphasis{T}    (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{BMASS} (\sphinxcode{realtype} of size \sphinxstyleemphasis{(MDIM,NEQ)}, output) \textendash{} 2D array
containing the mass matrix entries.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WK1}, \sphinxstyleemphasis{WK2}, \sphinxstyleemphasis{WK3}  (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace
of same size as \sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{NEQ}, \sphinxstyleemphasis{MU}, \sphinxstyleemphasis{ML}, \sphinxstyleemphasis{T}, and
\sphinxstyleemphasis{BMASS}. It must load the \sphinxstyleemphasis{MDIM} by \sphinxstyleemphasis{N} array \sphinxstyleemphasis{BMASS} with the mass
matrix at the current \((t)\) in band form.  Store in
\sphinxstyleemphasis{BMASS(k,j)} the mass matrix element \(M_{i,j}\) with
\sphinxstyleemphasis{k = i - j + MU + 1} (or \sphinxstyleemphasis{k = 1, …, ML+MU+1}) and \sphinxstyleemphasis{j = 1, …, N}.

\end{fulllineitems}


To indicate that the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBMASS}]{\sphinxcrossref{\sphinxcode{FARKBMASS()}}}} routine has been provided, then,
following the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}, the user must call the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETMASS}]{\sphinxcrossref{\sphinxcode{FARKBANDSETMASS()}}}}:
\index{FARKBANDSETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKBANDSETMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBANDSETMASS}}{\emph{IER}}{}
Interface to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}} function, specifying
to use the user-supplied routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKBMASS}]{\sphinxcrossref{\sphinxcode{FARKBMASS()}}}} for the mass
matrix calculation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


When using the mass-matrix linear solver interface with the
SUNLINSOL\_KLU or SUNLINSOL\_SUPERLUMT mass matrix linear solver
modules, the user must supply a routine that computes the sparse mass
matrix \(M\). Both the KLU and SuperLU\_MT solver interfaces
support the compressed-sparse-column (CSC) and compressed-sparse-row
(CSR) matrix formats.  The desired format must have been specified to
the \sphinxcode{FSUNSPARSEMASSMATINIT()} function when initializing the
sparse mass matrix.  The user-provided routine to compute \(M\)
must have the following form:
\index{FARKSPMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSPMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSPMASS}}{\emph{T}, \emph{N}, \emph{NNZ}, \emph{MDATA}, \emph{MINDEXVALS}, \emph{MINDEXPTRS}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied sparse mass matrix approximation
function (of type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassFn()}}}}), to be used by the
SUNLINSOL\_KLU or SUNLINSOL\_SUPERLUMT solver modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{sunindextype}, input) \textendash{} number of mass matrix rows and columns.

\item {} 
\sphinxstyleemphasis{NNZ} (\sphinxcode{sunindextype}, input) \textendash{} allocated length of nonzero storage
in mass matrix.

\item {} 
\sphinxstyleemphasis{MDATA} (\sphinxcode{realtype} of size NNZ, output) \textendash{} nonzero values
in mass matrix.

\item {} 
\sphinxstyleemphasis{MINDEXVALS} (\sphinxcode{sunindextype} of size NNZ, output) \textendash{} row \sphinxstyleemphasis{{[}CSR: column{]}} indices for each
nonzero mass matrix entry.

\item {} 
\sphinxstyleemphasis{MINDEXPTRS} (\sphinxcode{sunindextype} of size N+1, output) \textendash{} indices of where
each column’s \sphinxstyleemphasis{{[}CSR: row’s{]}} nonzeros begin in data array; last entry points
just past end of data values.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{WK1}, \sphinxstyleemphasis{WK2}, \sphinxstyleemphasis{WK3}  (\sphinxcode{realtype}, input) \textendash{} array containing temporary workspace
of same size as \sphinxstyleemphasis{Y}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} due to the internal storage format of the
SUNMATRIX\_SPARSE module, the matrix-specific integer parameters and
arrays are all of type \sphinxcode{sunindextype} \textendash{} the index precision
(32-bit vs 64-bit signed integers) specified during the SUNDIALS
build.  It is assumed that the user’s Fortran codes are constructed
to have matching type to how SUNDIALS was installed.

\end{fulllineitems}


To indicate that the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPMASS}]{\sphinxcrossref{\sphinxcode{FARKSPMASS()}}}} routine has been provided, then,
following the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}, the user must call the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETMASS}]{\sphinxcrossref{\sphinxcode{FARKSPARSESETMASS()}}}}:
\index{FARKSPARSESETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKSPARSESETMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKSPARSESETMASS}}{\emph{IER}}{}
Interface to the {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassFn}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassFn()}}}} function,
specifying that the user-supplied routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSPMASS}]{\sphinxcrossref{\sphinxcode{FARKSPMASS()}}}} has
been provided for the mass matrix calculation.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}



\subparagraph{Iterative mass matrix linear solvers}
\label{\detokenize{ARKode_f_interface/Usage:iterative-mass-matrix-linear-solvers}}
As described in the section {\hyperref[\detokenize{Mathematics:mathematics-error-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear iteration error control}}}}, a user
may adjust the linear solver tolerance scaling factor
\(\epsilon_L\).  Fortran users may adjust this value for the mass
matrix linear solver by calling the function
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSEPSLIN}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASSEPSLIN()}}}}:
\index{FARKLSSETMASSEPSLIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSEPSLIN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSSETMASSEPSLIN}}{\emph{EPLIFAC}, \emph{IER}}{}
Interface to the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassEpsLin}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassEpsLin()}}}} to
specify the linear solver tolerance scale factor \(\epsilon_L\)
for the mass matrix linear solver.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{EPLIFAC} (\sphinxcode{realtype}, input) \textendash{} value to use for
\(\epsilon_L\).  Passing a value of 0 indicates to use the
default value (0.05).

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


With treatment of the mass matrix linear systems by any of the Krylov
iterative solvers, there are two required user-supplied routines,
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTSETUP}]{\sphinxcrossref{\sphinxcode{FARKMTSETUP()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTIMES}]{\sphinxcrossref{\sphinxcode{FARKMTIMES()}}}}, and there are two
optional user-supplied routines, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSET}]{\sphinxcrossref{\sphinxcode{FARKMASSPSET()}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}}. The specifications of these functions are given below.

The required routines when using a Krylov iterative mass matrix linear
solver perform setup and computation of the product of the system mass
matrix \(M\) and a given vector \(v\).  The product routine
must have the following form:
\index{FARKMTIMES() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKMTIMES}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKMTIMES}}{\emph{V}, \emph{MV}, \emph{T}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Interface to a user-supplied mass-matrix-times-vector product
approximation function (corresponding to a C interface routine of
type {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesVecFn()}}}}), to be used by one of the
Krylov iterative linear solvers.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{V}    (\sphinxcode{realtype}, input) \textendash{} array containing the vector to multiply.

\item {} 
\sphinxstyleemphasis{MV}   (\sphinxcode{realtype}, output) \textendash{} array containing resulting product vector.

\item {} 
\sphinxstyleemphasis{T}    (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{T}, \sphinxstyleemphasis{V}, and
\sphinxstyleemphasis{MV}.  It must compute the product vector \(Mv\), where
\(v\) is given in \sphinxstyleemphasis{V}, and the product is stored in \sphinxstyleemphasis{MV}.

\end{fulllineitems}


If the user’s mass-matrix-times-vector product routine requires that
any mass matrix data be evaluated or preprocessed, then the following
routine can be used for the evaluation and preprocessing of this data:
\index{FARKMTSETUP() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKMTSETUP}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKMTSETUP}}{\emph{T}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Interface to a user-supplied mass-matrix-times-vector setup
function (corresponding to a C interface routine of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassTimesSetupFn()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T}    (\sphinxcode{realtype}, input) \textendash{} current value of the independent variable.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input) \textendash{} array containing integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input) \textendash{} array containing real user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{T}, and store
the results in either the arrays \sphinxstyleemphasis{IPAR} and \sphinxstyleemphasis{RPAR}, or in a Fortran
module or common block.  If no mass matrix setup is needed, this
routine should just set \sphinxstyleemphasis{IER} to 0 and return.

\end{fulllineitems}


To indicate that these routines have been supplied by the user, then,
following the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}, the user must
call the routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASS}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASS()}}}}:
\index{FARKLSSETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSSETMASS}}{\emph{IER}}{}
Interface to the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassTimes}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassTimes()}}}} to
specify use of the user-supplied mass-matrix-times-vector setup and
product functions {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTSETUP}]{\sphinxcrossref{\sphinxcode{FARKMTSETUP()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTIMES}]{\sphinxcrossref{\sphinxcode{FARKMTIMES()}}}}.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


Two optional user-supplied preconditioning routines may be supplied to
help accelerate convergence of the Krylov mass matrix linear solver.
If preconditioning was selected when enabling the Krylov solver
(i.e. the solver was set up with \sphinxstyleemphasis{IPRETYPE} \(\ne 0\)), then the
user must also call the routine {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSPREC}]{\sphinxcrossref{\sphinxcode{FARKLSSETMASSPREC()}}}} with
\sphinxstyleemphasis{FLAG} \(\ne 0\):
\index{FARKLSSETMASSPREC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETMASSPREC}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKLSSETMASSPREC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the function {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassPreconditioner}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassPreconditioner()}}}} to
specify use of the user-supplied preconditioner setup and solve
functions, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSET}]{\sphinxcrossref{\sphinxcode{FARKMASSPSET()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}},
respectively.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{FLAG} (\sphinxcode{int}, input) \textendash{} flag denoting use of user-supplied
preconditioning routines.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


In addition, the user must provide the following two routines to
implement the preconditioner setup and solve functions to be used
within the solve.
\index{FARKMASSPSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSET}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKMASSPSET}}{\emph{T}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied preconditioner setup routine (of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSetupFn()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent
variable.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array containing
integer user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array containing real
user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \textgreater{}0 if
a recoverable failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This routine must set up the preconditioner \(P\) to be used in
the subsequent call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}}.  The
preconditioner (or the product of the left and right
preconditioners if using both) should be an approximation to the
system mass matrix, \(M\).

\end{fulllineitems}

\index{FARKMASSPSOL() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKMASSPSOL}}{\emph{T}, \emph{R}, \emph{Z}, \emph{DELTA}, \emph{LR}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied preconditioner solve routine (of type
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:c.ARKLsMassPrecSolveFn}]{\sphinxcrossref{\sphinxcode{ARKLsMassPrecSolveFn()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the independent
variable.

\item {} 
\sphinxstyleemphasis{R} (\sphinxcode{realtype}, input) \textendash{} right-hand side array.

\item {} 
\sphinxstyleemphasis{Z} (\sphinxcode{realtype}, output) \textendash{} solution array.

\item {} 
\sphinxstyleemphasis{DELTA} (\sphinxcode{realtype}, input) \textendash{} desired residual tolerance.

\item {} 
\sphinxstyleemphasis{LR} (\sphinxcode{int}, input) \textendash{} flag denoting to solve the right or
left preconditioner system: 1 = left preconditioner, 2 = right
preconditioner.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array containing
integer user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array containing real
user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, \textgreater{}0 if
a recoverable failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
Typically this routine will use only \sphinxstyleemphasis{T}, \sphinxstyleemphasis{R}, \sphinxstyleemphasis{LR}, and \sphinxstyleemphasis{Z}.  It
must solve the preconditioner linear system \(Pz = r\).  The
preconditioner (or the product of the left and right
preconditioners if both are nontrivial) should be an approximation
to the system mass matrix \(M\).

\end{fulllineitems}


Notes:
\begin{enumerate}
\item {} 
If the user’s {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}} uses an iterative method in
its solution, the residual vector \(\rho = r - Pz\) of the
system should be made less than \(\delta =\) \sphinxstyleemphasis{DELTA} in the
weighted l2 norm, i.e.
\begin{equation*}
\begin{split}\left(\sum_i \left(\rho_i\, EWT_i\right)^2 \right)^{1/2} < \delta.\end{split}
\end{equation*}
\item {} 
If needed in {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTIMES}]{\sphinxcrossref{\sphinxcode{FARKMTIMES()}}}}, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTSETUP}]{\sphinxcrossref{\sphinxcode{FARKMTSETUP()}}}},
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}}, or {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSET}]{\sphinxcrossref{\sphinxcode{FARKMASSPSET()}}}}, the error
weight array \sphinxstyleemphasis{EWT} can be obtained by calling
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} using a user-allocated array as
temporary storage for \sphinxstyleemphasis{EWT}.

\item {} 
If needed in {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTIMES}]{\sphinxcrossref{\sphinxcode{FARKMTIMES()}}}}, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMTSETUP}]{\sphinxcrossref{\sphinxcode{FARKMTSETUP()}}}},
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSOL}]{\sphinxcrossref{\sphinxcode{FARKMASSPSOL()}}}}, or {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMASSPSET}]{\sphinxcrossref{\sphinxcode{FARKMASSPSET()}}}}, the unit
roundoff can be obtained as the optional output \sphinxstyleemphasis{ROUT(6)}
(available after the call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}) and can be
passed using either the \sphinxstyleemphasis{RPAR} user data array or a common block.

\end{enumerate}


\paragraph{Problem solution}
\label{\detokenize{ARKode_f_interface/Usage:problem-solution}}\label{\detokenize{ARKode_f_interface/Usage:finterface-solution}}
Carrying out the integration is accomplished by making calls to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}}.
\index{FARKODE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKODE}}{\emph{TOUT}, \emph{T}, \emph{Y}, \emph{ITASK}, \emph{IER}}{}
Fortran interface to the C routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}
for performing the solve, along with many of the ARK*Get*
routines for reporting on solver statistics.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{TOUT} (\sphinxcode{realtype}, input) \textendash{} next value of \(t\) at
which a solution is desired.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, output) \textendash{} value of independent variable
that corresponds to the output \sphinxstyleemphasis{Y}

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, output) \textendash{} array containing dependent state
variables on output.

\item {} 
\sphinxstyleemphasis{ITASK} (\sphinxcode{int}, input) \textendash{} task indicator :
\begin{itemize}
\item {} 
1 = normal mode (overshoot \sphinxstyleemphasis{TOUT} and interpolate)

\item {} 
2 = one-step mode (return after each internal step taken)

\item {} 
3 = normal ‘tstop’ mode (like 1, but integration never
proceeds past \sphinxstyleemphasis{TSTOP}, which must be specified through a
preceding call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKSETRIN}]{\sphinxcrossref{\sphinxcode{FARKSETRIN()}}}} using the key
\sphinxstyleemphasis{STOP\_TIME})

\item {} 
4 = one step ‘tstop’ mode (like 2, but integration never
goes past \sphinxstyleemphasis{TSTOP}).

\end{itemize}

\item {} 
\sphinxstyleemphasis{IER} (int, output) \textendash{} completion flag:
\begin{itemize}
\item {} 
0 = success,

\item {} 
1 = tstop return,

\item {} 
2 = root return,

\item {} 
values -1, …, -10 are failure modes (see {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}} and
{\hyperref[\detokenize{Constants:constants}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: ARKode Constants}}}}).

\end{itemize}

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
The current values of the optional outputs are immediately
available in \sphinxstyleemphasis{IOUT} and \sphinxstyleemphasis{ROUT} upon return from this function (see
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-iouttable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional FARKODE integer outputs}}}} and {\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-routtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional FARKODE real outputs}}}}).

A full description of error flags and output behavior of the solver
(values filled in for \sphinxstyleemphasis{T} and \sphinxstyleemphasis{Y}) is provided in the description
of {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepEvolve}]{\sphinxcrossref{\sphinxcode{ARKStepEvolve()}}}}.

\end{fulllineitems}



\paragraph{Additional solution output}
\label{\detokenize{ARKode_f_interface/Usage:additional-solution-output}}\label{\detokenize{ARKode_f_interface/Usage:finterface-additionaloutput}}
After a successful return from {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}}, the routine
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKDKY}]{\sphinxcrossref{\sphinxcode{FARKDKY()}}}} may be used to obtain a derivative of the solution,
of order up to 3, at any \(t\) within the last step taken.
\index{FARKDKY() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKDKY}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKDKY}}{\emph{T}, \emph{K}, \emph{DKY}, \emph{IER}}{}
Fortran interface to the C routine \sphinxcode{ARKDKY()} for
interpolating output of the solution or its derivatives at any
point within the last step taken.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} time at which solution derivative
is desired, within the interval \([t_n-h,t_n]\).

\item {} 
\sphinxstyleemphasis{K} (\sphinxcode{int}, input) \textendash{} derivative order \((0 \le k \le 3)\).

\item {} 
\sphinxstyleemphasis{DKY} (\sphinxcode{realtype}, output) \textendash{} array containing the computed
\sphinxstyleemphasis{K}-th derivative of \(y\).

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textless{}0 if an
illegal argument).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Problem reinitialization}
\label{\detokenize{ARKode_f_interface/Usage:problem-reinitialization}}\label{\detokenize{ARKode_f_interface/Usage:finterface-reinit}}
To re-initialize the ARKStep solver for the solution of a new
problem of the same size as one already solved, the user must call
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}]{\sphinxcrossref{\sphinxcode{FARKREINIT()}}}}:
\index{FARKREINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKREINIT}}{\emph{T0}, \emph{Y0}, \emph{IMEX}, \emph{IATOL}, \emph{RTOL}, \emph{ATOL}, \emph{IER}}{}
Re-initializes the Fortran interface to the ARKStep solver.

\sphinxstylestrong{Arguments:}  The arguments have the same names and meanings as those of
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\sphinxstylestrong{Notes:}
This routine performs no memory allocation, instead using the
existing memory created by the previous {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}
call.  The call to specify the linear system solution method may
or may not be needed.

\end{fulllineitems}


Following a call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}]{\sphinxcrossref{\sphinxcode{FARKREINIT()}}}} if the choice of linear
solver is being changed then a user must make a call to create the
alternate SUNLINSOL module and then attach it to ARKStep, as shown
above.  If only linear solver parameters are being modified, then
these calls may be made without re-attaching to ARKStep.


\paragraph{Resizing the ODE system}
\label{\detokenize{ARKode_f_interface/Usage:finterface-resize}}\label{\detokenize{ARKode_f_interface/Usage:resizing-the-ode-system}}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when solving a spatially-adaptive
PDE), the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} integrator may be “resized” between
integration steps, through calls to the {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKRESIZE}]{\sphinxcrossref{\sphinxcode{FARKRESIZE()}}}}
function, that interfaces with the C routine {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepResize}]{\sphinxcrossref{\sphinxcode{ARKStepResize()}}}}.
This function modifies ARKStep’s internal memory structures to use the
new problem size, without destruction of the temporal adaptivity
heuristics.  It is assumed that the dynamical time scales before and
after the vector resize will be comparable, so that all time-stepping
heuristics prior to calling \sphinxcode{FARKRESIZE()} remain valid after
the call.  If instead the dynamics should be re-calibrated, the
FARKODE memory structure should be deleted with a call to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKFREE}]{\sphinxcrossref{\sphinxcode{FARKFREE()}}}}, and re-created with a call to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.
\index{FARKRESIZE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKRESIZE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKRESIZE}}{\emph{T0}, \emph{Y0}, \emph{HSCALE}, \emph{ITOL}, \emph{RTOL}, \emph{ATOL}, \emph{IER}}{}
Re-initializes the Fortran interface to the ARKStep solver for a
differently-sized ODE system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T0} (\sphinxcode{realtype}, input) \textendash{} initial value of the independent
variable \(t\).

\item {} 
\sphinxstyleemphasis{Y0} (\sphinxcode{realtype}, input) \textendash{} array of dependent-variable
initial conditions.

\item {} 
\sphinxstyleemphasis{HSCALE} (\sphinxcode{realtype}, input) \textendash{} desired step size scale factor:
\begin{itemize}
\item {} 
1.0 is the default,

\item {} 
any value \textless{}= 0.0 results in the default.

\end{itemize}

\item {} 
\sphinxstyleemphasis{ITOL} (\sphinxcode{int}, input) \textendash{} flag denoting that a new relative
tolerance and vector of absolute tolerances are supplied in
the \sphinxstyleemphasis{RTOL} and \sphinxstyleemphasis{ATOL} arguments:
\begin{itemize}
\item {} 
0 = retain the current scalar-valued relative and absolute
tolerances, or the user-supplied error weight function,
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKEWT}]{\sphinxcrossref{\sphinxcode{FARKEWT()}}}}.

\item {} 
1 = \sphinxstyleemphasis{RTOL} contains the new scalar-valued relative tolerance
and \sphinxstyleemphasis{ATOL} contains a new array of absolute tolerances.

\end{itemize}

\item {} 
\sphinxstyleemphasis{RTOL} (\sphinxcode{realtype}, input) \textendash{} scalar relative tolerance.

\item {} 
\sphinxstyleemphasis{ATOL} (\sphinxcode{realtype}, input) \textendash{} array of absolute tolerances.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This routine performs the opposite set of of operations as
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}]{\sphinxcrossref{\sphinxcode{FARKREINIT()}}}}: it does not reinitialize any of the
time-step heuristics, but it does perform memory reallocation.

\end{fulllineitems}


Following a call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKRESIZE}]{\sphinxcrossref{\sphinxcode{FARKRESIZE()}}}}, the internal data
structures for all linear solver and matrix objects will be the
incorrect size.  Hence, calls must be made to re-create the linear
system solver, mass matrix solver, linear system matrix, and mass
matrix, followed by calls to attach the updated objects to ARKStep.

If any user-supplied linear solver helper routines were used (Jacobian
evaluation, Jacobian-vector product, mass matrix evaluation,
mass-matrix-vector product, preconditioning, etc.), then the
relevant “set” routines to specify their usage must be called again
\sphinxstylestrong{following} the re-specification of the linear solver module(s).


\paragraph{Memory deallocation}
\label{\detokenize{ARKode_f_interface/Usage:finterface-deallocation}}\label{\detokenize{ARKode_f_interface/Usage:memory-deallocation}}
To free the internal memory created by {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}},
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSMASSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSMASSINIT()}}}}, and the SUNMATRIX,
SUNLINSOL and SUNNONLINSOL objects, the user may call
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKFREE}]{\sphinxcrossref{\sphinxcode{FARKFREE()}}}}, as follows:
\index{FARKFREE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Usage:f/_/FARKFREE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKFREE}}{}{}
Frees the internal memory created by {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\sphinxstylestrong{Arguments:} None.

\end{fulllineitems}



\subsubsection{FARKODE optional output}
\label{\detokenize{ARKode_f_interface/Optional_output::doc}}\label{\detokenize{ARKode_f_interface/Optional_output:finterface-optionaloutputs}}\label{\detokenize{ARKode_f_interface/Optional_output:farkode-optional-output}}
We note that the optional inputs to FARKODE have already been
described in the section {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Setting optional inputs}}}}.


\paragraph{IOUT and ROUT arrays}
\label{\detokenize{ARKode_f_interface/Optional_output:iout-and-rout-arrays}}
In the Fortran interface, the optional outputs from the
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} solver are accessed not through individual
functions, but rather through a pair of user-allocated arrays, \sphinxstyleemphasis{IOUT}
(having \sphinxcode{long int} type) of dimension at least 36, and \sphinxstyleemphasis{ROUT}
(having \sphinxcode{realtype} type) of dimension at least 6.  These arrays must
be allocated by the user program that calls {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}}, that
passes them through the Fortran interface as arguments to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.  Following this call, {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} will
modify the entries of these arrays to contain all optional output
values provided to a Fortran user.

In the following tables, {\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-iouttable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional FARKODE integer outputs}}}} and
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-routtable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional FARKODE real outputs}}}}, we list the entries in these
arrays by index, naming them according to their role with the main
ARKStep solver, and list the relevant ARKStep C/C++ function that is
actually called to extract the output value.  Similarly, optional
integer output values that are specific to the ARKLS linear solver
interface are listed in {\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-lsiouttable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional ARKLS interface outputs}}}}.

For more details on the optional inputs and outputs to ARKStep, see
the sections {\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionalinputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional input functions}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:arkstep-cinterface-optionaloutputs}]{\sphinxcrossref{\DUrole{std,std-ref}{Optional output functions}}}}.


\paragraph{Table: Optional FARKODE integer outputs}
\label{\detokenize{ARKode_f_interface/Optional_output:table-optional-farkode-integer-outputs}}\label{\detokenize{ARKode_f_interface/Optional_output:finterface-iouttable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{IOUT} Index
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep function
\unskip}\relax \\
\hline
1
&
LENRW
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKStepGetWorkSpace()}}}}
\\
\hline
2
&
LENIW
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKStepGetWorkSpace()}}}}
\\
\hline
3
&
NST
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumSteps}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumSteps()}}}}
\\
\hline
4
&
NST\_STB
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumExpSteps}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumExpSteps()}}}}
\\
\hline
5
&
NST\_ACC
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumAccSteps}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumAccSteps()}}}}
\\
\hline
6
&
NST\_ATT
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumStepAttempts}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumStepAttempts()}}}}
\\
\hline
7
&
NFE
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumRhsEvals()}}}} (num \(f^E\) calls)
\\
\hline
8
&
NFI
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumRhsEvals()}}}} (num \(f^I\) calls)
\\
\hline
9
&
NSETUPS
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumLinSolvSetups}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumLinSolvSetups()}}}}
\\
\hline
10
&
NETF
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumErrTestFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumErrTestFails()}}}}
\\
\hline
11
&
NNI
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvIters}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumNonlinSolvIters()}}}}
\\
\hline
12
&
NCFN
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumNonlinSolvConvFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumNonlinSolvConvFails()}}}}
\\
\hline
13
&
NGE
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumGEvals}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumGEvals()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Table: Optional FARKODE real outputs}
\label{\detokenize{ARKode_f_interface/Optional_output:table-optional-farkode-real-outputs}}\label{\detokenize{ARKode_f_interface/Optional_output:finterface-routtable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{ROUT} Index
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep function
\unskip}\relax \\
\hline
1
&
H0U
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetActualInitStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetActualInitStep()}}}}
\\
\hline
2
&
HU
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetLastStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetLastStep()}}}}
\\
\hline
3
&
HCUR
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentStep}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentStep()}}}}
\\
\hline
4
&
TCUR
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}}
\\
\hline
5
&
TOLSF
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetTolScaleFactor}]{\sphinxcrossref{\sphinxcode{ARKStepGetTolScaleFactor()}}}}
\\
\hline
6
&
UROUND
&
\sphinxcode{UNIT\_ROUNDOFF} (see the section {\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}})
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Table: Optional ARKLS interface outputs}
\label{\detokenize{ARKode_f_interface/Optional_output:table-optional-arkls-interface-outputs}}\label{\detokenize{ARKode_f_interface/Optional_output:finterface-lsiouttable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{IOUT} Index
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep function
\unskip}\relax \\
\hline
14
&
LENRWLS
&
\sphinxcode{ARKLsGetWorkSpace()}
\\
\hline
15
&
LENIWLS
&
\sphinxcode{ARKLsGetWorkSpace()}
\\
\hline
16
&
LSTF
&
\sphinxcode{ARKLsGetLastFlag()}
\\
\hline
17
&
NFELS
&
\sphinxcode{ARKLsGetNumRhsEvals()}
\\
\hline
18
&
NJE
&
\sphinxcode{ARKLsGetNumJacEvals()}
\\
\hline
19
&
NJTS
&
\sphinxcode{ARKLsGetNumJTSetupEvals()}
\\
\hline
20
&
NJTV
&
\sphinxcode{ARKLsGetNumJtimesEvals()}
\\
\hline
21
&
NPE
&
\sphinxcode{ARKLsGetNumPrecEvals()}
\\
\hline
22
&
NPS
&
\sphinxcode{ARKLsGetNumPrecSolves()}
\\
\hline
23
&
NLI
&
\sphinxcode{ARKLsGetNumLinIters()}
\\
\hline
24
&
NCFL
&
\sphinxcode{ARKLsGetNumConvFails()}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Table: Optional ARKLS mass interface outputs}
\label{\detokenize{ARKode_f_interface/Optional_output:table-optional-arkls-mass-interface-outputs}}\label{\detokenize{ARKode_f_interface/Optional_output:finterface-lsmassiouttable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{IOUT} Index
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep function
\unskip}\relax \\
\hline
25
&
LENRWMS
&
\sphinxcode{ARKLsGetMassWorkSpace()}
\\
\hline
26
&
LENIWMS
&
\sphinxcode{ARKLsGetMassWorkSpace()}
\\
\hline
27
&
LSTMF
&
\sphinxcode{ARKLsGetLastMassFlag()}
\\
\hline
28
&
NMSET
&
\sphinxcode{ARKLsGetNumMassSetups()}
\\
\hline
29
&
NMSOL
&
\sphinxcode{ARKLsGetNumMassSolves()}
\\
\hline
30
&
NMTSET
&
\sphinxcode{ARKLsGetNumMTSetups()}
\\
\hline
31
&
NMMUL
&
\sphinxcode{ARKLsGetNumMassMult()}
\\
\hline
32
&
NMPE
&
\sphinxcode{ARKLsGetNumMassPrecEvals()}
\\
\hline
33
&
NMPS
&
\sphinxcode{ARKLsGetNumMassPrecSolves()}
\\
\hline
34
&
NMLI
&
\sphinxcode{ARKLsGetNumMassIters()}
\\
\hline
35
&
NMCFL
&
\sphinxcode{ARKLsGetNumMassConvFails()}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Table: Optional ARKode constraints outputs}
\label{\detokenize{ARKode_f_interface/Optional_output:table-optional-arkode-constraints-outputs}}\label{\detokenize{ARKode_f_interface/Optional_output:finterface-constriouttable}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{IOUT} Index
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Optional output
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep function
\unskip}\relax \\
\hline
36
&
CONSTRFAILS
&
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetNumConstrFails}]{\sphinxcrossref{\sphinxcode{ARKStepGetNumConstrFails()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Additional optional output routines}
\label{\detokenize{ARKode_f_interface/Optional_output:additional-optional-output-routines}}
In addition to the optional inputs communicated through FARKSET*
calls and the optional outputs extracted from \sphinxstyleemphasis{IOUT} and \sphinxstyleemphasis{ROUT},
the following user-callable routines are available.

To obtain the error weight array \sphinxstyleemphasis{EWT}, containing the
multiplicative error weights used in the WRMS norms, the user may call
the routine {\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}]{\sphinxcrossref{\sphinxcode{FARKGETERRWEIGHTS()}}}} as follows:
\index{FARKGETERRWEIGHTS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKGETERRWEIGHTS}}{\emph{EWT}, \emph{IER}}{}
Retrieves the current error weight vector (interfaces
with {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetErrWeights}]{\sphinxcrossref{\sphinxcode{ARKStepGetErrWeights()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{EWT} (\sphinxcode{realtype}, output) \textendash{} array containing the error
weight vector.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
The array \sphinxstyleemphasis{EWT} must have already been allocated by the user, of
the same size as the solution array \sphinxstyleemphasis{Y}.

\end{fulllineitems}


Similarly, to obtain the estimated local truncation errors, following
a successful call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}}, the user may call the
routine {\hyperref[\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETESTLOCALERR}]{\sphinxcrossref{\sphinxcode{FARKGETESTLOCALERR()}}}} as follows:
\index{FARKGETESTLOCALERR() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Optional_output:f/_/FARKGETESTLOCALERR}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKGETESTLOCALERR}}{\emph{ELE}, \emph{IER}}{}
Retrieves the current local truncation error estimate
vector (interfaces with {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetEstLocalErrors}]{\sphinxcrossref{\sphinxcode{ARKStepGetEstLocalErrors()}}}}).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ELE} (\sphinxcode{realtype}, output) \textendash{} array with the estimated local
truncation error vector.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
The array \sphinxstyleemphasis{ELE} must have already been allocated by the user, of
the same size as the solution array \sphinxstyleemphasis{Y}.

\end{fulllineitems}



\subsubsection{Usage of the FARKROOT interface to rootfinding}
\label{\detokenize{ARKode_f_interface/Rootfinding::doc}}\label{\detokenize{ARKode_f_interface/Rootfinding:finterface-rootfinding}}\label{\detokenize{ARKode_f_interface/Rootfinding:usage-of-the-farkroot-interface-to-rootfinding}}
The FARKROOT interface package allows programs written in Fortran to
use the rootfinding feature of the ARKStep solver module. The
user-callable functions in FARKROOT, with the corresponding ARKStep
functions, are as follows:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINIT}]{\sphinxcrossref{\sphinxcode{FARKROOTINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}},

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINFO}]{\sphinxcrossref{\sphinxcode{FARKROOTINFO()}}}} interfaces to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetRootInfo}]{\sphinxcrossref{\sphinxcode{ARKStepGetRootInfo()}}}}, and

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTFREE}]{\sphinxcrossref{\sphinxcode{FARKROOTFREE()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepRootInit}]{\sphinxcrossref{\sphinxcode{ARKStepRootInit()}}}},
freeing memory by calling the initializer with no root functions.

\end{itemize}

Note that at this time, FARKROOT does not provide support to specify
the direction of zero-crossing that is to be monitored.  Instead, all
roots are considered.  However, the actual direction of zero-crossing
may be captured by the user through monitoring the sign of any
non-zero elements in the array \sphinxstyleemphasis{INFO} returned by
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINFO}]{\sphinxcrossref{\sphinxcode{FARKROOTINFO()}}}}.

In order to use the rootfinding feature of ARKStep, after calling {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}} but prior to
calling {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}}, the user must call
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINIT}]{\sphinxcrossref{\sphinxcode{FARKROOTINIT()}}}} to allocate and initialize memory for the FARKROOT module:
\index{FARKROOTINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKROOTINIT}}{\emph{NRTFN}, \emph{IER}}{}
Initializes the Fortran interface to the FARKROOT module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NRTFN} (\sphinxcode{int}, input) \textendash{} total number of root functions.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 if
ARKStep memory is \sphinxcode{NULL}, and -11 if a memory allocation
error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


If rootfinding is enabled, the user must specify the functions whose
roots are to be found.  These rootfinding functions should be
implemented in the user-supplied {\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTFN}]{\sphinxcrossref{\sphinxcode{FARKROOTFN()}}}} subroutine:
\index{FARKROOTFN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTFN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKROOTFN}}{\emph{T}, \emph{Y}, \emph{G}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User supplied function implementing the vector-valued function
\(g(t,y)\) such that the roots of the \sphinxstyleemphasis{NRTFN} components
\(g_i(t,y)=0\) are sought.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} independent variable value \(t\).

\item {} 
\sphinxstyleemphasis{Y} (\sphinxcode{realtype}, input) \textendash{} dependent variable array \(y\).

\item {} 
\sphinxstyleemphasis{G} (\sphinxcode{realtype}, output) \textendash{} function value array \(g(t,y)\).

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} integer user data
array, the same as the array passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} real-valued user data
array, the same as the array passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(<0\)
if error).

\end{itemize}

\end{description}

\end{fulllineitems}


When making calls to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKODE}]{\sphinxcrossref{\sphinxcode{FARKODE()}}}} to solve the ODE system, the
occurrence of a root is flagged by the return value \sphinxstyleemphasis{IER = 2}.  In
that case, if \sphinxstyleemphasis{NRTFN \textgreater{} 1}, the functions \(g_i(t,y)\) which were
found to have a root can be identified by calling the routine
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINFO}]{\sphinxcrossref{\sphinxcode{FARKROOTINFO()}}}}:
\index{FARKROOTINFO() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINFO}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKROOTINFO}}{\emph{NRTFN}, \emph{INFO}, \emph{IER}}{}
Initializes the Fortran interface to the FARKROOT module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NRTFN} (\sphinxcode{int}, input) \textendash{} total number of root functions.

\item {} 
\sphinxstyleemphasis{INFO} (\sphinxcode{int}, input/output) \textendash{} array of length \sphinxstyleemphasis{NRTFN} with
root information (must be allocated by the user).  For each
index, \sphinxstyleemphasis{i = 1, …, NRTFN}:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{INFO(i) = 1}  if \(g_i(t,y)\) was found to have a root,
and \(g_i\) is increasing.

\item {} 
\sphinxstyleemphasis{INFO(i) = -1}  if \(g_i(t,y)\) was found to have a root,
and \(g_i\) is decreasing.

\item {} 
\sphinxstyleemphasis{INFO(i) = 0}  otherwise.

\end{itemize}

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, \(<0\)
if error).

\end{itemize}

\end{description}

\end{fulllineitems}


The total number of calls made to the root function
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTFN}]{\sphinxcrossref{\sphinxcode{FARKROOTFN()}}}}, denoted \sphinxstyleemphasis{NGE}, can be obtained from
\sphinxstyleemphasis{IOUT(12)}.  If the FARKODE/ARKStep memory block is reinitialized to
solve a different problem via a call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}]{\sphinxcrossref{\sphinxcode{FARKREINIT()}}}}, then
the counter \sphinxstyleemphasis{NGE} is reset to zero.

Lastly, to free the memory resources allocated by a prior call to
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTINIT}]{\sphinxcrossref{\sphinxcode{FARKROOTINIT()}}}}, the user must make a call to
{\hyperref[\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTFREE}]{\sphinxcrossref{\sphinxcode{FARKROOTFREE()}}}}:
\index{FARKROOTFREE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Rootfinding:f/_/FARKROOTFREE}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKROOTFREE}}{}{}
Frees memory associated with the FARKODE rootfinding module.

\end{fulllineitems}



\subsubsection{Usage of the FARKODE interface to built-in preconditioners}
\label{\detokenize{ARKode_f_interface/Preconditioning:finterface-preconditioning}}\label{\detokenize{ARKode_f_interface/Preconditioning::doc}}\label{\detokenize{ARKode_f_interface/Preconditioning:usage-of-the-farkode-interface-to-built-in-preconditioners}}
The FARKODE interface enables usage of the two built-in
preconditioning modules ARKBANDPRE and ARKBBDPRE.  Details on how
these preconditioners work are provided in the section
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:arkstep-cinterface-preconditionermodules}]{\sphinxcrossref{\DUrole{std,std-ref}{Preconditioner modules}}}}.  In this section, we focus
specifically on the Fortran interface to these modules.


\paragraph{Usage of the FARKBP interface to ARKBANDPRE}
\label{\detokenize{ARKode_f_interface/Preconditioning:finterface-bandpre}}\label{\detokenize{ARKode_f_interface/Preconditioning:usage-of-the-farkbp-interface-to-arkbandpre}}
The FARKBP interface module is a package of C functions which,
as part of the FARKODE interface module, support the use of the
ARKStep solver with the serial or threaded NVector modules
({\hyperref[\detokenize{nvectors/NVector_Serial:nvectors-nvserial}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_SERIAL Module}}}}, {\hyperref[\detokenize{nvectors/NVector_OpenMP:nvectors-openmp}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_OPENMP Module}}}} or
{\hyperref[\detokenize{nvectors/NVector_Pthreads:nvectors-pthreads}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PTHREADS Module}}}}), and the combination of the ARKBANDPRE
preconditioner module (see the section {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:arkstep-cinterface-bandpre}]{\sphinxcrossref{\DUrole{std,std-ref}{A serial banded preconditioner module}}}}) with
the ARKStep linear solver interface and any of the Krylov iterative linear solvers.

The two user-callable functions in this package, with the
corresponding ARKStep function around which they wrap, are:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBPINIT}]{\sphinxcrossref{\sphinxcode{FARKBPINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecInit}]{\sphinxcrossref{\sphinxcode{ARKBandPrecInit()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBPOPT}]{\sphinxcrossref{\sphinxcode{FARKBPOPT()}}}} interfaces to the ARKBANDPRE optional output
functions, {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetWorkSpace()}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetNumRhsEvals()}}}}.

\end{itemize}

As with the rest of the FARKODE routines, the names of the
user-supplied routines are mapped to actual values through a series of
definitions in the header file \sphinxcode{farkbp.h}.

The following is a summary of the usage of this module.  Steps that
are unchanged from the main program described in the section
{\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-usage}]{\sphinxcrossref{\DUrole{std,std-ref}{Usage of the FARKODE interface module}}}} are \sphinxstyleemphasis{italicized}.
\begin{enumerate}
\item {} 
\sphinxstyleemphasis{Right-hand side specification}

\item {} 
\sphinxstyleemphasis{NVECTOR module initialization}

\item {} 
SUNLINSOL module initialization

Initialize one of the iterative SUNLINSOL modules, by calling one
of FSUNPCGINIT, FSUNSPBCGSINIT, FSUNSPFGMRINIT, FSUNSPGMRINIT or
FSUNSPTFQMRINIT, supplying an argument to specify that the
SUNLINSOL module should utilize left or right preconditioning.

\item {} 
\sphinxstyleemphasis{Problem specification}

\item {} 
\sphinxstyleemphasis{Set optional inputs}

\item {} 
Linear solver interface specification

First, initialize the ARKStep linear solver interface by calling {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}.

Optionally, to specify that ARKStep should use the supplied
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}} routines, the
user should call {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}]{\sphinxcrossref{\sphinxcode{FARKLSSETJAC()}}}} with FLAG \(\ne 0\),
as described in the section {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-iterative}]{\sphinxcrossref{\DUrole{std,std-ref}{Iterative linear solvers}}}}.

Then, to initialize the ARKBANDPRE preconditioner, call the
routine {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBPINIT}]{\sphinxcrossref{\sphinxcode{FARKBPINIT()}}}}, as follows:
\index{FARKBPINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBPINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBPINIT}}{\emph{NEQ}, \emph{MU}, \emph{ML}, \emph{IER}}{}
Interfaces with the {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecInit}]{\sphinxcrossref{\sphinxcode{ARKBandPrecInit()}}}}
function to allocate memory and initialize data associated
with the ARKBANDPRE preconditioner.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NEQ} (\sphinxcode{long int}, input) \textendash{} problem size.

\item {} 
\sphinxstyleemphasis{MU} (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth of the
band matrix that is retained as an approximation of the
Jacobian.

\item {} 
\sphinxstyleemphasis{ML}  (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth of the
band matrix approximation to the Jacobian.

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag  (0 if success, -1
if a memory failure).

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\sphinxstyleemphasis{Problem solution}

\item {} 
ARKBANDPRE optional outputs

Optional outputs for ARKStep’s linear solver interface are listed in
{\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-lsiouttable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional ARKLS interface outputs}}}}.  To obtain the optional outputs
associated with the ARKBANDPRE module, the user should call the
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBPOPT}]{\sphinxcrossref{\sphinxcode{FARKBPOPT()}}}}, as specified below:
\index{FARKBPOPT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBPOPT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBPOPT}}{\emph{LENRWBP}, \emph{LENIWBP}, \emph{NFEBP}}{}
Interfaces with the ARKBANDPRE optional output functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LENRWBP} (\sphinxcode{long int}, output) \textendash{} length of real
preconditioner work space (from
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetWorkSpace()}}}}).

\item {} 
\sphinxstyleemphasis{LENIWBP} (\sphinxcode{long int}, output) \textendash{} length of integer
preconditioner work space, in integer words (from
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetWorkSpace()}}}}).

\item {} 
\sphinxstyleemphasis{NFEBP} (\sphinxcode{long int}, output) \textendash{} number of
\(f^I(t,y)\) evaluations (from
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals}]{\sphinxcrossref{\sphinxcode{ARKBandPrecGetNumRhsEvals()}}}})

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\sphinxstyleemphasis{Additional solution output}

\item {} 
\sphinxstyleemphasis{Problem re-initialization}

\item {} 
\sphinxstyleemphasis{Memory deallocation}

(The memory allocated for the FARKBP module is deallocated
automatically by {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKFREE}]{\sphinxcrossref{\sphinxcode{FARKFREE()}}}})

\end{enumerate}


\paragraph{Usage of the FARKBBD interface to ARKBBDPRE}
\label{\detokenize{ARKode_f_interface/Preconditioning:usage-of-the-farkbbd-interface-to-arkbbdpre}}\label{\detokenize{ARKode_f_interface/Preconditioning:finterface-bbdpre}}
The FARKBBD interface module is a package of C functions which, as
part of the FARKODE interface module, support the use of the ARKStep
solver with the parallel vector module ({\hyperref[\detokenize{nvectors/NVector_Parallel:nvectors-nvparallel}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PARALLEL Module}}}}),
and the combination of the ARKBBDPRE preconditioner module (see the
section {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:arkstep-cinterface-bbdpre}]{\sphinxcrossref{\DUrole{std,std-ref}{A parallel band-block-diagonal preconditioner module}}}}) with any of the Krylov iterative
linear solvers.

The user-callable functions in this package, with the corresponding
ARKStep and ARKBBDPRE functions, are as follows:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecInit()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDREINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDREINIT()}}}} interfaces to {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecReInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecReInit()}}}}.

\item {} 
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDOPT}]{\sphinxcrossref{\sphinxcode{FARKBBDOPT()}}}} interfaces to the ARKBBDPRE optional output
functions.

\end{itemize}

In addition to the functions required for general FARKODE usage, the
user-supplied functions required by this package are listed in the
table below, each with the corresponding interface function which
calls it (and its type within ARKBBDPRE or ARKStep).

\sphinxstyleemphasis{Table: FARKBBD function mapping}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
FARKBBD routine
(FORTRAN, user-supplied)
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep routine
(C, interface)
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKStep interface
function type
\unskip}\relax \\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKGLOCFN}]{\sphinxcrossref{\sphinxcode{FARKGLOCFN()}}}}
&
FARKgloc
&
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{\sphinxcode{ARKLocalFn()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKCOMMFN}]{\sphinxcrossref{\sphinxcode{FARKCOMMFN()}}}}
&
FARKcfn
&
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}]{\sphinxcrossref{\sphinxcode{ARKCommFn()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}}
&
FARKJtimes
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesVecFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesVecFn()}}}}
\\
\hline
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}}
&
FARKJTSetup
&
{\hyperref[\detokenize{MRIStep_c_interface/User_supplied:c.ARKLsJacTimesSetupFn}]{\sphinxcrossref{\sphinxcode{ARKLsJacTimesSetupFn()}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

As with the rest of the FARKODE routines, the names of all
user-supplied routines here are fixed, in order to maximize
portability for the resulting mixed-language program.  Additionally,
based on flags discussed above in the section {\hyperref[\detokenize{ARKode_f_interface/Routines:finterface-routines}]{\sphinxcrossref{\DUrole{std,std-ref}{FARKODE routines}}}},
the names of the user-supplied routines are mapped to actual values
through a series of definitions in the header file \sphinxcode{farkbbd.h}.

The following is a summary of the usage of this module. Steps that are
unchanged from the main program described in the section
{\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-usage}]{\sphinxcrossref{\DUrole{std,std-ref}{Usage of the FARKODE interface module}}}} are \sphinxstyleemphasis{italicized}.
\begin{enumerate}
\item {} 
\sphinxstyleemphasis{Right-hand side specification}

\item {} 
\sphinxstyleemphasis{NVECTOR module initialization}

\item {} 
SUNLINSOL module initialization

Initialize one of the iterative SUNLINSOL modules, by calling one
of FSUNPCGINIT, FSUNSPBCGSINIT, FSUNSPFGMRINIT, FSUNSPGMRINIT or
FSUNSPTFQMRINIT, supplying an argument to specify that the
SUNLINSOL module should utilize left or right preconditioning.

\item {} 
\sphinxstyleemphasis{Problem specification}

\item {} 
\sphinxstyleemphasis{Set optional inputs}

\item {} 
Linear solver interface specification

First, initialize ARKStep’s linear solver interface by
calling {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}}.

Optionally, to specify that ARKStep should use the supplied
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTIMES}]{\sphinxcrossref{\sphinxcode{FARKJTIMES()}}}} and {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKJTSETUP}]{\sphinxcrossref{\sphinxcode{FARKJTSETUP()}}}} routines, the
user should call {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSSETJAC}]{\sphinxcrossref{\sphinxcode{FARKLSSETJAC()}}}} with FLAG \(\ne 0\),
as described in the section {\hyperref[\detokenize{ARKode_f_interface/Usage:finterface-iterative}]{\sphinxcrossref{\DUrole{std,std-ref}{Iterative linear solvers}}}}.

Then, to initialize the ARKBBDPRE preconditioner, call the function
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}}, as described below:
\index{FARKBBDINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBBDINIT}}{\emph{NLOCAL}, \emph{MUDQ}, \emph{MLDQ}, \emph{MU}, \emph{ML}, \emph{DQRELY}, \emph{IER}}{}
Interfaces with the {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecInit()}}}}
routine to initialize the ARKBBDPRE preconditioning module.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLOCAL} (\sphinxcode{long int}, input) \textendash{} local vector size on this
process.

\item {} 
\sphinxstyleemphasis{MUDQ} (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth to be
used in the computation of the local Jacobian blocks by
difference quotients.  These may be smaller than the
true half-bandwidths of the Jacobian of the local block
of \(g\), when smaller values may provide greater
efficiency.

\item {} 
\sphinxstyleemphasis{MLDQ} (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth to be
used in the computation of the local Jacobian blocks by
difference quotients.

\item {} 
\sphinxstyleemphasis{MU} (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth of the
band matrix that is retained as an approximation of the
local Jacobian block (may be smaller than \sphinxstyleemphasis{MUDQ}).

\item {} 
\sphinxstyleemphasis{ML} (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth of the
band matrix that is retained as an approximation of the
local Jacobian block (may be smaller than \sphinxstyleemphasis{MLDQ}).

\item {} 
\sphinxstyleemphasis{DQRELY} (\sphinxcode{realtype}, input) \textendash{} relative increment factor
in \(y\) for difference quotients (0.0 indicates to use
the default).

\item {} 
\sphinxstyleemphasis{IER}  (\sphinxcode{int}, output) \textendash{} return flag (0 if success, -1
if a memory failure).

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\sphinxstyleemphasis{Problem solution}

\item {} 
ARKBBDPRE optional outputs

Optional outputs from the ARKStep linear solver interface are
listed in {\hyperref[\detokenize{ARKode_f_interface/Optional_output:finterface-lsiouttable}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: Optional ARKLS interface outputs}}}}.  To obtain the optional
outputs associated with the ARKBBDPRE module, the user should call
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDOPT}]{\sphinxcrossref{\sphinxcode{FARKBBDOPT()}}}}, as specified below:
\index{FARKBBDOPT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDOPT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBBDOPT}}{\emph{LENRWBBD}, \emph{LENIWBBD}, \emph{NGEBBD}}{}
Interfaces with the ARKBBDPRE optional output functions.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LENRWBP} (\sphinxcode{long int}, output) \textendash{} length of real
preconditioner work space on this process (from
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecGetWorkSpace()}}}}).

\item {} 
\sphinxstyleemphasis{LENIWBP} (\sphinxcode{long int}, output) \textendash{} length of integer
preconditioner work space on this process (from
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecGetWorkSpace()}}}}).

\item {} 
\sphinxstyleemphasis{NGEBBD} (\sphinxcode{long int}, output) \textendash{} number of \(g(t,y)\)
evaluations (from {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecGetNumGfnEvals}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecGetNumGfnEvals()}}}}) so
far.

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\sphinxstyleemphasis{Additional solution output}

\item {} 
Problem re-initialization

If a sequence of problems of the same size is being solved using
the same linear solver in combination with the ARKBBDPRE
preconditioner, then the ARKStep package can be re-initialized for
the second and subsequent problems by calling
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKREINIT}]{\sphinxcrossref{\sphinxcode{FARKREINIT()}}}}, following which a call to
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDREINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDREINIT()}}}} may or may not be needed. If the input
arguments are the same, no {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDREINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDREINIT()}}}} call is
needed.

If there is a change in input arguments other than \sphinxstyleemphasis{MU} or
\sphinxstyleemphasis{ML}, then the user program should call {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDREINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDREINIT()}}}}
as specified below:
\index{FARKBBDREINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDREINIT}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBBDREINIT}}{\emph{NLOCAL}, \emph{MUDQ}, \emph{MLDQ}, \emph{DQRELY}, \emph{IER}}{}
Interfaces with the
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecReInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecReInit()}}}} function to reinitialize the
ARKBBDPRE module.

\sphinxstylestrong{Arguments:}  The arguments of the same names have the same
meanings as in {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}}.

\end{fulllineitems}


However, if the value of \sphinxstyleemphasis{MU} or \sphinxstyleemphasis{ML} is being changed, then a call
to {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}} must be made instead.

Finally, if there is a change in any of the linear solver inputs,
then a call to one of \sphinxcode{FSUNSPGMRINIT()},
\sphinxcode{FSUNSPBCGSINIT()}, \sphinxcode{FSUNSPTFQMRINIT()},
\sphinxcode{FSUNSPFGMRINIT()} or \sphinxcode{FSUNPCGINIT()}, followed by
a call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}} must also be made; in this case
the linear solver memory is reallocated.

\item {} 
Problem resizing

If a sequence of problems of different sizes (but with similar
dynamical time scales) is being solved using the same linear
solver (SPGMR, SPBCG, SPTFQMR, SPFGMR or PCG) in combination with
the ARKBBDPRE preconditioner, then the ARKStep package can be
re-initialized for the second and subsequent problems by calling
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKRESIZE}]{\sphinxcrossref{\sphinxcode{FARKRESIZE()}}}}, following which a call to
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}} is required to delete and re-allocate the
preconditioner memory of the correct size.
\index{FARKBBDREINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKBBDREINIT}}{\emph{NLOCAL}, \emph{MUDQ}, \emph{MLDQ}, \emph{DQRELY}, \emph{IER}}{}
Interfaces with the
{\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKBBDPrecReInit}]{\sphinxcrossref{\sphinxcode{ARKBBDPrecReInit()}}}} function to reinitialize the
ARKBBDPRE module.

\sphinxstylestrong{Arguments:}  The arguments of the same names have the same
meanings as in {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}}.

\end{fulllineitems}


However, if the value of MU or ML is being changed, then a call to
{\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKBBDINIT}]{\sphinxcrossref{\sphinxcode{FARKBBDINIT()}}}} must be made instead.

Finally, if there is a change in any of the linear solver inputs,
then a call to one of \sphinxcode{FSUNSPGMRINIT()},
\sphinxcode{FSUNSPBCGSINIT()}, \sphinxcode{FSUNSPTFQMRINIT()},
\sphinxcode{FSUNSPFGMRINIT()} or \sphinxcode{FSUNPCGINIT()}, followed by
a call to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKLSINIT}]{\sphinxcrossref{\sphinxcode{FARKLSINIT()}}}} must also be made; in this case
the linear solver memory is reallocated.

\item {} 
\sphinxtitleref{Memory deallocation}

(The memory allocated for the FARKBBD module is deallocated
automatically by {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKFREE}]{\sphinxcrossref{\sphinxcode{FARKFREE()}}}}).

\item {} 
User-supplied routines

The following two routines must be supplied for use with the
ARKBBDPRE module:
\index{FARKGLOCFN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKGLOCFN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKGLOCFN}}{\emph{NLOC}, \emph{T}, \emph{YLOC}, \emph{GLOC}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied routine (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKLocalFn}]{\sphinxcrossref{\sphinxcode{ARKLocalFn()}}}}) that
computes a processor-local approximation \(g(t,y)\) to
the right-hand side function \(f^I(t,y)\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLOC} (\sphinxcode{long int}, input) \textendash{} local problem size.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the
independent variable.

\item {} 
\sphinxstyleemphasis{YLOC} (\sphinxcode{realtype}, input) \textendash{} array containing local
dependent state variables.

\item {} 
\sphinxstyleemphasis{GLOC} (\sphinxcode{realtype}, output) \textendash{} array containing local
dependent state derivatives.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array containing
integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array containing
real user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0
if a recoverable error occurred, \textless{}0 if an unrecoverable
error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKCOMMFN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKCOMMFN}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FARKCOMMFN}}{\emph{NLOC}, \emph{T}, \emph{YLOC}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied routine (of type {\hyperref[\detokenize{ARKStep_c_interface/Preconditioners:c.ARKCommFn}]{\sphinxcrossref{\sphinxcode{ARKCommFn()}}}}) that
performs all inter-process communication necessary for the
execution of the {\hyperref[\detokenize{ARKode_f_interface/Preconditioning:f/_/FARKGLOCFN}]{\sphinxcrossref{\sphinxcode{FARKGLOCFN()}}}} function above, using
the input vector \sphinxstyleemphasis{YLOC}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLOC} (\sphinxcode{long int}, input) \textendash{} local problem size.

\item {} 
\sphinxstyleemphasis{T} (\sphinxcode{realtype}, input) \textendash{} current value of the
independent variable.

\item {} 
\sphinxstyleemphasis{YLOC} (\sphinxcode{realtype}, input) \textendash{} array containing local
dependent state variables.

\item {} 
\sphinxstyleemphasis{IPAR} (\sphinxcode{long int}, input/output) \textendash{} array containing
integer user data that was passed to
{\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{RPAR} (\sphinxcode{realtype}, input/output) \textendash{} array containing
real user data that was passed to {\hyperref[\detokenize{ARKode_f_interface/Usage:f/_/FARKMALLOC}]{\sphinxcrossref{\sphinxcode{FARKMALLOC()}}}}.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 if success, \textgreater{}0
if a recoverable error occurred, \textless{}0 if an unrecoverable
error occurred).

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This subroutine must be supplied even if it is not needed, and
must return \sphinxstyleemphasis{IER = 0}.

\end{fulllineitems}


\end{enumerate}


\chapter{Butcher Table Data Structure}
\label{\detokenize{ARKodeButcherTable:arkodebutchertable}}\label{\detokenize{ARKodeButcherTable::doc}}\label{\detokenize{ARKodeButcherTable:butcher-table-data-structure}}
To store the Butcher table defining a Runge Kutta method ARKode provides the
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} type and several related utilitiy routines. We use
the following Butcher table notation (shown for a 3-stage method):
\begin{equation*}
\begin{split}\begin{array}{r|c}
  c & A \\
  \hline
  q & b \\
  p & \tilde{b}
\end{array}
=
\begin{array}{r|ccc}
  c_1 & a_{1,1} & a_{1,2} & a_{1,3} \\
  c_2 & a_{2,1} & a_{2,2} & a_{2,3} \\
  c_3 & a_{3,1} & a_{3,2} & a_{3,3} \\
  \hline
  q & b_1 & b_2 & b_3 \\
  p & \tilde{b}_1 & \tilde{b}_2 & \tilde{b}_3
\end{array}\end{split}
\end{equation*}
where the method and embedding share stage \(A\) and abscissa \(c\)
values, but use their stages \(z_i\) differently through the coefficients
\(b\) and \(\tilde{b}\) to generate methods of orders \(q\) (the
main method) and \(p\) (the embedding, typically \(q = p+1\), though
sometimes this is reversed). {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} is defined as
\index{ARKodeButcherTable (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}}\pysigline{typedef ARKodeButcherTableMem* \sphinxbfcode{ARKodeButcherTable}}
\end{fulllineitems}


where \sphinxcode{ARKodeButcherTableMem} is the structure

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{ARKodeButcherTableMem} \PYG{p}{\PYGZob{}}

  \PYG{k+kt}{int} \PYG{n}{q}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{p}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{stages}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{A}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{c}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{d}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{stages} is the number of stages in the RK method, the variables \sphinxcode{q},
\sphinxcode{p}, \sphinxcode{A}, \sphinxcode{c}, and \sphinxcode{b} have the same meaning as in the Butcher table
above, and \sphinxcode{d} is used to store \(\tilde{b}\).


\section{ARKodeButcherTable functions}
\label{\detokenize{ARKodeButcherTable:arkodebutchertable-functions}}\label{\detokenize{ARKodeButcherTable:id1}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Function name
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Description
\unskip}\relax \\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}
&
Retrieve a given explicit Butcher table by its unique name
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}
&
Retrieve a given implicit Butcher table by its unique name
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Alloc}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_Alloc()}}}}
&
Allocate an empty Butcher table
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Create}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_Create()}}}}
&
Create a new Butcher table
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Copy}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_Copy()}}}}
&
Create a copy of a Butcher table
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Space}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_Space()}}}}
&
Get the Butcher table real and integer workspace size
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Free}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_Free()}}}}
&
Deallocate a Butcher table
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Write}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_Write()}}}}
&
Write the Butcher table to an output file
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_CheckOrder}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_CheckOrder()}}}}
&
Check the order of a Butcher table
\\
\hline
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_CheckARKOrder}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_CheckARKOrder()}}}}
&
Check the order of an ARK pair of Butcher tables
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{ARKodeButcherTable\_LoadERK (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}}\pysiglinewithargsret{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}} \sphinxbfcode{ARKodeButcherTable\_LoadERK}}{int\sphinxstyleemphasis{ emethod}}{}
Retrieves a specified explicit Butcher table. The prototype for this
function, as well as the integer names for each provided method, are defined
in the header file \sphinxcode{arkode/arkode\_butcher\_erk.h}.  For further information
on these tables and their corresponding identifiers, see {\hyperref[\detokenize{Butcher:butcher}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: Butcher tables}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{emethod} \textendash{} integer input specifying the given Butcher table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{imethod} was invalid.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeButcherTable\_LoadDIRK (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}}\pysiglinewithargsret{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}} \sphinxbfcode{ARKodeButcherTable\_LoadDIRK}}{int\sphinxstyleemphasis{ imethod}}{}
Retrieves a specified diagonally-implicit Butcher table. The prototype for
this function, as well as the integer names for each provided method, are
defined in the header file \sphinxcode{arkode/arkode\_butcher\_dirk.h}.  For further
information on these tables and their corresponding identifiers, see
{\hyperref[\detokenize{Butcher:butcher}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix: Butcher tables}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{imethod} \textendash{} integer input specifying the given Butcher table.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{imethod} was invalid.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeButcherTable\_Alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Alloc}}\pysiglinewithargsret{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}} \sphinxbfcode{ARKodeButcherTable\_Alloc}}{int\sphinxstyleemphasis{ stages}, booleantype\sphinxstyleemphasis{ embedded}}{}
Allocates an empty Butcher table.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{stages} \textendash{} the number of stages in the Butcher table.

\item {} 
\sphinxstyleemphasis{embedded} \textendash{} flag denoting whether the Butcher table has an embedding
(\sphinxcode{SUNTRUE}) or not (\sphinxcode{SUNFALSE}).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{stages} was invalid or an allocation error occured.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeButcherTable\_Create (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Create}}\pysiglinewithargsret{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}} \sphinxbfcode{ARKodeButcherTable\_Create}}{int\sphinxstyleemphasis{ s}, int\sphinxstyleemphasis{ q}, int\sphinxstyleemphasis{ p}, realtype\sphinxstyleemphasis{ *c}, realtype\sphinxstyleemphasis{ *A}, realtype\sphinxstyleemphasis{ *b}, realtype\sphinxstyleemphasis{ *d}}{}
Allocates a Butcher table and fills it with the given values.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{s} \textendash{} number of stages in the RK method.

\item {} 
\sphinxstyleemphasis{q} \textendash{} global order of accuracy for the RK method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} global order of accuracy for the embedded RK method.

\item {} 
\sphinxstyleemphasis{c} \textendash{} array (of length \sphinxstyleemphasis{s}) of stage times for the RK method.

\item {} 
\sphinxstyleemphasis{A} \textendash{} array of coefficients defining the RK stages. This should be
stored as a 1D array of size \sphinxstyleemphasis{s*s}, in row-major order.

\item {} 
\sphinxstyleemphasis{b} \textendash{} array of coefficients (of length \sphinxstyleemphasis{s}) defining the time step solution.

\item {} 
\sphinxstyleemphasis{d} \textendash{} array of coefficients (of length \sphinxstyleemphasis{s}) defining the embedded solution.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer if \sphinxstyleemphasis{stages} was invalid or an allocation error occured.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} If the method does not have an embedding then \sphinxstyleemphasis{d} should be
\sphinxcode{NULL} and \sphinxstyleemphasis{p} should be equal to zero.

\end{fulllineitems}

\index{ARKodeButcherTable\_Copy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Copy}}\pysiglinewithargsret{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}} \sphinxbfcode{ARKodeButcherTable\_Copy}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}}{}
Creates copy of the given Butcher table.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table to copy.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable}}}} structure if successful.

\item {} 
\sphinxcode{NULL} pointer an allocation error occured.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeButcherTable\_Space (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Space}}\pysiglinewithargsret{void \sphinxbfcode{ARKodeButcherTable\_Space}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}, sunindextype\sphinxstyleemphasis{ *liw}, sunindextype\sphinxstyleemphasis{ *lrw}}{}
Get the real and integer workspace size for a Butcher table.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table.

\item {} 
\sphinxstyleemphasis{lenrw} \textendash{} the number of \sphinxcode{realtype} values in the Butcher table workspace.

\item {} 
\sphinxstyleemphasis{leniw} \textendash{} the number of integer values in the Butcher table workspace.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful.

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the Butcher table memory was \sphinxcode{NULL}.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeButcherTable\_Free (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Free}}\pysiglinewithargsret{void \sphinxbfcode{ARKodeButcherTable\_Free}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}}{}
Deallocate the Butcher table memory.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeButcherTable\_Write (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_Write}}\pysiglinewithargsret{void \sphinxbfcode{ARKodeButcherTable\_Write}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}, FILE\sphinxstyleemphasis{ *outfile}}{}
Write the Butcher table to the provided file pointer.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table.

\item {} 
\sphinxstyleemphasis{outfile} \textendash{} pointer to use for printing the Butcher table.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} The \sphinxstyleemphasis{outfile} argument can be \sphinxcode{stdout} or \sphinxcode{stderr}, or it
may point to a specific file created using \sphinxcode{fopen}.

\end{fulllineitems}

\index{ARKodeButcherTable\_CheckOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_CheckOrder}}\pysiglinewithargsret{int \sphinxbfcode{ARKodeButcherTable\_CheckOrder}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B}, int*\sphinxstyleemphasis{ q}, int*\sphinxstyleemphasis{ p}, FILE*\sphinxstyleemphasis{ outfile}}{}
Determine the analytic order of accuracy for the specified Butcher
table. The analytic (necessary) conditions are checked up to order 6. For
orders greater than 6 the Butcher simplifying (sufficient) assumptions are
used.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B} \textendash{} the Butcher table.

\item {} 
\sphinxstyleemphasis{q} \textendash{} the measured order of accuracy for the method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} the measured order of accuracy for the embedding; 0 if the
method does not have an embedding.

\item {} 
\sphinxstyleemphasis{outfile} \textendash{} file pointer for printing results; \sphinxcode{NULL} to suppress
output.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{0} \textendash{} success, the measured vales of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} match the values of
\sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} in the provided Butcher tables.

\item {} 
\sphinxstyleemphasis{1} \textendash{} warning, the values of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} in the provided Butcher tables
are \sphinxstyleemphasis{lower} than the measured values, or the measured values achieve the
\sphinxstyleemphasis{maximum order} possible with this function and the values of \sphinxstyleemphasis{q} and
\sphinxstyleemphasis{p} in the provided Butcher tables table are higher.

\item {} 
\sphinxstyleemphasis{-1} \textendash{} failure, the values of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} in the provided Butcher tables
are \sphinxstyleemphasis{higher} than the measured values.

\item {} 
\sphinxstyleemphasis{-2} \textendash{} failure, the input Butcher table or critical table contents are
\sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} For embedded methods, if the return flags for \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} would
differ, failure takes precedence over warning, which takes precedence over
success.

\end{fulllineitems}

\index{ARKodeButcherTable\_CheckARKOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_CheckARKOrder}}\pysiglinewithargsret{int \sphinxbfcode{ARKodeButcherTable\_CheckARKOrder}}{{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B1}, {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable}]{\sphinxcrossref{ARKodeButcherTable}}}\sphinxstyleemphasis{ B2}, int\sphinxstyleemphasis{ *q}, int\sphinxstyleemphasis{ *p}, FILE\sphinxstyleemphasis{ *outfile}}{}
Determine the analytic order of accuracy (up to order 6) for a specified
ARK pair of Butcher tables.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{B1} \textendash{} a Butcher table in the ARK pair.

\item {} 
\sphinxstyleemphasis{B2} \textendash{} a Butcher table in the ARK pair.

\item {} 
\sphinxstyleemphasis{q} \textendash{} the measured order of accuracy for the method.

\item {} 
\sphinxstyleemphasis{p} \textendash{} the measured order of accuracy for the embedding; 0 if the
method does not have an embedding.

\item {} 
\sphinxstyleemphasis{outfile} \textendash{} file pointer for printing results; \sphinxcode{NULL} to suppress
output.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{0} \textendash{} success, the measured vales of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} match the values of
\sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} in the provided Butcher tables.

\item {} 
\sphinxstyleemphasis{1} \textendash{} warning, the values of \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} in the provided Butcher tables
are \sphinxstyleemphasis{lower} than the measured values, or the measured values achieve the
\sphinxstyleemphasis{maximum order} possible with this function and the values of \sphinxstyleemphasis{q} and
\sphinxstyleemphasis{p} in the provided Butcher tables table are higher.

\item {} 
\sphinxstyleemphasis{-1} \textendash{} failure, the input Butcher tables or critical table contents are
\sphinxcode{NULL}.

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:} For embedded methods, if the return flags for \sphinxstyleemphasis{q} and \sphinxstyleemphasis{p} would
differ, warning takes precedence over success.

\end{fulllineitems}



\chapter{ARKODE Features for GPU Accelerated Computing}
\label{\detokenize{ARKodeGpu:arkode-features-for-gpu-accelerated-computing}}\label{\detokenize{ARKodeGpu::doc}}\label{\detokenize{ARKodeGpu:arkodegpu}}
This chapter is concerned with using GPU-acceleration and ARKODE for the
solution of IVPs.


\section{SUNDIALS GPU Programming Model}
\label{\detokenize{ARKodeGpu:sundials-gpu-programming-model}}\label{\detokenize{ARKodeGpu:arkodegpu-model}}
In this section, we introduce the SUNDIALS GPU programming model and
highlight SUNDIALS GPU features. The model leverages the fact that all
of the SUNDIALS packages interact with simulation data either through
the shared vector, matrix, and solver APIs (see {\hyperref[\detokenize{nvectors/index:nvectors}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Data Structures}}}},
{\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}}, {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}, and {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}}) or through
user-supplied callback functions. Thus, under the model, the overall
structure of the user’s calling program, and the way users interact with
the SUNDIALS packages is similar to using SUNDIALS in CPU-only
environments.

Within the SUNDIALS GPU programming model, all control logic executes on
the CPU, and all simulation data resides wherever the vector or matrix
object dictates as long as SUNDIALS is in control of the program. That
is, SUNDIALS will not migrate data (explicitly) from one memory space to
another. Except in the most advanced use cases, it is safe to assume
that data is kept resident in the GPU-device memory space. The
consequence of this is that, when control is passed from the user’s
calling program to SUNDIALS, simulation data in vector or matrix objects
must be up-to-date in the device memory space. Similarly, when control
is passed from SUNDIALS to the user’s calling program, the user should
assume that any simulation data in vector and matrix objects are
up-to-date in the device memory space. To put it succinctly, \sphinxstyleemphasis{it is the
responsibility of the user’s calling program to manage data coherency
between the CPU and GPU-device memory spaces} unless unified virtual
memory (UVM), also known as managed memory, is being utilized.
Typically, the GPU-enabled SUNDIALS modules provide functions to copy
data from the host to the device and vice-versa as well as support for
unmanaged memory or UVM. In practical terms, the way SUNDIALS handles
distinct host and device memory spaces means that \sphinxstyleemphasis{users need to ensure
that the user-supplied functions, e.g. the right-hand side function,
only operate on simulation data in the device memory space} otherwise
extra memory transfers will be required and performance will be poor.
The exception to this rule is if some form of hybrid data partitioning
(achievable with the {\hyperref[\detokenize{nvectors/NVector_ManyVector:nvectors-manyvector}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_MANYVECTOR Module}}}}) is utilized.

SUNDIALS provides many native shared features and modules that are GPU-enabled.
Currently, these are primarily limited to the NVIDIA CUDA platform \phantomsection\label{\detokenize{ARKodeGpu:id1}}{\hyperref[\detokenize{References:cuda}]{\sphinxcrossref{{[}CUDA{]}}}},
although support for more GPU computing platforms such as AMD ROCm/HIP \phantomsection\label{\detokenize{ARKodeGpu:id2}}{\hyperref[\detokenize{References:rocm}]{\sphinxcrossref{{[}ROCm{]}}}}
and Intel oneAPI \phantomsection\label{\detokenize{ARKodeGpu:id3}}{\hyperref[\detokenize{References:oneapi}]{\sphinxcrossref{{[}oneAPI{]}}}}, is an area of active development. Table
{\hyperref[\detokenize{ARKodeGpu:arkodegpu-table}]{\sphinxcrossref{\DUrole{std,std-ref}{List of SUNDIALS GPU-enabled Modules}}}} summarizes the shared SUNDIALS modules that are
GPU-enabled, what GPU programming environments they support, and what class of
memory they support (unmanaged or UVM). Users may also supply their own
GPU-enabled \sphinxcode{N\_Vector},  \sphinxcode{SUNMatrix}, \sphinxcode{SUNLinearSolver}, or
\sphinxcode{SUNNonlinearSolver} implementation, and the capabilties will be leveraged
since SUNDIALS operates on data through these APIs.

In addition, SUNDIALS provides {\hyperref[\detokenize{sunmemory/index:sunmemory}]{\sphinxcrossref{\DUrole{std,std-ref}{Tools for Memory Management}}}} to support
applications which implement their own memory management or memory
pooling.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{List of SUNDIALS GPU-enabled Modules}\label{\detokenize{ARKodeGpu:arkodegpu-table}}\label{\detokenize{ARKodeGpu:id4}}
\sphinxaftercaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Module
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CUDA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ROCm/HIP
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
oneAPI
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Unmanaged Memory
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
UVM
\unskip}\relax \\
\hline
{\hyperref[\detokenize{nvectors/NVector_CUDA:nvectors-cuda}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR\_CUDA}}}}
&
X
&&&
X
&
X
\\
\hline
{\hyperref[\detokenize{nvectors/NVector_RAJA:nvectors-raja}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR\_RAJA}}}}
&
X
&&&
X
&
X
\\
\hline
{\hyperref[\detokenize{nvectors/NVector_OpenMPDEV:nvectors-openmpdev}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR\_OPENMPDEV}}}}
&
X
&
X$^{\text{2}}$
&
X$^{\text{2}}$
&
X
&\\
\hline
{\hyperref[\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX\_CUSPARSE}}}}
&
X
&&&
X
&
X
\\
\hline
{\hyperref[\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL\_CUSOLVERSP}}}}
&
X
&&&
X
&
X
\\
\hline
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:sunlinsol-spgmr}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL\_SPGMR}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:sunlinsol-spfgmr}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL\_SPFGMR}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:sunlinsol-sptfqmr}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL\_SPTFQMR}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:sunlinsol-spbcgs}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL\_SPBCGS}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
{\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:sunlinsol-pcg}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLINSOL\_PCG}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsol-newton}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNONLINSOL\_NEWTON}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsol-fixedpoint}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNONLINSOL\_FIXEDPOINT}}}}
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
&
X$^{\text{1}}$
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{enumerate}
\item {} 
This module inherits support from the NVECTOR module used

\item {} 
Support for ROCm/HIP and oneAPI are currently untested.

\end{enumerate}

In addition, note that implicit UVM (i.e. \sphinxcode{malloc} returning UVM) is not
accounted for.


\section{Steps for Using GPU Accelerated SUNDIALS}
\label{\detokenize{ARKodeGpu:steps-for-using-gpu-accelerated-sundials}}\label{\detokenize{ARKodeGpu:arkodegpu-usage}}
For any SUNDIALS package, the generalized steps a user needs to take to
use GPU accelerated SUNDIALS are:
\begin{enumerate}
\item {} 
Utilize a GPU-enabled vector implementation. Initial data can be loaded on
the host, but must be in the device memory space prior to handing
control to SUNDIALS.

\item {} 
Utilize a GPU-enabled linear solver (if necessary).

\item {} 
Utilize a GPU-enabled implementation (if using a matrix-based linear
solver).

\item {} 
Utilize a GPU-enabled nonlinear solver (if necessary).

\item {} 
Write user-supplied functions so that they use data only in the
device memory space (again, unless an atypical data partitioning is
used). A few examples of these functions are the right-hand side
evaluation function, the Jacobian evalution function, or the
preconditioner evaulation function. In the context of CUDA and the
right-hand side function, one way a user might ensure data is
accessed on the device is, for example, calling a CUDA kernel, which
does all of the computation, from a CPU function which simply
extracts the underlying device data array from the vector object that is
passed from SUNDIALS to the user-supplied function.

\end{enumerate}

Users should refer to Table {\hyperref[\detokenize{ARKodeGpu:arkodegpu-table}]{\sphinxcrossref{\DUrole{std,std-ref}{List of SUNDIALS GPU-enabled Modules}}}} for a list of
GPU-enabled native SUNDIALS modules.


\chapter{Vector Data Structures}
\label{\detokenize{nvectors/index:vector-data-structures}}\label{\detokenize{nvectors/index::doc}}\label{\detokenize{nvectors/index:nvectors}}
The SUNDIALS library comes packaged with a variety of NVECTOR
implementations, designed for simulations in serial, shared-memory
parallel, and distributed-memory parallel environments, as well as
interfaces to vector data structures used within external linear
solver libraries.  All native implementations assume that the
process-local data is stored contiguously, and they in turn provide a
variety of standard vector algebra operations that may be performed on
the data.

In addition, SUNDIALS provides a simple interface for generic vectors
(akin to a C++ \sphinxstyleemphasis{abstract base class}).  All of the major SUNDIALS
solvers (CVODE(s), IDA(s), KINSOL, ARKODE) in turn are constructed to
only depend on these generic vector operations, making them immediately
extensible to new user-defined vector objects.  The only exceptions to
this rule relate to the dense, banded and sparse-direct linear system
solvers, since they rely on particular data storage and access
patterns in the NVECTORS used.


\section{Description of the NVECTOR Modules}
\label{\detokenize{nvectors/NVector_Description:description-of-the-nvector-modules}}\label{\detokenize{nvectors/NVector_Description::doc}}\label{\detokenize{nvectors/NVector_Description:nvectors-description}}
The SUNDIALS solvers are written in a data-independent manner. They
all operate on generic vectors (of type \sphinxcode{N\_Vector}) through a set of
operations defined by, and specific to, the particular NVECTOR
implementation. Users can provide a custom implementation of the
NVECTOR module or use one of four provided within SUNDIALS \textendash{} a serial
and three parallel implementations.  The generic operations are
described below.  In the sections following, the implementations
provided with SUNDIALS are described.

The generic \sphinxcode{N\_Vector} type is a pointer to a structure that has an
implementation-dependent \sphinxstyleemphasis{content} field containing the description
and actual data of the vector, and an \sphinxstyleemphasis{ops} field pointing to a
structure with generic vector operations. The type \sphinxcode{N\_Vector} is
defined as:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector} \PYG{p}{\PYGZob{}}
   \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
   \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Here, the \sphinxcode{\_generic\_N\_Vector\_Op} structure is essentially a list of
function pointers to the various actual vector operations, and is
defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
   \PYG{n}{N\PYGZus{}Vector\PYGZus{}ID}  \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetvectorid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{N\PYGZus{}Vector}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvclone}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{N\PYGZus{}Vector}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvcloneempty}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdestroy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvspace}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{sunindextype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{sunindextype} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}\PYG{o}{*}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetarraypointer}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}\PYG{o}{*}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetdevicearraypointer}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvsetarraypointer}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}\PYG{o}{*}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetcommunicator}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{sunindextype} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetlength}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvlinearsum}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvconst}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvprod}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdiv}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}           \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvscale}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}           \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvabs}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvinv}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvaddconst}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdotprod}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvmaxnorm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwrmsnorm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwrmsnormmask}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvmin}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwl2norm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvl1norm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvcompare}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{booleantype}  \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvinvtest}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{booleantype}  \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvconstrmask}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvminquotient}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvlinearcombination}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvscaleaddmulti}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdotprodmulti}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,}  \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvlinearsumvectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,}
                                          \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvscalevectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,}  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvconstvectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwrmsnomrvectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwrmsnomrmaskvectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,}
                                             \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvscaleaddmultivectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{,}
                                              \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvlinearcombinationvectorarray}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{o}{*}\PYG{p}{,}
                                                  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdotprodlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvmaxnormlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvminlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvl1normlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{booleantype}  \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvinvtestlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{booleantype}  \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvconstrmasklocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvminquotientlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwsqrsumlocal}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwsqrsummasklocal}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvbufsize}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{sunindextype} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvbufpack}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvbufunpack}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The generic NVECTOR module defines and implements the vector
operations acting on a \sphinxcode{N\_Vector}. These routines are nothing but
wrappers for the vector operations defined by a particular NVECTOR
implementation, which are accessed through the \sphinxstyleemphasis{ops} field of the
\sphinxcode{N\_Vector} structure. To illustrate this point we show below the
implementation of a typical vector operation from the generic NVECTOR
module, namely \sphinxcode{N\_VScale}, which performs the scaling of a vector
\sphinxcode{x} by a scalar \sphinxcode{c}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{N\PYGZus{}VScale}\PYG{p}{(}\PYG{n}{realtype} \PYG{n}{c}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{x}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{z}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{z}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{nvscale}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The subsection {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}} contains a complete list of all
standard vector operations defined by the generic NVECTOR module.  The
subsections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}} and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-exchangeops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR exchange operations}}}} list \sphinxstyleemphasis{optional}
fused, vector array, local reduction, and exchange operations respectively.

Fused and vector array operations are intended to increase data reuse, reduce
parallel communication on distributed memory systems, and lower the number of
kernel launches on systems with accelerators. If a particular NVECTOR
implementation defines a fused or vector array operation as \sphinxcode{NULL}, the
generic NVECTOR module will automatically call standard vector operations as
necessary to complete the desired operation. In all SUNDIALS-provided
NVECTOR implementations, all fused and vector array operations are
disabled by default.  However, these implementations provide
additional user-callable functions to enable/disable any or all of the
fused and vector array operations. See the following sections
for the implementation specific functions to enable/disable operations.

Local reduction operations are similarly intended to reduce parallel
communication on distributed memory systems, particularly when
NVECTOR objects are combined together within a NVECTOR\_MANYVECTOR
object (see the section {\hyperref[\detokenize{nvectors/NVector_ManyVector:nvectors-manyvector}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_MANYVECTOR Module}}}}).  If a
particular NVECTOR implementation defines a local reduction
operation as \sphinxcode{NULL}, the NVECTOR\_MANYVECTOR module will
automatically call standard vector reduction operations as necessary
to complete the desired operation. All SUNDIALS-provided NVECTOR
implementations include these local reduction operations, which may be
used as templates for user-defined NVECTOR implementations.

The exchange operations are intended only for use with the XBraid library
for parallel-in-time integration and are otherwise unused by SUNDIALS
packages.


\subsection{NVECTOR Utility Functions}
\label{\detokenize{nvectors/NVector_Description:nvector-utility-functions}}\label{\detokenize{nvectors/NVector_Description:nvectors-utilities}}
The generic NVECTOR module also defines the utility functions
\sphinxcode{N\_VCloneVectorArray}, \sphinxcode{N\_VCloneVectorArrayEmpty}, and
\sphinxcode{N\_VDestroyVectorArray}. Both clone functions create (by cloning) an array of
\sphinxstyleemphasis{count} variables of type \sphinxcode{N\_Vector}, each of the same type as an existing
\sphinxcode{N\_Vector}. Their prototypes are:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n+nf}{N\PYGZus{}VCloneVectorArray}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n+nf}{N\PYGZus{}VCloneVectorArrayEmpty}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and their definitions are based on the implementation-specific
\sphinxcode{N\_VClone} and \sphinxcode{N\_VCloneEmpty} operations, respectively.
An array of variables of type \sphinxcode{N\_Vector} can be destroyed
by calling \sphinxcode{N\_VDestroyVectorArray}, whose prototype is

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{N\PYGZus{}VDestroyVectorArray}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{vs}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and whose definition is based on the implementation-specific
\sphinxcode{N\_VDestroy} operation.

Finally, we note that users of the Fortran 2003 interface may be interested in
the additional utility functions \sphinxcode{N\_NewVectorArray}, \sphinxcode{N\_VGetVecAtIndexVectorArray},
and \sphinxcode{N\_VSetVecAtIndexVectorArray}. These functions allow a Fortran 2003 user to
create an empty vector array, get a vector at an index, and set a vector at an
index. There prototypes are given below:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n+nf}{N\PYGZus{}VNewVectorArray}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n+nf}{N\PYGZus{}VGetVecAtIndexVectorArray}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{o}{*} \PYG{n}{vs}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void} \PYG{n}{N\PYGZus{}VSetVecAtIndexVectorArray}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{o}{*} \PYG{n}{vs}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{index}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{w}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Vector Identifications associated with vector kernels supplied with SUNDIALS}
\label{\detokenize{nvectors/NVector_Description:nvector-vectorids}}\label{\detokenize{nvectors/NVector_Description:vector-identifications-associated-with-vector-kernels-supplied-with-sundials}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Vector ID
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Vector type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ID Value
\unskip}\relax \\
\hline
SUNDIALS\_NVEC\_SERIAL
&
Serial
&
0
\\
\hline
SUNDIALS\_NVEC\_PARALLEL
&
Distributed memory parallel (MPI)
&
1
\\
\hline
SUNDIALS\_NVEC\_OPENMP
&
OpenMP shared memory parallel
&
2
\\
\hline
SUNDIALS\_NVEC\_PTHREADS
&
PThreads shared memory parallel
&
3
\\
\hline
SUNDIALS\_NVEC\_PARHYP
&
\sphinxstyleemphasis{hypre} ParHyp parallel vector
&
4
\\
\hline
SUNDIALS\_NVEC\_PETSC
&
PETSc parallel vector
&
5
\\
\hline
SUNDIALS\_NVEC\_CUDA
&
CUDA parallel vector
&
6
\\
\hline
SUNDIALS\_NVEC\_RAJA
&
RAJA parallel vector
&
7
\\
\hline
SUNDIALS\_NVEC\_OPENMPDEV
&
OpenMP parallel vector with device offloading
&
8
\\
\hline
SUNDIALS\_NVEC\_TRILINOS
&
Trilinos Tpetra vector
&
9
\\
\hline
SUNDIALS\_NVEC\_MANYVECTOR
&
“ManyVector” vector
&
10
\\
\hline
SUNDIALS\_NVEC\_MPIMANYVECTOR
&
MPI-enabled “ManyVector” vector
&
11
\\
\hline
SUNDIALS\_NVEC\_MPIPLUSX
&
MPI+X vector
&
12
\\
\hline
SUNDIALS\_NVEC\_CUSTOM
&
User-provided custom vector
&
13
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Implementing a custom NVECTOR}
\label{\detokenize{nvectors/NVector_Description:nvector-custom-implementation}}\label{\detokenize{nvectors/NVector_Description:implementing-a-custom-nvector}}
A particular implementation of the NVECTOR module must:
\begin{itemize}
\item {} 
Specify the \sphinxstyleemphasis{content} field of \sphinxcode{N\_Vector}.

\item {} 
Define and implement the vector operations.  Note that the names of
these routines should be unique to that implementation in order to
permit using more than one NVECTOR module (each with different
\sphinxcode{N\_Vector} internal data representations) in the same code.

\item {} 
Define and implement user-callable constructor and destructor
routines to create and free an \sphinxcode{N\_Vector} with
the new \sphinxstyleemphasis{content} field and with \sphinxstyleemphasis{ops} pointing to the
new vector operations.

\item {} 
Optionally, define and implement additional user-callable routines
acting on the newly defined \sphinxcode{N\_Vector} (e.g., a routine to print
the content for debugging purposes).

\item {} 
Optionally, provide accessor macros as needed for that particular implementation to
be used to access different parts in the \sphinxstyleemphasis{content} field of the
newly defined \sphinxcode{N\_Vector}.

\end{itemize}

To aid in the creation of custom NVECTOR modules the generic NVECTOR module
provides two utility functions {\hyperref[\detokenize{nvectors/NVector_Description:c.N_VNewEmpty}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty()}}}} and
{\hyperref[\detokenize{nvectors/NVector_Description:c.N_VCopyOps}]{\sphinxcrossref{\sphinxcode{N\_VCopyOps()}}}}. When used in custom NVECTOR constructors and clone
routines these functions will ease the introduction of any new optional vector
operations to the NVECTOR API by ensuring only required operations need to be
set and all operations are copied when cloning a vector.
\index{N\_VNewEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Description:c.N_VNewEmpty}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty}}{}{}
This allocates a new generic \sphinxcode{N\_Vector} object and initializes its content
pointer and the function pointers in the operations structure to \sphinxcode{NULL}.

\sphinxstylestrong{Return value:} If successful, this function returns an \sphinxcode{N\_Vector}
object. If an error occurs when allocating the object, then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VFreeEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Description:c.N_VFreeEmpty}}\pysiglinewithargsret{void \sphinxbfcode{N\_VFreeEmpty}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This routine frees the generic \sphinxcode{N\_Vector} object, under the assumption that any
implementation-specific data that was allocated within the underlying content structure
has already been freed. It will additionally test whether the ops pointer is \sphinxcode{NULL},
and, if it is not, it will free it as well.
\begin{quote}
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{v} \textendash{} an N\_Vector object

\end{itemize}

\end{description}
\end{quote}

\end{fulllineitems}

\index{N\_VCopyOps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Description:c.N_VCopyOps}}\pysiglinewithargsret{int \sphinxbfcode{N\_VCopyOps}}{N\_Vector\sphinxstyleemphasis{ w}, N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies the function pointers in the \sphinxcode{ops} structure of \sphinxcode{w}
into the \sphinxcode{ops} structure of \sphinxcode{v}.
\begin{quote}
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{w} \textendash{} the vector to copy operations from

\item {} 
\sphinxstyleemphasis{v} \textendash{} the vector to copy operations to

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  If successful, this function returns \sphinxcode{0}. If either of
the inputs are \sphinxcode{NULL} or the \sphinxcode{ops} structure of either input is \sphinxcode{NULL},
then is function returns a non-zero value.
\end{quote}

\end{fulllineitems}


Each NVECTOR implementation included in SUNDIALS has a unique
identifier specified in enumeration and shown in the table below.
It is recommended that a user supplied NVECTOR implementation use the
\sphinxcode{SUNDIALS\_NVEC\_CUSTOM} identifier.


\subsubsection{Support for complex-valued vectors}
\label{\detokenize{nvectors/NVector_Description:support-for-complex-valued-vectors}}
While SUNDIALS itself is written under an assumption of real-valued
data, it does provide limited support for complex-valued problems.
However, since none of the built-in NVECTOR modules supports
complex-valued data, users must provide a custom NVECTOR
implementation for this task.  Many of the NVECTOR routines
described in the subsections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}} through
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} above naturally extend to complex-valued
vectors; however, some do not.  To this end, we provide the
following guidance:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMin}]{\sphinxcrossref{\sphinxcode{N\_VMin()}}}} and \sphinxcode{N\_VMinLocal())()} should return the
minimum of all \sphinxstyleemphasis{real} components of the vector, i.e.,  \(m = \min_i
\operatorname{real}(x_i)\).

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConst}]{\sphinxcrossref{\sphinxcode{N\_VConst()}}}} (and similarly {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VConstVectorArray()}}}}) should
set the real components of the vector to the input constant, and set
all imaginary components to zero, i.e., \(z_i = c + 0 j,\: i=0,\ldots,n-1\).

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VAddConst}]{\sphinxcrossref{\sphinxcode{N\_VAddConst()}}}} should only update the real components of the
vector with the input constant, leaving all imaginary components
unchanged.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWrmsNorm}]{\sphinxcrossref{\sphinxcode{N\_VWrmsNorm()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormMask}]{\sphinxcrossref{\sphinxcode{N\_VWrmsNormMask()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWSqrSumLocal}]{\sphinxcrossref{\sphinxcode{N\_VWSqrSumLocal()}}}} and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWSqrSumMaskLocal}]{\sphinxcrossref{\sphinxcode{N\_VWSqrSumMaskLocal()}}}}
should assume that all entries of the weight vector \sphinxcode{w} and the
mask vector \sphinxcode{id} are real-valued.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}} should mathematically return a complex number
for complex-valued vectors; as this is not possible with
SUNDIALS’ current \sphinxcode{realtype}, this routine should
be set to \sphinxcode{NULL} in the custom NVECTOR implementation.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VCompare}]{\sphinxcrossref{\sphinxcode{N\_VCompare()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMask}]{\sphinxcrossref{\sphinxcode{N\_VConstrMask()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotient}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotient()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMaskLocal}]{\sphinxcrossref{\sphinxcode{N\_VConstrMaskLocal()}}}} and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotientLocal}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotientLocal()}}}}
are ill-defined due to the lack of a clear ordering in the
complex plane.  These routines should be set to \sphinxcode{NULL}
in the custom NVECTOR implementation.

\end{itemize}

While many SUNDIALS solver modules may be utilized on
complex-valued data, others cannot.  Specifically, although both
SUNNonlinearSolver\_Newton and SUNNonlinearSolver\_FixedPoint may be
used with any of the IVP solvers (CVODE(S), IDA(S) and ARKode) for
complex-valued problems, the Anderson-acceleration feature
SUNNonlinearSolver\_FixedPoint cannot be used due to its reliance on
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}.  By this same logic, the Anderson acceleration
feature within KINSOL also will not work with complex-valued vectors.

Similarly, although each package’s linear solver interface (e.g.,
ARKLS) may be used on complex-valued problems, none of the built-in
SUNMatrix or SUNLinearSolver modules work.  Hence a complex-valued
user should provide a custom SUNLinearSolver (and optionally a custom
SUNMatrix) implementation for solving linear systems, and then
attach this module as normal to the package’s linear solver
interface.

Finally, constraint-handling features of each package cannot be used
for complex-valued data, due to the issue of
ordering in the complex plane discussed above with
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VCompare}]{\sphinxcrossref{\sphinxcode{N\_VCompare()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMask}]{\sphinxcrossref{\sphinxcode{N\_VConstrMask()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotient}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotient()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMaskLocal}]{\sphinxcrossref{\sphinxcode{N\_VConstrMaskLocal()}}}} and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotientLocal}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotientLocal()}}}}.

We provide a simple example of a complex-valued example problem,
including a custom complex-valued Fortran 2003 NVECTOR module, in the
files \sphinxcode{examples/arkode/F2003\_custom/ark\_analytic\_complex\_f2003.f90},
\sphinxcode{examples/arkode/F2003\_custom/fnvector\_complex\_mod.f90}, and
\sphinxcode{examples/arkode/F2003\_custom/test\_fnvector\_complex\_mod.f90}.


\section{Description of the NVECTOR operations}
\label{\detokenize{nvectors/NVector_Operations:nvectors-ops}}\label{\detokenize{nvectors/NVector_Operations::doc}}\label{\detokenize{nvectors/NVector_Operations:description-of-the-nvector-operations}}
The standard vector operations defined by the generic \sphinxcode{N\_Vector}
module are defined as follows.  For each of these operations, we give
the name, usage of the function, and a description of its mathematical
operations below.
\index{N\_VGetVectorID (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VGetVectorID}}\pysiglinewithargsret{N\_Vector\_ID \sphinxbfcode{N\_VGetVectorID}}{N\_Vector\sphinxstyleemphasis{ w}}{}
Returns the vector type identifier for the vector \sphinxcode{w}.  It is
used to determine the vector implementation type (e.g. serial,
parallel, …) from the abstract \sphinxcode{N\_Vector} interface.  Returned
values are given in the table, {\hyperref[\detokenize{nvectors/NVector_Description:nvector-vectorids}]{\sphinxcrossref{\DUrole{std,std-ref}{Vector Identifications associated with vector kernels supplied with SUNDIALS}}}}

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{id} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetVectorID}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VClone (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VClone}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VClone}}{N\_Vector\sphinxstyleemphasis{ w}}{}
Creates a new \sphinxcode{N\_Vector} of the same type as an existing vector
\sphinxstyleemphasis{w} and sets the \sphinxstyleemphasis{ops} field.  It does not copy the vector, but
rather allocates storage for the new vector.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{n}{N\PYGZus{}VClone}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VCloneEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VCloneEmpty}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VCloneEmpty}}{N\_Vector\sphinxstyleemphasis{ w}}{}
Creates a new \sphinxcode{N\_Vector} of the same type as an existing vector
\sphinxstyleemphasis{w} and sets the \sphinxstyleemphasis{ops} field.  It does not allocate storage for the
new vector’s data.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{n}{N} \PYG{n}{VCloneEmpty}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VDestroy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VDestroy}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroy}}{N\_Vector\sphinxstyleemphasis{ v}}{}
Destroys the \sphinxcode{N\_Vector} \sphinxstyleemphasis{v} and frees memory allocated for its
internal data.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDestroy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VSpace}}\pysiglinewithargsret{void \sphinxbfcode{N\_VSpace}}{N\_Vector\sphinxstyleemphasis{ v}, sunindextype*\sphinxstyleemphasis{ lrw}, sunindextype*\sphinxstyleemphasis{ liw}}{}
Returns storage requirements for the \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}: \sphinxstyleemphasis{lrw} contains
the number of \sphinxcode{realtype} words and \sphinxstyleemphasis{liw} contains the number of
integer words.  This function is advisory only, for use in
determining a user’s total space requirements; it could be a dummy
function in a user-supplied NVECTOR module if that information is
not of interest.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VSpace}\PYG{p}{(}\PYG{n}{nvSpec}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{lrw}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{liw}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VGetArrayPointer (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VGetArrayPointer}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetArrayPointer}}{N\_Vector\sphinxstyleemphasis{ v}}{}
Returns a pointer to a \sphinxcode{realtype} array from the \sphinxcode{N\_Vector}
\sphinxstyleemphasis{v}.  Note that this assumes that the internal data in the
\sphinxcode{N\_Vector} is a contiguous array of \sphinxcode{realtype} and is
accesible from the CPU.

This routine is
only used in the solver-specific interfaces to the dense and banded
(serial) linear solvers, and in the interfaces to the banded
(serial) and band-block-diagonal (parallel) preconditioner modules
provided with SUNDIALS.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vdata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VGetDeviceArrayPointer (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VGetDeviceArrayPointer}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetDeviceArrayPointer}}{N\_Vector\sphinxstyleemphasis{ v}}{}
Returns a device pointer to a \sphinxcode{realtype} array from the \sphinxcode{N\_Vector}
\sphinxcode{v}. Note that this assumes that the internal data in \sphinxcode{N\_Vector} is a
contiguous array of \sphinxcode{realtype} and is accessible from the device (e.g.,
GPU).

This operation is \sphinxstyleemphasis{optional} except when using the GPU-enabled direct
linear solvers.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{vdata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VSetArrayPointer (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VSetArrayPointer}}\pysiglinewithargsret{void \sphinxbfcode{N\_VSetArrayPointer}}{realtype*\sphinxstyleemphasis{ vdata}, N\_Vector\sphinxstyleemphasis{ v}}{}
Replaces the data array pointer in an \sphinxcode{N\_Vector} with a given
array of \sphinxcode{realtype}.  Note that this assumes that the internal
data in the \sphinxcode{N\_Vector} is a contiguous array of
\sphinxcode{realtype}. This routine is only used in the interfaces to the
dense (serial) linear solver, hence need not exist in a
user-supplied NVECTOR module.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VSetArrayPointer}\PYG{p}{(}\PYG{n}{vdata}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VGetCommunicator (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VGetCommunicator}}\pysiglinewithargsret{void* \sphinxbfcode{N\_VGetCommunicator}}{N\_Vector\sphinxstyleemphasis{ v}}{}
Returns a pointer to the \sphinxcode{MPI\_Comm} object associated with the
vector (if applicable).  For MPI-unaware vector implementations, this
should return \sphinxcode{NULL}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{commptr} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetCommunicator}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VGetLength (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VGetLength}}\pysiglinewithargsret{sunindextype \sphinxbfcode{N\_VGetLength}}{N\_Vector\sphinxstyleemphasis{ v}}{}
Returns the global length (number of ‘active’ entries) in the
NVECTOR \sphinxstyleemphasis{v}.  This value should be cumulative across all processes
if the vector is used in a parallel environment.  If \sphinxstyleemphasis{v}
contains additional storage, e.g., for parallel communication, those
entries should not be included.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{global\PYGZus{}length} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetLength}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VLinearSum (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}}\pysiglinewithargsret{void \sphinxbfcode{N\_VLinearSum}}{realtype\sphinxstyleemphasis{ a}, N\_Vector\sphinxstyleemphasis{ x}, realtype\sphinxstyleemphasis{ b}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ z}}{}
Performs the operation \sphinxstyleemphasis{z = ax + by}, where \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b} are
\sphinxcode{realtype} scalars and \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y} are of type \sphinxcode{N\_Vector}:
\begin{equation*}
\begin{split}z_i = a x_i + b y_i, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
The output vector \sphinxstyleemphasis{z} can be the same as either of the input vectors (\sphinxstyleemphasis{x} or \sphinxstyleemphasis{y}).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VLinearSum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VConst (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VConst}}\pysiglinewithargsret{void \sphinxbfcode{N\_VConst}}{realtype\sphinxstyleemphasis{ c}, N\_Vector\sphinxstyleemphasis{ z}}{}
Sets all components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} to \sphinxcode{realtype} \sphinxstyleemphasis{c}:
\begin{equation*}
\begin{split}z_i = c, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VConst}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VProd (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VProd}}\pysiglinewithargsret{void \sphinxbfcode{N\_VProd}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ z}}{}
Sets the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} to be the component-wise product of the
\sphinxcode{N\_Vector} inputs \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y}:
\begin{equation*}
\begin{split}z_i = x_i y_i, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VProd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VDiv (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VDiv}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDiv}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ y}, N\_Vector\sphinxstyleemphasis{ z}}{}
Sets the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} to be the component-wise ratio of the
\sphinxcode{N\_Vector} inputs \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y}:
\begin{equation*}
\begin{split}z_i = \frac{x_i}{y_i}, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
The \(y_i\) may not be tested for 0 values. It should only be
called with a \sphinxstyleemphasis{y} that is guaranteed to have all nonzero components.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDiv}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VScale (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VScale}}\pysiglinewithargsret{void \sphinxbfcode{N\_VScale}}{realtype\sphinxstyleemphasis{ c}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ z}}{}
Scales the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x} by the \sphinxcode{realtype} scalar \sphinxstyleemphasis{c} and
returns the result in \sphinxstyleemphasis{z}:
\begin{equation*}
\begin{split}z_i = c x_i, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VScale}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VAbs (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VAbs}}\pysiglinewithargsret{void \sphinxbfcode{N\_VAbs}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ z}}{}
Sets the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} to be the absolute
values of the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}z_i = |x_i|, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VAbs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VInv (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VInv}}\pysiglinewithargsret{void \sphinxbfcode{N\_VInv}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ z}}{}
Sets the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} to be the inverses of
the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}z_i = 1.0/x_i, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
This routine may not check for division by 0.  It should be called
only with an \sphinxstyleemphasis{x} which is guaranteed to have all nonzero components.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VInv}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VAddConst (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VAddConst}}\pysiglinewithargsret{void \sphinxbfcode{N\_VAddConst}}{N\_Vector\sphinxstyleemphasis{ x}, realtype\sphinxstyleemphasis{ b}, N\_Vector\sphinxstyleemphasis{ z}}{}
Adds the \sphinxcode{realtype} scalar \sphinxstyleemphasis{b} to all components of \sphinxstyleemphasis{x} and
returns the result in the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z}:
\begin{equation*}
\begin{split}z_i = x_i+b, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VAddConst}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VDotProd (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VDotProd}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VDotProd}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ z}}{}
Returns the value of the dot-product of the \sphinxcode{N\_Vectors} \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y}:
\begin{equation*}
\begin{split}d = \sum_{i=0}^{n-1} x_i y_i.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{N\PYGZus{}VDotProd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VMaxNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VMaxNorm}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VMaxNorm}}{N\_Vector\sphinxstyleemphasis{ x}}{}
Returns the value of the \(l_{\infty}\) norm of the
\sphinxcode{N\_Vector} \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}m = \max_{0\le i\le n-1} |x_i|.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMaxNorm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWrmsNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWrmsNorm}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VWrmsNorm}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ w}}{}
Returns the weighted root-mean-square norm of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}
with (positive) \sphinxcode{realtype} weight vector \sphinxstyleemphasis{w}:
\begin{equation*}
\begin{split}m = \sqrt{\left( \sum_{i=0}^{n-1} (x_i w_i)^2 \right) / n}\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWrmsNorm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWrmsNormMask (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormMask}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VWrmsNormMask}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ w}, N\_Vector\sphinxstyleemphasis{ id}}{}
Returns the weighted root mean square norm of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}
with \sphinxcode{realtype} weight vector \sphinxstyleemphasis{w} built using only the
elements of \sphinxstyleemphasis{x} corresponding to positive elements of the
\sphinxcode{N\_Vector} \sphinxstyleemphasis{id}:
\begin{equation*}
\begin{split}m = \sqrt{\left( \sum_{i=0}^{n-1} (x_i w_i H(id_i))^2 \right) / n},\end{split}
\end{equation*}
where \(H(\alpha)=\begin{cases} 1 & \alpha>0\\ 0 & \alpha \leq 0\end{cases}\).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWrmsNormMask}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{id}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VMin (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VMin}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VMin}}{N\_Vector\sphinxstyleemphasis{ x}}{}
Returns the smallest element of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}m = \min_{0\le i\le n-1} x_i.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWl2Norm (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWl2Norm}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VWl2Norm}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ w}}{}
Returns the weighted Euclidean \(l_2\) norm of the \sphinxcode{N\_Vector}
\sphinxstyleemphasis{x} with \sphinxcode{realtype} weight vector \sphinxstyleemphasis{w}:
\begin{equation*}
\begin{split}m = \sqrt{\sum_{i=0}^{n-1}\left(x_i w_i\right)^2}.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWL2Norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VL1Norm (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VL1Norm}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VL1Norm}}{N\_Vector\sphinxstyleemphasis{ x}}{}
Returns the \(l_1\) norm of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}m = \sum_{i=0}^{n-1} |x_i|.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VL1Norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VCompare (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VCompare}}\pysiglinewithargsret{void \sphinxbfcode{N\_VCompare}}{realtype\sphinxstyleemphasis{ c}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ z}}{}
Compares the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x} to the \sphinxcode{realtype}
scalar \sphinxstyleemphasis{c} and returns an \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} such that for all
\(0\le i\le n-1\),
\begin{equation*}
\begin{split}z_i = \begin{cases} 1.0 &\quad\text{if}\; |x_i| \ge c,\\
                    0.0 &\quad\text{otherwise}\end{cases}.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VCompare}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VInvTest (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VInvTest}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VInvTest}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ z}}{}
Sets the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{z} to be the inverses of
the components of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}, with prior testing for
zero values:
\begin{equation*}
\begin{split}z_i = 1.0/x_i, \quad i=0,\ldots,n-1.\end{split}
\end{equation*}
This routine returns a boolean assigned to \sphinxcode{SUNTRUE} if all
components of \sphinxstyleemphasis{x} are nonzero (successful inversion) and returns
\sphinxcode{SUNFALSE} otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{N\PYGZus{}VInvTest}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VConstrMask (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VConstrMask}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VConstrMask}}{N\_Vector\sphinxstyleemphasis{ c}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ m}}{}
Performs the following constraint tests based on the values in
\(c_i\):
\begin{equation*}
\begin{split}x_i > 0 \;\text{if}\; c_i = 2, \\
x_i \ge 0 \;\text{if}\; c_i = 1, \\
x_i < 0 \;\text{if}\; c_i = -2, \\
x_i \le 0 \;\text{if}\; c_i = -1.\end{split}
\end{equation*}
There is no constraint on \(x_i\) if \(c_i = 0\). This
routine returns a boolean assigned to \sphinxcode{SUNFALSE} if any element
failed the constraint test and assigned to \sphinxcode{SUNTRUE} if all
passed. It also sets a mask vector \sphinxstyleemphasis{m}, with elements equal to 1.0
where the constraint test failed, and 0.0 where the test
passed. This routine is used only for constraint checking.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{N\PYGZus{}VConstrMask}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VMinQuotient (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VMinQuotient}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VMinQuotient}}{N\_Vector\sphinxstyleemphasis{ num}, N\_Vector\sphinxstyleemphasis{ denom}}{}
This routine returns the minimum of the quotients obtained by
termwise dividing the elements of \sphinxstyleemphasis{n} by the elements in \sphinxstyleemphasis{d}:
\begin{equation*}
\begin{split}\min_{i=0,\ldots,n-1} \frac{\text{num}_i}{\text{denom}_i}.\end{split}
\end{equation*}
A zero element in \sphinxstyleemphasis{denom} will be skipped.  If no such quotients
are found, then the large value \sphinxcode{BIG\_REAL} (defined in the header
file \sphinxcode{sundials\_types.h}) is returned.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{minq} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMinQuotient}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{Description of the NVECTOR fused operations}
\label{\detokenize{nvectors/NVector_Operations:description-of-the-nvector-fused-operations}}\label{\detokenize{nvectors/NVector_Operations:nvectors-fusedops}}
The following fused vector operations are \sphinxstyleemphasis{optional}. These
operations are intended to increase data reuse, reduce parallel
communication on distributed memory systems, and lower the number of
kernel launches on systems with accelerators. If a particular NVECTOR
implementation defines one of the fused vector operations as
\sphinxcode{NULL}, the NVECTOR interface will call one of the above standard
vector operations as necessary.  As above, for each operation, we give
the name, usage of the function, and a description of its mathematical
operations below.
\index{N\_VLinearCombination (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VLinearCombination}}\pysiglinewithargsret{int \sphinxbfcode{N\_VLinearCombination}}{int\sphinxstyleemphasis{ nv}, realtype*\sphinxstyleemphasis{ c}, N\_Vector*\sphinxstyleemphasis{ X}, N\_Vector\sphinxstyleemphasis{ z}}{}
This routine computes the linear combination of \sphinxstyleemphasis{nv} vectors with \(n\) elements:
\begin{equation*}
\begin{split}z_i = \sum_{j=0}^{nv-1} c_j x_{j,i}, \quad i=0,\ldots,n-1,\end{split}
\end{equation*}
where \(c\) is an array of \(nv\) scalars, \(x_j\) is a
vector in the vector array \sphinxstyleemphasis{X}, and \sphinxstyleemphasis{z} is the output
vector. If the output vector \sphinxstyleemphasis{z} is one of the vectors in \sphinxstyleemphasis{X}, then
it \sphinxstyleemphasis{must} be the first vector in the vector array. The operation
returns 0 for success and a non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VLinearCombination}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VScaleAddMulti (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VScaleAddMulti}}\pysiglinewithargsret{int \sphinxbfcode{N\_VScaleAddMulti}}{int\sphinxstyleemphasis{ nv}, realtype*\sphinxstyleemphasis{ c}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector*\sphinxstyleemphasis{ Y}, N\_Vector*\sphinxstyleemphasis{ Z}}{}
This routine scales and adds one vector to \sphinxstyleemphasis{nv} vectors with \(n\) elements:
\begin{equation*}
\begin{split}z_{j,i} = c_j x_i + y_{j,i}, \quad j=0,\ldots,nv-1 \quad i=0,\ldots,n-1,\end{split}
\end{equation*}
where \sphinxstyleemphasis{c} is an array of scalars, \sphinxstyleemphasis{x} is a vector, \(y_j\) is a
vector in the vector array \sphinxstyleemphasis{Y}, and \(z_j\) is an output vector
in the vector array \sphinxstyleemphasis{Z}. The operation returns 0 for success and a
non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VScaleAddMulti}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VDotProdMulti (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VDotProdMulti}}\pysiglinewithargsret{int \sphinxbfcode{N\_VDotProdMulti}}{int\sphinxstyleemphasis{ nv}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector*\sphinxstyleemphasis{ Y}, realtype*\sphinxstyleemphasis{ d}}{}
This routine computes the dot product of a vector with \sphinxstyleemphasis{nv} vectors
having \(n\) elements:
\begin{equation*}
\begin{split}d_j = \sum_{i=0}^{n-1} x_i y_{j,i}, \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \sphinxstyleemphasis{d} is an array of scalars containing the computed dot
products, \sphinxstyleemphasis{x} is a vector, and \(y_j\) is a vector the vector
array \sphinxstyleemphasis{Y}. The operation returns 0 for success and a non-zero value
otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VDotProdMulti}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{Description of the NVECTOR vector array operations}
\label{\detokenize{nvectors/NVector_Operations:nvectors-arrayops}}\label{\detokenize{nvectors/NVector_Operations:description-of-the-nvector-vector-array-operations}}
The following vector array operations are also \sphinxstyleemphasis{optional}. As with the
fused vector operations, these are intended to increase data reuse,
reduce parallel communication on distributed memory systems, and lower
the number of kernel launches on systems with accelerators. If a
particular NVECTOR implementation defines one of the fused or vector
array operations as \sphinxcode{NULL}, the NVECTOR interface will call one of
the above standard vector operations as necessary.  As above, for each
operation, we give the name, usage of the function, and a description
of its mathematical operations below.
\index{N\_VLinearSumVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VLinearSumVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VLinearSumVectorArray}}{int\sphinxstyleemphasis{ nv}, realtype\sphinxstyleemphasis{ a}, N\_Vector\sphinxstyleemphasis{ X}, realtype\sphinxstyleemphasis{ b}, N\_Vector*\sphinxstyleemphasis{ Y}, N\_Vector*\sphinxstyleemphasis{ Z}}{}
This routine computes the linear sum of two vector arrays of \sphinxstyleemphasis{nv} vectors with \(n\) elements:
\begin{equation*}
\begin{split}z_{j,i} = a x_{j,i} + b y_{j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \sphinxstyleemphasis{a} and \sphinxstyleemphasis{b} are scalars, \(x_j\) and \(y_j\) are
vectors in the vector arrays \sphinxstyleemphasis{X} and \sphinxstyleemphasis{Y} respectively, and
\(z_j\) is a vector in the output vector array \sphinxstyleemphasis{Z}. The
operation returns 0 for success and a non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VLinearSumVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VScaleVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VScaleVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VScaleVectorArray}}{int\sphinxstyleemphasis{ nv}, realtype*\sphinxstyleemphasis{ c}, N\_Vector*\sphinxstyleemphasis{ X}, N\_Vector*\sphinxstyleemphasis{ Z}}{}
This routine scales each element in a vector of \(n\) elements
in a vector array of \sphinxstyleemphasis{nv} vectors by a potentially different constant:
\begin{equation*}
\begin{split}z_{j,i} = c_j x_{j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \sphinxstyleemphasis{c} is an array of scalars, \(x_j\) is a vector in the
vector array \sphinxstyleemphasis{X}, and \(z_j\) is a vector in the output vector
array \sphinxstyleemphasis{Z}. The operation returns 0 for success and a non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VScaleVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VConstVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VConstVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VConstVectorArray}}{int\sphinxstyleemphasis{ nv}, realtype\sphinxstyleemphasis{ c}, N\_Vector*\sphinxstyleemphasis{ Z}}{}
This routine sets each element in a vector of \(n\) elements in
a vector array of \sphinxstyleemphasis{nv} vectors to the same value:
\begin{equation*}
\begin{split}z_{j,i} = c, \quad i=0,\ldots,n-1 \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \sphinxstyleemphasis{c} is a scalar and \(z_j\) is a vector in the vector
array \sphinxstyleemphasis{Z}. The operation returns 0 for success and a non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VConstVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWrmsNormVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VWrmsNormVectorArray}}{int\sphinxstyleemphasis{ nv}, N\_Vector*\sphinxstyleemphasis{ X}, N\_Vector*\sphinxstyleemphasis{ W}, realtype*\sphinxstyleemphasis{ m}}{}
This routine computes the weighted root mean square norm of each
vector in a vector array:
\begin{equation*}
\begin{split}m_j = \left( \frac1n \sum_{i=0}^{n-1} \left(x_{j,i} w_{j,i}\right)^2\right)^{1/2}, \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \(x_j\) is a vector in the vector array \sphinxstyleemphasis{X}, \(w_j\)
is a weight vector in the vector array \sphinxstyleemphasis{W}, and \sphinxstyleemphasis{m} is the output
array of scalars containing the computed norms. The operation
returns 0 for success and a non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWrmsNormVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{W}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWrmsNormMaskVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormMaskVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VWrmsNormMaskVectorArray}}{int\sphinxstyleemphasis{ nv}, N\_Vector*\sphinxstyleemphasis{ X}, N\_Vector*\sphinxstyleemphasis{ W}, N\_Vector\sphinxstyleemphasis{ id}, realtype*\sphinxstyleemphasis{ m}}{}
This routine computes the masked weighted root mean square norm of
each vector in a vector array:
\begin{equation*}
\begin{split}m_j = \left( \frac1n \sum_{i=0}^{n-1} \left(x_{j,i} w_{j,i} H(id_i)\right)^2 \right)^{1/2}, \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \(H(id_i)=1\) for \(id_i > 0\) and is zero otherwise,
\(x_j\) is a vector in the vector array \sphinxstyleemphasis{X}, \(w_j\) is a
weight vector in the vector array \sphinxstyleemphasis{W}, \sphinxstyleemphasis{id} is the mask vector, and
\sphinxstyleemphasis{m} is the output array of scalars containing the computed
norms. The operation returns 0 for success and a non-zero value
otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWrmsNormMaskVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{W}\PYG{p}{,} \PYG{n}{id}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VScaleAddMultiVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VScaleAddMultiVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VScaleAddMultiVectorArray}}{int\sphinxstyleemphasis{ nv}, int\sphinxstyleemphasis{ nsum}, realtype*\sphinxstyleemphasis{ c}, N\_Vector*\sphinxstyleemphasis{ X}, N\_Vector**\sphinxstyleemphasis{ YY}, N\_Vector**\sphinxstyleemphasis{ ZZ}}{}
This routine scales and adds a vector array of \sphinxstyleemphasis{nv} vectors to
\sphinxstyleemphasis{nsum} other vector arrays:
\begin{equation*}
\begin{split}z_{k,j,i} = c_k x_{j,i} + y_{k,j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,nv-1, \quad k=0,\ldots,nsum-1\end{split}
\end{equation*}
where \sphinxstyleemphasis{c} is an array of scalars, \(x_j\) is a vector in the
vector array \sphinxstyleemphasis{X}, \(y_{k,j}\) is a vector in the array of
vector arrays \sphinxstyleemphasis{YY}, and \(z_{k,j}\) is an output vector in the
array of vector arrays \sphinxstyleemphasis{ZZ}. The operation returns 0 for success
and a non-zero value otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VScaleAddMultiVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{nsum}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{YY}\PYG{p}{,} \PYG{n}{ZZ}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VLinearCombinationVectorArray (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VLinearCombinationVectorArray}}\pysiglinewithargsret{int \sphinxbfcode{N\_VLinearCombinationVectorArray}}{int\sphinxstyleemphasis{ nv}, int\sphinxstyleemphasis{ nsum}, realtype*\sphinxstyleemphasis{ c}, N\_Vector**\sphinxstyleemphasis{ XX}, N\_Vector*\sphinxstyleemphasis{ Z}}{}
This routine computes the linear combination of \sphinxstyleemphasis{nsum} vector
arrays containing \sphinxstyleemphasis{nv} vectors:
\begin{equation*}
\begin{split}z_{j,i} = \sum_{k=0}^{nsum-1} c_k x_{k,j,i}, \quad i=0,\ldots,n-1 \quad j=0,\ldots,nv-1,\end{split}
\end{equation*}
where \sphinxstyleemphasis{c} is an array of scalars, \(x_{k,j}\) is a vector in
array of vector arrays \sphinxstyleemphasis{XX}, and \(z_{j,i}\) is an output
vector in the vector array \sphinxstyleemphasis{Z}. If the output vector array is one
of the vector arrays in \sphinxstyleemphasis{XX}, it \sphinxstyleemphasis{must} be the first vector array
in \sphinxstyleemphasis{XX}. The operation returns 0 for success and a non-zero value
otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{N\PYGZus{}VLinearCombinationVectorArray}\PYG{p}{(}\PYG{n}{nv}\PYG{p}{,} \PYG{n}{nsum}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n}{XX}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{Description of the NVECTOR local reduction operations}
\label{\detokenize{nvectors/NVector_Operations:nvectors-localops}}\label{\detokenize{nvectors/NVector_Operations:description-of-the-nvector-local-reduction-operations}}
The following local reduction operations are also \sphinxstyleemphasis{optional}. As with
the fused and vector array operations, these are intended to reduce
parallel communication on distributed memory systems. If a particular
NVECTOR implementation defines one of the local reduction operations
as \sphinxcode{NULL}, the NVECTOR interface will call one of the above standard
vector operations as necessary.  As above, for each operation, we give
the name, usage of the function, and a description of its mathematical
operations below.
\index{N\_VDotProdLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VDotProdLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VDotProdLocal}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ y}}{}
This routine computes the MPI task-local portion of the ordinary
dot product of \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y}:
\begin{equation*}
\begin{split}d=\sum_{i=0}^{n_{local}-1} x_i y_i,\end{split}
\end{equation*}
where \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{N\PYGZus{}VDotProdLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VMaxNormLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VMaxNormLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VMaxNormLocal}}{N\_Vector\sphinxstyleemphasis{ x}}{}
This routine computes the MPI task-local portion of the maximum
norm of the NVECTOR \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}m = \max_{0\le i< n_{local}} | x_i |,\end{split}
\end{equation*}
where \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMaxNormLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VMinLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VMinLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VMinLocal}}{N\_Vector\sphinxstyleemphasis{ x}}{}
This routine computes the smallest element of the MPI task-local
portion of the NVECTOR \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}m = \min_{0\le i< n_{local}} x_i,\end{split}
\end{equation*}
where \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMinLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VL1NormLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VL1NormLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VL1NormLocal}}{N\_Vector\sphinxstyleemphasis{ x}}{}
This routine computes the MPI task-local portion of the \(l_1\)
norm of the \sphinxcode{N\_Vector} \sphinxstyleemphasis{x}:
\begin{equation*}
\begin{split}n = \sum_{i=0}^{n_{local}-1} | x_i |,\end{split}
\end{equation*}
where \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n}{N\PYGZus{}VL1NormLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWSqrSumLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWSqrSumLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VWSqrSumLocal}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ w}}{}
This routine computes the MPI task-local portion of the weighted
squared sum of the NVECTOR \sphinxstyleemphasis{x} with weight vector \sphinxstyleemphasis{w}:
\begin{equation*}
\begin{split}s = \sum_{i=0}^{n_{local}-1} (x_i w_i)^2,\end{split}
\end{equation*}
where \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWSqrSumLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VWSqrSumMaskLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VWSqrSumMaskLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VWSqrSumMaskLocal}}{N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ w}, N\_Vector\sphinxstyleemphasis{ id}}{}
This routine computes the MPI task-local portion of the weighted
squared sum of the NVECTOR \sphinxstyleemphasis{x} with weight vector \sphinxstyleemphasis{w} built using
only the elements of \sphinxstyleemphasis{x} corresponding to positive elements of the NVECTOR \sphinxstyleemphasis{id}:
\begin{equation*}
\begin{split}m = \sum_{i=0}^{n_{local}-1} (x_i w_i H(id_i))^2,\end{split}
\end{equation*}
where
\begin{equation*}
\begin{split}H(\alpha) = \begin{cases} 1 & \alpha > 0 \\ 0 & \alpha \leq 0 \end{cases}\end{split}
\end{equation*}
and \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWSqrSumMaskLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{id}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VInvTestLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VInvTestLocal}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VInvTestLocal}}{N\_Vector\sphinxstyleemphasis{ x}}{}
This routine sets the MPI task-local components of the
NVECTOR \sphinxstyleemphasis{z} to be the inverses of the components of the NVECTOR
\sphinxstyleemphasis{x}, with prior testing for zero values:
\begin{equation*}
\begin{split}z_i = 1.0 /  x_i  , \: i=0,\ldots,n_{local}-1\end{split}
\end{equation*}
where \(n_{local}\) corresponds to the number of components in
the vector on this MPI task (or \(n_{local}=n\) for MPI-unaware
applications).  This routine returns a boolean assigned to
\sphinxcode{SUNTRUE} if all task-local components of \sphinxstyleemphasis{x} are nonzero
(successful inversion) and returns \sphinxcode{SUNFALSE} otherwise.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{N\PYGZus{}VInvTestLocal}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VConstrMaskLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VConstrMaskLocal}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VConstrMaskLocal}}{N\_Vector\sphinxstyleemphasis{ c}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ m}}{}
This routine performs the following constraint tests:
\(x_i > 0\) if \(c_i=2\),
\(x_i \ge 0\) if \(c_i=1\),
\(x_i \le 0\) if \(c_i=-1\),
\(x_i < 0\) if \(c_i=-2\), and
\(x_i =\) anything if \(c_i=0\),
for all MPI task-local components of the vectors.
This routine returns a boolean assigned to \sphinxcode{SUNFALSE} if any
task-local element failed the constraint test and assigned to
\sphinxcode{SUNTRUE} if all passed.  It also sets a mask vector \sphinxstyleemphasis{m}, with
elements equal to 1.0 where the constraint test failed, and 0.0
where the test passed.  This routine is used only for constraint
checking.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{N\PYGZus{}VConstrMaskLocal}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VMinQuotientLocal (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VMinQuotientLocal}}\pysiglinewithargsret{realtype \sphinxbfcode{N\_VMinQuotientLocal}}{N\_Vector\sphinxstyleemphasis{ num}, N\_Vector\sphinxstyleemphasis{ denom}}{}
This routine returns the minimum of the quotients obtained by
term-wise dividing \(num_i\) by \(denom_i\), for all MPI
task-local components of the vectors.  A zero element in \sphinxstyleemphasis{denom}
will be skipped. If no such quotients are found, then the large value
\sphinxcode{BIG\_REAL} (defined in the header file \sphinxcode{sundials\_types.h})
is returned.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{minq} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMinQuotientLocal}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{Description of the NVECTOR exchange operations}
\label{\detokenize{nvectors/NVector_Operations:nvectors-exchangeops}}\label{\detokenize{nvectors/NVector_Operations:description-of-the-nvector-exchange-operations}}
The following vector exchange operations are also \sphinxstyleemphasis{optional} and are
intended only for use when interfacing with the XBraid library for
parallel-in-time integration. In that setting these operations are
required but are otherwise unused by SUNDIALS packages and may be set
to \sphinxcode{NULL}. For each operation, we give the function signature, a
description of the expected behavior, and an example of the function
usage.
\index{N\_VBufSize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VBufSize}}\pysiglinewithargsret{int \sphinxbfcode{N\_VBufSize}}{N\_Vector\sphinxstyleemphasis{ x}, sunindextype\sphinxstyleemphasis{ *size}}{}
This routine returns the buffer size need to exchange in the data in the
vector \sphinxstyleemphasis{x} between computational nodes.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{N\PYGZus{}VBufSize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{buf\PYGZus{}size}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VBufPack (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VBufPack}}\pysiglinewithargsret{int \sphinxbfcode{N\_VBufPack}}{N\_Vector\sphinxstyleemphasis{ x}, void\sphinxstyleemphasis{ *buf}}{}
This routine fills the exchange buffer \sphinxstyleemphasis{buf} with the vector data in \sphinxstyleemphasis{x}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{N\PYGZus{}VBufPack}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{buf}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{N\_VBufUnpack (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Operations:c.N_VBufUnpack}}\pysiglinewithargsret{int \sphinxbfcode{N\_VBufUnpack}}{N\_Vector\sphinxstyleemphasis{ x}, void\sphinxstyleemphasis{ *buf}}{}
This routine unpacks the data in the exchange buffer \sphinxstyleemphasis{buf} into the vector
\sphinxstyleemphasis{x}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{flag} \PYG{o}{=} \PYG{n}{N\PYGZus{}VBufUnpack}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{buf}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}



\section{The NVECTOR\_SERIAL Module}
\label{\detokenize{nvectors/NVector_Serial::doc}}\label{\detokenize{nvectors/NVector_Serial:nvectors-nvserial}}\label{\detokenize{nvectors/NVector_Serial:the-nvector-serial-module}}
The serial implementation of the NVECTOR module provided with
SUNDIALS, NVECTOR\_SERIAL, defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{N\_Vector} to be a structure containing the length of the vector, a
pointer to the beginning of a contiguous data array, and a boolean
flag \sphinxstyleemphasis{own\_data} which specifies the ownership of data.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Serial} \PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to be included when using this module is \sphinxcode{nvector\_serial.h}.
The installed module library to link to is
\sphinxcode{libsundials\_nvecserial.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libraries and \sphinxcode{.a} for static libraries.


\subsection{NVECTOR\_SERIAL accessor macros}
\label{\detokenize{nvectors/NVector_Serial:nvector-serial-accessor-macros}}
The following five macros are provided to access the content of an
NVECTOR\_SERIAL vector. The suffix \sphinxcode{\_S} in the names denotes the serial
version.
\index{NV\_CONTENT\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.NV_CONTENT_S}}\pysiglinewithargsret{\sphinxbfcode{NV\_CONTENT\_S}}{v}{}
This macro gives access to the contents of the serial vector
\sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_cont = NV\_CONTENT\_S(v)} sets \sphinxcode{v\_cont} to be a
pointer to the serial \sphinxcode{N\_Vector} \sphinxtitleref{content} structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}S(v) ( (N\PYGZus{}VectorContent\PYGZus{}Serial)(v\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.NV_OWN_DATA_S}}\pysiglinewithargsret{\sphinxbfcode{NV\_OWN\_DATA\_S}}{v}{}
Access the \sphinxstyleemphasis{own\_data} component of the serial \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}S(v) ( NV\PYGZus{}CONTENT\PYGZus{}S(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_DATA\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.NV_DATA_S}}\pysiglinewithargsret{\sphinxbfcode{NV\_DATA\_S}}{v}{}
The assignment \sphinxcode{v\_data = NV\_DATA\_S(v)} sets \sphinxcode{v\_data} to be a
pointer to the first component of the \sphinxstyleemphasis{data} for the \sphinxcode{N\_Vector}
\sphinxcode{v}.

Similarly, the assignment \sphinxcode{NV\_DATA\_S(v) = v\_data} sets the component
array of \sphinxcode{v} to be \sphinxcode{v\_data} by storing the pointer \sphinxcode{v\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}S(v) ( NV\PYGZus{}CONTENT\PYGZus{}S(v)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.NV_LENGTH_S}}\pysiglinewithargsret{\sphinxbfcode{NV\_LENGTH\_S}}{v}{}
Access the \sphinxstyleemphasis{length} component of the serial \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_len = NV\_LENGTH\_S(v)} sets \sphinxcode{v\_len} to be the
\sphinxstyleemphasis{length} of \sphinxcode{v}. On the other hand, the call \sphinxcode{NV\_LENGTH\_S(v) =
len\_v} sets the \sphinxstyleemphasis{length} of \sphinxcode{v} to be \sphinxcode{len\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}S(v) ( NV\PYGZus{}CONTENT\PYGZus{}S(v)\PYGZhy{}\PYGZgt{}length )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_Ith\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.NV_Ith_S}}\pysiglinewithargsret{\sphinxbfcode{NV\_Ith\_S}}{v, i}{}
This macro gives access to the individual components of the \sphinxstyleemphasis{data}
array of an \sphinxcode{N\_Vector}, using standard 0-based C indexing.

The assignment \sphinxcode{r = NV\_Ith\_S(v,i)} sets \sphinxcode{r} to be the value of
the \sphinxcode{i}-th component of \sphinxcode{v}.

The assignment \sphinxcode{NV\_Ith\_S(v,i) = r} sets the value of the \sphinxcode{i}-th
component of \sphinxcode{v} to be \sphinxcode{r}.

Here \sphinxcode{i} ranges from 0 to \(n-1\) for a vector of length
\(n\).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}S(v,i) ( NV\PYGZus{}DATA\PYGZus{}S(v)[i] )}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{NVECTOR\_SERIAL functions}
\label{\detokenize{nvectors/NVector_Serial:nvector-serial-functions}}
The NVECTOR\_SERIAL module defines serial implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}.  Their names are obtained from those in
those sections by appending the suffix \sphinxcode{\_Serial}
(e.g. \sphinxcode{N\_VDestroy\_Serial}).  All the standard vector operations
listed in the section {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}} with the suffix \sphinxcode{\_Serial}
appended are callable via the Fortran 2003 interface by prepending an
\sphinxcode{F} (e.g. \sphinxcode{FN\_VDestroy\_Serial}).

The module NVECTOR\_SERIAL provides the following additional
user-callable routines:
\index{N\_VNew\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VNew_Serial}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_Serial}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates and allocates memory for a serial
\sphinxcode{N\_Vector}. Its only argument is the vector length.

\end{fulllineitems}

\index{N\_VNewEmpty\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VNewEmpty_Serial}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Serial}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates a new serial \sphinxcode{N\_Vector} with an empty
(\sphinxcode{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VMake_Serial}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Serial}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype*\sphinxstyleemphasis{ v\_data}}{}
This function creates and allocates memory for a serial vector with
user-provided data array, \sphinxstyleemphasis{v\_data}.

(This function does \sphinxstyleemphasis{not} allocate memory for \sphinxcode{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VCloneVectorArray_Serial}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArray\_Serial}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} serial
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VCloneVectorArrayEmpty_Serial}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArrayEmpty\_Serial}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} serial
vectors, each with an empty (\sphinxcode{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VDestroyVectorArray_Serial}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroyVectorArray\_Serial}}{N\_Vector*\sphinxstyleemphasis{ vs}, int\sphinxstyleemphasis{ count}}{}
This function frees memory allocated for the array of \sphinxstyleemphasis{count}
variables of type \sphinxcode{N\_Vector} created with
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VCloneVectorArray_Serial}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArray\_Serial()}}}} or with
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VCloneVectorArrayEmpty_Serial}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Serial()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VPrint_Serial}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the content of a serial vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VPrintFile_Serial}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the content of a serial vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_SERIAL
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VNew_Serial}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Serial()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VNew_Serial}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Serial()}}}} will have the default settings for the NVECTOR\_SERIAL module.
\index{N\_VEnableFusedOps\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableFusedOps_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the serial vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableLinearCombination_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the serial vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableScaleAddMulti_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the serial vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableDotProdMulti_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the serial vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableLinearSumVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the serial vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableScaleVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the serial vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableConstVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the serial vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableWrmsNormVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the serial vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableWrmsNormMaskVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the serial vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableScaleAddMultiVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the serial vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Serial:c.N_VEnableLinearCombinationVectorArray_Serial}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Serial}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the serial vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \sphinxcode{N\_Vector v}, it is more
efficient to first obtain the component array via \sphinxcode{v\_data =
NV\_DATA\_S(v)} and then access \sphinxcode{v\_data{[}i{]}} within the loop than it
is to use \sphinxcode{NV\_Ith\_S(v,i)} within the loop.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VNewEmpty_Serial}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Serial()}}}}, {\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VMake_Serial}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Serial()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VCloneVectorArrayEmpty_Serial}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Serial()}}}} set the field \sphinxstyleemphasis{own\_data}
to \sphinxcode{SUNFALSE}.  The functions \sphinxcode{N\_VDestroy\_Serial()} and
{\hyperref[\detokenize{nvectors/NVector_Serial:c.N_VDestroyVectorArray_Serial}]{\sphinxcrossref{\sphinxcode{N\_VDestroyVectorArray\_Serial()}}}} will not attempt to free the
pointer data for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_data} set to \sphinxcode{SUNFALSE}.
In such a case, it is the user’s responsibility to deallocate the
data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_SERIAL
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
length.

\end{itemize}


\subsection{NVECTOR\_SERIAL Fortran Interfaces}
\label{\detokenize{nvectors/NVector_Serial:nvector-serial-fortran-interfaces}}
The NVECTOR\_SERIAL module provides a Fortran 2003 module as well as
Fortran 77 style interface functions for use from Fortran applications.


\subsubsection{FORTRAN 2003 interface module}
\label{\detokenize{nvectors/NVector_Serial:fortran-2003-interface-module}}
The \sphinxcode{fnvector\_serial\_mod} Fortran module defines interfaces to all
NVECTOR\_SERIAL C functions using the intrinsic \sphinxcode{iso\_c\_binding}
module which provides a standardized mechanism for interoperating with C. As
noted in the C function descriptions above, the interface functions are
named after the corresponding C function, but with a leading \sphinxcode{F}. For
example, the function \sphinxcode{N\_VNew\_Serial} is interfaced as
\sphinxcode{FN\_VNew\_Serial}.

The Fortran 2003 NVECTOR\_SERIAL interface module can be accessed with the \sphinxcode{use}
statement, i.e. \sphinxcode{use fnvector\_serial\_mod}, and linking to the library
\sphinxcode{libsundials\_fnvectorserial\_mod.lib} in addition to the C library.
For details on where the library and module file
\sphinxcode{fnvector\_serial\_mod.mod} are installed see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}.
We note that the module is accessible from the Fortran 2003 SUNDIALS integrators
\sphinxstyleemphasis{without} separately linking to the \sphinxcode{libsundials\_fnvectorserial\_mod} library.


\subsubsection{FORTRAN 77 interface functions}
\label{\detokenize{nvectors/NVector_Serial:fortran-77-interface-functions}}
For solvers that include a Fortran 77 interface module, the NVECTOR\_SERIAL module
also includes a Fortran-callable function \sphinxcode{FNVINITS(code, NEQ, IER)},
to initialize this module.  Here \sphinxcode{code} is an input solver id
(1 for CVODE, 2 for IDA, 3 for KINSOL, 4 for ARKode); \sphinxcode{NEQ} is
the problem size (declared so as to match C type \sphinxcode{long int}); and
\sphinxcode{IER} is an error return flag equal 0 for success and -1 for failure.


\section{The NVECTOR\_PARALLEL Module}
\label{\detokenize{nvectors/NVector_Parallel::doc}}\label{\detokenize{nvectors/NVector_Parallel:the-nvector-parallel-module}}\label{\detokenize{nvectors/NVector_Parallel:nvectors-nvparallel}}
The NVECTOR\_PARALLEL implementation of the NVECTOR module provided with
SUNDIALS is based on MPI.  It defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{N\_Vector} to be a structure containing the global and local lengths
of the vector, a pointer to the beginning of a contiguous local data
array, an MPI communicator, an a boolean flag \sphinxstyleemphasis{own\_data} indicating
ownership of the data array \sphinxstyleemphasis{data}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Parallel} \PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{local\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{sunindextype} \PYG{n}{global\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
   \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{comm}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to be included when using this module is
\sphinxcode{nvector\_parallel.h}. The installed module library to link to is
\sphinxcode{libsundials\_nvecparallel.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so}
for shared libraries and \sphinxcode{.a} for static libraries.


\subsection{NVECTOR\_PARALLEL accessor macros}
\label{\detokenize{nvectors/NVector_Parallel:nvector-parallel-accessor-macros}}
The following seven macros are provided to access the content of a
NVECTOR\_PARALLEL vector. The suffix \sphinxcode{\_P} in the names denotes the
distributed memory parallel version.
\index{NV\_CONTENT\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_CONTENT_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_CONTENT\_P}}{v}{}
This macro gives access to the contents of the parallel
\sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_cont = NV\_CONTENT\_P(v)} sets \sphinxcode{v\_cont} to be a
pointer to the \sphinxcode{N\_Vector} \sphinxstyleemphasis{content} structure of type \sphinxcode{struct
N\_VectorContent\_Parallel}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}P(v) ( (N\PYGZus{}VectorContent\PYGZus{}Parallel)(v\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_OWN_DATA_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_OWN\_DATA\_P}}{v}{}
Access the \sphinxstyleemphasis{own\_data} component of the parallel \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}P(v)   ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_DATA\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_DATA_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_DATA\_P}}{v}{}
The assignment \sphinxcode{v\_data = NV\_DATA\_P(v)} sets \sphinxcode{v\_data} to be a
pointer to the first component of the \sphinxstyleemphasis{local\_data} for the
\sphinxcode{N\_Vector v}.

The assignment \sphinxcode{NV\_DATA\_P(v) = v\_data} sets the component array of
\sphinxcode{v} to be \sphinxcode{v\_data} by storing the pointer \sphinxcode{v\_data} into
\sphinxstyleemphasis{data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}P(v)       ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_LOCLENGTH\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_LOCLENGTH_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_LOCLENGTH\_P}}{v}{}
The assignment \sphinxcode{v\_llen = NV\_LOCLENGTH\_P(v)} sets \sphinxcode{v\_llen} to be
the length of the local part of \sphinxcode{v}.

The call \sphinxcode{NV\_LOCLENGTH\_P(v) = llen\_v} sets the \sphinxstyleemphasis{local\_length} of
\sphinxcode{v} to be \sphinxcode{llen\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LOCLENGTH\PYGZus{}P(v)  ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}local\PYGZus{}length )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_GLOBLENGTH\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_GLOBLENGTH_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_GLOBLENGTH\_P}}{v}{}
The assignment \sphinxcode{v\_glen = NV\_GLOBLENGTH\_P(v)} sets \sphinxcode{v\_glen} to be
the \sphinxstyleemphasis{global\_length} of the vector \sphinxcode{v}.

The call \sphinxcode{NV\_GLOBLENGTH\_P(v) = glen\_v} sets the \sphinxstyleemphasis{global\_length}
of \sphinxcode{v} to be \sphinxcode{glen\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}GLOBLENGTH\PYGZus{}P(v) ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}global\PYGZus{}length )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_COMM\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_COMM_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_COMM\_P}}{v}{}
This macro provides access to the MPI communicator used by the
parallel \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}COMM\PYGZus{}P(v) ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}comm )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_Ith\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.NV_Ith_P}}\pysiglinewithargsret{\sphinxbfcode{NV\_Ith\_P}}{v, i}{}
This macro gives access to the individual components of the
\sphinxstyleemphasis{local\_data} array of an \sphinxcode{N\_Vector}.

The assignment \sphinxcode{r = NV\_Ith\_P(v,i)} sets \sphinxcode{r} to be the value of
the \sphinxcode{i}-th component of the local part of \sphinxcode{v}.

The assignment \sphinxcode{NV\_Ith\_P(v,i) = r} sets the value of the \sphinxcode{i}-th
component of the local part of \sphinxcode{v} to be \sphinxcode{r}.

Here \sphinxcode{i} ranges from 0 to \(n-1\), where \(n\) is the
\sphinxstyleemphasis{local\_length}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}P(v,i) ( NV\PYGZus{}DATA\PYGZus{}P(v)[i] )}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{NVECTOR\_PARALLEL functions}
\label{\detokenize{nvectors/NVector_Parallel:nvector-parallel-functions}}
The NVECTOR\_PARALLEL module defines parallel implementations of all
vector operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}.  Their names are obtained from those in
those sections by appending the suffix \sphinxcode{\_Parallel}
(e.g. \sphinxcode{N\_VDestroy\_Parallel}).   The module NVECTOR\_PARALLEL provides
the following additional user-callable routines:
\index{N\_VNew\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VNew_Parallel}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_Parallel}}{MPI\_Comm\sphinxstyleemphasis{ comm}, sunindextype\sphinxstyleemphasis{ local\_length}, sunindextype\sphinxstyleemphasis{ global\_length}}{}
This function creates and allocates memory for a parallel vector
having global length \sphinxstyleemphasis{global\_length}, having processor-local length
\sphinxstyleemphasis{local\_length}, and using the MPI communicator \sphinxstyleemphasis{comm}.

\end{fulllineitems}

\index{N\_VNewEmpty\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VNewEmpty_Parallel}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Parallel}}{MPI\_Comm\sphinxstyleemphasis{ comm}, sunindextype\sphinxstyleemphasis{ local\_length}, sunindextype\sphinxstyleemphasis{ global\_length}}{}
This function creates a new parallel \sphinxcode{N\_Vector} with an empty
(\sphinxcode{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VMake_Parallel}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Parallel}}{MPI\_Comm\sphinxstyleemphasis{ comm}, sunindextype\sphinxstyleemphasis{ local\_length}, sunindextype\sphinxstyleemphasis{ global\_length}, realtype*\sphinxstyleemphasis{ v\_data}}{}
This function creates and allocates memory for a parallel vector
with user-provided data array.

(This function does \sphinxstyleemphasis{not} allocate memory for \sphinxcode{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VCloneVectorArray_Parallel}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArray\_Parallel}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} parallel vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VCloneVectorArrayEmpty_Parallel}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArrayEmpty\_Parallel}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} parallel
vectors, each with an empty (\sphinxcode{NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VDestroyVectorArray_Parallel}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroyVectorArray\_Parallel}}{N\_Vector*\sphinxstyleemphasis{ vs}, int\sphinxstyleemphasis{ count}}{}
This function frees memory allocated for the array of \sphinxstyleemphasis{count}
variables of type \sphinxcode{N\_Vector} created with
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VCloneVectorArray_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArray\_Parallel()}}}} or with
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VCloneVectorArrayEmpty_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Parallel()}}}}.

\end{fulllineitems}

\index{N\_VGetLocalLength\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VGetLocalLength_Parallel}}\pysiglinewithargsret{sunindextype \sphinxbfcode{N\_VGetLocalLength\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns the local vector length.

\end{fulllineitems}

\index{N\_VPrint\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VPrint_Parallel}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the local content of a parallel vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VPrintFile_Parallel}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the local content of a parallel vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_PARALLEL
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VNew_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Parallel()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VNew_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Parallel()}}}} will have the default settings for the NVECTOR\_PARALLEL module.
\index{N\_VEnableFusedOps\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableFusedOps_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the parallel vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableLinearCombination_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the parallel vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableScaleAddMulti_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the parallel vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableDotProdMulti_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the parallel vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableLinearSumVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the parallel vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableScaleVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the parallel vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableConstVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the parallel vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableWrmsNormVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the parallel vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableWrmsNormMaskVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the parallel vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableScaleAddMultiVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the parallel vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Parallel:c.N_VEnableLinearCombinationVectorArray_Parallel}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Parallel}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the parallel vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \sphinxcode{N\_Vector v}, it is
more efficient to first obtain the local component array via \sphinxcode{v\_data
= NV\_DATA\_P(v)} and then access \sphinxcode{v\_data{[}i{]}} within the loop than it
is to use \sphinxcode{NV\_Ith\_P(v,i)} within the loop.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VNewEmpty_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Parallel()}}}}, {\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VMake_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Parallel()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VCloneVectorArrayEmpty_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Parallel()}}}} set the field \sphinxstyleemphasis{own\_data} to
\sphinxcode{SUNFALSE}. The routines \sphinxcode{N\_VDestroy\_Parallel()} and
{\hyperref[\detokenize{nvectors/NVector_Parallel:c.N_VDestroyVectorArray_Parallel}]{\sphinxcrossref{\sphinxcode{N\_VDestroyVectorArray\_Parallel()}}}} will not attempt to free the
pointer data for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_data} set to
\sphinxcode{SUNFALSE}. In such a case, it is the user’s responsibility to
deallocate the data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PARALLEL
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\subsection{NVECTOR\_PARALLEL Fortran Interfaces}
\label{\detokenize{nvectors/NVector_Parallel:nvector-parallel-fortran-interfaces}}
For solvers that include a Fortran interface module, the
NVECTOR\_PARALLEL module also includes a Fortran-callable function
\sphinxcode{FNVINITP(COMM, code, NLOCAL, NGLOBAL, IER)}, to initialize this
NVECTOR\_PARALLEL module.  Here \sphinxcode{COMM} is the MPI communicator,
\sphinxcode{code} is an input solver id (1 for CVODE, 2 for IDA, 3 for KINSOL,
4 for ARKode); \sphinxcode{NLOCAL} and \sphinxcode{NGLOBAL} are the local and global
vector sizes, respectively (declared so as to match C type \sphinxcode{long
int}); and \sphinxcode{IER} is an error return flag equal 0 for success and -1
for failure.

\begin{sphinxadmonition}{note}{Note:}
If the header file \sphinxcode{sundials\_config.h} defines
\sphinxcode{SUNDIALS\_MPI\_COMM\_F2C} to be 1 (meaning the MPI implementation
used to build SUNDIALS includes the \sphinxcode{MPI\_Comm\_f2c} function),
then \sphinxcode{COMM} can be any valid MPI communicator. Otherwise,
\sphinxcode{MPI\_COMM\_WORLD} will be used, so just pass an integer value as a
placeholder.
\end{sphinxadmonition}


\section{The NVECTOR\_OPENMP Module}
\label{\detokenize{nvectors/NVector_OpenMP:the-nvector-openmp-module}}\label{\detokenize{nvectors/NVector_OpenMP::doc}}\label{\detokenize{nvectors/NVector_OpenMP:nvectors-openmp}}
In situations where a user has a multi-core processing unit capable of
running multiple parallel threads with shared memory, SUNDIALS provides
an implementation of NVECTOR using OpenMP, called NVECTOR\_OPENMP, and
an implementation using Pthreads, called NVECTOR\_PTHREADS. Testing has
shown that vectors should be of length at least \(100,000\) before
the overhead associated with creating and using the threads is made up
by the parallelism in the vector calculations.

The OpenMP NVECTOR implementation provided with SUNDIALS,
NVECTOR\_OPENMP, defines the \sphinxstyleemphasis{content} field of \sphinxcode{N\_Vector} to be a structure
containing the length of the vector, a pointer to the beginning of a contiguous
data array, a boolean flag \sphinxstyleemphasis{own\_data} which specifies the ownership of
\sphinxstyleemphasis{data}, and the number of threads.  Operations on the vector are
threaded using OpenMP, the number of threads used is based on the
supplied argument in the vector constructor.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}OpenMP} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}threads}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to be included when using this module is \sphinxcode{nvector\_openmp.h}.
The installed module library to link to is
\sphinxcode{libsundials\_nvecopenmp.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a}
for static libraries.
The Fortran module file to use when using the Fortran 2003 interface to
this module is \sphinxcode{fnvector\_openmp\_mod.mod}.


\subsection{NVECTOR\_OPENMP accessor macros}
\label{\detokenize{nvectors/NVector_OpenMP:nvector-openmp-accessor-macros}}
The following six macros are provided to access the content of an NVECTOR\_OPENMP
vector. The suffix \sphinxcode{\_OMP} in the names denotes the OpenMP version.
\index{NV\_CONTENT\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.NV_CONTENT_OMP}}\pysiglinewithargsret{\sphinxbfcode{NV\_CONTENT\_OMP}}{v}{}
This macro gives access to the contents of the OpenMP vector
\sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_cont = NV\_CONTENT\_OMP(v)} sets \sphinxcode{v\_cont} to be
a pointer to the OpenMP \sphinxcode{N\_Vector} content structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}OMP(v) ( (N\PYGZus{}VectorContent\PYGZus{}OpenMP)(v\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.NV_OWN_DATA_OMP}}\pysiglinewithargsret{\sphinxbfcode{NV\_OWN\_DATA\_OMP}}{v}{}
Access the \sphinxstyleemphasis{own\_data} component of the OpenMP \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_DATA\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.NV_DATA_OMP}}\pysiglinewithargsret{\sphinxbfcode{NV\_DATA\_OMP}}{v}{}
The assignment \sphinxcode{v\_data = NV\_DATA\_OMP(v)} sets \sphinxcode{v\_data} to be a
pointer to the first component of the \sphinxstyleemphasis{data} for the \sphinxcode{N\_Vector}
\sphinxcode{v}.

Similarly, the assignment \sphinxcode{NV\_DATA\_OMP(v) = v\_data} sets the component
array of \sphinxcode{v} to be \sphinxcode{v\_data} by storing the pointer \sphinxcode{v\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.NV_LENGTH_OMP}}\pysiglinewithargsret{\sphinxbfcode{NV\_LENGTH\_OMP}}{v}{}
Access the \sphinxstyleemphasis{length} component of the OpenMP \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_len = NV\_LENGTH\_OMP(v)} sets \sphinxcode{v\_len} to be the
\sphinxstyleemphasis{length} of \sphinxcode{v}. On the other hand, the call \sphinxcode{NV\_LENGTH\_OMP(v) =
len\_v} sets the \sphinxstyleemphasis{length} of \sphinxcode{v} to be \sphinxcode{len\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}length )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_NUM\_THREADS\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.NV_NUM_THREADS_OMP}}\pysiglinewithargsret{\sphinxbfcode{NV\_NUM\_THREADS\_OMP}}{v}{}
Access the \sphinxstyleemphasis{num\_threads} component of the OpenMP \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_threads = NV\_NUM\_THREADS\_OMP(v)} sets
\sphinxcode{v\_threads} to be the \sphinxstyleemphasis{num\_threads} of \sphinxcode{v}. On the other hand,
the call \sphinxcode{NV\_NUM\_THREADS\_OMP(v) = num\_threads\_v} sets the
\sphinxstyleemphasis{num\_threads} of \sphinxcode{v} to be \sphinxcode{num\_threads\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}NUM\PYGZus{}THREADS\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}num\PYGZus{}threads )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_Ith\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.NV_Ith_OMP}}\pysiglinewithargsret{\sphinxbfcode{NV\_Ith\_OMP}}{v, i}{}
This macro gives access to the individual components of the \sphinxstyleemphasis{data}
array of an \sphinxcode{N\_Vector}, using standard 0-based C indexing.

The assignment \sphinxcode{r = NV\_Ith\_OMP(v,i)} sets \sphinxcode{r} to be the value of
the \sphinxcode{i}-th component of \sphinxcode{v}.

The assignment \sphinxcode{NV\_Ith\_OMP(v,i) = r} sets the value of the \sphinxcode{i}-th
component of \sphinxcode{v} to be \sphinxcode{r}.

Here \sphinxcode{i} ranges from 0 to \(n-1\) for a vector of length
\(n\).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}OMP(v,i) ( NV\PYGZus{}DATA\PYGZus{}OMP(v)[i] )}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{NVECTOR\_OPENMP functions}
\label{\detokenize{nvectors/NVector_OpenMP:nvector-openmp-functions}}
The NVECTOR\_OPENMP module defines OpenMP implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}.  Their names are obtained from those in
those sections by appending the suffix \sphinxcode{\_OpenMP}
(e.g. \sphinxcode{N\_VDestroy\_OpenMP}).  All the standard vector operations
listed in the section {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}} with the suffix \sphinxcode{\_OpenMP}
appended are callable via the Fortran 2003 interface by prepending an
\sphinxtitleref{F’ (e.g. {}`{}`FN\_VDestroy\_OpenMP{}`}).

The module NVECTOR\_OPENMP provides the following additional user-callable routines:
\index{N\_VNew\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VNew_OpenMP}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_OpenMP}}{sunindextype\sphinxstyleemphasis{ vec\_length}, int\sphinxstyleemphasis{ num\_threads}}{}
This function creates and allocates memory for a OpenMP
\sphinxcode{N\_Vector}. Arguments are the vector length and number of threads.

\end{fulllineitems}

\index{N\_VNewEmpty\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VNewEmpty_OpenMP}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_OpenMP}}{sunindextype\sphinxstyleemphasis{ vec\_length}, int\sphinxstyleemphasis{ num\_threads}}{}
This function creates a new OpenMP \sphinxcode{N\_Vector} with an empty
(\sphinxcode{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VMake_OpenMP}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_OpenMP}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype*\sphinxstyleemphasis{ v\_data}, int\sphinxstyleemphasis{ num\_threads}}{}
This function creates and allocates memory for a OpenMP vector with
user-provided data array, \sphinxstyleemphasis{v\_data}.

(This function does \sphinxstyleemphasis{not} allocate memory for \sphinxcode{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VCloneVectorArray_OpenMP}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArray\_OpenMP}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} OpenMP
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VCloneVectorArrayEmpty_OpenMP}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArrayEmpty\_OpenMP}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} OpenMP
vectors, each with an empty (\sphinxcode{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VDestroyVectorArray_OpenMP}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroyVectorArray\_OpenMP}}{N\_Vector*\sphinxstyleemphasis{ vs}, int\sphinxstyleemphasis{ count}}{}
This function frees memory allocated for the array of \sphinxstyleemphasis{count}
variables of type \sphinxcode{N\_Vector} created with
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VCloneVectorArray_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArray\_OpenMP()}}}} or with
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VCloneVectorArrayEmpty_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_OpenMP()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VPrint_OpenMP}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the content of an OpenMP vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VPrintFile_OpenMP}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the content of an OpenMP vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_OPENMP
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VNew_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VNew\_OpenMP()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VNew_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VNew\_OpenMP()}}}} will have the default settings for the NVECTOR\_OPENMP module.
\index{N\_VEnableFusedOps\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableFusedOps_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the OpenMP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableLinearCombination_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the OpenMP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableScaleAddMulti_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the OpenMP vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableDotProdMulti_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the OpenMP vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableLinearSumVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the OpenMP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableScaleVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the OpenMP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableConstVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the OpenMP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableWrmsNormVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the OpenMP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableWrmsNormMaskVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the OpenMP vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableScaleAddMultiVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the OpenMP vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMP:c.N_VEnableLinearCombinationVectorArray_OpenMP}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_OpenMP}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the OpenMP vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \sphinxcode{N\_Vector v}, it is more
efficient to first obtain the component array via \sphinxcode{v\_data =
NV\_DATA\_OMP(v)} and then access \sphinxcode{v\_data{[}i{]}} within the loop than it
is to use \sphinxcode{NV\_Ith\_OMP(v,i)} within the loop.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VNewEmpty_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_OpenMP()}}}}, {\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VMake_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VMake\_OpenMP()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VCloneVectorArrayEmpty_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_OpenMP()}}}} set the field \sphinxstyleemphasis{own\_data}
to \sphinxcode{SUNFALSE}.  The functions \sphinxcode{N\_VDestroy\_OpenMP()} and
{\hyperref[\detokenize{nvectors/NVector_OpenMP:c.N_VDestroyVectorArray_OpenMP}]{\sphinxcrossref{\sphinxcode{N\_VDestroyVectorArray\_OpenMP()}}}} will not attempt to free the
pointer data for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_data} set to \sphinxcode{SUNFALSE}.
In such a case, it is the user’s responsibility to deallocate the
data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_OPENMP
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\subsection{NVECTOR\_OPENMP Fortran Interfaces}
\label{\detokenize{nvectors/NVector_OpenMP:nvector-openmp-fortran-interfaces}}
The NVECTOR\_OPENMP module provides a Fortran 2003 module as well as
Fortran 77 style interface functions for use from Fortran applications.


\subsubsection{FORTRAN 2003 interface module}
\label{\detokenize{nvectors/NVector_OpenMP:fortran-2003-interface-module}}
The \sphinxcode{fnvector\_openmp\_mod} Fortran module defines interfaces to all
NVECTOR\_OPENMP C functions using the intrinsic \sphinxcode{iso\_c\_binding}
module which provides a standardized mechanism for interoperating with C. As
noted in the C function descriptions above, the interface functions are
named after the corresponding C function, but with a leading \sphinxcode{F}. For
example, the function \sphinxcode{N\_VNew\_OpenMP} is interfaced as
\sphinxcode{FN\_VNew\_OpenMP}.

The Fortran 2003 NVECTOR\_OPENMP interface module can be accessed with the \sphinxcode{use}
statement, i.e. \sphinxcode{use fnvector\_openmp\_mod}, and linking to the library
\sphinxcode{libsundials\_fnvectoropenmp\_mod.lib} in addition to the C library.
For details on where the library and module file
\sphinxcode{fnvector\_openmp\_mod.mod} are installed see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}.


\subsubsection{FORTRAN 77 interface functions}
\label{\detokenize{nvectors/NVector_OpenMP:fortran-77-interface-functions}}
For solvers that include a Fortran 77 interface module, the
NVECTOR\_OPENMP module also includes a Fortran-callable function
\sphinxcode{FNVINITOMP(code, NEQ, NUMTHREADS, IER)}, to initialize this
module.  Here \sphinxcode{code} is an input solver id (1 for CVODE, 2 for IDA,
3 for KINSOL, 4 for ARKode); \sphinxcode{NEQ} is the problem size (declared so
as to match C type \sphinxcode{long int}); \sphinxcode{NUMTHREADS} is the number of
threads; and \sphinxcode{IER} is an error return flag equal 0 for success
and -1 for failure.


\section{The NVECTOR\_PTHREADS Module}
\label{\detokenize{nvectors/NVector_Pthreads:nvectors-pthreads}}\label{\detokenize{nvectors/NVector_Pthreads:the-nvector-pthreads-module}}\label{\detokenize{nvectors/NVector_Pthreads::doc}}
In situations where a user has a multi-core processing unit capable of
running multiple parallel threads with shared memory, SUNDIALS
provides an implementation of NVECTOR using OpenMP, called
NVECTOR\_OPENMP, and an implementation using Pthreads, called
NVECTOR\_PTHREADS.  Testing has shown that vectors should be of length
at least \(100,000\) before the overhead associated with creating
and using the threads is made up by the parallelism in the vector calculations.

The Pthreads NVECTOR implementation provided with SUNDIALS, denoted
NVECTOR\_PTHREADS, defines the \sphinxstyleemphasis{content} field of \sphinxcode{N\_Vector} to be a structure
containing the length of the vector, a pointer to the beginning of a contiguous
data array, a boolean flag \sphinxstyleemphasis{own\_data} which specifies the ownership
of \sphinxstyleemphasis{data}, and the number of threads.  Operations on the vector are
threaded using POSIX threads (Pthreads).

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Pthreads} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}threads}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to be included when using this module is \sphinxcode{nvector\_pthreads.h}.
The installed module library to link to is
\sphinxcode{libsundials\_nvecpthreads.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so}
for shared libraries and \sphinxcode{.a} for static libraries.


\subsection{NVECTOR\_PTHREADS accessor macros}
\label{\detokenize{nvectors/NVector_Pthreads:nvector-pthreads-accessor-macros}}
The following six macros are provided to access the content of an NVECTOR\_PTHREADS
vector. The suffix \sphinxcode{\_PT} in the names denotes the Pthreads version.
\index{NV\_CONTENT\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.NV_CONTENT_PT}}\pysiglinewithargsret{\sphinxbfcode{NV\_CONTENT\_PT}}{v}{}
This macro gives access to the contents of the Pthreads vector
\sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_cont = NV\_CONTENT\_PT(v)} sets \sphinxcode{v\_cont} to be
a pointer to the Pthreads \sphinxcode{N\_Vector} content structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}PT(v) ( (N\PYGZus{}VectorContent\PYGZus{}Pthreads)(v\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.NV_OWN_DATA_PT}}\pysiglinewithargsret{\sphinxbfcode{NV\_OWN\_DATA\_PT}}{v}{}
Access the \sphinxstyleemphasis{own\_data} component of the Pthreads \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_DATA\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.NV_DATA_PT}}\pysiglinewithargsret{\sphinxbfcode{NV\_DATA\_PT}}{v}{}
The assignment \sphinxcode{v\_data = NV\_DATA\_PT(v)} sets \sphinxcode{v\_data} to be a
pointer to the first component of the \sphinxstyleemphasis{data} for the \sphinxcode{N\_Vector}
\sphinxcode{v}.

Similarly, the assignment \sphinxcode{NV\_DATA\_PT(v) = v\_data} sets the component
array of \sphinxcode{v} to be \sphinxcode{v\_data} by storing the pointer \sphinxcode{v\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.NV_LENGTH_PT}}\pysiglinewithargsret{\sphinxbfcode{NV\_LENGTH\_PT}}{v}{}
Access the \sphinxstyleemphasis{length} component of the Pthreads \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_len = NV\_LENGTH\_PT(v)} sets \sphinxcode{v\_len} to be the
\sphinxstyleemphasis{length} of \sphinxcode{v}. On the other hand, the call \sphinxcode{NV\_LENGTH\_PT(v) =
len\_v} sets the \sphinxstyleemphasis{length} of \sphinxcode{v} to be \sphinxcode{len\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}length )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_NUM\_THREADS\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.NV_NUM_THREADS_PT}}\pysiglinewithargsret{\sphinxbfcode{NV\_NUM\_THREADS\_PT}}{v}{}
Access the \sphinxstyleemphasis{num\_threads} component of the Pthreads \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_threads = NV\_NUM\_THREADS\_PT(v)} sets
\sphinxcode{v\_threads} to be the \sphinxstyleemphasis{num\_threads} of \sphinxcode{v}. On the other hand,
the call \sphinxcode{NV\_NUM\_THREADS\_PT(v) = num\_threads\_v} sets the
\sphinxstyleemphasis{num\_threads} of \sphinxcode{v} to be \sphinxcode{num\_threads\_v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}NUM\PYGZus{}THREADS\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}num\PYGZus{}threads )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_Ith\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.NV_Ith_PT}}\pysiglinewithargsret{\sphinxbfcode{NV\_Ith\_PT}}{v, i}{}
This macro gives access to the individual components of the \sphinxstyleemphasis{data}
array of an \sphinxcode{N\_Vector}, using standard 0-based C indexing.

The assignment \sphinxcode{r = NV\_Ith\_PT(v,i)} sets \sphinxcode{r} to be the value of
the \sphinxcode{i}-th component of \sphinxcode{v}.

The assignment \sphinxcode{NV\_Ith\_PT(v,i) = r} sets the value of the \sphinxcode{i}-th
component of \sphinxcode{v} to be \sphinxcode{r}.

Here \sphinxcode{i} ranges from 0 to \(n-1\) for a vector of length
\(n\).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}PT(v,i) ( NV\PYGZus{}DATA\PYGZus{}PT(v)[i] )}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{NVECTOR\_PTHREADS functions}
\label{\detokenize{nvectors/NVector_Pthreads:nvector-pthreads-functions}}
The NVECTOR\_PTHREADS module defines Pthreads implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}.  Their names
are obtained from those in those sections by appending the suffix
\sphinxcode{\_Pthreads} (e.g. N\_VDestroy\_Pthreads).  All the standard vector
operations listed in the section {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}} are callable via
the Fortran 2003 interface by prepending an \sphinxtitleref{F’ (e.g. {}`{}`FN\_VDestroy\_Pthreads{}`}).
The module NVECTOR\_PTHREADS provides the following additional
user-callable routines:
\index{N\_VNew\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VNew_Pthreads}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_Pthreads}}{sunindextype\sphinxstyleemphasis{ vec\_length}, int\sphinxstyleemphasis{ num\_threads}}{}
This function creates and allocates memory for a Pthreads
\sphinxcode{N\_Vector}. Arguments are the vector length and number of threads.

\end{fulllineitems}

\index{N\_VNewEmpty\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VNewEmpty_Pthreads}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Pthreads}}{sunindextype\sphinxstyleemphasis{ vec\_length}, int\sphinxstyleemphasis{ num\_threads}}{}
This function creates a new Pthreads \sphinxcode{N\_Vector} with an empty
(\sphinxcode{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VMake_Pthreads}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Pthreads}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype*\sphinxstyleemphasis{ v\_data}, int\sphinxstyleemphasis{ num\_threads}}{}
This function creates and allocates memory for a Pthreads vector with
user-provided data array, \sphinxstyleemphasis{v\_data}.

(This function does \sphinxstyleemphasis{not} allocate memory for \sphinxcode{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VCloneVectorArray_Pthreads}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArray\_Pthreads}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} Pthreads
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VCloneVectorArrayEmpty_Pthreads}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArrayEmpty\_Pthreads}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} Pthreads
vectors, each with an empty (\sphinxcode{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VDestroyVectorArray_Pthreads}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroyVectorArray\_Pthreads}}{N\_Vector*\sphinxstyleemphasis{ vs}, int\sphinxstyleemphasis{ count}}{}
This function frees memory allocated for the array of \sphinxstyleemphasis{count}
variables of type \sphinxcode{N\_Vector} created with
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VCloneVectorArray_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArray\_Pthreads()}}}} or with
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VCloneVectorArrayEmpty_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Pthreads()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VPrint_Pthreads}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the content of a Pthreads vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VPrintFile_Pthreads}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the content of a Pthreads vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_PTHREADS
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VNew_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Pthreads()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VNew_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Pthreads()}}}} will have the default settings for the NVECTOR\_PTHREADS module.
\index{N\_VEnableFusedOps\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableFusedOps_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the Pthreads vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableLinearCombination_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the Pthreads vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableScaleAddMulti_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the Pthreads vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableDotProdMulti_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the Pthreads vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableLinearSumVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the Pthreads vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableScaleVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the Pthreads vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableConstVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the Pthreads vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableWrmsNormVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the Pthreads vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableWrmsNormMaskVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the Pthreads vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableScaleAddMultiVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the Pthreads vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Pthreads:c.N_VEnableLinearCombinationVectorArray_Pthreads}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Pthreads}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the Pthreads vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \sphinxcode{N\_Vector v}, it is more
efficient to first obtain the component array via \sphinxcode{v\_data =
NV\_DATA\_PT(v)} and then access \sphinxcode{v\_data{[}i{]}} within the loop than it
is to use \sphinxcode{NV\_Ith\_S(v,i)} within the loop.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VNewEmpty_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Pthreads()}}}}, {\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VMake_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Pthreads()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VCloneVectorArrayEmpty_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Pthreads()}}}} set the field \sphinxstyleemphasis{own\_data}
to \sphinxcode{SUNFALSE}.  The functions \sphinxcode{N\_VDestroy\_Pthreads()} and
{\hyperref[\detokenize{nvectors/NVector_Pthreads:c.N_VDestroyVectorArray_Pthreads}]{\sphinxcrossref{\sphinxcode{N\_VDestroyVectorArray\_Pthreads()}}}} will not attempt to free the
pointer data for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_data} set to \sphinxcode{SUNFALSE}.
In such a case, it is the user’s responsibility to deallocate the
data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PTHREADS
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\subsection{NVECTOR\_PTHREADS Fortran Interfaces}
\label{\detokenize{nvectors/NVector_Pthreads:nvector-pthreads-fortran-interfaces}}
The NVECTOR\_PTHREADS module provides a Fortran 2003 module as well as
Fortran 77 style interface functions for use from Fortran applications.


\subsubsection{FORTRAN 2003 interface module}
\label{\detokenize{nvectors/NVector_Pthreads:fortran-2003-interface-module}}
The \sphinxcode{fnvector\_pthreads\_mod} Fortran module defines interfaces to all
NVECTOR\_PTHREADS C functions using the intrinsic \sphinxcode{iso\_c\_binding}
module which provides a standardized mechanism for interoperating with C. As
noted in the C function descriptions above, the interface functions are
named after the corresponding C function, but with a leading \sphinxcode{F}. For
example, the function \sphinxcode{N\_VNew\_Pthreads} is interfaced as
\sphinxcode{FN\_VNew\_Pthreads}.

The Fortran 2003 NVECTOR\_PTHREADS interface module can be accessed with the \sphinxcode{use}
statement, i.e. \sphinxcode{use fnvector\_pthreads\_mod}, and linking to the library
\sphinxcode{libsundials\_fnvectorpthreads\_mod.lib} in addition to the C library.
For details on where the library and module file
\sphinxcode{fnvector\_pthreads\_mod.mod} are installed see the section {\hyperref[\detokenize{Install:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode Installation Procedure}}}}.


\subsubsection{FORTRAN 77 interface functions}
\label{\detokenize{nvectors/NVector_Pthreads:fortran-77-interface-functions}}
For solvers that include a Fortran interface module, the
NVECTOR\_PTHREADS module slso includes a Fortran-callable function
\sphinxcode{FNVINITPTS(code, NEQ, NUMTHREADS, IER)}, to initialize this
module.  Here \sphinxcode{code} is an input solver id
(1 for CVODE, 2 for IDA, 3 for KINSOL, 4 for ARKode); \sphinxcode{NEQ} is
the problem size (declared so as to match C type \sphinxcode{long int});
\sphinxcode{NUMTHREADS} is the number of threads; and \sphinxcode{IER} is an error
return flag equal 0 for success and -1 for failure.


\section{The NVECTOR\_PARHYP Module}
\label{\detokenize{nvectors/NVector_ParHyp::doc}}\label{\detokenize{nvectors/NVector_ParHyp:nvectors-parhyp}}\label{\detokenize{nvectors/NVector_ParHyp:the-nvector-parhyp-module}}
The NVECTOR\_PARHYP implementation of the NVECTOR  module provided with
SUNDIALS is a wrapper around HYPRE’s ParVector class.
Most of the vector kernels simply call HYPRE vector operations.
The implementation defines the \sphinxstyleemphasis{content} field of \sphinxcode{N\_Vector} to
be a structure containing the global and local lengths of the vector, a
pointer to an object of type \sphinxcode{hypre\_ParVector}, an MPI communicator,
and a boolean flag \sphinxstyleemphasis{own\_parvector} indicating ownership of the
HYPRE parallel vector object \sphinxstyleemphasis{x}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}ParHyp} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{local\PYGZus{}length}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{global\PYGZus{}length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}parvector}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{comm}\PYG{p}{;}
  \PYG{n}{hypre\PYGZus{}ParVector} \PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to be included when using this module is \sphinxcode{nvector\_parhyp.h}.
The installed module library to link to is
\sphinxcode{libsundials\_nvecparhyp.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libraries and \sphinxcode{.a} for static libraries.

Unlike native SUNDIALS vector types, NVECTOR\_PARHYP does not provide macros
to access its member variables.
Note that NVECTOR\_PARHYP requires SUNDIALS to be built with MPI support.


\subsection{NVECTOR\_PARHYP functions}
\label{\detokenize{nvectors/NVector_ParHyp:nvector-parhyp-functions}}
The NVECTOR\_PARHYP module defines implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for \sphinxcode{N\_VSetArrayPointer} and
\sphinxcode{N\_VGetArrayPointer}, because accessing raw vector data is handled
by low-level HYPRE functions.  As such, this vector is not available
for use with SUNDIALS Fortran interfaces.  When access to raw vector
data is needed, one should extract the HYPRE vector first, and
then use HYPRE methods to access the data.  Usage examples of
NVECTOR\_PARHYP are provided in the \sphinxcode{cvAdvDiff\_non\_ph.c} example
programs for CVODE and the \sphinxcode{ark\_diurnal\_kry\_ph.c} example program
for ARKode.

The names of parhyp methods are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffix \sphinxcode{\_ParHyp}
(e.g. \sphinxcode{N\_VDestroy\_ParHyp}).  The module NVECTOR\_PARHYP provides the
following additional user-callable routines:
\index{N\_VNewEmpty\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VNewEmpty_ParHyp}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_ParHyp}}{MPI\_Comm\sphinxstyleemphasis{ comm}, sunindextype\sphinxstyleemphasis{ local\_length}, sunindextype\sphinxstyleemphasis{ global\_length}}{}
This function creates a new parhyp \sphinxcode{N\_Vector} with the pointer to the
HYPRE vector set to \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VMake\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VMake_ParHyp}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_ParHyp}}{hypre\_ParVector\sphinxstyleemphasis{ *x}}{}
This function creates an \sphinxcode{N\_Vector} wrapper around an existing
HYPRE parallel vector.  It does \sphinxstyleemphasis{not} allocate memory for \sphinxcode{x} itself.

\end{fulllineitems}

\index{N\_VGetVector\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VGetVector_ParHyp}}\pysiglinewithargsret{hypre\_ParVector *\sphinxbfcode{N\_VGetVector\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns a pointer to the underlying HYPRE vector.

\end{fulllineitems}

\index{N\_VCloneVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VCloneVectorArray_ParHyp}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArray\_ParHyp}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} parhyp
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VCloneVectorArrayEmpty_ParHyp}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArrayEmpty\_ParHyp}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count} parhyp
vectors, each with an empty (\sphinxcode{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VDestroyVectorArray_ParHyp}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroyVectorArray\_ParHyp}}{N\_Vector*\sphinxstyleemphasis{ vs}, int\sphinxstyleemphasis{ count}}{}
This function frees memory allocated for the array of \sphinxstyleemphasis{count}
variables of type \sphinxcode{N\_Vector} created with
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VCloneVectorArray_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArray\_ParHyp()}}}} or with
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VCloneVectorArrayEmpty_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_ParHyp()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VPrint_ParHyp}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the local content of a parhyp vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VPrintFile_ParHyp}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the local content of a parhyp vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_PARHYP
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VMake_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VMake\_ParHyp()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VMake_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VMake\_ParHyp()}}}} will have the default settings for the NVECTOR\_PARHYP module.
\index{N\_VEnableFusedOps\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableFusedOps_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the parhyp vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableLinearCombination_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the parhyp vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableScaleAddMulti_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the parhyp vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableDotProdMulti_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the parhyp vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableLinearSumVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the parhyp vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableScaleVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the parhyp vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableConstVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the parhyp vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableWrmsNormVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the parhyp vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableWrmsNormMaskVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the parhyp vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableScaleAddMultiVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the parhyp vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ParHyp:c.N_VEnableLinearCombinationVectorArray_ParHyp}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_ParHyp}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the parhyp vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \sphinxcode{N\_Vector\_ParHyp v},
it is recommended to extract the HYPRE vector via
\sphinxcode{x\_vec = N\_VGetVector\_ParHyp(v)} and then access components using
appropriate HYPRE functions.

\item {} 
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VNewEmpty_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_ParHyp()}}}}, {\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VMake_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VMake\_ParHyp()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VCloneVectorArrayEmpty_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_ParHyp()}}}} set the field \sphinxstyleemphasis{own\_parvector}
to \sphinxcode{SUNFALSE}.  The functions \sphinxcode{N\_VDestroy\_ParHyp()} and
{\hyperref[\detokenize{nvectors/NVector_ParHyp:c.N_VDestroyVectorArray_ParHyp}]{\sphinxcrossref{\sphinxcode{N\_VDestroyVectorArray\_ParHyp()}}}} will not attempt to delete an
underlying HYPRE vector for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_parvector}
set to \sphinxcode{SUNFALSE}.  In such a case, it is the user’s responsibility
to delete the underlying vector.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PARHYP
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representations of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\section{The NVECTOR\_PETSC Module}
\label{\detokenize{nvectors/NVector_PETSc:nvectors-nvpetsc}}\label{\detokenize{nvectors/NVector_PETSc:the-nvector-petsc-module}}\label{\detokenize{nvectors/NVector_PETSc::doc}}
The NVECTOR\_PETSC module is an NVECTOR wrapper around the PETSc vector. It
defines the \sphinxstyleemphasis{content} field of a \sphinxcode{N\_Vector} to be a structure
containing the global and local lengths of the vector, a pointer to
the PETSc vector, an MPI communicator, and a boolean flag  \sphinxstyleemphasis{own\_data}
indicating ownership of the wrapped PETSc vector.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Petsc} \PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{local\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{sunindextype} \PYG{n}{global\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{Vec} \PYG{o}{*}\PYG{n}{pvec}\PYG{p}{;}
   \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{comm}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to be included when using this module is
\sphinxcode{nvector\_petsc.h}.  The installed module library to link to is
\sphinxcode{libsundials\_nvecpetsc.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libraries and \sphinxcode{.a} for static libraries.

Unlike native SUNDIALS vector types, NVECTOR\_PETSC does not provide
macros to access its member variables.  Note that NVECTOR\_PETSC
requires SUNDIALS to be built with MPI support.


\subsection{NVECTOR\_PETSC functions}
\label{\detokenize{nvectors/NVector_PETSc:nvector-petsc-functions}}
The NVECTOR\_PETSC module defines implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
\sphinxcode{N\_VGetArrayPointer} and \sphinxcode{N\_VSetArrayPointer}.  As such, this
vector cannot be used with SUNDIALS Fortran interfaces.  When access
to raw vector data is needed, it is recommended to extract the PETSc
vector first, and then use PETSc methods to access the data.  Usage
examples of NVECTOR\_PETSC is provided in example programs for IDA.

The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffice \sphinxcode{\_Petsc}
(e.g. \sphinxcode{N\_VDestroy\_Petsc}).  The module NVECTOR\_PETSC provides the
following additional user-callable routines:
\index{N\_VNewEmpty\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VNewEmpty_Petsc}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Petsc}}{MPI\_Comm\sphinxstyleemphasis{ comm}, sunindextype\sphinxstyleemphasis{ local\_length}, sunindextype\sphinxstyleemphasis{ global\_length}}{}
This function creates a new PETSC \sphinxcode{N\_Vector} with the pointer to
the wrapped PETSc vector set to \sphinxcode{NULL}. It is used by the
\sphinxcode{N\_VMake\_Petsc} and \sphinxcode{N\_VClone\_Petsc} implementations.  It
should be used only with great caution.

\end{fulllineitems}

\index{N\_VMake\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VMake_Petsc}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Petsc}}{Vec*\sphinxstyleemphasis{ pvec}}{}
This function creates and allocates memory for an NVECTOR\_PETSC
wrapper with a user-provided PETSc vector.  It does \sphinxstyleemphasis{not} allocate
memory for the vector \sphinxcode{pvec} itself.

\end{fulllineitems}

\index{N\_VGetVector\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VGetVector_Petsc}}\pysiglinewithargsret{Vec *\sphinxbfcode{N\_VGetVector\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns a pointer to the underlying PETSc vector.

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VCloneVectorArray_Petsc}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArray\_Petsc}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count}
NVECTOR\_PETSC vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VCloneVectorArrayEmpty_Petsc}}\pysiglinewithargsret{N\_Vector* \sphinxbfcode{N\_VCloneVectorArrayEmpty\_Petsc}}{int\sphinxstyleemphasis{ count}, N\_Vector\sphinxstyleemphasis{ w}}{}
This function creates (by cloning) an array of \sphinxstyleemphasis{count}
NVECTOR\_PETSC vectors, each with pointers to PETSc vectors set to \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VDestroyVectorArray_Petsc}}\pysiglinewithargsret{void \sphinxbfcode{N\_VDestroyVectorArray\_Petsc}}{N\_Vector*\sphinxstyleemphasis{ vs}, int\sphinxstyleemphasis{ count}}{}
This function frees memory allocated for the array of \sphinxstyleemphasis{count}
variables of type \sphinxcode{N\_Vector} created with
{\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VCloneVectorArray_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArray\_Petsc()}}}} or with
{\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VCloneVectorArrayEmpty_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Petsc()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VPrint_Petsc}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the global content of a wrapped PETSc vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VPrintFile_Petsc}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, const char\sphinxstyleemphasis{ fname{[}{]}}}{}
This function prints the global content of a wrapped PETSc vector to \sphinxcode{fname}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_PETSC
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VMake_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Petsc()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VMake_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Petsc()}}}} will have the default settings for the NVECTOR\_PETSC module.
\index{N\_VEnableFusedOps\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableFusedOps_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the PETSc vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableLinearCombination_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the PETSc vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableScaleAddMulti_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the PETSc vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableDotProdMulti_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the PETSc vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableLinearSumVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the PETSc vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableScaleVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the PETSc vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableConstVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the PETSc vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableWrmsNormVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the PETSc vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableWrmsNormMaskVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the PETSc vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableScaleAddMultiVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the PETSc vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_PETSc:c.N_VEnableLinearCombinationVectorArray_Petsc}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Petsc}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the PETSc vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \sphinxcode{N\_Vector\_Petsc v}, it
is recommeded to extract the PETSc vector via

\sphinxcode{x\_vec = N\_VGetVector\_Petsc(v);}

and then access components using appropriate PETSc functions.

\item {} 
The functions {\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VNewEmpty_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VNewEmpty\_Petsc()}}}}, {\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VMake_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Petsc()}}}},
and {\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VCloneVectorArrayEmpty_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VCloneVectorArrayEmpty\_Petsc()}}}} set the field
\sphinxstyleemphasis{own\_data} to \sphinxcode{SUNFALSE}. The routines \sphinxcode{N\_VDestroy\_Petsc()} and
{\hyperref[\detokenize{nvectors/NVector_PETSc:c.N_VDestroyVectorArray_Petsc}]{\sphinxcrossref{\sphinxcode{N\_VDestroyVectorArray\_Petsc()}}}} will not attempt to free the
pointer \sphinxcode{pvec} for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_data} set to
\sphinxcode{SUNFALSE}. In such a case, it is the user’s responsibility to
deallocate the \sphinxcode{pvec} pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PETSC
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representations of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\section{The NVECTOR\_CUDA Module}
\label{\detokenize{nvectors/NVector_CUDA:nvectors-cuda}}\label{\detokenize{nvectors/NVector_CUDA::doc}}\label{\detokenize{nvectors/NVector_CUDA:the-nvector-cuda-module}}
The NVECTOR\_CUDA module is an NVECTOR implementation in the CUDA language.
The module allows for SUNDIALS vector kernels to run on NVIDIA GPU devices. It is intended
for users who are already familiar with CUDA and GPU programming. Building this vector
module requires a CUDA compiler and, by extension, a C++ compiler. The vector content layout
is as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Cuda}
\PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype}       \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype}        \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype}\PYG{o}{*}          \PYG{n}{host\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype}\PYG{o}{*}          \PYG{n}{device\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{SUNCudaExecPolicy}\PYG{o}{*} \PYG{n}{stream\PYGZus{}exec\PYGZus{}policy}\PYG{p}{;}
  \PYG{n}{SUNCudaExecPolicy}\PYG{o}{*} \PYG{n}{reduce\PYGZus{}exec\PYGZus{}policy}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*}              \PYG{n}{priv}\PYG{p}{;} \PYG{c+cm}{/* \PYGZsq{}private\PYGZsq{} data */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Cuda} \PYG{o}{*}\PYG{n}{N\PYGZus{}VectorContent\PYGZus{}Cuda}\PYG{p}{;}
\end{sphinxVerbatim}

The content members are the vector length (size), a boolean flag that signals if
the vector owns the data (i.e. it is in charge of freeing the data), pointers to
vector data on the host and the device, pointers to \sphinxcode{SUNCudaExecPolicy}
implementations that control how the CUDA kernels are launched for streaming and
reduction vector kernels, and a private data structure which holds additonal members
that should not be accessed directly.

When instantiated with \sphinxcode{N\_VNew\_Cuda}, the underlying data will be allocated
memory on both the host and the device. Alternatively, a user can provide host
and device data arrays by using the \sphinxcode{N\_VMake\_Cuda} constructor. To use CUDA
managed memory, the constructors \sphinxcode{N\_VNewManaged\_Cuda} and
\sphinxcode{N\_VMakeManaged\_Cuda} are provided. Details on each of these constructors
are provided below.

To use the NVECTOR\_CUDA module, include \sphinxcode{nvector\_cuda.h} and link to
the library \sphinxcode{libsundials\_nveccuda.lib}. The extension, \sphinxcode{.lib}, is
typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a} for static libraries.


\subsection{NVECTOR\_CUDA functions}
\label{\detokenize{nvectors/NVector_CUDA:nvector-cuda-functions}}
Unlike other native SUNDIALS vector types, the NVECTOR\_CUDA module does not
provide macros to access its member variables. Instead, user should use the
accessor functions:
\index{N\_VGetHostArrayPointer\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VGetHostArrayPointer_Cuda}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetHostArrayPointer\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns pointer to the vector data on the host.

\end{fulllineitems}

\index{N\_VGetDeviceArrayPointer\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VGetDeviceArrayPointer_Cuda}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetDeviceArrayPointer\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns pointer to the vector data on the device.

\end{fulllineitems}

\index{N\_VIsManagedMemory\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VIsManagedMemory_Cuda}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VIsManagedMemory\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns a boolean flag indiciating if the vector
data array is in managed memory or not.

\end{fulllineitems}


The NVECTOR\_CUDA module defines implementations of all standard vector
operations defined in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
\sphinxcode{N\_VSetArrayPointer}, and, if using unmanaged memory, \sphinxcode{N\_VGetArrayPointer}.
As such, this vector can only be used with SUNDIALS Fortran interfaces, and the
SUNDIALS direct solvers and preconditioners when using managed memory.
The NVECTOR\_CUDA module provides separate functions to access data on the host
and on the device for the unmanaged memory use case. It also provides methods for
copying from the host to the device and vice versa. Usage examples of NVECTOR\_CUDA
are provided in example programs for CVODE \phantomsection\label{\detokenize{nvectors/NVector_CUDA:id1}}{\hyperref[\detokenize{References:hsr2017}]{\sphinxcrossref{{[}HSR2017{]}}}}.

The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffix \sphinxcode{\_Cuda}
(e.g. \sphinxcode{N\_VDestroy\_Cuda}).  The module NVECTOR\_CUDA provides the
following additional user-callable routines:
\index{N\_VNew\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VNew_Cuda}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_Cuda}}{sunindextype\sphinxstyleemphasis{ length}}{}
This function creates and allocates memory for a CUDA \sphinxcode{N\_Vector}.
The vector data array is allocated on both the host and device.

\end{fulllineitems}

\index{N\_VNewManaged\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VNewManaged_Cuda}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewManaged\_Cuda}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates and allocates memory for a CUDA
\sphinxcode{N\_Vector}. The vector data array is allocated in managed memory.

\end{fulllineitems}

\index{N\_VNewEmpty\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VNewEmpty_Cuda}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Cuda}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates a new \sphinxcode{N\_Vector} wrapper with the pointer
to the wrapped CUDA vector set to \sphinxcode{NULL}.  It is used by
{\hyperref[\detokenize{nvectors/NVector_CUDA:c.N_VNew_Cuda}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Cuda()}}}}, {\hyperref[\detokenize{nvectors/NVector_CUDA:c.N_VMake_Cuda}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Cuda()}}}}, and
\sphinxcode{N\_VClone\_Cuda()} implementations.

\end{fulllineitems}

\index{N\_VMake\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VMake_Cuda}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Cuda}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype\sphinxstyleemphasis{ *h\_vdata}, realtype\sphinxstyleemphasis{ *d\_vdata}}{}
This function creates a CUDA \sphinxcode{N\_Vector} with user-supplied vector data arrays
for the host and the device.

\end{fulllineitems}

\index{N\_VMakeManaged\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VMakeManaged_Cuda}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMakeManaged\_Cuda}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype\sphinxstyleemphasis{ *vdata}}{}
This function creates a CUDA \sphinxcode{N\_Vector} with a user-supplied
managed memory data array.

\end{fulllineitems}

\index{N\_VMakeWithManagedAllocator\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VMakeWithManagedAllocator_Cuda}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMakeWithManagedAllocator\_Cuda}}{sunindextype\sphinxstyleemphasis{ length}, void* (\sphinxstyleemphasis{*allocfn})(size\_t size), void (*freefn)(void* ptr)}{}
This function creates a CUDA \sphinxcode{N\_Vector} with a user-supplied memory allocator.
It requires the user to provide a corresponding free function as well.
The memory allocated by the allocator function must behave like CUDA managed memory.

\end{fulllineitems}


The module NVECTOR\_CUDA also provides the following user-callable routines:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{void~N\_VSetKernelExecPolicy\_Cuda(N\_Vector~v,}}\pysigline{\sphinxbfcode{SUNCudaExecPolicy*~stream\_exec\_policy,}}\pysigline{\sphinxbfcode{SUNCudaExecPolicy*~reduce\_exec\_policy)}}
This function sets the execution policies which control the kernel parameters
utilized when launching the streaming and reduction CUDA kernels. By default
the vector is setup to use the \sphinxcode{SUNCudaThreadDirectExecPolicy} and
\sphinxcode{SUNCudaBlockReduceExecPolicy}. Any custom execution policy for reductions
must ensure that the grid dimensions (number of thread blocks) is a multiple of
the CUDA warp size (32). See section {\hyperref[\detokenize{nvectors/NVector_CUDA:nvectors-cuda-suncudaexecpolicy}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNCudaExecPolicy Class}}}}
below for more information about the \sphinxcode{SUNCudaExecPolicy} class.

\sphinxstyleemphasis{Note: All vectors used in a single instance of a \{sundials\} solver must
use the same execution policy. It is **strongly recommended*} that
this function is called immediately after constructing the vector,
and any subsequent vector be created by cloning to ensure consistent execution
policies across vectors*

\end{fulllineitems}

\index{N\_VSetCudaStream\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VSetCudaStream_Cuda}}\pysiglinewithargsret{void \sphinxbfcode{N\_VSetCudaStream\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, cudaStream\_t\sphinxstyleemphasis{ *stream}}{}
\sphinxstylestrong{DEPRECATED} This function will be removed in the next major release,
user should utilize the \sphinxcode{N\_VSetKernelExecPolicy\_Cuda} function instead.

This function sets the CUDA stream that all vector kernels will be launched on.
By default an NVECTOR\_CUDA uses the default CUDA stream.

\sphinxstyleemphasis{Note: All vectors used in a single instance of a \{sundials\} solver must
use the same CUDA stream. It is **strongly recommended*} that
this function is called immediately after constructing the vector,
and any subsequent vector be created by cloning to ensure consistent execution
policies across vectors*

\end{fulllineitems}

\index{N\_VCopyToDevice\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VCopyToDevice_Cuda}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VCopyToDevice\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies host vector data to the device.

\end{fulllineitems}

\index{N\_VCopyFromDevice\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VCopyFromDevice_Cuda}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VCopyFromDevice\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies vector data from the device to the host.

\end{fulllineitems}

\index{N\_VPrint\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VPrint_Cuda}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the content of a CUDA vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VPrintFile_Cuda}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the content of a CUDA vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_CUDA
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_CUDA:c.N_VNew_Cuda}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Cuda()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_CUDA:c.N_VNew_Cuda}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Cuda()}}}} will have the default settings for the NVECTOR\_CUDA module.
\index{N\_VEnableFusedOps\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableFusedOps_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the CUDA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableLinearCombination_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the CUDA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableScaleAddMulti_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the CUDA vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableDotProdMulti_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the CUDA vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableLinearSumVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the CUDA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableScaleVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the CUDA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableConstVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the CUDA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableWrmsNormVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the CUDA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableWrmsNormMaskVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the CUDA vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableScaleAddMultiVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the CUDA vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_CUDA:c.N_VEnableLinearCombinationVectorArray_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Cuda}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the CUDA vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \sphinxcode{N\_Vector\_Cuda}, \sphinxcode{v},
it is recommeded to use functions {\hyperref[\detokenize{nvectors/NVector_CUDA:c.N_VGetDeviceArrayPointer_Cuda}]{\sphinxcrossref{\sphinxcode{N\_VGetDeviceArrayPointer\_Cuda()}}}} or
{\hyperref[\detokenize{nvectors/NVector_CUDA:c.N_VGetHostArrayPointer_Cuda}]{\sphinxcrossref{\sphinxcode{N\_VGetHostArrayPointer\_Cuda()}}}}. However, when using managed memory,
the function {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetArrayPointer()}}}} may also be used.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_CUDA implementation
that have more than one \sphinxcode{N\_Vector} argument do not check for
consistent internal representations of these vectors. It is the user’s
responsibility to ensure that such routines are called with \sphinxcode{N\_Vector}
arguments that were all created with the same internal representations.

\end{itemize}


\subsection{The \sphinxstyleliteralintitle{SUNCudaExecPolicy} Class}
\label{\detokenize{nvectors/NVector_CUDA:nvectors-cuda-suncudaexecpolicy}}\label{\detokenize{nvectors/NVector_CUDA:the-suncudaexecpolicy-class}}
In order to provide maximum flexibility to users, the CUDA kernel execution parameters used
by kernels within SUNDIALS are defined by objects of the \sphinxcode{sundials::CudaExecPolicy}
abstract class type (this class can be accessed in the global namespace as \sphinxcode{SUNCudaExecPolicy}).
Thus, users may provide custom execution policies that fit the needs of their problem. The
\sphinxcode{sundials::CudaExecPolicy} is defined in the header file \sphinxcode{sundials\_cuda\_policies.hpp},
as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{CudaExecPolicy}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n+nf}{blockSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{n}{cudaStream\PYGZus{}t} \PYG{n+nf}{stream}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{n}{CudaExecPolicy}\PYG{o}{*} \PYG{n+nf}{clone}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{CudaExecPolicy}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

To define a custom execution policy, a user simply needs to create a class that inherits from
the abstract class and implements the methods. The SUNDIALS provided
\sphinxcode{sundials::CudaThreadDirectExecPolicy} (aka in the global namespace as
\sphinxcode{SUNCudaThreadDirectExecPolicy}) class is a good example of a what a custom execution policy
may look like:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{CudaThreadDirectExecPolicy} \PYG{o}{:} \PYG{k}{public} \PYG{n}{CudaExecPolicy}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{n}{CudaThreadDirectExecPolicy}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim}\PYG{p}{,} \PYG{k}{const} \PYG{n}{cudaStream\PYGZus{}t} \PYG{n}{stream} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
      \PYG{o}{:} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{(}\PYG{n}{blockDim}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stream\PYGZus{}}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

   \PYG{n}{CudaThreadDirectExecPolicy}\PYG{p}{(}\PYG{k}{const} \PYG{n}{CudaThreadDirectExecPolicy}\PYG{o}{\PYGZam{}} \PYG{n}{ex}\PYG{p}{)}
      \PYG{o}{:} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{.}\PYG{n}{blockDim\PYGZus{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stream\PYGZus{}}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{.}\PYG{n}{stream\PYGZus{}}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{p}{(}\PYG{n}{numWorkUnits} \PYG{o}{+} \PYG{n}{blockSize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{blockSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{n}{cudaStream\PYGZus{}t} \PYG{n}{stream}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{stream\PYGZus{}}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{n}{CudaExecPolicy}\PYG{o}{*} \PYG{n}{clone}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{CudaExecPolicy}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{new} \PYG{n}{CudaThreadDirectExecPolicy}\PYG{p}{(}\PYG{o}{*}\PYG{k}{this}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
   \PYG{k}{const} \PYG{n}{cudaStream\PYGZus{}t} \PYG{n}{stream\PYGZus{}}\PYG{p}{;}
   \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

In total, SUNDIALS provides 3 execution policies:
\begin{enumerate}
\item {} 
\sphinxcode{SUNCudaThreadDirectExecPolicy(const size\_t blockDim, const cudaStream\_t stream = 0)}
maps each CUDA thread to a work unit. The number of threads per block (blockDim) can be set
to anything. The grid size will be calculated so that there are enough threads for one
thread per element. If a CUDA stream is provided, it will be used to execute the kernel.

\item {} 
\sphinxcode{SUNCudaGridStrideExecPolicy(const size\_t blockDim, const size\_t gridDim, const cudaStream\_t stream = 0)}
is for kernels that use grid stride loops. The number of threads per block (blockDim)
can be set to anything. The number of blocks (gridDim) can be set to anything. If a
CUDA stream is provided, it will be used to execute the kernel.

\item {} 
\sphinxcode{SUNCudaBlockReduceExecPolicy(const size\_t blockDim, const cudaStream\_t stream = 0)}
is for kernels performing a reduction across indvidual thread blocks. The number of threads
per block (blockDim) can be set to any valid multiple of the CUDA warp size. The grid size
(gridDim) can be set to any value greater than 0. If it is set to 0, then the grid size
will be chosen so that there is enough threads for one thread per work unit. If a
CUDA stream is provided, it will be used to execute the kernel.

\end{enumerate}

For example, a policy that uses 128 threads per block and a user provided stream can be
created like so:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cudaStream\PYGZus{}t} \PYG{n}{stream}\PYG{p}{;}
\PYG{n}{cudaStreamCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{SUNCudaThreadDirectExecPolicy} \PYG{n+nf}{thread\PYGZus{}direct}\PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

These default policy objects can be reused for multiple SUNDIALS data structures
(e.g. a \sphinxcode{SUNMatrix} and an \sphinxcode{N\_Vector}) since they do not hold any modifiable
state information.


\section{The NVECTOR\_HIP Module}
\label{\detokenize{nvectors/NVector_HIP::doc}}\label{\detokenize{nvectors/NVector_HIP:the-nvector-hip-module}}\label{\detokenize{nvectors/NVector_HIP:nvectors-hip}}
The NVECTOR\_HIP module is an NVECTOR implementation using the AMD ROCm HIP
library. The module allows for SUNDIALS vector kernels to run on AMD or NVIDIA
GPU devices. It is intended for users who are already familiar with HIP and GPU
programming. Building this vector module requires the HIP-clang compiler. The
vector content layout is as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Hip}
\PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype}       \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype}        \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{SUNMemory}          \PYG{n}{host\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{SUNMemory}          \PYG{n}{device\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{SUNHipExecPolicy}\PYG{o}{*}  \PYG{n}{stream\PYGZus{}exec\PYGZus{}policy}\PYG{p}{;}
  \PYG{n}{SUNHipExecPolicy}\PYG{o}{*}  \PYG{n}{reduce\PYGZus{}exec\PYGZus{}policy}\PYG{p}{;}
  \PYG{n}{SUNMemoryHelper}    \PYG{n}{mem\PYGZus{}helper}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*}              \PYG{n}{priv}\PYG{p}{;} \PYG{c+cm}{/* \PYGZsq{}private\PYGZsq{} data */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Hip} \PYG{o}{*}\PYG{n}{N\PYGZus{}VectorContent\PYGZus{}Hip}\PYG{p}{;}
\end{sphinxVerbatim}

The content members are the vector length (size), a boolean flag that signals if
the vector owns the data (i.e. it is in charge of freeing the data), pointers to
vector data on the host and the device, pointers to \sphinxcode{SUNHipExecPolicy}
implementations that control how the HIP kernels are launched for streaming and
reduction vector kernels, and a private data structure which holds additonal members
that should not be accessed directly.

When instantiated with {\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VNew_Hip}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Hip()}}}}, the underlying data will be allocated
memory on both the host and the device. Alternatively, a user can provide host
and device data arrays by using the {\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VMake_Hip}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Hip()}}}} constructor. To use HIP
managed memory, the constructors {\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VNewManaged_Hip}]{\sphinxcrossref{\sphinxcode{N\_VNewManaged\_Hip()}}}} and
{\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VMakeManaged_Hip}]{\sphinxcrossref{\sphinxcode{N\_VMakeManaged\_Hip()}}}} are provided. Details on each of these constructors
are provided below.

To use the NVECTOR\_HIP module, include \sphinxcode{nvector\_hip.h} and link to
the library \sphinxcode{libsundials\_nvechip.lib}. The extension, \sphinxcode{.lib}, is
typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a} for static libraries.


\subsection{NVECTOR\_HIP functions}
\label{\detokenize{nvectors/NVector_HIP:nvector-hip-functions}}
Unlike other native SUNDIALS vector types, the NVECTOR\_HIP module does not
provide macros to access its member variables. Instead, user should use the
accessor functions:
\index{N\_VGetHostArrayPointer\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VGetHostArrayPointer_Hip}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetHostArrayPointer\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns pointer to the vector data on the host.

\end{fulllineitems}

\index{N\_VGetDeviceArrayPointer\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VGetDeviceArrayPointer_Hip}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetDeviceArrayPointer\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns pointer to the vector data on the device.

\end{fulllineitems}

\index{N\_VIsManagedMemory\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VIsManagedMemory_Hip}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VIsManagedMemory\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns a boolean flag indiciating if the vector
data array is in managed memory or not.

\end{fulllineitems}


The NVECTOR\_HIP module defines implementations of all standard vector
operations defined in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VSetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VSetArrayPointer()}}}}.
The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffix \sphinxcode{\_Hip}
(e.g. \sphinxcode{N\_VDestroy\_Hip()}).  The module NVECTOR\_HIP provides the
following additional user-callable routines:
\index{N\_VNew\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VNew_Hip}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_Hip}}{sunindextype\sphinxstyleemphasis{ length}}{}
This function creates and allocates memory for a HIP \sphinxcode{N\_Vector}.
The vector data array is allocated on both the host and device.

\end{fulllineitems}

\index{N\_VNewManaged\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VNewManaged_Hip}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewManaged\_Hip}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates and allocates memory for a HIP
\sphinxcode{N\_Vector}. The vector data array is allocated in managed memory.

\end{fulllineitems}

\index{N\_VNewEmpty\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VNewEmpty_Hip}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Hip}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates a new \sphinxcode{N\_Vector} wrapper with the pointer
to the wrapped HIP vector set to \sphinxcode{NULL}.  It is used by
{\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VNew_Hip}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Hip()}}}}, {\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VMake_Hip}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Hip()}}}}, and
\sphinxcode{N\_VClone\_Hip()} implementations.

\end{fulllineitems}

\index{N\_VMake\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VMake_Hip}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Hip}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype\sphinxstyleemphasis{ *h\_vdata}, realtype\sphinxstyleemphasis{ *d\_vdata}}{}
This function creates a HIP \sphinxcode{N\_Vector} with user-supplied vector data arrays
for the host and the device.

\end{fulllineitems}

\index{N\_VMakeManaged\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VMakeManaged_Hip}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMakeManaged\_Hip}}{sunindextype\sphinxstyleemphasis{ vec\_length}, realtype\sphinxstyleemphasis{ *vdata}}{}
This function creates a HIP \sphinxcode{N\_Vector} with a user-supplied
managed memory data array.

\end{fulllineitems}


The module NVECTOR\_HIP also provides the following user-callable routines:
\index{N\_VSetKernelExecPolicy\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VSetKernelExecPolicy_Hip}}\pysiglinewithargsret{void \sphinxbfcode{N\_VSetKernelExecPolicy\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, SUNHipExecPolicy*\sphinxstyleemphasis{ stream\_exec\_policy}, SUNHipExecPolicy*\sphinxstyleemphasis{ reduce\_exec\_policy}}{}
This function sets the execution policies which control the kernel parameters
utilized when launching the streaming and reduction HIP kernels. By default
the vector is setup to use the \sphinxcode{SUNHipThreadDirectExecPolicy} and
\sphinxcode{SUNHipBlockReduceExecPolicy}. Any custom execution policy for reductions
must ensure that the grid dimensions (number of thread blocks) is a multiple
of the HIP warp size (32 for NVIDIA GPUs, 64 for AMD GPUs). See section
{\hyperref[\detokenize{nvectors/NVector_HIP:nvectors-hip-sunhipexecpolicy}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNHipExecPolicy Class}}}} below for more information about the
\sphinxcode{SUNHipExecPolicy} class.

\sphinxstyleemphasis{Note: All vectors used in a single instance of a \{sundials\} solver must
use the same execution policy. It is **strongly recommended*} that
this function is called immediately after constructing the vector,
and any subsequent vector be created by cloning to ensure consistent execution
policies across vectors*

\end{fulllineitems}

\index{N\_VCopyToDevice\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VCopyToDevice_Hip}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VCopyToDevice\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies host vector data to the device.

\end{fulllineitems}

\index{N\_VCopyFromDevice\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VCopyFromDevice_Hip}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VCopyFromDevice\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies vector data from the device to the host.

\end{fulllineitems}

\index{N\_VPrint\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VPrint_Hip}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the content of a HIP vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VPrintFile_Hip}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the content of a HIP vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_HIP
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VNew_Hip}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Hip()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VNew_Hip}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Hip()}}}} will have the default settings for the NVECTOR\_HIP module.
\index{N\_VEnableFusedOps\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableFusedOps_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the HIP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableLinearCombination_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the HIP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableScaleAddMulti_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the HIP vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableDotProdMulti_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the HIP vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableLinearSumVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the HIP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableScaleVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the HIP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableConstVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the HIP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableWrmsNormVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the HIP vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableWrmsNormMaskVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the HIP vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableScaleAddMultiVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the HIP vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Hip (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_HIP:c.N_VEnableLinearCombinationVectorArray_Hip}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Hip}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the HIP vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \sphinxcode{N\_Vector\_Hip}, \sphinxcode{v},
it is recommeded to use functions {\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VGetDeviceArrayPointer_Hip}]{\sphinxcrossref{\sphinxcode{N\_VGetDeviceArrayPointer\_Hip()}}}} or
{\hyperref[\detokenize{nvectors/NVector_HIP:c.N_VGetHostArrayPointer_Hip}]{\sphinxcrossref{\sphinxcode{N\_VGetHostArrayPointer\_Hip()}}}}. However, when using managed memory,
the function {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetArrayPointer()}}}} may also be used.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_HIP implementation
that have more than one \sphinxcode{N\_Vector} argument do not check for
consistent internal representations of these vectors. It is the user’s
responsibility to ensure that such routines are called with \sphinxcode{N\_Vector}
arguments that were all created with the same internal representations.

\end{itemize}


\subsection{The \sphinxstyleliteralintitle{SUNHipExecPolicy} Class}
\label{\detokenize{nvectors/NVector_HIP:nvectors-hip-sunhipexecpolicy}}\label{\detokenize{nvectors/NVector_HIP:the-sunhipexecpolicy-class}}
In order to provide maximum flexibility to users, the HIP kernel execution parameters used
by kernels within SUNDIALS are defined by objects of the \sphinxcode{sundials::HipExecPolicy}
abstract class type (this class can be accessed in the global namespace as \sphinxcode{SUNHipExecPolicy}).
Thus, users may provide custom execution policies that fit the needs of their problem. The
\sphinxcode{sundials::HipExecPolicy} is defined in the header file \sphinxcode{sundials\_hip\_policies.hpp},
as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{HipExecPolicy}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n+nf}{blockSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{n}{hipStream\PYGZus{}t} \PYG{n+nf}{stream}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{n}{HipExecPolicy}\PYG{o}{*} \PYG{n+nf}{clone}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{virtual} \PYG{o}{\PYGZti{}}\PYG{n}{HipExecPolicy}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

To define a custom execution policy, a user simply needs to create a class that inherits from
the abstract class and implements the methods. The SUNDIALS provided
\sphinxcode{sundials::HipThreadDirectExecPolicy} (aka in the global namespace as
\sphinxcode{SUNHipThreadDirectExecPolicy}) class is a good example of a what a custom execution policy
may look like:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{HipThreadDirectExecPolicy} \PYG{o}{:} \PYG{k}{public} \PYG{n}{HipExecPolicy}
\PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
   \PYG{n}{HipThreadDirectExecPolicy}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim}\PYG{p}{,} \PYG{k}{const} \PYG{n}{hipStream\PYGZus{}t} \PYG{n}{stream} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
      \PYG{o}{:} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{(}\PYG{n}{blockDim}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stream\PYGZus{}}\PYG{p}{(}\PYG{n}{stream}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

   \PYG{n}{HipThreadDirectExecPolicy}\PYG{p}{(}\PYG{k}{const} \PYG{n}{HipThreadDirectExecPolicy}\PYG{o}{\PYGZam{}} \PYG{n}{ex}\PYG{p}{)}
      \PYG{o}{:} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{.}\PYG{n}{blockDim\PYGZus{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stream\PYGZus{}}\PYG{p}{(}\PYG{n}{ex}\PYG{p}{.}\PYG{n}{stream\PYGZus{}}\PYG{p}{)}
   \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{p}{(}\PYG{n}{numWorkUnits} \PYG{o}{+} \PYG{n}{blockSize}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{blockSize}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockSize}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{numWorkUnits} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{gridDim} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{n}{hipStream\PYGZus{}t} \PYG{n}{stream}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{stream\PYGZus{}}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k}{virtual} \PYG{n}{HipExecPolicy}\PYG{o}{*} \PYG{n}{clone}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}
   \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{k}{static\PYGZus{}cast}\PYG{o}{\PYGZlt{}}\PYG{n}{HipExecPolicy}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{new} \PYG{n}{HipThreadDirectExecPolicy}\PYG{p}{(}\PYG{o}{*}\PYG{k}{this}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{k}{private}\PYG{o}{:}
   \PYG{k}{const} \PYG{n}{hipStream\PYGZus{}t} \PYG{n}{stream\PYGZus{}}\PYG{p}{;}
   \PYG{k}{const} \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{blockDim\PYGZus{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

In total, SUNDIALS provides 3 execution policies:
\begin{enumerate}
\item {} 
\sphinxcode{SUNHipThreadDirectExecPolicy(const size\_t blockDim, const hipStream\_t stream = 0)}
maps each HIP thread to a work unit. The number of threads per block (blockDim) can be set
to anything. The grid size will be calculated so that there are enough threads for one
thread per element. If a HIP stream is provided, it will be used to execute the kernel.

\item {} 
\sphinxcode{SUNHipGridStrideExecPolicy(const size\_t blockDim, const size\_t gridDim, const hipStream\_t stream = 0)}
is for kernels that use grid stride loops. The number of threads per block (blockDim)
can be set to anything. The number of blocks (gridDim) can be set to anything. If a
HIP stream is provided, it will be used to execute the kernel.

\item {} 
\sphinxcode{SUNHipBlockReduceExecPolicy(const size\_t blockDim, const hipStream\_t stream = 0)}
is for kernels performing a reduction across indvidual thread blocks. The number of threads
per block (blockDim) can be set to any valid multiple of the HIP warp size. The grid size
(gridDim) can be set to any value greater than 0. If it is set to 0, then the grid size
will be chosen so that there is enough threads for one thread per work unit. If a
HIP stream is provided, it will be used to execute the kernel.

\end{enumerate}

For example, a policy that uses 128 threads per block and a user provided stream can be
created like so:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hipStream\PYGZus{}t} \PYG{n}{stream}\PYG{p}{;}
\PYG{n}{hipStreamCreate}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{SUNHipThreadDirectExecPolicy} \PYG{n+nf}{thread\PYGZus{}direct}\PYG{p}{(}\PYG{l+m+mi}{128}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

These default policy objects can be reused for multiple SUNDIALS data structures
(e.g. a \sphinxcode{SUNMatrix} and an \sphinxcode{N\_Vector}) since they do not hold any modifiable
state information.


\section{The NVECTOR\_RAJA Module}
\label{\detokenize{nvectors/NVector_RAJA:the-nvector-raja-module}}\label{\detokenize{nvectors/NVector_RAJA::doc}}\label{\detokenize{nvectors/NVector_RAJA:nvectors-raja}}
The NVECTOR\_RAJA module is an experimental \{nvector\} implementation using the
\sphinxhref{https://software.llnl.gov/RAJA/}{RAJA} hardware abstraction layer. In this
implementation, RAJA allows for SUNDIALS vector kernels to run on AMD or NVIDIA
GPU devices. The module is intended for users who are already familiar with RAJA
and GPU programming. Building this vector module requires a C++11 compliant
compiler and either the NVIDIA CUDA programming environment, or the AMD ROCm HIP
programming environment. When using the AMD ROCm HIP environment, the HIP-clang
compiler must be utilized. Users can select which backend (CUDA or HIP) to
compile with by setting the \sphinxcode{SUNDIALS\_RAJA\_BACKENDS} CMake variable to
either CUDA or HIP. Besides the CUDA and HIP backends, RAJA has other
backends such as serial, OpenMP, and OpenACC. These backends are not used in
this SUNDIALS release.

The vector content layout is as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Raja}
\PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
   \PYG{n}{booleantype}  \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{realtype}\PYG{o}{*}    \PYG{n}{host\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{realtype}\PYG{o}{*}    \PYG{n}{device\PYGZus{}data}\PYG{p}{;}
   \PYG{k+kt}{void}\PYG{o}{*}        \PYG{n}{priv}\PYG{p}{;} \PYG{c+cm}{/* \PYGZsq{}private\PYGZsq{} data */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The content members are the vector length (size), a boolean flag that signals if
the vector owns the data (i.e., it is in charge of freeing the data), pointers to
vector data on the host and the device, and a private data structure which holds
the memory management type, which should not be accessed directly.

When instantiated with {\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VNew_Raja}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Raja()}}}}, the underlying data will be allocated
on both the host and the device. Alternatively, a user can provide host
and device data arrays by using the {\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VMake_Raja}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Raja()}}}} constructor. To use
managed memory, the constructors {\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VNewManaged_Raja}]{\sphinxcrossref{\sphinxcode{N\_VNewManaged\_Raja()}}}} and
\sphinxcode{N\_VMakeManaged\_Raja()} are provided. Details on each of these constructors
are provided below.

The header file to include when using this is \sphinxcode{nvector\_raja.h}. The installed
module library to link to is \sphinxcode{libsundials\_nveccudaraja.lib} when using the
CUDA backend and \sphinxcode{libsundials\_nvechipraja.lib} when using the HIP backend. The
extension \sphinxcode{.lib} is typically \sphinxcode{.so} for shared libraries \sphinxcode{.a} for static
libraries.


\subsection{NVECTOR\_RAJA functions}
\label{\detokenize{nvectors/NVector_RAJA:nvector-raja-functions}}
Unlike other native SUNDIALS vector types, the NVECTOR\_RAJA module does not
provide macros to access its member variables. Instead, user should use the
accessor functions:
\index{N\_VGetHostArrayPointer\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VGetHostArrayPointer_Raja}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetHostArrayPointer\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns pointer to the vector data on the host.

\end{fulllineitems}

\index{N\_VGetDeviceArrayPointer\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VGetDeviceArrayPointer_Raja}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VGetDeviceArrayPointer\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns pointer to the vector data on the device.

\end{fulllineitems}

\index{N\_VIsManagedMemory\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VIsManagedMemory_Raja}}\pysiglinewithargsret{booleantype \sphinxbfcode{N\_VIsManagedMemory\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns a boolean flag indicating if the vector
data is allocated in managed memory or not.

\end{fulllineitems}


The NVECTOR\_RAJA module defines the implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
\sphinxcode{N\_VDotProdMulti}, \sphinxcode{N\_VWrmsNormVectorArray},
\sphinxcode{N\_VWrmsNormMaskVectorArray} as support for arrays of reduction
vectors is not yet supported in RAJA.  These functions will be added
to the NVECTOR\_RAJA implementation in the future.  Additionally, the
operations \sphinxcode{N\_VGetArrayPointer} and \sphinxcode{N\_VSetArrayPointer} are not
implemented by the RAJA vector.  As such, this
vector cannot be used with SUNDIALS Fortran interfaces, nor with
SUNDIALS direct solvers and preconditioners. The NVECTOR\_RAJA module
provides separate functions to access data on the host and on the
device. It also provides methods for copying from the host to the
device and vice versa. Usage examples of NVECTOR\_RAJA are provided in
some example programs for CVODE \phantomsection\label{\detokenize{nvectors/NVector_RAJA:id1}}{\hyperref[\detokenize{References:hsr2017}]{\sphinxcrossref{{[}HSR2017{]}}}}.

The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffix \sphinxcode{\_Raja}
(e.g. \sphinxcode{N\_VDestroy\_Raja}).  The module NVECTOR\_RAJA
provides the following additional user-callable routines:
\index{N\_VNew\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VNew_Raja}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_Raja}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates and allocates memory for a RAJA
\sphinxcode{N\_Vector}. The memory is allocated on both the host and the
device. Its only argument is the vector length.

\end{fulllineitems}

\index{N\_VNewManaged\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VNewManaged_Raja}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewManaged\_Raja}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates and allocates memory for a RAJA \sphinxcode{N\_Vector}.
The vector data array is allocated in managed memory.

\end{fulllineitems}

\index{N\_VNewEmpty\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VNewEmpty_Raja}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNewEmpty\_Raja}}{sunindextype\sphinxstyleemphasis{ vec\_length}}{}
This function creates a new \sphinxcode{N\_Vector} wrapper with the pointer
to the wrapped RAJA vector set to \sphinxcode{NULL}.  It is used by
{\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VNew_Raja}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Raja()}}}}, {\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VMake_Raja}]{\sphinxcrossref{\sphinxcode{N\_VMake\_Raja()}}}}, and
\sphinxcode{N\_VClone\_Raja()} implementations.

\end{fulllineitems}

\index{N\_VMake\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VMake_Raja}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_Raja}}{sunindextype\sphinxstyleemphasis{ length}, realtype\sphinxstyleemphasis{ *vdata}}{}
This function creates an NVECTOR\_RAJA with a user-supplied managed
memory data array. This function does not allocate memory for data itself.

\end{fulllineitems}

\index{N\_VCopyToDevice\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VCopyToDevice_Raja}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VCopyToDevice\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies host vector data to the device.

\end{fulllineitems}

\index{N\_VCopyFromDevice\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VCopyFromDevice_Raja}}\pysiglinewithargsret{realtype* \sphinxbfcode{N\_VCopyFromDevice\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function copies vector data from the device to the host.

\end{fulllineitems}

\index{N\_VPrint\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VPrint_Raja}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrint\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function prints the content of a RAJA vector to \sphinxcode{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VPrintFile_Raja}}\pysiglinewithargsret{void \sphinxbfcode{N\_VPrintFile\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, FILE\sphinxstyleemphasis{ *outfile}}{}
This function prints the content of a RAJA vector to \sphinxcode{outfile}.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_RAJA
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with {\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VNew_Raja}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Raja()}}}}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
{\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VNew_Raja}]{\sphinxcrossref{\sphinxcode{N\_VNew\_Raja()}}}} will have the default settings for the NVECTOR\_RAJA module.
\index{N\_VEnableFusedOps\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableFusedOps_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the RAJA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableLinearCombination_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the RAJA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableScaleAddMulti_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the RAJA vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableLinearSumVectorArray_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the RAJA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableScaleVectorArray_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the RAJA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableConstVectorArray_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the RAJA vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableScaleAddMultiVectorArray_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the RAJA vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_RAJA:c.N_VEnableLinearCombinationVectorArray_Raja}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_Raja}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the RAJA vector. The return value
is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure
are \sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \sphinxcode{N\_Vector\_Raja}, \sphinxcode{v},
it is recommended to use functions {\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VGetDeviceArrayPointer_Raja}]{\sphinxcrossref{\sphinxcode{N\_VGetDeviceArrayPointer\_Raja()}}}} or
{\hyperref[\detokenize{nvectors/NVector_RAJA:c.N_VGetHostArrayPointer_Raja}]{\sphinxcrossref{\sphinxcode{N\_VGetHostArrayPointer\_Raja()}}}}. However, when using managed memory,
the function \sphinxcode{N\_VGetArrayPointer} may also be used.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_RAJA implementation
that have more than one \sphinxcode{N\_Vector} argument do not check for
consistent internal representations of these vectors. It is the user’s
responsibility to ensure that such routines are called with \sphinxcode{N\_Vector}
arguments that were all created with the same internal representations.

\end{itemize}


\section{The NVECTOR\_OPENMPDEV Module}
\label{\detokenize{nvectors/NVector_OpenMPDEV:nvectors-openmpdev}}\label{\detokenize{nvectors/NVector_OpenMPDEV:the-nvector-openmpdev-module}}\label{\detokenize{nvectors/NVector_OpenMPDEV::doc}}
In situations where a user has access to a device such as a GPU for
offloading computation, SUNDIALS provides an NVECTOR implementation using
OpenMP device offloading, called NVECTOR\_OPENMPDEV.

The NVECTOR\_OPENMPDEV implementation defines the \sphinxstyleemphasis{content} field
of the \sphinxcode{N\_Vector} to be a structure  containing the length of the vector, a pointer
to the beginning of a contiguousdata array on the host, a pointer to the beginning of
a contiguous data array on the device, and a boolean flag \sphinxcode{own\_data} which specifies
the ownership of host and device data arrays.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}OpenMPDEV} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{host\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{dev\PYGZus{}data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to include when using this module is \sphinxcode{nvector\_openmpdev.h}.
The installed module library to link to is \sphinxcode{libsundials\_nvecopenmpdev.lib}
where \sphinxcode{.lib} is typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a}
for static libraries.


\subsection{NVECTOR\_OPENMPDEV accessor macros}
\label{\detokenize{nvectors/NVector_OpenMPDEV:nvector-openmpdev-accessor-macros}}
The following macros are provided to access the content of an NVECTOR\_OPENMPDEV
vector.
\index{NV\_CONTENT\_OMPDEV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.NV_CONTENT_OMPDEV}}\pysiglinewithargsret{\sphinxbfcode{NV\_CONTENT\_OMPDEV}}{v}{}
This macro gives access to the contents of the NVECTOR\_OPENMPDEV
vector \sphinxcode{N\_Vector}.

The assignment \sphinxcode{v\_cont = NV\_CONTENT\_S(v)} sets \sphinxcode{v\_cont} to be a
pointer to the NVECTOR\_OPENMPDEV  content structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}OMPDEV(v) ( (N\PYGZus{}VectorContent\PYGZus{}OpenMPDEV)(v\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_OMPDEV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.NV_OWN_DATA_OMPDEV}}\pysiglinewithargsret{\sphinxbfcode{NV\_OWN\_DATA\_OMPDEV}}{v}{}
Access the \sphinxstyleemphasis{own\_data} component of the OpenMPDEV \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_data = NV\_DATA\_HOST\_OMPDEV(v)} sets \sphinxcode{v\_data} to be
a pointer to the first component of the data on the host for the \sphinxcode{N\_Vector} \sphinxcode{v}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}OMPDEV(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMPDEV(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_DATA\_HOST\_OMPDEV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.NV_DATA_HOST_OMPDEV}}\pysiglinewithargsret{\sphinxbfcode{NV\_DATA\_HOST\_OMPDEV}}{v}{}
The assignment \sphinxcode{NV\_DATA\_HOST\_OMPDEV(v) = v\_data} sets the host component array
of \sphinxcode{v} to  be \sphinxcode{v\_data} by storing the pointer \sphinxcode{v\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}HOST\PYGZus{}OMPDEV(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMPDEV(v)\PYGZhy{}\PYGZgt{}host\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_DATA\_DEV\_OMPDEV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.NV_DATA_DEV_OMPDEV}}\pysiglinewithargsret{\sphinxbfcode{NV\_DATA\_DEV\_OMPDEV}}{v}{}
The assignment \sphinxcode{v\_dev\_data = NV\_DATA\_DEV\_OMPDEV(v)} sets \sphinxcode{v\_dev\_data} to be
a pointer to the first component of the data on the device for the \sphinxcode{N\_Vector} \sphinxcode{v}.
The assignment \sphinxcode{NV\_DATA\_DEV\_OMPDEV(v) = v\_dev\_data} sets the device component
array of \sphinxcode{v} to be \sphinxcode{v\_dev\_data} by storing the pointer \sphinxcode{v\_dev\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}DEV\PYGZus{}OMPDEV(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMPDEV(v)\PYGZhy{}\PYGZgt{}dev\PYGZus{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_OMPDEV (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.NV_LENGTH_OMPDEV}}\pysigline{\sphinxbfcode{NV\_LENGTH\_OMPDEV}}
Access the \sphinxstyleemphasis{length} component of the OpenMPDEV \sphinxcode{N\_Vector} \sphinxstyleemphasis{v}.

The assignment \sphinxcode{v\_len = NV\_LENGTH\_OMPDEV(v)} sets \sphinxcode{v\_len} to be
the length of \sphinxcode{v}. On the other hand, the call \sphinxcode{NV\_LENGTH\_OMPDEV(v) = len\_v}
sets the length of \sphinxcode{v} to be \sphinxcode{len\_v}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}OMPDEV(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMPDEV(v)\PYGZhy{}\PYGZgt{}length )}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{NVECTOR\_OPENMPDEV functions}
\label{\detokenize{nvectors/NVector_OpenMPDEV:nvector-openmpdev-functions}}
The NVECTOR\_OPENMPDEV module defines OpenMP device offloading implementations of all vector
operations listed in Tables {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for \sphinxcode{N\_VGetArrayPointer} and \sphinxcode{N\_VSetArrayPointer}.
As such, this vector cannot be used with the SUNDIALS FORTRAN interfaces, nor with the
SUNDIALS direct solvers and preconditioners. It also provides methods for copying from
the host to the device and vice versa.

The names of the vector operations are obtained from those in tables
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffix \sphinxcode{\_OpenMPDEV} (e.g. \sphinxcode{N\_VDestroy\_OpenMPDEV}).
The module NVECTOR\_OPENMPDEV provides the following additional user-callable routines:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{N\_Vector~N\_VNew\_OpenMPDEV(sunindextype~vec\_length);}}
This function creates and allocates memory for an NVECTOR\_OPENMPDEV \sphinxcode{N\_Vector}.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{N\_Vector~N\_VNewEmpty\_OpenMPDEV(sunindextype~vec\_length);}}
This function creates a new NVECTOR\_OPENMPDEV \sphinxcode{N\_Vector} with an empty
(\sphinxcode{NULL}) data array.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{N\_Vector~N\_VMake\_OpenMPDEV(sunindextype~vec\_length,~realtype~*h\_vdata,~realtype~*d\_vdata);}}
This function creates an NVECTOR\_OPENMPDEV vector with user-supplied vector data
arrays \sphinxcode{h\_vdata\} and {}`{}`d\_vdata}. This function does not allocate memory for
data itself.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{N\_Vector~*N\_VCloneVectorArray\_OpenMPDEV(int~count,~N\_Vector~w);}}
This function creates (by cloning) an array of \sphinxcode{count} NVECTOR\_OPENMPDEV vectors.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{N\_Vector~*N\_VCloneVectorArrayEmpty\_OpenMPDEV(int~count,~N\_Vector~w);}}
This function creates (by cloning) an array of \sphinxcode{count} NVECTOR\_OPENMPDEV vectors,
each with an empty (\sphinxcode{NULL}) data array.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{void~N\_VDestroyVectorArray\_OpenMPDEV(N\_Vector~*vs,~int~count);}}
This function frees memory allocated for the array of \sphinxcode{count} variables of type
\sphinxcode{N\_Vector} created with \sphinxcode{N\_VCloneVectorArray\_OpenMPDEV} or with
\sphinxcode{N\_VCloneVectorArrayEmpty\_OpenMPDEV}.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{realtype~*N\_VGetHostArrayPointer\_OpenMPDEV(N\_Vector~v);}}
This function returns a pointer to the host data array.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{realtype~*N\_VGetDeviceArrayPointer\_OpenMPDEV(N\_Vector~v);}}
This function returns a pointer to the device data array.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{void~N\_VPrint\_OpenMPDEV(N\_Vector~v);}}
This function prints the content of an NVECTOR\_OPENMPDEV vector to \sphinxcode{stdout}.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{void~N\_VPrintFile\_OpenMPDEV(N\_Vector~v,~FILE~*outfile);}}
This function prints the content of an NVECTOR\_OPENMPDEV vector to \sphinxcode{outfile}.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{void~N\_VCopyToDevice\_OpenMPDEV(N\_Vector~v);}}
This function copies the content of an NVECTOR\_OPENMPDEV vector’s host data array
to the device data array.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{void~N\_VCopyFromDevice\_OpenMPDEV(N\_Vector~v);}}
This function copies the content of an NVECTOR\_OPENMPDEV vector’s device data array
to the host data array.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_OPENMPDEV
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with id\{N\_VNew\_OpenMPDEV\}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using id\{N\_VClone\}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
id\{N\_VNew\_OpenMPDEV\} will have the default settings for the NVECTOR\_OPENMPDEV module.
\index{N\_VEnableFusedOps\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableFusedOps_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\} for
success and id\{-1\} if the input vector or its id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableLinearCombination_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\} for
success and id\{-1\} if the input vector or its id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableScaleAddMulti_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the NVECTOR\_OPENMPDEV vector. The
return value is id\{0\} for success and id\{-1\} if the input vector or its
id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableDotProdMulti_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\}
for success and id\{-1\} if the input vector or its id\{ops\} structure are
id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableLinearSumVectorArray_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\} for
success and id\{-1\} if the input vector or its id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableScaleVectorArray_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\} for
success and id\{-1\} if the input vector or its id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableConstVectorArray_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\} for
success and id\{-1\} if the input vector or its id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableWrmsNormVectorArray_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the NVECTOR\_OPENMPDEV vector. The return value is id\{0\} for
success and id\{-1\} if the input vector or its id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableWrmsNormMaskVectorArray_OpenMPDEV}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the NVECTOR\_OPENMPDEV vector. The return value is
id\{0\} for success and id\{-1\} if the input vector or its id\{ops\} structure are
id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMultiVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableScaleAddMultiVectorArray_OpenMPDEV}}\pysiglinewithargsret{\sphinxbfcode{N\_VEnableScaleAddMultiVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector array to multiple vector arrays operation in the NVECTOR\_OPENMPDEV vector. The
return value is id\{0\} for success and id\{-1\} if the input vector or its
id\{ops\} structure are id\{NULL\}.

\end{fulllineitems}

\index{N\_VEnableLinearCombinationVectorArray\_OpenMPDEV (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_OpenMPDEV:c.N_VEnableLinearCombinationVectorArray_OpenMPDEV}}\pysiglinewithargsret{\sphinxbfcode{N\_VEnableLinearCombinationVectorArray\_OpenMPDEV}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination operation for vector arrays in the NVECTOR\_OPENMPDEV vector. The return value
is id\{0\} for success and id\{-1\} if the input vector or its id\{ops\} structure
are id\{NULL\}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \sphinxcode{N\_Vector} \sphinxcode{v}, it is
most efficient to first obtain the component array via
\sphinxcode{h\_data = NV\_DATA\_HOST\_OMPDEV(v)} for the host arry or
\sphinxcode{v\_data = NV\_DATA\_DEV\_OMPDEV(v)} for the device array and then
access \sphinxcode{v\_data{[}i{]}} within the loop.

\item {} 
When accessing individual components of an \sphinxcode{N\_Vector} \sphinxcode{v} on
the host remember to first copy the array
back from the device with \sphinxcode{N\_VCopyFromDevice\_OpenMPDEV(v)}
to ensure the array is up to date.

\item {} 
\sphinxcode{N\_VNewEmpty\_OpenMPDEV()}, \sphinxcode{N\_VMake\_OpenMPDEV()}, and
\sphinxcode{N\_VCloneVectorArrayEmpty\_OpenMPDEV()} set the field \sphinxstyleemphasis{own\_data}
to \sphinxcode{SUNFALSE}.  The functions \sphinxcode{N\_VDestroy\_OpenMPDEV()} and
\sphinxcode{N\_VDestroyVectorArray\_OpenMPDEV()} will not attempt to free the
pointer data for any \sphinxcode{N\_Vector} with \sphinxstyleemphasis{own\_data} set to \sphinxcode{SUNFALSE}.
In such a case, it is the user’s responsibility to deallocate the
data pointers.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_OPENMPDEV
implementation that have more than one \sphinxcode{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user’s responsibility to ensure that such routines are called
with \sphinxcode{N\_Vector} arguments that were all created with the same
length.

\end{itemize}


\section{The NVECTOR\_TRILINOS Module}
\label{\detokenize{nvectors/NVector_Trilinos:nvectors-nvtrilinos}}\label{\detokenize{nvectors/NVector_Trilinos::doc}}\label{\detokenize{nvectors/NVector_Trilinos:the-nvector-trilinos-module}}
The NVECTOR\_TRILINOS module is an NVECTOR wrapper around the Trilinos
\sphinxhref{https://github.com/trilinos/Trilinos}{Tpetra} vector. The interface
to Tpetra is implemented in the \sphinxcode{Sundials::TpetraVectorInterface}
class. This class simply stores a reference counting pointer to a
Tpetra vector and inherits from an empty structure

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Trilinos} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

to interface the C++ class with the NVECTOR C code.
A pointer to an instance of this class is kept in the \sphinxstyleemphasis{content} field
of the \sphinxcode{N\_Vector} object, to ensure that the Tpetra vector
is not deleted for as long as the \sphinxcode{N\_Vector} object exists.

The Tpetra vector type in the \sphinxcode{Sundials::TpetraVectorInterface}
class is defined as:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{n}{Tpetra}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{realtype}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{sunindextype}\PYG{o}{\PYGZgt{}} \PYG{n}{vector\PYGZus{}type}\PYG{p}{;}
\end{sphinxVerbatim}

The Tpetra vector will use the SUNDIALS-specified \sphinxcode{realtype} as its scalar
type, \sphinxcode{int} as the local ordinal type, and \sphinxcode{sunindextype} as the global ordinal type.
This type definition will use Tpetra’s default node type. Available Kokkos node
types in Trilinos 12.14 release are serial (single thread), OpenMP, Pthread,
and CUDA. The default node type is selected when building the Kokkos package.
For example, the Tpetra vector will use a CUDA node if Tpetra was built with
CUDA support and the CUDA node was selected as the default when Tpetra was
built.

The header file to include when using this module is \sphinxcode{nvector\_trilinos.h}.
The installed module library to link to is \sphinxcode{libsundials\_nvectrilinos.lib}
where \sphinxcode{.lib} is typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a}
for static libraries.


\subsection{NVECTOR\_TRILINOS functions}
\label{\detokenize{nvectors/NVector_Trilinos:nvector-trilinos-functions}}
The NVECTOR\_TRILINOS module defines implementations of all vector
operations listed in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
\sphinxcode{N\_VGetArrayPointer} and \sphinxcode{N\_VSetArrayPointer}.  As such, this
vector cannot be used with SUNDIALS Fortran interfaces, nor with the
SUNDIALS direct solvers and preconditioners.  When access to raw
vector data is needed, it is recommended to extract the Trilinos
Tpetra vector first, and then use Tpetra vector methods to access the
data.  Usage examples of NVECTOR\_TRILINOS are provided in example
programs for IDA.

The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by appending the suffice \sphinxcode{\_Trilinos}
(e.g. \sphinxcode{N\_VDestroy\_Trilinos}).  Vector operations call existing
\sphinxcode{Tpetra::Vector} methods when available. Vector operations specific
to SUNDIALS are implemented as standalone functions in the namespace
\sphinxcode{Sundials::TpetraVector}, located in the file \sphinxcode{SundialsTpetraVectorKernels.hpp}.
The module NVECTOR\_TRILINOS provides the following additional user-callable routines:
\index{N\_VGetVector\_Trilinos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Trilinos:_CPPv221N_VGetVector_Trilinos8N_Vector}}%
\pysigstartmultiline
\pysiglinewithargsret{Teuchos::RCP\textless{}vector\_type\textgreater{} \sphinxcode{}\sphinxbfcode{N\_VGetVector\_Trilinos}}{N\_Vector \sphinxstyleemphasis{v}}{}%
\pysigstopmultiline
This C++ function takes an \sphinxcode{N\_Vector} as the argument and returns
a reference counting pointer to the underlying Tpetra vector. This
is a standalone function defined in the global namespace.

\end{fulllineitems}

\index{N\_VMake\_Trilinos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_Trilinos:_CPPv216N_VMake_TrilinosN7Teuchos3RCPI11vector_typeEE}}%
\pysigstartmultiline
\pysiglinewithargsret{N\_Vector \sphinxcode{}\sphinxbfcode{N\_VMake\_Trilinos}}{Teuchos::RCP\textless{}vector\_type\textgreater{} \sphinxstyleemphasis{v}}{}%
\pysigstopmultiline
This C++ function creates and allocates memory for an
NVECTOR\_TRILINOS wrapper around a user-provided Tpetra vector. This
is a standalone function defined in the global namespace.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
The template parameter \sphinxcode{vector\_type} should be set as:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{n}{Sundials}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TpetraVectorInterface}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector\PYGZus{}type} \PYG{n}{vector\PYGZus{}type}
\end{sphinxVerbatim}

This will ensure that data types used in Tpetra vector match those
in SUNDIALS.

\item {} 
When there is a need to access components of an \sphinxcode{N\_Vector\_Trilinos}, \sphinxcode{v},
it is recommeded to extract the Trilinos vector object via \sphinxcode{x\_vec =
N\_VGetVector\_Trilinos(v)} and then access components using the
appropriate Trilinos functions.

\item {} 
The functions \sphinxcode{N\_VDestroy\_Trilinos} and
\sphinxcode{N\_VDestroyVectorArray\_Trilinos} only delete the \sphinxcode{N\_Vector}
wrapper. The underlying Tpetra vector object will exist for as long
as there is at least one reference to it.

\end{itemize}


\section{The NVECTOR\_MANYVECTOR Module}
\label{\detokenize{nvectors/NVector_ManyVector:nvectors-manyvector}}\label{\detokenize{nvectors/NVector_ManyVector::doc}}\label{\detokenize{nvectors/NVector_ManyVector:the-nvector-manyvector-module}}
The NVECTOR\_MANYVECTOR implementation of the NVECTOR module provided with
SUNDIALS is designed to facilitate problems with an inherent
data partitioning for the solution vector within a computational node.
These data partitions are entirely user-defined, through construction
of distinct NVECTOR modules for each component, that are then combined
together to form the NVECTOR\_MANYVECTOR.  We envision two generic use
cases for this implementation:
\begin{enumerate}
\item {} 
\sphinxstyleemphasis{Heterogenous computational architectures}:
for users who wish to partition data on a node between different
computing resources, they may create architecture-specific
subvectors for each partition.  For example, a user could create
one serial component based on NVECTOR\_SERIAL, another component for
GPU accelerators based on NVECTOR\_CUDA, and another threaded
component based on NVECTOR\_OPENMP.

\item {} 
\sphinxstyleemphasis{Structure of arrays (SOA) data layouts}:
for users who wish to create separate subvectors for each
solution component, e.g., in a Navier-Stokes simulation they
could have separate subvectors for density, velocities and
pressure, which are combined together into a single
NVECTOR\_MANYVECTOR for the overall “solution”.

\end{enumerate}

We note that the above use cases are not mutually exclusive, and the
NVECTOR\_MANYVECTOR implementation should support arbitrary combinations
of these cases.

The NVECTOR\_MANYVECTOR implementation is designed to work with any
NVECTOR subvectors that implement the minimum \sphinxstyleemphasis{required} set
of operations.  Additionally, NVECTOR\_MANYVECTOR sets no limit on the
number of subvectors that may be attached (aside from the limitations
of using \sphinxcode{sunindextype} for indexing, and standard per-node memory
limitations).  However, while this ostensibly supports subvectors
with one entry each (i.e., one subvector for each solution entry), we
anticipate that this extreme situation will hinder performance due to
non-stride-one memory accesses and increased function call overhead.
We therefore recommend a relatively coarse partitioning of the
problem, although actual performance will likely be
problem-dependent.

As a final note, in the coming years we plan to introduce additional
algebraic solvers and time integration modules that will leverage the
problem partitioning enabled by NVECTOR\_MANYVECTOR.  However, even at
present we anticipate that users will be able to leverage such data
partitioning in their problem-defining ODE right-hand side, DAE
residual, or nonlinear solver residual functions.


\subsection{NVECTOR\_MANYVECTOR structure}
\label{\detokenize{nvectors/NVector_ManyVector:nvector-manyvector-structure}}
The NVECTOR\_MANYVECTOR implementation defines the \sphinxstyleemphasis{content} field
of \sphinxcode{N\_Vector} to be a structure containing the number of
subvectors comprising the ManyVector, the global length of the
ManyVector (including all subvectors), a pointer to
the beginning of the array of subvectors, and a boolean flag
\sphinxcode{own\_data} indicating ownership of the subvectors that populate
\sphinxcode{subvec\_array}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}ManyVector} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype}  \PYG{n}{num\PYGZus{}subvectors}\PYG{p}{;}  \PYG{c+cm}{/* number of vectors attached      */}
  \PYG{n}{sunindextype}  \PYG{n}{global\PYGZus{}length}\PYG{p}{;}   \PYG{c+cm}{/* overall manyvector length       */}
  \PYG{n}{N\PYGZus{}Vector}\PYG{o}{*}     \PYG{n}{subvec\PYGZus{}array}\PYG{p}{;}    \PYG{c+cm}{/* pointer to N\PYGZus{}Vector array       */}
  \PYG{n}{booleantype}   \PYG{n}{own\PYGZus{}data}\PYG{p}{;}        \PYG{c+cm}{/* flag indicating data ownership  */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to include when using this module is
\sphinxcode{nvector\_manyvector.h}. The installed module library to link against is
\sphinxcode{libsundials\_nvecmanyvector.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libraries and \sphinxcode{.a} for static libraries.


\subsection{NVECTOR\_MANYVECTOR functions}
\label{\detokenize{nvectors/NVector_ManyVector:nvector-manyvector-functions}}
The NVECTOR\_MANYVECTOR module implements all vector operations listed
in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetArrayPointer()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VSetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VSetArrayPointer()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScaleAddMultiVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VScaleAddMultiVectorArray()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearCombinationVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VLinearCombinationVectorArray()}}}}.  As such, this vector
cannot be used with the SUNDIALS Fortran-77 interfaces, nor with the
SUNDIALS direct solvers and preconditioners. Instead, the
NVECTOR\_MANYVECTOR module provides functions to access subvectors,
whose data may in turn be accessed according to their NVECTOR
implementations.

The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by
appending the suffix \sphinxcode{\_ManyVector} (e.g. \sphinxcode{N\_VDestroy\_ManyVector}).
The module NVECTOR\_MANYVECTOR provides the following additional
user-callable routines:
\index{N\_VNew\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VNew_ManyVector}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_ManyVector}}{sunindextype\sphinxstyleemphasis{ num\_subvectors}, N\_Vector\sphinxstyleemphasis{ *vec\_array}}{}
This function creates a ManyVector from a set of existing
NVECTOR objects.

This routine will copy all \sphinxcode{N\_Vector} pointers from the input
\sphinxcode{vec\_array}, so the user may modify/free that pointer array
after calling this function.  However, this routine does \sphinxstyleemphasis{not}
allocate any new subvectors, so the underlying NVECTOR objects
themselves should not be destroyed before the ManyVector that
contains them.

Upon successful completion, the new ManyVector is returned;
otherwise this routine returns \sphinxcode{NULL} (e.g., a memory allocation
failure occurred).

Users of the Fortran 2003 interface to this function will first need to use
the generic \sphinxcode{N\textbackslash{}\_Vector} utility functions \sphinxcode{N\_VNewVectorArray}, and
\sphinxcode{N\_VSetVecAtIndexVectorArray} to create the \sphinxcode{N\_Vector*} argument.  This is
further explained in Chapter {\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-nvectorarrays}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with N\_Vector arrays}}}},
and the functions are documented in Chapter {\hyperref[\detokenize{nvectors/NVector_Description:nvectors-utilities}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR Utility Functions}}}}.

\end{fulllineitems}

\index{N\_VGetSubvector\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VGetSubvector_ManyVector}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VGetSubvector\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, sunindextype\sphinxstyleemphasis{ vec\_num}}{}
This function returns the \sphinxstyleemphasis{vec\_num} subvector from the NVECTOR array.

\end{fulllineitems}

\index{N\_VGetSubvectorArrayPointer\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VGetSubvectorArrayPointer_ManyVector}}\pysiglinewithargsret{realtype *\sphinxbfcode{N\_VGetSubvectorArrayPointer\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, sunindextype\sphinxstyleemphasis{ vec\_num}}{}
This function returns the data array pointer for the \sphinxstyleemphasis{vec\_num}
subvector from the NVECTOR array.

If the input \sphinxstyleemphasis{vec\_num} is invalid, or if the subvector does not
support the \sphinxcode{N\_VGetArrayPointer} operation, then \sphinxcode{NULL} is
returned.

\end{fulllineitems}

\index{N\_VSetSubvectorArrayPointer\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VSetSubvectorArrayPointer_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VSetSubvectorArrayPointer\_ManyVector}}{realtype\sphinxstyleemphasis{ *v\_data}, N\_Vector\sphinxstyleemphasis{ v}, sunindextype\sphinxstyleemphasis{ vec\_num}}{}
This function sets the data array pointer for the \sphinxstyleemphasis{vec\_num}
subvector from the NVECTOR array.

If the input \sphinxstyleemphasis{vec\_num} is invalid, or if the subvector does not
support the \sphinxcode{N\_VSetArrayPointer} operation, then \sphinxcode{-1} is
returned; otherwise it returns \sphinxcode{0}.

\end{fulllineitems}

\index{N\_VGetNumSubvectors\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VGetNumSubvectors_ManyVector}}\pysiglinewithargsret{sunindextype \sphinxbfcode{N\_VGetNumSubvectors\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns the overall number of subvectors in the ManyVector object.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the
NVECTOR\_MANYVECTOR module, except for {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VWrmsNormVectorArray()}}}}
and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormMaskVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VWrmsNormMaskVectorArray()}}}}, that are enabled by
default. The following additional user-callable routines are provided
to enable or disable fused and vector array operations for a specific
vector. To ensure consistency across vectors it is recommended to
first create a vector with {\hyperref[\detokenize{nvectors/NVector_ManyVector:c.N_VNew_ManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_ManyVector()}}}},
enable/disable the desired operations
for that vector with the functions below, and create any additional
vectors from that vector using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees
that the new vectors will have the same operations enabled/disabled,
since cloned vectors inherit those configuration options from the
vector they are cloned from, while vectors created with
{\hyperref[\detokenize{nvectors/NVector_ManyVector:c.N_VNew_ManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_ManyVector()}}}} will
have the default settings for the NVECTOR\_MANYVECTOR module.  We note
that these routines \sphinxstyleemphasis{do not} call the corresponding routines on
subvectors, so those should be set up as desired \sphinxstyleemphasis{before} attaching
them to the ManyVector in {\hyperref[\detokenize{nvectors/NVector_ManyVector:c.N_VNew_ManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_ManyVector()}}}}.
\index{N\_VEnableFusedOps\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableFusedOps_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the manyvector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableLinearCombination_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the manyvector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableScaleAddMulti_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the manyvector vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableDotProdMulti_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the manyvector vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableLinearSumVectorArray_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the manyvector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableScaleVectorArray_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the manyvector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableConstVectorArray_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the manyvector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableWrmsNormVectorArray_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the manyvector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_ManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_ManyVector:c.N_VEnableWrmsNormMaskVectorArray_ManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_ManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the manyvector vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{nvectors/NVector_ManyVector:c.N_VNew_ManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_ManyVector()}}}} sets
the field \sphinxcode{own\_data = SUNFALSE}.
\sphinxcode{N\_VDestroy\_ManyVector()} will not attempt to call
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}} on any subvectors contained in the
subvector array for any \sphinxcode{N\_Vector} with \sphinxcode{own\_data} set to
\sphinxcode{SUNFALSE}. In such a case, it is the user’s responsibility to
deallocate the subvectors.

\item {} 
To maximize efficiency, arithmetic vector operations in the
NVECTOR\_MANYVECTOR implementation that have more than one
\sphinxcode{N\_Vector} argument do not check for consistent internal
representation of these vectors. It is the user’s responsibility to
ensure that such routines are called with \sphinxcode{N\_Vector} arguments
that were all created with the same subvector representations.

\end{itemize}


\section{The NVECTOR\_MPIMANYVECTOR Module}
\label{\detokenize{nvectors/NVector_MPIManyVector:nvectors-mpimanyvector}}\label{\detokenize{nvectors/NVector_MPIManyVector::doc}}\label{\detokenize{nvectors/NVector_MPIManyVector:the-nvector-mpimanyvector-module}}
The NVECTOR\_MPIMANYVECTOR implementation of the NVECTOR module provided with
SUNDIALS is designed to facilitate problems with an inherent
data partitioning for the solution vector, and when using
distributed-memory parallel architectures.  As such, the MPIManyVector
implementation supports all use cases allowed by the MPI-unaware
NVECTOR\_MANYVECTOR implementation, as well as partitioning data
between nodes in a parallel environment.  These data partitions are
entirely user-defined, through construction of distinct NVECTOR
modules for each component, that are then combined together to form
the NVECTOR\_MPIMANYVECTOR.  We envision three generic use cases for this
implementation:
\begin{enumerate}
\item {} 
\sphinxstyleemphasis{Heterogenous computational architectures (single-node or multi-node)}:
for users who wish to partition data on a node between different
computing resources, they may create architecture-specific
subvectors for each partition.  For example, a user could create
one MPI-parallel component based on NVECTOR\_PARALLEL, another
single-node component for GPU accelerators based on NVECTOR\_CUDA,
and another threaded single-node component based on
NVECTOR\_OPENMP.

\item {} 
\sphinxstyleemphasis{Process-based multiphysics decompositions (multi-node)}: for users
who wish to combine separate simulations together, e.g., where
one subvector resides on one subset of MPI processes, while
another subvector resides on a different subset of MPI processes,
and where the user has created a MPI \sphinxstyleemphasis{intercommunicator} to
connect these distinct process sets together.

\item {} 
\sphinxstyleemphasis{Structure of arrays (SOA) data layouts (single-node or multi-node)}:
for users who wish to create separate subvectors for each
solution component, e.g., in a Navier-Stokes simulation they
could have separate subvectors for density, velocities and
pressure, which are combined together into a single
NVECTOR\_MPIMANYVECTOR for the overall “solution”.

\end{enumerate}

We note that the above use cases are not mutually exclusive, and the
NVECTOR\_MPIMANYVECTOR implementation should support arbitrary combinations
of these cases.

The NVECTOR\_MPIMANYVECTOR implementation is designed to work with any
NVECTOR subvectors that implement the minimum \sphinxstyleemphasis{required} set
of operations, however significant performance benefits may be
obtained when subvectors additionally implement the optional local
reduction operations listed in the section {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}.

Additionally, NVECTOR\_MPIMANYVECTOR sets no limit on the number of
subvectors that may be attached (aside from the limitations of using
\sphinxcode{sunindextype} for indexing, and standard per-node memory
limitations).  However, while this ostensibly supports subvectors
with one entry each (i.e., one subvector for each solution entry), we
anticipate that this extreme situation will hinder performance due to
non-stride-one memory accesses and increased function call overhead.
We therefore recommend a relatively coarse partitioning of the
problem, although actual performance will likely be
problem-dependent.

As a final note, in the coming years we plan to introduce additional
algebraic solvers and time integration modules that will leverage the
problem partitioning enabled by NVECTOR\_MPIMANYVECTOR.  However, even at
present we anticipate that users will be able to leverage such data
partitioning in their problem-defining ODE right-hand side, DAE
residual, or nonlinear solver residual functions.


\subsection{NVECTOR\_MPIMANYVECTOR structure}
\label{\detokenize{nvectors/NVector_MPIManyVector:nvectors-mpimanyvector-structure}}\label{\detokenize{nvectors/NVector_MPIManyVector:nvector-mpimanyvector-structure}}
The NVECTOR\_MPIMANYVECTOR implementation defines the \sphinxstyleemphasis{content} field
of \sphinxcode{N\_Vector} to be a structure containing the MPI communicator
(or \sphinxcode{MPI\_COMM\_NULL} if running on a single-node), the number of
subvectors comprising the MPIManyVector, the global length of the
MPIManyVector (including all subvectors on all MPI tasks), a pointer to
the beginning of the array of subvectors, and a boolean flag
\sphinxcode{own\_data} indicating ownership of the subvectors that populate
\sphinxcode{subvec\_array}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}MPIManyVector} \PYG{p}{\PYGZob{}}
  \PYG{n}{MPI\PYGZus{}Comm}      \PYG{n}{comm}\PYG{p}{;}            \PYG{c+cm}{/* overall MPI communicator        */}
  \PYG{n}{sunindextype}  \PYG{n}{num\PYGZus{}subvectors}\PYG{p}{;}  \PYG{c+cm}{/* number of vectors attached      */}
  \PYG{n}{sunindextype}  \PYG{n}{global\PYGZus{}length}\PYG{p}{;}   \PYG{c+cm}{/* overall mpimanyvector length    */}
  \PYG{n}{N\PYGZus{}Vector}\PYG{o}{*}     \PYG{n}{subvec\PYGZus{}array}\PYG{p}{;}    \PYG{c+cm}{/* pointer to N\PYGZus{}Vector array       */}
  \PYG{n}{booleantype}   \PYG{n}{own\PYGZus{}data}\PYG{p}{;}        \PYG{c+cm}{/* flag indicating data ownership  */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The header file to include when using this module is
\sphinxcode{nvector\_mpimanyvector.h}. The installed module library to link against is
\sphinxcode{libsundials\_nvecmpimanyvector.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libraries and \sphinxcode{.a} for static libraries.

\sphinxstyleemphasis{Note:} If SUNDIALS is configured with MPI disabled, then the
MPIManyVector library will not be built.  Furthermore, any user codes
that include \sphinxcode{nvector\_mpimanyvector.h} \sphinxstyleemphasis{must} be compiled using an
MPI-aware compiler (whether the specific user code utilizes MPI or
not).  We note that the NVECTOR\_MANYVECTOR implementation is designed
for ManyVector use cases in an MPI-unaware environment.


\subsection{NVECTOR\_MPIMANYVECTOR functions}
\label{\detokenize{nvectors/NVector_MPIManyVector:nvector-mpimanyvector-functions}}
The NVECTOR\_MPIMANYVECTOR module implements all vector operations listed
in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, except for
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetArrayPointer()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VSetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VSetArrayPointer()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScaleAddMultiVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VScaleAddMultiVectorArray()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearCombinationVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VLinearCombinationVectorArray()}}}}.  As such, this vector
cannot be used with the SUNDIALS Fortran-77 interfaces, nor with the
SUNDIALS direct solvers and preconditioners. Instead, the
NVECTOR\_MPIMANYVECTOR module provides functions to access subvectors,
whose data may in turn be accessed according to their NVECTOR
implementations.

The names of vector operations are obtained from those in the sections
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}} by
appending the suffix \sphinxcode{\_MPIManyVector} (e.g. \sphinxcode{N\_VDestroy\_MPIManyVector}).
The module NVECTOR\_MPIMANYVECTOR provides the following additional
user-callable routines:
\index{N\_VNew\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VNew_MPIManyVector}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VNew\_MPIManyVector}}{sunindextype\sphinxstyleemphasis{ num\_subvectors}, N\_Vector\sphinxstyleemphasis{ *vec\_array}}{}
This function creates a MPIManyVector from a set of existing
NVECTOR objects, under the requirement that all MPI-aware
subvectors use the same MPI communicator (this is checked
internally).  If none of the subvectors are MPI-aware, then this
may equivalently be used to describe data partitioning within a
single node.  We note that this routine is designed to support use
cases A and C above.

This routine will copy all \sphinxcode{N\_Vector} pointers from the input
\sphinxcode{vec\_array}, so the user may modify/free that pointer array
after calling this function.  However, this routine does \sphinxstyleemphasis{not}
allocate any new subvectors, so the underlying NVECTOR objects
themselves should not be destroyed before the MPIManyVector that
contains them.

Upon successful completion, the new MPIManyVector is returned;
otherwise this routine returns \sphinxcode{NULL} (e.g., if two MPI-aware
subvectors use different MPI communicators).

Users of the Fortran 2003 interface to this function will first need to use
the generic \sphinxcode{N\textbackslash{}\_Vector} utility functions \sphinxcode{N\_VNewVectorArray}, and
\sphinxcode{N\_VSetVecAtIndexVectorArray} to create the \sphinxcode{N\_Vector*} argument.  This is
further explained in Chapter {\hyperref[\detokenize{ARKode_f_interface/F2003Module:fortran2003-differences-nvectorarrays}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with N\_Vector arrays}}}},
and the functions are documented in Chapter {\hyperref[\detokenize{nvectors/NVector_Description:nvectors-utilities}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR Utility Functions}}}}.

\end{fulllineitems}

\index{N\_VMake\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VMake_MPIManyVector}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_MPIManyVector}}{MPI\_Comm\sphinxstyleemphasis{ comm}, sunindextype\sphinxstyleemphasis{ num\_subvectors}, N\_Vector\sphinxstyleemphasis{ *vec\_array}}{}
This function creates a MPIManyVector from a set of existing NVECTOR
objects, and a user-created MPI communicator that “connects” these
subvectors.  Any MPI-aware subvectors may use different MPI
communicators than the input \sphinxstyleemphasis{comm}.  We note that this routine
is designed to support any combination of the use cases above.

The input \sphinxstyleemphasis{comm} should be this user-created MPI communicator.
This routine will internally call \sphinxcode{MPI\_Comm\_dup} to create a
copy of the input \sphinxcode{comm}, so the user-supplied \sphinxcode{comm} argument
need not be retained after the call to
{\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VMake_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIManyVector()}}}}.

If all subvectors are MPI-unaware, then the input \sphinxstyleemphasis{comm} argument
should be \sphinxcode{MPI\_COMM\_NULL}, although in this case, it would be
simpler to call {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VNew_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_MPIManyVector()}}}} instead, or to just
use the NVECTOR\_MANYVECTOR module.

This routine will copy all \sphinxcode{N\_Vector} pointers from the input
\sphinxstyleemphasis{vec\_array}, so the user may modify/free that pointer array
after calling this function.  However, this routine does \sphinxstyleemphasis{not}
allocate any new subvectors, so the underlying NVECTOR objects
themselves should not be destroyed before the MPIManyVector that
contains them.

Upon successful completion, the new MPIManyVector is returned;
otherwise this routine returns \sphinxcode{NULL} (e.g., if the input
\sphinxstyleemphasis{vec\_array} is \sphinxcode{NULL}).

\end{fulllineitems}

\index{N\_VGetSubvector\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VGetSubvector_MPIManyVector}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VGetSubvector\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, sunindextype\sphinxstyleemphasis{ vec\_num}}{}
This function returns the \sphinxstyleemphasis{vec\_num} subvector from the NVECTOR array.

\end{fulllineitems}

\index{N\_VGetSubvectorArrayPointer\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VGetSubvectorArrayPointer_MPIManyVector}}\pysiglinewithargsret{realtype *\sphinxbfcode{N\_VGetSubvectorArrayPointer\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, sunindextype\sphinxstyleemphasis{ vec\_num}}{}
This function returns the data array pointer for the \sphinxstyleemphasis{vec\_num}
subvector from the NVECTOR array.

If the input \sphinxstyleemphasis{vec\_num} is invalid, or if the subvector does not
support the \sphinxcode{N\_VGetArrayPointer} operation, then \sphinxcode{NULL} is
returned.

\end{fulllineitems}

\index{N\_VSetSubvectorArrayPointer\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VSetSubvectorArrayPointer_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VSetSubvectorArrayPointer\_MPIManyVector}}{realtype\sphinxstyleemphasis{ *v\_data}, N\_Vector\sphinxstyleemphasis{ v}, sunindextype\sphinxstyleemphasis{ vec\_num}}{}
This function sets the data array pointer for the \sphinxstyleemphasis{vec\_num}
subvector from the NVECTOR array.

If the input \sphinxstyleemphasis{vec\_num} is invalid, or if the subvector does not
support the \sphinxcode{N\_VSetArrayPointer} operation, then \sphinxcode{-1} is
returned; otherwise it returns \sphinxcode{0}.

\end{fulllineitems}

\index{N\_VGetNumSubvectors\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VGetNumSubvectors_MPIManyVector}}\pysiglinewithargsret{sunindextype \sphinxbfcode{N\_VGetNumSubvectors\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns the overall number of subvectors in the MPIManyVector object.

\end{fulllineitems}


By default all fused and vector array operations are disabled in the NVECTOR\_MPIMANYVECTOR
module, except for {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VWrmsNormVectorArray()}}}} and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VWrmsNormMaskVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VWrmsNormMaskVectorArray()}}}}, that are enabled by default. The
following additional user-callable routines are provided to enable or
disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a
vector with {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VNew_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_MPIManyVector()}}}} or
{\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VMake_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIManyVector()}}}}, enable/disable the desired operations
for that vector with the functions below, and create any additional
vectors from that vector using {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}. This guarantees
that the new vectors will have the same operations enabled/disabled,
since cloned vectors inherit those configuration options from the
vector they are cloned from, while vectors created with
{\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VNew_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_MPIManyVector()}}}} and {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VMake_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIManyVector()}}}} will
have the default settings for the NVECTOR\_MPIMANYVECTOR module.  We note
that these routines \sphinxstyleemphasis{do not} call the corresponding routines on
subvectors, so those should be set up as desired \sphinxstyleemphasis{before} attaching
them to the MPIManyVector in {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VNew_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_MPIManyVector()}}}} or
{\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VMake_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIManyVector()}}}}.
\index{N\_VEnableFusedOps\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableFusedOps_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableFusedOps\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) all fused and
vector array operations in the MPIManyVector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearCombination\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableLinearCombination_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearCombination\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear
combination fused operation in the MPIManyVector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleAddMulti\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableScaleAddMulti_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleAddMulti\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale and
add a vector to multiple vectors fused operation in the MPIManyVector vector. The
return value is \sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its
\sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableDotProdMulti\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableDotProdMulti_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableDotProdMulti\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the multiple
dot products fused operation in the MPIManyVector vector. The return value is \sphinxcode{0}
for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableLinearSumVectorArray\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableLinearSumVectorArray_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableLinearSumVectorArray\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the linear sum
operation for vector arrays in the MPIManyVector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableScaleVectorArray\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableScaleVectorArray_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableScaleVectorArray\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the scale
operation for vector arrays in the MPIManyVector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableConstVectorArray\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableConstVectorArray_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableConstVectorArray\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the const
operation for vector arrays in the MPIManyVector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormVectorArray\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableWrmsNormVectorArray_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormVectorArray\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the WRMS norm
operation for vector arrays in the MPIManyVector vector. The return value is \sphinxcode{0} for
success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are \sphinxcode{NULL}.

\end{fulllineitems}

\index{N\_VEnableWrmsNormMaskVectorArray\_MPIManyVector (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIManyVector:c.N_VEnableWrmsNormMaskVectorArray_MPIManyVector}}\pysiglinewithargsret{int \sphinxbfcode{N\_VEnableWrmsNormMaskVectorArray\_MPIManyVector}}{N\_Vector\sphinxstyleemphasis{ v}, booleantype\sphinxstyleemphasis{ tf}}{}
This function enables (\sphinxcode{SUNTRUE}) or disables (\sphinxcode{SUNFALSE}) the masked WRMS
norm operation for vector arrays in the MPIManyVector vector. The return value is
\sphinxcode{0} for success and \sphinxcode{-1} if the input vector or its \sphinxcode{ops} structure are
\sphinxcode{NULL}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VNew_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VNew\_MPIManyVector()}}}} and {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:c.N_VMake_MPIManyVector}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIManyVector()}}}} set
the field \sphinxcode{own\_data = SUNFALSE}.
\sphinxcode{N\_VDestroy\_MPIManyVector()} will not attempt to call
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}} on any subvectors contained in the
subvector array for any \sphinxcode{N\_Vector} with \sphinxcode{own\_data} set to
\sphinxcode{SUNFALSE}. In such a case, it is the user’s responsibility to
deallocate the subvectors.

\item {} 
To maximize efficiency, arithmetic vector operations in the
NVECTOR\_MPIMANYVECTOR implementation that have more than one
\sphinxcode{N\_Vector} argument do not check for consistent internal
representation of these vectors. It is the user’s responsibility to
ensure that such routines are called with \sphinxcode{N\_Vector} arguments
that were all created with the same subvector representations.

\end{itemize}


\section{The NVECTOR\_MPIPLUSX Module}
\label{\detokenize{nvectors/NVector_MPIPlusX:the-nvector-mpiplusx-module}}\label{\detokenize{nvectors/NVector_MPIPlusX::doc}}\label{\detokenize{nvectors/NVector_MPIPlusX:nvectors-mpiplusx}}
The NVECTOR\_MPIPLUSX implementation of the NVECTOR module provided
with SUNDIALS is designed to facilitate the MPI+X paradigm, where
X is some form of on-node (local) parallelism (e.g. OpenMP, CUDA).
This paradigm is becoming increasingly popular with the rise of
heterogeneous computing architectures.

The NVECTOR\_MPIPLUSX implementation is designed to work with any
NVECTOR that implements the minimum \sphinxstyleemphasis{required} set of operations.
However, it is not recommended to use the NVECTOR\_PARALLEL,
NVECTOR\_PARHYP, NVECTOR\_PETSC, or NVECTOR\_TRILINOS implementations
underneath the NVECTOR\_MPIPLUSX module since they already provide
MPI capabilities.


\subsection{NVECTOR\_MPIPLUSX structure}
\label{\detokenize{nvectors/NVector_MPIPlusX:nvector-mpiplusx-structure}}
The NVECTOR\_MPIPLUSX implementation is a thin wrapper around the
NVECTOR\_MPIMANYVECTOR. Accordingly, it adopts the same content
structure as defined in the section {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:nvectors-mpimanyvector-structure}]{\sphinxcrossref{\DUrole{std,std-ref}{NVECTOR\_MPIMANYVECTOR structure}}}}.

The header file to include when using this module is
\sphinxcode{nvector\_mpiplusx.h}. The installed module library to link against is
\sphinxcode{libsundials\_nvecmpiplusx.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libraries and \sphinxcode{.a} for static libraries.

\sphinxstylestrong{Note:} If SUNDIALS is configured with MPI disabled, then the
mpiplusx library will not be built.  Furthermore, any user codes
that include \sphinxcode{nvector\_mpiplusx.h} \sphinxstyleemphasis{must} be compiled using an MPI-aware
compiler.


\subsection{NVECTOR\_MPIPLUSX functions}
\label{\detokenize{nvectors/NVector_MPIPlusX:nvector-mpiplusx-functions}}
The NVECTOR\_MPIPLUSX module adopts all vector operations listed
in the sections {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR operations}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-fusedops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR fused operations}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-arrayops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR vector array operations}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:nvectors-localops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR local reduction operations}}}}, from the
NVECTOR\_MPIMANYVECTOR (see section {\hyperref[\detokenize{nvectors/NVector_MPIManyVector:nvectors-mpimanyvector}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_MPIMANYVECTOR Module}}}})
except for {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VGetArrayPointer()}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VSetArrayPointer}]{\sphinxcrossref{\sphinxcode{N\_VSetArrayPointer()}}}};
the module provides its own implementation of these functions that
call the local vector implementations. Therefore, the NVECTOR\_MPIPLUSX
module implements all of the operations listed in the referenced
sections except for {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScaleAddMultiVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VScaleAddMultiVectorArray()}}}},
and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearCombinationVectorArray}]{\sphinxcrossref{\sphinxcode{N\_VLinearCombinationVectorArray()}}}}. Accordingly, it’s
compatibility with the SUNDIALS Fortran-77 interface, and with the
SUNDIALS direct solvers and preconditioners depends on the local
vector implementation.

The module NVECTOR\_MPIPLUSX provides the following additional
user-callable routines:
\index{N\_VMake\_MPIPlusX (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIPlusX:c.N_VMake_MPIPlusX}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VMake\_MPIPlusX}}{MPI\_Comm\sphinxstyleemphasis{ comm}, N\_Vector\sphinxstyleemphasis{ *local\_vector}}{}
This function creates a MPIPlusX vector from an exisiting local
(i.e. on node) NVECTOR object, and a user-created MPI communicator.

The input \sphinxstyleemphasis{comm} should be this user-created MPI communicator.
This routine will internally call \sphinxcode{MPI\_Comm\_dup} to create a
copy of the input \sphinxcode{comm}, so the user-supplied \sphinxcode{comm} argument
need not be retained after the call to
{\hyperref[\detokenize{nvectors/NVector_MPIPlusX:c.N_VMake_MPIPlusX}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIPlusX()}}}}.

This routine will copy the NVECTOR pointer to the input
\sphinxcode{local\_vector}, so the underlying local NVECTOR object
should not be destroyed before the mpiplusx that contains it.

Upon successful completion, the new MPIPlusX is returned;
otherwise this routine returns \sphinxcode{NULL} (e.g., if the input
\sphinxstyleemphasis{local\_vector} is \sphinxcode{NULL}).

\end{fulllineitems}

\index{N\_VGetLocal\_MPIPlusX (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIPlusX:c.N_VGetLocal_MPIPlusX}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{N\_VGetLocal\_MPIPlusX}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns the local vector underneath the MPIPlusX
NVECTOR.

\end{fulllineitems}

\index{N\_VGetArrayPointer\_MPIPlusX (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIPlusX:c.N_VGetArrayPointer_MPIPlusX}}\pysiglinewithargsret{realtype *\sphinxbfcode{N\_VGetArrayPointer\_MPIPlusX}}{N\_Vector\sphinxstyleemphasis{ v}}{}
This function returns the data array pointer for the local vector.

If the local vector does not support the \sphinxcode{N\_VGetArrayPointer}
operation, then \sphinxcode{NULL} is returned.

\end{fulllineitems}

\index{N\_VSetArrayPointer\_MPIPlusX (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{nvectors/NVector_MPIPlusX:c.N_VSetArrayPointer_MPIPlusX}}\pysiglinewithargsret{void \sphinxbfcode{N\_VSetArrayPointer\_MPIPlusX}}{realtype\sphinxstyleemphasis{ *v\_data}, N\_Vector\sphinxstyleemphasis{ v}}{}
This function sets the data array pointer for the local vector if
the local vector implements the \sphinxcode{N\_VGetArrayPointe()} operation.

\end{fulllineitems}


The NVECTOR\_MPIPLUSX module does not implement any fused or vector array
operations. Instead users should enable/disable fused operations on the
local vector.

\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
{\hyperref[\detokenize{nvectors/NVector_MPIPlusX:c.N_VMake_MPIPlusX}]{\sphinxcrossref{\sphinxcode{N\_VMake\_MPIPlusX()}}}} sets the field \sphinxcode{own\_data = SUNFALSE} and
\sphinxcode{N\_VDestroy\_MPIPlusX()} will not call {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}} on the
local vector. In this a case, it is the user’s responsibility to deallocate
the local vector.

\item {} 
To maximize efficiency, arithmetic vector operations in the
NVECTOR\_MPIPLUSX implementation that have more than one
\sphinxcode{N\_Vector} argument do not check for consistent internal
representation of these vectors. It is the user’s responsibility to
ensure that such routines are called with \sphinxcode{N\_Vector} arguments
that were all created with the same subvector representations.

\end{itemize}


\section{NVECTOR Examples}
\label{\detokenize{nvectors/NVector_Examples:nvector-examples}}\label{\detokenize{nvectors/NVector_Examples::doc}}\label{\detokenize{nvectors/NVector_Examples:nvectors-examples}}
There are NVECTOR examples that may be installed for each
implementation: serial, parallel, OpenMP, and Pthreads.  Each
implementation makes use of the functions in \sphinxcode{test\_nvector.c}.
These example functions show simple usage of the NVECTOR family
of functions. The input to the examples are the vector length, number
of threads (if threaded implementation), and a print timing flag.

The following is a list of the example functions in \sphinxcode{test\_nvector.c}:
\begin{itemize}
\item {} 
\sphinxcode{Test\_N\_VClone}: Creates clone of vector and checks validity of clone.

\item {} 
\sphinxcode{Test\_N\_VCloneEmpty}: Creates clone of empty vector and checks validity of clone.

\item {} 
\sphinxcode{Test\_N\_VCloneVectorArray}: Creates clone of vector array and checks validity of cloned array.

\item {} 
\sphinxcode{Test\_N\_VCloneVectorArray}: Creates clone of empty vector array and checks validity of cloned array.

\item {} 
\sphinxcode{Test\_N\_VGetArrayPointer}: Get array pointer.

\item {} 
\sphinxcode{Test\_N\_VSetArrayPointer}: Allocate new vector, set pointer to new vector array, and check values.

\item {} 
\sphinxcode{Test\_N\_VGetLength}: Compares self-reported length to calculated length.

\item {} 
\sphinxcode{Test\_N\_VGetCommunicator}: Compares self-reported communicator to the one used in constructor; or for MPI-unaware vectors it ensures that NULL is reported.

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 1a: Test y =  x + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 1b: Test y = -x + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 1c: Test y = ax + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 2a: Test x =  x + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 2b: Test x =  x - y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 2c: Test x =  x + by

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 3:  Test z =  x + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 4a: Test z =  x - y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 4b: Test z = -x + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 5a: Test z =  x + by

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 5b: Test z = ax + y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 6a: Test z = -x + by

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 6b: Test z = ax - y

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 7:  Test z = a(x + y)

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 8:  Test z = a(x - y)

\item {} 
\sphinxcode{Test\_N\_VLinearSum} Case 9:  Test z = ax + by

\item {} 
\sphinxcode{Test\_N\_VConst}: Fill vector with constant and check result.

\item {} 
\sphinxcode{Test\_N\_VProd}: Test vector multiply: z = x * y

\item {} 
\sphinxcode{Test\_N\_VDiv}: Test vector division: z = x / y

\item {} 
\sphinxcode{Test\_N\_VScale}: Case 1: scale: x = cx

\item {} 
\sphinxcode{Test\_N\_VScale}: Case 2: copy: z = x

\item {} 
\sphinxcode{Test\_N\_VScale}: Case 3: negate: z = -x

\item {} 
\sphinxcode{Test\_N\_VScale}: Case 4: combination: z = cx

\item {} 
\sphinxcode{Test\_N\_VAbs}: Create absolute value of vector.

\item {} 
\sphinxcode{Test\_N\_VAddConst}: add constant vector: z = c + x

\item {} 
\sphinxcode{Test\_N\_VDotProd}: Calculate dot product of two vectors.

\item {} 
\sphinxcode{Test\_N\_VMaxNorm}: Create vector with known values, find and validate the max norm.

\item {} 
\sphinxcode{Test\_N\_VWrmsNorm}: Create vector of known values, find and validate the weighted root mean square.

\item {} 
\sphinxcode{Test\_N\_VWrmsNormMask}: Create vector of known values, find and validate the weighted root mean square using all elements except one.

\item {} 
\sphinxcode{Test\_N\_VMin}: Create vector, find and validate the min.

\item {} 
\sphinxcode{Test\_N\_VWL2Norm}: Create vector, find and validate the weighted Euclidean L2 norm.

\item {} 
\sphinxcode{Test\_N\_VL1Norm}: Create vector, find and validate the L1 norm.

\item {} 
\sphinxcode{Test\_N\_VCompare}: Compare vector with constant returning and validating comparison vector.

\item {} 
\sphinxcode{Test\_N\_VInvTest}: Test z{[}i{]} = 1 / x{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VConstrMask}: Test mask of vector x with vector c.

\item {} 
\sphinxcode{Test\_N\_VMinQuotient}: Fill two vectors with known values. Calculate and validate minimum quotient.

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 1a: Test x = a x

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 1b: Test z = a x

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 2a: Test x = a x + b y

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 2b: Test z = a x + b y

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 3a: Test x = x + a y + b z

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 3b: Test x = a x + b y + c z

\item {} 
\sphinxcode{Test\_N\_VLinearCombination}: Case 3c: Test w = a x + b y + c z

\item {} 
\sphinxcode{Test\_N\_VScaleAddMulti}: Case 1a: y = a x + y

\item {} 
\sphinxcode{Test\_N\_VScaleAddMulti}: Case 1b: z = a x + y

\item {} 
\sphinxcode{Test\_N\_VScaleAddMulti}: Case 2a: Y{[}i{]} = c{[}i{]} x + Y{[}i{]}, i = 1,2,3

\item {} 
\sphinxcode{Test\_N\_VScaleAddMulti}: Case 2b: Z{[}i{]} = c{[}i{]} x + Y{[}i{]}, i = 1,2,3

\item {} 
\sphinxcode{Test\_N\_VDotProdMulti}: Case 1: Calculate the dot product of two vectors

\item {} 
\sphinxcode{Test\_N\_VDotProdMulti}: Case 2: Calculate the dot product of one vector with three other vectors in a vector array.

\item {} 
\sphinxcode{Test\_N\_VLinearSumVectorArray}: Case 1: z = a x + b y

\item {} 
\sphinxcode{Test\_N\_VLinearSumVectorArray}: Case 2a: Z{[}i{]} = a X{[}i{]} + b Y{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearSumVectorArray}: Case 2b: X{[}i{]} = a X{[}i{]} + b Y{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearSumVectorArray}: Case 2c: Y{[}i{]} = a X{[}i{]} + b Y{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VScaleVectorArray}: Case 1a: y = c y

\item {} 
\sphinxcode{Test\_N\_VScaleVectorArray}: Case 1b: z = c y

\item {} 
\sphinxcode{Test\_N\_VScaleVectorArray}: Case 2a: Y{[}i{]} = c{[}i{]} Y{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VScaleVectorArray}: Case 2b: Z{[}i{]} = c{[}i{]} Y{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VScaleVectorArray}: Case 1a: z = c

\item {} 
\sphinxcode{Test\_N\_VScaleVectorArray}: Case 1b: Z{[}i{]} = c

\item {} 
\sphinxcode{Test\_N\_VWrmsNormVectorArray}: Case 1a: Create a vector of know values, find and validate the weighted root mean square norm.

\item {} 
\sphinxcode{Test\_N\_VWrmsNormVectorArray}: Case 1b: Create a vector array of three vectors of know values, find and validate the weighted root mean square norm of each.

\item {} 
\sphinxcode{Test\_N\_VWrmsNormMaskVectorArray}: Case 1a: Create a vector of know values, find and validate the weighted root mean square norm using all elements except one.

\item {} 
\sphinxcode{Test\_N\_VWrmsNormMaskVectorArray}: Case 1b: Create a vector array of three vectors of know values, find and validate the weighted root mean square norm of each using all elements except one.

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 1a: y = a x + y

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 1b: z = a x + y

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 2a: Y{[}j{]}{[}0{]} = a{[}j{]} X{[}0{]} + Y{[}j{]}{[}0{]}

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 2b: Z{[}j{]}{[}0{]} = a{[}j{]} X{[}0{]} + Y{[}j{]}{[}0{]}

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 3a: Y{[}0{]}{[}i{]} = a{[}0{]} X{[}i{]} + Y{[}0{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 3b: Z{[}0{]}{[}i{]} = a{[}0{]} X{[}i{]} + Y{[}0{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 4a: Y{[}j{]}{[}i{]} = a{[}j{]} X{[}i{]} + Y{[}j{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VScaleAddMultiVectorArray}: Case 4b: Z{[}j{]}{[}i{]} = a{[}j{]} X{[}i{]} + Y{[}j{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 1a: x = a x

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 1b: z = a x

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 2a: x = a x + b y

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 2b: z = a x + b y

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 3a: x = a x + b y + c z

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 3b: w = a x + b y + c z

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 4a: X{[}0{]}{[}i{]} = c{[}0{]} X{[}0{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 4b: Z{[}i{]} = c{[}0{]} X{[}0{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 5a: X{[}0{]}{[}i{]} = c{[}0{]} X{[}0{]}{[}i{]} + c{[}1{]} X{[}1{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 5b: Z{[}i{]} = c{[}0{]} X{[}0{]}{[}i{]} + c{[}1{]} X{[}1{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 6a: X{[}0{]}{[}i{]} = X{[}0{]}{[}i{]} + c{[}1{]} X{[}1{]}{[}i{]} + c{[}2{]} X{[}2{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 6b: X{[}0{]}{[}i{]} = c{[}0{]} X{[}0{]}{[}i{]} + c{[}1{]} X{[}1{]}{[}i{]} + c{[}2{]} X{[}2{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VLinearCombinationVectorArray}: Case 6c: Z{[}i{]} = c{[}0{]} X{[}0{]}{[}i{]} + c{[}1{]} X{[}1{]}{[}i{]} + c{[}2{]} X{[}2{]}{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VDotProdLocal}: Calculate MPI task-local portion of the dot product of two vectors.

\item {} 
\sphinxcode{Test\_N\_VMaxNormLocal}: Create vector with known values, find and validate the MPI task-local portion of the max norm.

\item {} 
\sphinxcode{Test\_N\_VMinLocal}: Create vector, find and validate the MPI task-local min.

\item {} 
\sphinxcode{Test\_N\_VL1NormLocal}: Create vector, find and validate the MPI task-local portion of the L1 norm.

\item {} 
\sphinxcode{Test\_N\_VWSqrSumLocal}: Create vector of known values, find and validate the MPI task-local portion of the weighted squared sum of two vectors.

\item {} 
\sphinxcode{Test\_N\_VWSqrSumMaskLocal}: Create vector of known values, find and validate the MPI task-local portion of the weighted squared sum of two vectors, using all elements except one.

\item {} 
\sphinxcode{Test\_N\_VInvTestLocal}: Test the MPI task-local portion of z{[}i{]} = 1 / x{[}i{]}

\item {} 
\sphinxcode{Test\_N\_VConstrMaskLocal}: Test the MPI task-local portion of the mask of vector x with vector c.

\item {} 
\sphinxcode{Test\_N\_VMinQuotientLocal}: Fill two vectors with known values. Calculate and validate the MPI task-local minimum quotient.

\end{itemize}


\section{NVECTOR functions required by ARKode}
\label{\detokenize{nvectors/ARKode_requirements:nvectors-arkode}}\label{\detokenize{nvectors/ARKode_requirements::doc}}\label{\detokenize{nvectors/ARKode_requirements:nvector-functions-required-by-arkode}}
In the table below, we list the vector functions in the \sphinxcode{N\_Vector}
module that are called within the ARKode package.  The table also
shows, for each function, which ARKode module uses the function.
The ARKSTEP and ERKSTEP columns show function usage within the main
time-stepping modules and the shared ARKode infrastructure,  while the
remaining columns show function usage within the ARKLS linear solver
interface, the ARKBANDPRE and ARKBBDPRE preconditioner modules, and
the FARKODE module.

Note that since FARKODE is built on top of ARKode, and therefore
requires the same \sphinxcode{N\_Vector} routines, in the FARKODE column we only
list the routines that the FARKODE interface directly utilizes.

Note that for ARKLS we only list the \sphinxcode{N\_Vector} routines used
directly by ARKLS, each \sphinxcode{SUNLinearSolver} module may have additional
requirements that are not listed here.  In addition, specific
\sphinxcode{SUNNonlinearSolver} modules attached to ARKode may have additional
\sphinxcode{N\_Vector} requirements.  For additional requirements by specific
\sphinxcode{SUNLinearSolver} and \sphinxcode{SUNNonlinearSolver} modules, please see the
accompanying sections {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}} and {\hyperref[\detokenize{sunnonlinsol/index:sunnonlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNNonlinearSolver Module}}}}.

At this point, we should emphasize that the user does not need to know
anything about ARKode’s usage of vector functions in order to use
ARKode.  Instead, this information is provided primarily for users
interested in constructing a custom \sphinxcode{N\_Vector} module.  We note that
a number of \sphinxcode{N\_Vector} functions from the section
{\hyperref[\detokenize{nvectors/NVector_Description:nvectors-description}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the NVECTOR Modules}}}} are not listed in the above table.
Therefore a user-supplied \sphinxcode{N\_Vector} module for ARKode could safely
omit these functions from their implementation (although
some may be needed by \sphinxcode{SUNNonlinearSolver} or \sphinxcode{SUNLinearSolver}
modules).


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Routine
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKSTEP
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ERKSTEP
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKLS
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKBANDPRE
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKBBDPRE
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
FARKODE
\unskip}\relax \\
\hline
N\_VGetLength
&&&
X
&&&\\
\hline
N\_VAbs
&
X
&
X
&&&&\\
\hline
N\_VAddConst
&
X
&
X
&&&&\\
\hline
N\_VClone
&
X
&
X
&
X
&&&\\
\hline
N\_VCloneEmpty
&&&&&&
X
\\
\hline
N\_VConst
&
X
&
X
&
X
&&&
X
\\
\hline
N\_VDestroy
&
X
&
X
&
X
&&&
X
\\
\hline
N\_VDiv
&
X
&
X
&&&&\\
\hline
N\_VGetArrayPointer
&&&
X$^{\text{1}}$
&
X
&
X
&
X
\\
\hline
N\_VInv
&
X
&
X
&&&&\\
\hline
N\_VLinearSum
&
X
&
X
&
X
&&&\\
\hline
N\_VMaxNorm
&
X
&
X
&&&&\\
\hline
N\_VMin
&
X
&
X
&&&&
X
\\
\hline
N\_VScale
&
X
&
X
&
X
&
X
&
X
&\\
\hline
N\_VSetArrayPointer
&&&
X$^{\text{1}}$
&&&
X
\\
\hline
N\_VSpace$^{\text{2}}$
&
X
&
X
&
X
&
X
&
X
&\\
\hline
N\_VWrmsNorm
&
X
&
X
&
X
&
X
&
X
&\\
\hline
N\_VLinearCombination$^{\text{3}}$
&
X
&
X
&&&&\\
\hline
N\_VMinQuotient$^{\text{5}}$
&
X
&
X
&&&&\\
\hline
N\_VConstrMask$^{\text{5}}$
&
X
&
X
&&&&\\
\hline
N\_VCompare$^{\text{5}}$
&
X
&
X
&&&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{enumerate}
\item {} 
This is only required with dense or band matrix-based linear solver modules,
where the default difference-quotient Jacobian approximation is used.

\item {} 
The {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VSpace}]{\sphinxcrossref{\sphinxcode{N\_VSpace()}}}} function is only informational, and will
only be called if provided by the \sphinxcode{N\_Vector} implementation.

\item {} 
The {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearCombination}]{\sphinxcrossref{\sphinxcode{N\_VLinearCombination()}}}} function is in fact optional;
if it is not supplied then {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}} will be used instead.

\item {} 
The {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VGetLength}]{\sphinxcrossref{\sphinxcode{N\_VGetLength()}}}} function is only required when an iterative or
matrix iterative \sphinxcode{SUNLinearSolver} module is used.

\item {} 
The functions {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VMinQuotient}]{\sphinxcrossref{\sphinxcode{N\_VMinQuotient()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConstrMask}]{\sphinxcrossref{\sphinxcode{N\_VConstrMask()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VCompare}]{\sphinxcrossref{\sphinxcode{N\_VCompare()}}}} are only used when inequality constraints are enabled
and may be omitted if this feature is not used.

\end{enumerate}


\chapter{Matrix Data Structures}
\label{\detokenize{sunmatrix/index:sunmatrix}}\label{\detokenize{sunmatrix/index:matrix-data-structures}}\label{\detokenize{sunmatrix/index::doc}}
The SUNDIALS library comes packaged with a variety of \sphinxcode{SUNMatrix}
implementations, designed for simulations requiring direct linear
solvers for problems in serial or shared-memory parallel
environments.  SUNDIALS additionally provides a simple interface for
generic matrices (akin to a C++ \sphinxstyleemphasis{abstract base class}).  All of the
major SUNDIALS packages (CVODE(s), IDA(s), KINSOL, ARKODE), are
constructed to only depend on these generic matrix operations, making
them immediately extensible to new user-defined matrix objects.  For
each of the SUNDIALS-provided matrix types, SUNDIALS also provides at
least two \sphinxcode{SUNLinearSolver} implementations that factor these
matrix objects and use them in the solution of linear systems.


\section{Description of the SUNMATRIX Modules}
\label{\detokenize{sunmatrix/SUNMatrix_Description:description-of-the-sunmatrix-modules}}\label{\detokenize{sunmatrix/SUNMatrix_Description:sunmatrix-description}}\label{\detokenize{sunmatrix/SUNMatrix_Description::doc}}
For problems that involve direct methods for solving linear systems,
the SUNDIALS solvers not only operate on generic vectors, but also
on generic matrices (of type \sphinxcode{SUNMatrix}), through a set of
operations defined by the particular SUNMATRIX implementation.
Users can provide their own specific implementation of the
SUNMATRIX module, particularly in cases where they provide their
own \sphinxcode{N\_Vector} and/or linear solver modules, and require matrices
that are compatible with those implementations.  Alternately, we
provide three SUNMATRIX implementations: dense, banded, and sparse.
The generic operations are described below, and descriptions of the
implementations provided with SUNDIALS follow.

The generic \sphinxcode{SUNMatrix} type has been modeled after the
object-oriented style of the generic \sphinxcode{N\_Vector} type.
Specifically, a generic \sphinxcode{SUNMatrix} is a pointer to a structure
that has an implementation-dependent \sphinxstyleemphasis{content} field containing
the description and actual data of the matrix, and an \sphinxstyleemphasis{ops} field
pointing to a structure with generic matrix operations.
The type \sphinxcode{SUNMatrix} is defined as:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix} \PYG{o}{*}\PYG{n}{SUNMatrix}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Here, the \sphinxcode{\_generic\_SUNMatrix\_Ops} structure is essentially a list of
function pointers to the various actual matrix operations, and is
defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
  \PYG{n}{SUNMatrix\PYGZus{}ID} \PYG{p}{(}\PYG{o}{*}\PYG{n}{getid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{SUNMatrix}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{clone}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{destroy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{zero}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{copy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{scaleadd}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{scaleaddi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{matvecsetup}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{matvec}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{space}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The generic SUNMATRIX module defines and implements the matrix
operations acting on a \sphinxcode{SUNMatrix}. These routines are nothing but
wrappers for the matrix operations defined by a particular SUNMATRIX
implementation, which are accessed through the \sphinxstyleemphasis{ops} field of the
\sphinxcode{SUNMatrix} structure. To illustrate this point we show below the
implementation of a typical matrix operation from the generic
SUNMATRIX module, namely \sphinxcode{SUNMatZero}, which sets all values of a
matrix \sphinxcode{A} to zero, returning a flag denoting a successful/failed
operation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{SUNMatZero}\PYG{p}{(}\PYG{n}{SUNMatrix} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{A}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{zero}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The subsection {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNMATRIX operations}}}} contains a complete list of all
matrix operations defined by the generic SUNMATRIX module.  A
particular implementation of the SUNMATRIX module must:
\begin{itemize}
\item {} 
Specify the \sphinxstyleemphasis{content} field of the \sphinxcode{SUNMatrix} object.

\item {} 
Define and implement a minimal subset of the matrix operations.
See the documentation for each SUNDIALS solver to determine which
SUNMATRIX operations they require.  The list of required
operations for use with ARKode is given in the section
{\hyperref[\detokenize{sunmatrix/ARKode_requirements:sunmatrix-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX functions required by ARKode}}}}.

Note that the names of these routines should be unique to that
implementation in order to permit using more than one SUNMATRIX
module (each with different \sphinxcode{SUNMatrix} internal data
representations) in the same code.

\item {} 
Define and implement user-callable constructor and destructor
routines to create and free a \sphinxcode{SUNMatrix} with the new \sphinxstyleemphasis{content}
field and with \sphinxstyleemphasis{ops} pointing to the new matrix operations.

\item {} 
Optionally, define and implement additional user-callable routines
acting on the newly defined \sphinxcode{SUNMatrix} (e.g., a routine to print the
\sphinxstyleemphasis{content} for debugging purposes).

\item {} 
Optionally, provide accessor macros as needed for that particular
implementation to be used to access different parts in the content
field of the newly defined \sphinxcode{SUNMatrix}.

\end{itemize}

To aid in the creation of custom SUNMATRIX modules the generic SUNMATRIX module
provides three utility functions {\hyperref[\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatNewEmpty}]{\sphinxcrossref{\sphinxcode{SUNMatNewEmpty()}}}},  {\hyperref[\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatCopyOps}]{\sphinxcrossref{\sphinxcode{SUNMatCopyOps()}}}},
and {\hyperref[\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatFreeEmpty}]{\sphinxcrossref{\sphinxcode{SUNMatFreeEmpty()}}}}. When used in custom SUNMATRIX constructors and clone
routines these functions will ease the introduction of any new optional matrix
operations to the SUNMATRIX API by ensuring only required operations need to be
set and all operations are copied when cloning a matrix.
\index{SUNMatNewEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatNewEmpty}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNMatNewEmpty}}{}{}
This function allocates a new generic \sphinxcode{SUNMatrix} object and initializes its
content pointer and the function pointers in the operations structure to \sphinxcode{NULL}.

\sphinxstylestrong{Return value:} If successful, this function returns a \sphinxcode{SUNMatrix}
object. If an error occurs when allocating the object, then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNMatCopyOps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatCopyOps}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatCopyOps}}{SUNMatrix\sphinxstyleemphasis{ A}, SUNMatrix\sphinxstyleemphasis{ B}}{}
This function copies the function pointers in the \sphinxcode{ops} structure of \sphinxcode{A}
into the \sphinxcode{ops} structure of \sphinxcode{B}.
\begin{quote}
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{A} \textendash{} the matrix to copy operations from.

\item {} 
\sphinxstyleemphasis{B} \textendash{} the matrix to copy operations to.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  If successful, this function returns \sphinxcode{0}. If either of
the inputs are \sphinxcode{NULL} or the \sphinxcode{ops} structure of either input is \sphinxcode{NULL},
then is function returns a non-zero value.
\end{quote}

\end{fulllineitems}

\index{SUNMatFreeEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Description:c.SUNMatFreeEmpty}}\pysiglinewithargsret{void \sphinxbfcode{SUNMatFreeEmpty}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This routine frees the generic \sphinxcode{SUNMatrix} object, under the assumption that any
implementation-specific data that was allocated within the underlying content structure
has already been freed. It will additionally test whether the ops pointer is \sphinxcode{NULL},
and, if it is not, it will free it as well.
\begin{quote}
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{A} \textendash{} a SUNMatrix object

\end{itemize}

\end{description}
\end{quote}

\end{fulllineitems}


Each SUNMATRIX implementation included in SUNDIALS has a unique
identifier specified in enumeration and shown in the table below.
It is recommended that a user-supplied SUNMATRIX implementation use
the \sphinxcode{SUNMATRIX\_CUSTOM} identifier.


\subsection{Identifiers associated with matrix kernels supplied with SUNDIALS}
\label{\detokenize{sunmatrix/SUNMatrix_Description:sunmatrix-matrixids}}\label{\detokenize{sunmatrix/SUNMatrix_Description:identifiers-associated-with-matrix-kernels-supplied-with-sundials}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Matrix ID
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Matrix type
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ID Value
\unskip}\relax \\
\hline
SUNMATRIX\_DENSE
&
Dense \(M\times N\) matrix
&
0
\\
\hline
SUNMATRIX\_BAND
&
Band \(M\times M\) matrix
&
1
\\
\hline
SUNMATRIX\_SPARSE
&
Sparse (CSR or CSC) \(M\times N\) matrix
&
2
\\
\hline
SUNMATRIX\_SLUNRLOC
&
SUNMatrix wrapper for SuperLU\_DIST SuperMatrix
&
3
\\
\hline
SUNMATRIX\_CUSTOM
&
User-provided custom matrix
&
4
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Description of the SUNMATRIX operations}
\label{\detokenize{sunmatrix/SUNMatrix_Operations:description-of-the-sunmatrix-operations}}\label{\detokenize{sunmatrix/SUNMatrix_Operations::doc}}\label{\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}}
For each of the \sphinxcode{SUNMatrix} operations, we give the name, usage
of the function, and a description of its mathematical operations
below.
\index{SUNMatGetID (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatGetID}}\pysiglinewithargsret{SUNMatrix\_ID \sphinxbfcode{SUNMatGetID}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
Returns the type identifier for the matrix \sphinxstyleemphasis{A}.  It is used to determine the
matrix implementation type (e.g. dense, banded, sparse,…) from the abstract
\sphinxcode{SUNMatrix} interface.  This is used to assess compatibility with
SUNDIALS-provided linear solver implementations.  Returned values
are given in the Table {\hyperref[\detokenize{sunmatrix/SUNMatrix_Description:sunmatrix-matrixids}]{\sphinxcrossref{\DUrole{std,std-ref}{Identifiers associated with matrix kernels supplied with SUNDIALS}}}}

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{id} \PYG{o}{=} \PYG{n}{SUNMatGetID}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatClone (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatClone}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNMatClone}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
Creates a new \sphinxcode{SUNMatrix} of the same type as an existing
matrix \sphinxstyleemphasis{A} and sets the \sphinxstyleemphasis{ops} field.  It does not copy the matrix,
but rather allocates storage for the new matrix.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{n}{SUNMatClone}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatDestroy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatDestroy}}\pysiglinewithargsret{void \sphinxbfcode{SUNMatDestroy}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
Destroys the \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A} and frees memory allocated for its
internal data.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatDestroy}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatSpace}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatSpace}}{SUNMatrix\sphinxstyleemphasis{ A}, long int\sphinxstyleemphasis{ *lrw}, long int\sphinxstyleemphasis{ *liw}}{}
Returns the storage requirements for the matrix \sphinxstyleemphasis{A}.  \sphinxstyleemphasis{lrw}
contains the number of realtype words and \sphinxstyleemphasis{liw} contains the number
of integer words.  The return value denotes success/failure of the
operation.

This function is advisory only, for use in determining a user’s total
space requirements; it could be a dummy function in a user-supplied
\sphinxcode{SUNMatrix} module if that information is not of interest.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatSpace}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{lrw}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{liw}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatZero (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatZero}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatZero}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
Zeros all entries of the \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  The return value is an
integer flag denoting success/failure of the operation:
\begin{equation*}
\begin{split}A_{i,j} = 0, \quad i=1,\ldots,m, \; j=1,\ldots,n.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatZero}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatCopy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatCopy}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatCopy}}{SUNMatrix\sphinxstyleemphasis{ A}, SUNMatrix\sphinxstyleemphasis{ B}}{}
Performs the operation \sphinxstyleemphasis{B = A} for all entries of the matrices \sphinxstyleemphasis{A}
and \sphinxstyleemphasis{B}.  The return value is an integer flag denoting success/failure of
the operation:
\begin{equation*}
\begin{split}B_{i,j} = A_{i,j}, \quad i=1,\ldots,m, \; j=1,\ldots,n.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatCopy}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatScaleAdd (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatScaleAdd}}\pysiglinewithargsret{\sphinxbfcode{SUNMatScaleAdd}}{realtype\sphinxstyleemphasis{ c}, SUNMatrix\sphinxstyleemphasis{ A}, SUNMatrix\sphinxstyleemphasis{ B}}{}
Performs the operation \sphinxstyleemphasis{A = cA + B}.  The return value is an integer
flag denoting success/failure of the operation:
\begin{equation*}
\begin{split}A_{i,j} = cA_{i,j} + B_{i,j}, \quad i=1,\ldots,m, \; j=1,\ldots,n.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatScaleAdd}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatScaleAddI (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatScaleAddI}}\pysiglinewithargsret{\sphinxbfcode{SUNMatScaleAddI}}{realtype\sphinxstyleemphasis{ c}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Performs the operation \sphinxstyleemphasis{A = cA + I}.  The return value is an integer
flag denoting success/failure of the operation:
\begin{equation*}
\begin{split}A_{i,j} = cA_{i,j} + \delta_{i,j}, \quad i,j=1,\ldots,n.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatScaleAddI}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatMatvecSetup (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatMatvecSetup}}\pysiglinewithargsret{\sphinxbfcode{SUNMatMatvecSetup}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
Performs any setup necessary to perform a matrix-vector product.
The return value is an integer flag denoting success/failure of the
operation. It is useful for SUNMatrix implementations which need to
prepare the matrix itself, or communication structures before performing
the matrix-vector product.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatMatvecSetup}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNMatMatvec (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Operations:c.SUNMatMatvec}}\pysiglinewithargsret{\sphinxbfcode{SUNMatMatvec}}{SUNMatrix\sphinxstyleemphasis{ A}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ y}}{}
Performs the matrix-vector product \sphinxstyleemphasis{y = Ax}.  It should
only be called with vectors \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y} that are compatible with
the matrix \sphinxstyleemphasis{A} \textendash{} both in storage type and dimensions.  The return
value is an integer flag denoting success/failure of the operation:
\begin{equation*}
\begin{split}y_i = \sum_{j=1}^n A_{i,j} x_j, \quad i=1,\ldots,m.\end{split}
\end{equation*}
Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatMatvec}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{SUNMatrix return codes}
\label{\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops-errorcodes}}\label{\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-return-codes}}
The functions provided to SUNMatrix modules within the SUNDIALS-provided SUNMatrix implementations utilize a common set of return codes, listed below. These adhere to a
common pattern: 0 indicates success, a negative value indicates a failure. Aside
from this pattern, the actual values of each error code are primarily to provide additional information to the user in case of a SUNMatrix failure.
\begin{itemize}
\item {} 
\sphinxcode{SUNMAT\_SUCCESS} (0) \textendash{} successful call

\item {} 
\sphinxcode{SUNMAT\_ILL\_INPUT} (-1) \textendash{} an illegal input has been provided to the function

\item {} 
\sphinxcode{SUNMAT\_MEM\_FAIL} (-2) \textendash{} failed memory access or allocation

\item {} 
\sphinxcode{SUNMAT\_OPERATION\_FAIL} (-3) \textendash{} a SUNMatrix operation returned nonzero

\item {} 
\sphinxcode{SUNMAT\_MATVEC\_SETUP\_REQUIRED} (-4) \textendash{} the \sphinxcode{SUNMatMatvecSetup} routine needs to be
called prior to calling \sphinxcode{SUNMatMatvec}

\end{itemize}


\section{Compatibility of SUNMATRIX types}
\label{\detokenize{sunmatrix/SUNMatrix_Compatibility:sunmatrix-compatibility}}\label{\detokenize{sunmatrix/SUNMatrix_Compatibility::doc}}\label{\detokenize{sunmatrix/SUNMatrix_Compatibility:compatibility-of-sunmatrix-types}}
We note that not all \sphinxcode{SUNMatrix} types are compatible with all
\sphinxcode{N\_Vector} types provided with SUNDIALS.  This is primarily due to
the need for compatibility within the \sphinxcode{SUNMatMatvec} routine;
however, compatibility between \sphinxcode{SUNMatrix} and \sphinxcode{N\_Vector}
implementations is more crucial when considering their interaction
within \sphinxcode{SUNLinearSolver} objects, as will be described in more detail in
section {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.  More specifically, in the Table
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Compatibility:sunmatrix-matrix-vector}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS matrix interfaces and vector implementations that can be used for each}}}} we show the matrix interfaces available as
\sphinxcode{SUNMatrix} modules, and the compatible vector implementations.


\subsection{SUNDIALS matrix interfaces and vector implementations that can be used for each}
\label{\detokenize{sunmatrix/SUNMatrix_Compatibility:sunmatrix-matrix-vector}}\label{\detokenize{sunmatrix/SUNMatrix_Compatibility:sundials-matrix-interfaces-and-vector-implementations-that-can-be-used-for-each}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Linear Solver
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Serial
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Parallel (MPI)
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
OpenMP
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
pThreads
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
\sphinxstyleemphasis{hypre} Vec.
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
PETSc Vec.
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CUDA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
RAJA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
User Suppl.
\unskip}\relax \\
\hline
Dense
&
X
&&
X
&
X
&&&&&
X
\\
\hline
Band
&
X
&&
X
&
X
&&&&&
X
\\
\hline
Sparse
&
X
&&
X
&
X
&&&&&
X
\\
\hline
SLUNRloc
&
X
&
X
&
X
&
X
&
X
&
X
&&&
X
\\
\hline
User supplied
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
&
X
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{The SUNMATRIX\_DENSE Module}
\label{\detokenize{sunmatrix/SUNMatrix_Dense:sunmatrix-dense}}\label{\detokenize{sunmatrix/SUNMatrix_Dense::doc}}\label{\detokenize{sunmatrix/SUNMatrix_Dense:the-sunmatrix-dense-module}}
The dense implementation of the \sphinxcode{SUNMatrix} module provided with
SUNDIALS, SUNMATRIX\_DENSE, defines the \sphinxstyleemphasis{content} field of
\sphinxcode{SUNMatrix} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}Dense} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{M}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ldata}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{cols}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following information:
\begin{itemize}
\item {} 
\sphinxcode{M} - number of rows

\item {} 
\sphinxcode{N} - number of columns

\item {} 
\sphinxcode{data} - pointer to a contiguous block of \sphinxcode{realtype} variables.
The elements of the dense matrix are stored columnwise, i.e. the
\(A_{i,j}\) element of a dense \sphinxcode{SUNMatrix A}
(with \(0 \le i < M\) and \(0 \le j < N\)) may be accessed
via \sphinxcode{data{[}j*M+i{]}}.

\item {} 
\sphinxcode{ldata} - length of the data array (\(= M \cdot N\)).

\item {} 
\sphinxcode{cols} - array of pointers. \sphinxcode{cols{[}j{]}} points to the first
element of the j-th column of the matrix in the array \sphinxcode{data}.
The \(A_{i,j}\) element of a dense \sphinxcode{SUNMatrix A}
(with \(0 \le i < M\) and \(0 \le j < N\)) may be accessed
may be accessed via \sphinxcode{cols{[}j{]}{[}i{]}}.

\end{itemize}

The header file to be included when using this module is
\sphinxcode{sunmatrix/sunmatrix\_dense.h}.

The following macros are provided to access the content of a
SUNMATRIX\_DENSE matrix. The prefix \sphinxcode{SM\_} in the names denotes that
these macros are for \sphinxstyleemphasis{SUNMatrix} implementations, and the suffix
\sphinxcode{\_D} denotes that these are specific to the \sphinxstyleemphasis{dense} version.
\index{SM\_CONTENT\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_CONTENT_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_CONTENT\_D}}{A}{}
This macro gives access to the contents of the dense \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

The assignment \sphinxcode{A\_cont = SM\_CONTENT\_D(A)} sets
\sphinxcode{A\_cont} to be a pointer to the dense \sphinxcode{SUNMatrix} content
structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}CONTENT\PYGZus{}D(A)   ( (SUNMatrixContent\PYGZus{}Dense)(A\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_ROWS\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_ROWS_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_ROWS\_D}}{A}{}
Access the number of rows in the dense \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \sphinxcode{A\_rows = SM\_ROWS\_D(A)} sets \sphinxcode{A\_rows} to be
the number of rows in the matrix \sphinxcode{A}.  Similarly, the
assignment \sphinxcode{SM\_ROWS\_D(A) = A\_rows} sets the number of
columns in \sphinxcode{A} to equal \sphinxcode{A\_rows}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ROWS\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}M )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLUMNS\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_COLUMNS_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLUMNS\_D}}{A}{}
Access the number of columns in the dense \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \sphinxcode{A\_columns = SM\_COLUMNS\_D(A)} sets
\sphinxcode{A\_columns} to be the number of columns in the matrix \sphinxcode{A}.
Similarly, the assignment \sphinxcode{SM\_COLUMNS\_D(A) = A\_columns} sets the
number of columns in \sphinxcode{A} to equal \sphinxcode{A\_columns}

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMNS\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}N )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_LDATA\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_LDATA_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_LDATA\_D}}{A}{}
Access the total data length in the dense \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \sphinxcode{A\_ldata = SM\_LDATA\_D(A)} sets
\sphinxcode{A\_ldata} to be the length of the data array in the matrix \sphinxcode{A}.
Similarly, the assignment \sphinxcode{SM\_LDATA\_D(A) = A\_ldata} sets the
parameter for the length of the data array in \sphinxcode{A} to equal
\sphinxcode{A\_ldata}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LDATA\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}ldata )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_DATA\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_DATA_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_DATA\_D}}{A}{}
This macro gives access to the \sphinxcode{data} pointer for the matrix entries.

The assignment \sphinxcode{A\_data = SM\_DATA\_D(A)} sets \sphinxcode{A\_data} to be
a pointer to the first component of the data array for the dense
\sphinxcode{SUNMatrix A}.  The assignment \sphinxcode{SM\_DATA\_D(A) = A\_data}
sets the data array of \sphinxcode{A} to be \sphinxcode{A\_data} by storing the
pointer \sphinxcode{A\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}DATA\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLS\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_COLS_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLS\_D}}{A}{}
This macro gives access to the \sphinxcode{cols} pointer for the matrix entries.

The assignment \sphinxcode{A\_cols = SM\_COLS\_D(A)} sets \sphinxcode{A\_cols} to be
a pointer to the array of column pointers for the dense \sphinxcode{SUNMatrix A}.
The assignment \sphinxcode{SM\_COLS\_D(A) = A\_cols} sets the column pointer
array of \sphinxcode{A} to be \sphinxcode{A\_cols} by storing the pointer
\sphinxcode{A\_cols}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLS\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}cols )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLUMN\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_COLUMN_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLUMN\_D}}{A}{}
This macros gives access to the individual columns of the data
array of a dense \sphinxcode{SUNMatrix}.

The assignment \sphinxcode{col\_j = SM\_COLUMN\_D(A,j)} sets \sphinxcode{col\_j} to be
a pointer to the first entry of the \sphinxcode{j}-th column of the \(M \times N\)
dense matrix \sphinxcode{A} (with \(0 \le j < N\)).  The type of the
expression \sphinxcode{SM\_COLUMN\_D(A,j)} is \sphinxcode{realtype *}.  The pointer
returned by the call \sphinxcode{SM\_COLUMN\_D(A,j)} can be treated as
an array which is indexed from 0 to \sphinxcode{M-1}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMN\PYGZus{}D(A,j)    ( (SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}cols)[j] )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_ELEMENT\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SM_ELEMENT_D}}\pysiglinewithargsret{\sphinxbfcode{SM\_ELEMENT\_D}}{A}{}
This macro gives access to the individual entries of the data array
of a dense \sphinxcode{SUNMatrix}.

The assignments \sphinxcode{SM\_ELEMENT\_D(A,i,j) = a\_ij} and \sphinxcode{a\_ij =
SM\_ELEMENT\_D(A,i,j)} reference the \(A_{i,j}\) element of the
\(M \times N\) dense matrix \sphinxcode{A} (with \(0 \le i < M\) and
\(0 \le j < N\)).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ELEMENT\PYGZus{}D(A,i,j) ( (SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}cols)[j][i] )}
\end{sphinxVerbatim}

\end{fulllineitems}


The SUNMATRIX\_DENSE module defines dense implementations of all matrix
operations listed in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNMATRIX operations}}}}. Their names are obtained
from those in that section by appending the suffix \sphinxcode{\_Dense}
(e.g. \sphinxcode{SUNMatCopy\_Dense}).  The module SUNMATRIX\_DENSE provides the
following additional user-callable routines:
\index{SUNDenseMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNDenseMatrix}}{sunindextype\sphinxstyleemphasis{ M}, sunindextype\sphinxstyleemphasis{ N}}{}
This constructor function creates and allocates memory for a dense
\sphinxcode{SUNMatrix}.  Its arguments are the number of rows, \sphinxcode{M}, and
columns, \sphinxcode{N}, for the dense matrix.

\end{fulllineitems}

\index{SUNDenseMatrix\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Print}}\pysiglinewithargsret{void \sphinxbfcode{SUNDenseMatrix\_Print}}{SUNMatrix\sphinxstyleemphasis{ A}, FILE*\sphinxstyleemphasis{ outfile}}{}
This function prints the content of a dense \sphinxcode{SUNMatrix} to the
output stream specified by \sphinxcode{outfile}.  Note: \sphinxcode{stdout}
or \sphinxcode{stderr} may be used as arguments for \sphinxcode{outfile} to print
directly to standard output or standard error, respectively.

\end{fulllineitems}

\index{SUNDenseMatrix\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Rows}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNDenseMatrix\_Rows}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of rows in the dense \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Columns}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNDenseMatrix\_Columns}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of columns in the dense \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_LData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_LData}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNDenseMatrix\_LData}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the length of the data array for the dense \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Data}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNDenseMatrix\_Data}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the data array for the dense \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Cols (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Cols}}\pysiglinewithargsret{realtype** \sphinxbfcode{SUNDenseMatrix\_Cols}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the cols array for the dense \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Column (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Column}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNDenseMatrix\_Column}}{SUNMatrix\sphinxstyleemphasis{ A}, sunindextype\sphinxstyleemphasis{ j}}{}
This function returns a pointer to the first entry of the jth
column of the dense \sphinxcode{SUNMatrix}.  The resulting pointer should
be indexed over the range \sphinxcode{0} to \sphinxcode{M-1}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of a dense \sphinxcode{SUNMatrix A},
the most efficient approaches are to:
\begin{itemize}
\item {} 
First obtain the component array via \sphinxcode{A\_data = SM\_DATA\_D(A)} or
\sphinxcode{A\_data = SUNDenseMatrix\_Data(A)} and then access \sphinxcode{A\_data{[}i{]}}
within the loop.

\item {} 
First obtain the array of column pointers via \sphinxcode{A\_cols = SM\_COLS\_D(A)} or
\sphinxcode{A\_cols = SUNDenseMatrix\_Cols(A)}, and then access
\sphinxcode{A\_cols{[}j{]}{[}i{]}} within the loop.

\item {} 
Within a loop over the columns, access the column pointer via
\sphinxcode{A\_colj = SUNDenseMatrix\_Column(A,j)} and then to access the
entries within that column using \sphinxcode{A\_colj{[}i{]}} within the loop.

\end{itemize}

All three of these are more efficient than
using \sphinxcode{SM\_ELEMENT\_D(A,i,j)} within a double loop.

\item {} 
Within the \sphinxcode{SUNMatMatvec\_Dense} routine, internal consistency
checks are performed to ensure that the matrix is called with
consistent \sphinxcode{N\_Vector} implementations.  These are currently
limited to: NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS.
As additional compatible vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

\end{itemize}

For solvers that include a Fortran interface module, the SUNMATRIX\_DENSE
module also includes the Fortran-callable function
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMatInit}]{\sphinxcrossref{\sphinxcode{FSUNDenseMatInit()}}}} to initialize this SUNMATRIX\_DENSE module
for a given SUNDIALS solver.
\index{FSUNDenseMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMatInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNDenseMatInit}}{\emph{CODE}, \emph{M}, \emph{N}, \emph{IER}}{}
Initializes a dense \sphinxcode{SUNMatrix} structure for use in a SUNDIALS solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{M} (\sphinxcode{long int}, input) \textendash{} number of matrix rows.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{long int}, input) \textendash{} number of matrix columns.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMassMatInit}]{\sphinxcrossref{\sphinxcode{FSUNDenseMassMatInit()}}}} initializes
this SUNMATRIX\_DENSE module for storing the mass matrix.
\index{FSUNDenseMassMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMassMatInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNDenseMassMatInit}}{\emph{M}, \emph{N}, \emph{IER}}{}
Initializes a dense \sphinxcode{SUNMatrix} structure for use as a mass
matrix in ARKode.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{M} (\sphinxcode{long int}, input) \textendash{} number of matrix rows.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{long int}, input) \textendash{} number of matrix columns.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNMATRIX\_BAND Module}
\label{\detokenize{sunmatrix/SUNMatrix_Band:the-sunmatrix-band-module}}\label{\detokenize{sunmatrix/SUNMatrix_Band:sunmatrix-band}}\label{\detokenize{sunmatrix/SUNMatrix_Band::doc}}
The banded implementation of the \sphinxcode{SUNMatrix} module provided with
SUNDIALS, SUNMATRIX\_BAND, defines the \sphinxstyleemphasis{content} field of
\sphinxcode{SUNMatrix} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}Band} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{M}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{mu}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ml}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{smu}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ldim}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ldata}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{cols}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

A diagram of the underlying data representation in a banded matrix is
shown in Figure {\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:sunbandmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNBandMatrix Diagram}}}}.  A more
complete description of the parts of this \sphinxstyleemphasis{content} field is given below:
\begin{itemize}
\item {} 
\sphinxcode{M} - number of rows

\item {} 
\sphinxcode{N} - number of columns (\sphinxcode{N} = \sphinxcode{M})

\item {} 
\sphinxcode{mu} - upper half-bandwidth, \(0 \le \text{mu} < N\)

\item {} 
\sphinxcode{ml} - lower half-bandwidth, \(0 \le \text{ml} < N\)

\item {} 
\sphinxcode{smu} - storage upper bandwidth, \(\text{mu} \le \text{smu} < N\).
The LU decomposition routines in the associated SUNLINSOL\_BAND
and SUNLINSOL\_LAPACKBAND modules write the LU factors into the
existing storage for the band matrix. The upper triangular factor
U, however, may have an upper bandwidth as big as
\sphinxcode{min(N-1, mu+ml)} because of partial pivoting. The \sphinxcode{smu} field
holds the upper half-bandwidth allocated for the band matrix.

\item {} 
\sphinxcode{ldim} - leading dimension (\(\text{ldim} \ge smu + ml + 1\))

\item {} 
\sphinxcode{data} - pointer to a contiguous block of \sphinxcode{realtype} variables.
The elements of the banded matrix are stored columnwise
(i.e. columns are stored one on top of the other in memory). Only
elements within the specified half-bandwidths are stored.  \sphinxcode{data}
is a pointer to \sphinxcode{ldata} contiguous locations which hold the
elements within the banded matrix.

\item {} 
\sphinxcode{ldata} - length of the data array (\(= \text{ldim} \cdot N\))

\item {} 
\sphinxcode{cols} - array of pointers. \sphinxcode{cols{[}j{]}} is a pointer to the
uppermost element within the band in the j-th column. This pointer
may be treated as an array indexed from
\sphinxcode{smu-mu} (to access the uppermost element within the band in the
j-th column) to \sphinxcode{smu+ml} (to access the lowest element within the
band in the j-th column). Indices from 0 to \sphinxcode{smu-mu-1} give access
to extra storage elements required by the LU decomposition function.
Finally, \sphinxcode{cols{[}j{]}{[}i-j+smu{]}} is the (\(i,j\))-th element with
\(j-\text{mu} \le i \le j+\text{ml}\).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bandmat1}.png}
\caption{Diagram of the storage for the SUNMATRIX\_BAND module. Here \sphinxcode{A} is an
\(N \times N\) band matrix with upper and lower half-bandwidths \sphinxcode{mu}
and \sphinxcode{ml}, respectively. The rows and columns of \sphinxcode{A} are
numbered from 0 to \sphinxcode{N-1} and the (\(i,j\))-th element of \sphinxcode{A} is
denoted \sphinxcode{A(i,j)}. The greyed out areas of the underlying
component storage are used by the associated SUNLINSOL\_BAND or
SUNLINSOL\_LAPACKBAND linear solver.}\label{\detokenize{sunmatrix/SUNMatrix_Band:sunbandmatrix}}\label{\detokenize{sunmatrix/SUNMatrix_Band:id1}}\end{figure}

The header file to be included when using this module is
\sphinxcode{sunmatrix/sunmatrix\_band.h}.

The following macros are provided to access the
content of a SUNMATRIX\_BAND matrix. The prefix \sphinxcode{SM\_} in the names
denotes that these macros are for \sphinxstyleemphasis{SUNMatrix} implementations,
and the suffix \sphinxcode{\_B} denotes that these are specific to
the \sphinxstyleemphasis{banded} version.
\index{SM\_CONTENT\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_CONTENT_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_CONTENT\_B}}{A}{}
This macro gives access to the contents of the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

The assignment \sphinxcode{A\_cont = SM\_CONTENT\_B(A)} sets
\sphinxcode{A\_cont} to be a pointer to the banded \sphinxcode{SUNMatrix} content
structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}CONTENT\PYGZus{}B(A)   ( (SUNMatrixContent\PYGZus{}Band)(A\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_ROWS\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_ROWS_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_ROWS\_B}}{A}{}
Access the number of rows in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \sphinxcode{A\_rows = SM\_ROWS\_B(A)} sets \sphinxcode{A\_rows} to be
the number of rows in the matrix \sphinxcode{A}.  Similarly, the
assignment \sphinxcode{SM\_ROWS\_B(A) = A\_rows} sets the number of
columns in \sphinxcode{A} to equal \sphinxcode{A\_rows}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ROWS\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}M )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLUMNS\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_COLUMNS_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLUMNS\_B}}{A}{}
Access the number of columns in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMNS\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}N )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_UBAND\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_UBAND_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_UBAND\_B}}{A}{}
Access the \sphinxcode{mu} parameter in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}UBAND\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}mu )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_LBAND\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_LBAND_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_LBAND\_B}}{A}{}
Access the \sphinxcode{ml} parameter in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LBAND\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}ml )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_SUBAND\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_SUBAND_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_SUBAND\_B}}{A}{}
Access the \sphinxcode{smu} parameter in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}SUBAND\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}smu )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_LDIM\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_LDIM_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_LDIM\_B}}{A}{}
Access the \sphinxcode{ldim} parameter in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LDIM\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}ldim )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_LDATA\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_LDATA_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_LDATA\_B}}{A}{}
Access the \sphinxcode{ldata} parameter in the banded \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LDATA\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}ldata )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_DATA\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_DATA_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_DATA\_B}}{A}{}
This macro gives access to the \sphinxcode{data} pointer for the matrix entries.

The assignment \sphinxcode{A\_data = SM\_DATA\_B(A)} sets \sphinxcode{A\_data} to be
a pointer to the first component of the data array for the banded
\sphinxcode{SUNMatrix A}.  The assignment \sphinxcode{SM\_DATA\_B(A) = A\_data}
sets the data array of \sphinxcode{A} to be \sphinxcode{A\_data} by storing the
pointer \sphinxcode{A\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}DATA\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLS\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_COLS_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLS\_B}}{A}{}
This macro gives access to the \sphinxcode{cols} pointer for the matrix entries.

The assignment \sphinxcode{A\_cols = SM\_COLS\_B(A)} sets \sphinxcode{A\_cols} to be
a pointer to the array of column pointers for the banded \sphinxcode{SUNMatrix A}.
The assignment \sphinxcode{SM\_COLS\_B(A) = A\_cols} sets the column pointer
array of \sphinxcode{A} to be \sphinxcode{A\_cols} by storing the pointer
\sphinxcode{A\_cols}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLS\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}cols )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLUMN\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_COLUMN_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLUMN\_B}}{A}{}
This macros gives access to the individual columns of the data
array of a banded \sphinxcode{SUNMatrix}.

The assignment \sphinxcode{col\_j = SM\_COLUMN\_B(A,j)} sets \sphinxcode{col\_j} to be
a pointer to the diagonal element of the j-th column of the
\(N \times N\) band matrix \sphinxcode{A}, \(0 \le j \le N-1\).
The type of the expression \sphinxcode{SM\_COLUMN\_B(A,j)} is \sphinxcode{realtype *}.
The pointer returned by the call \sphinxcode{SM\_COLUMN\_B(A,j)} can be treated as
an array which is indexed from \sphinxcode{-mu} to \sphinxcode{ml}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMN\PYGZus{}B(A,j)   ( ((SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}cols)[j])+SM\PYGZus{}SUBAND\PYGZus{}B(A) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_ELEMENT\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_ELEMENT_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_ELEMENT\_B}}{A}{}
This macro gives access to the individual entries of the data array
of a banded \sphinxcode{SUNMatrix}.

The assignments \sphinxcode{SM\_ELEMENT\_B(A,i,j) = a\_ij} and \sphinxcode{a\_ij =
SM\_ELEMENT\_B(A,i,j)} reference the (\(i,j\))-th element of the
\(N \times N\) band matrix \sphinxcode{A}, where \(0 \le i,j \le N-1\).
The location (\(i,j\)) should further satisfy
\(j-\text{mu} \le i \le j+\text{ml}\).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ELEMENT\PYGZus{}B(A,i,j)   ( (SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}cols)[j][(i)\PYGZhy{}(j)+SM\PYGZus{}SUBAND\PYGZus{}B(A)] )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLUMN\_ELEMENT\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SM_COLUMN_ELEMENT_B}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLUMN\_ELEMENT\_B}}{A}{}
This macro gives access to the individual entries of the data array
of a banded \sphinxcode{SUNMatrix}.

The assignments \sphinxcode{SM\_COLUMN\_ELEMENT\_B(col\_j,i,j) = a\_ij} and
\sphinxcode{a\_ij = SM\_COLUMN\_ELEMENT\_B(col\_j,i,j)} reference the
(\(i,j\))-th entry of the band matrix \sphinxcode{A} when used in
conjunction with \sphinxcode{SM\_COLUMN\_B} to reference the j-th column
through \sphinxcode{col\_j}. The index (\(i,j\)) should satisfy
\(j-\text{mu} \le i \le j+\text{ml}\).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMN\PYGZus{}ELEMENT\PYGZus{}B(col\PYGZus{}j,i,j)   (col\PYGZus{}j[(i)\PYGZhy{}(j)])}
\end{sphinxVerbatim}

\end{fulllineitems}


The SUNMATRIX\_BAND module defines banded implementations of all matrix
operations listed in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNMATRIX operations}}}}. Their names are
obtained from those in that section by appending the suffix \sphinxcode{\_Band}
(e.g. \sphinxcode{SUNMatCopy\_Band}).  The module SUNMATRIX\_BAND provides the
following additional user-callable routines:
\index{SUNBandMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNBandMatrix}}{sunindextype\sphinxstyleemphasis{ N}, sunindextype\sphinxstyleemphasis{ mu}, sunindextype\sphinxstyleemphasis{ ml}}{}
This constructor function creates and allocates memory for a banded \sphinxcode{SUNMatrix}.
Its arguments are the matrix size, \sphinxcode{N}, and the upper and lower
half-bandwidths of the matrix, \sphinxcode{mu} and \sphinxcode{ml}.  The stored upper
bandwidth is set to \sphinxcode{mu+ml} to accommodate subsequent
factorization in the SUNLINSOL\_BAND and SUNLINSOL\_LAPACKBAND
modules.

\end{fulllineitems}

\index{SUNBandMatrixStorage (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrixStorage}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNBandMatrixStorage}}{sunindextype\sphinxstyleemphasis{ N}, sunindextype\sphinxstyleemphasis{ mu}, sunindextype\sphinxstyleemphasis{ ml}, sunindextype\sphinxstyleemphasis{ smu}}{}
This constructor function creates and allocates memory for a banded \sphinxcode{SUNMatrix}.
Its arguments are the matrix size, \sphinxcode{N}, the upper and lower
half-bandwidths of the matrix, \sphinxcode{mu} and \sphinxcode{ml}, and the stored
upper bandwidth, \sphinxcode{smu}.  When creating a band \sphinxcode{SUNMatrix},
this value should be
\begin{itemize}
\item {} 
at least \sphinxcode{min(N-1,mu+ml)} if the matrix will be
used by the SUNLinSol\_Band module;

\item {} 
exactly equal to \sphinxcode{mu+ml} if the matrix will be used by
the SUNLinSol\_LapackBand module;

\item {} 
at least \sphinxcode{mu} if used in some other manner.

\end{itemize}

\sphinxstyleemphasis{Note: it is strongly recommended that users call the default
constructor, :c:func:{}`SUNBandMatrix(){}`, in all standard use cases.
This advanced constructor is used internally within SUNDIALS
solvers, and is provided to users who require banded matrices for
non-default purposes.}

\end{fulllineitems}

\index{SUNBandMatrix\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Print}}\pysiglinewithargsret{void \sphinxbfcode{SUNBandMatrix\_Print}}{SUNMatrix\sphinxstyleemphasis{ A}, FILE*\sphinxstyleemphasis{ outfile}}{}
This function prints the content of a banded \sphinxcode{SUNMatrix} to the
output stream specified by \sphinxcode{outfile}.  Note: \sphinxcode{stdout}
or \sphinxcode{stderr} may be used as arguments for \sphinxcode{outfile} to print
directly to standard output or standard error, respectively.

\end{fulllineitems}

\index{SUNBandMatrix\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Rows}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNBandMatrix\_Rows}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of rows in the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Columns}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNBandMatrix\_Columns}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of columns in the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_LowerBandwidth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_LowerBandwidth}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNBandMatrix\_LowerBandwidth}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the lower half-bandwidth for the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_UpperBandwidth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_UpperBandwidth}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNBandMatrix\_UpperBandwidth}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the upper half-bandwidth of the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_StoredUpperBandwidth (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_StoredUpperBandwidth}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNBandMatrix\_StoredUpperBandwidth}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the stored upper half-bandwidth of the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_LDim (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_LDim}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNBandMatrix\_LDim}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the length of the leading dimension of the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Data}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNBandMatrix\_Data}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the data array for the banded \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Cols (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Cols}}\pysiglinewithargsret{realtype** \sphinxbfcode{SUNBandMatrix\_Cols}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the cols array for the band \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Column (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Column}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNBandMatrix\_Column}}{SUNMatrix\sphinxstyleemphasis{ A}, sunindextype\sphinxstyleemphasis{ j}}{}
This function returns a pointer to the diagonal entry of the j-th
column of the banded \sphinxcode{SUNMatrix}.  The resulting pointer should
be indexed over the range \sphinxcode{-mu} to \sphinxcode{ml}.

\end{fulllineitems}


\sphinxstylestrong{Notes}
\begin{itemize}
\item {} 
When looping over the components of a banded \sphinxcode{SUNMatrix A},
the most efficient approaches are to:
\begin{itemize}
\item {} 
First obtain the component array via \sphinxcode{A\_data = SM\_DATA\_B(A)} or
\sphinxcode{A\_data = SUNBandMatrix\_Data(A)} and then
access \sphinxcode{A\_data{[}i{]}} within the loop.

\item {} 
First obtain the array of column pointers via \sphinxcode{A\_cols = SM\_COLS\_B(A)} or
\sphinxcode{A\_cols = SUNBandMatrix\_Cols(A)}, and then
access \sphinxcode{A\_cols{[}j{]}{[}i{]}} within the loop.

\item {} 
Within a loop over the columns, access the column pointer via
\sphinxcode{A\_colj = SUNBandMatrix\_Column(A,j)} and then to access the
entries within that column using \sphinxcode{SM\_COLUMN\_ELEMENT\_B(A\_colj,i,j)}.

\end{itemize}

All three of these are more efficient than
using \sphinxcode{SM\_ELEMENT\_B(A,i,j)} within a double loop.

\item {} 
Within the \sphinxcode{SUNMatMatvec\_Band} routine, internal consistency
checks are performed to ensure that the matrix is called with
consistent \sphinxcode{N\_Vector} implementations.  These are currently
limited to: NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS.
As additional compatible vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

\end{itemize}

For solvers that include a Fortran interface module, the SUNMATRIX\_BAND
module also includes the Fortran-callable function
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:f/_/FSUNBandMatInit}]{\sphinxcrossref{\sphinxcode{FSUNBandMatInit()}}}} to initialize this SUNMATRIX\_BAND module
for a given SUNDIALS solver.
\index{FSUNBandMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:f/_/FSUNBandMatInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNBandMatInit}}{\emph{CODE}, \emph{N}, \emph{MU}, \emph{ML}, \emph{IER}}{}
Initializes a band \sphinxcode{SUNMatrix} structure for use in a SUNDIALS solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{long int}, input) \textendash{} number of matrix rows (and columns).

\item {} 
\sphinxstyleemphasis{MU} (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth.

\item {} 
\sphinxstyleemphasis{ML} (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunmatrix/SUNMatrix_Band:f/_/FSUNBandMassMatInit}]{\sphinxcrossref{\sphinxcode{FSUNBandMassMatInit()}}}} initializes
this SUNMATRIX\_BAND module for storing the mass matrix.
\index{FSUNBandMassMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Band:f/_/FSUNBandMassMatInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNBandMassMatInit}}{\emph{N}, \emph{MU}, \emph{ML}, \emph{IER}}{}
Initializes a band \sphinxcode{SUNMatrix} structure for use as a mass
matrix in ARKode.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{long int}, input) \textendash{} number of matrix rows (and columns).

\item {} 
\sphinxstyleemphasis{MU} (\sphinxcode{long int}, input) \textendash{} upper half-bandwidth.

\item {} 
\sphinxstyleemphasis{ML} (\sphinxcode{long int}, input) \textendash{} lower half-bandwidth.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNMATRIX\_CUSPARSE Module}
\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:the-sunmatrix-cusparse-module}}\label{\detokenize{sunmatrix/SUNMatrix_cuSparse::doc}}\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse}}
The SUNMATRIX\_CUSPARSE implementation of the \sphinxcode{SUNMatrix} module provided with
SUNDIALS, is an interface to the NVIDIA cuSPARSE matrix for use on NVIDIA GPUs (\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:id1}}{\hyperref[\detokenize{References:cusparse}]{\sphinxcrossref{{[}cuSPARSE{]}}}}).
All data stored by this matrix implementation resides on the GPU at all times.

The header file to be included when using this module is \sphinxcode{sunmatrix/sunmatrix\_cusparse.h}.
The installed library to link to is \sphinxcode{libsundials\_sunmatrixcusparse.lib} where \sphinxcode{.lib} is
typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a} for static libraries.


\subsection{SUNMATRIX\_CUSPARSE Description}
\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse-description}}\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:id2}}
The implementation currently supports the cuSPARSE CSR matrix format described
in the cuSPARSE documentation as well as a unique low-storage format for
block-diagonal matrices of the form
\begin{equation*}
\begin{split}\mathbf{A} =
\begin{bmatrix}
   \mathbf{A_1} & 0 & \cdots & 0\\
   0 & \mathbf{A_2} & \cdots & 0\\
   \vdots & \vdots & \ddots & \vdots\\
   0 & 0 & \cdots & \mathbf{A_n}\\
\end{bmatrix}\end{split}
\end{equation*}
where all the block matrices \(\mathbf{A_j}\) share the same sparsisty pattern.
We will refer to this format as BCSR (not to be confused with the canonical BSR format where
each block is stored as dense). In this format, the CSR column indices and row pointers
are only stored for the first block and are computed only as necessary for other blocks.
This can drastically reduce the amount of storage required compared to the regular CSR
format when there is a large number of blocks. This format is well-suited for, and
intended to be used with the {\hyperref[\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinSol\_cuSolverSp\_batchQR Module}}}}.

\sphinxstylestrong{The SUNMATRIX\_CUSPARSE module is experimental and subject to change.}


\subsection{SUNMATRIX\_CUSPARSE Functions}
\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:id3}}\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse-functions}}
The SUNMATRIX\_CUSPARSE module defines GPU-enabled sparse implementations of all matrix
operations listed in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNMATRIX operations}}}} except for the \sphinxcode{SUNMatSpace}
and \sphinxcode{SUNMatMatvecSetup} operations:
\begin{itemize}
\item {} 
\sphinxcode{SUNMatGetID\_cuSparse} \textendash{} returns \sphinxcode{SUNMATRIX\_CUSPARSE}

\item {} 
\sphinxcode{SUNMatClone\_cuSparse}

\item {} 
\sphinxcode{SUNMatDestroy\_cuSparse}

\item {} 
\sphinxcode{SUNMatZero\_cuSparse}

\item {} 
\sphinxcode{SUNMatCopy\_cuSparse}

\item {} 
\sphinxcode{SUNMatScaleAdd\_cuSparse} \textendash{} performs \(A = cA + B\), where \(A\) and \(B\)
must have the same sparsity pattern

\item {} 
\sphinxcode{SUNMatScaleAddI\_cuSparse} \textendash{} performs \(A = cA + I\), where the diagonal of \(A\)
must be present

\item {} 
\sphinxcode{SUNMatMatvec\_cuSparse}

\end{itemize}

In addition, the SUNMATRIX\_CUSPARSE module defines the following implementation specific
functions:
\index{SUNMatrix\_cuSparse\_NewCSR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_NewCSR}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNMatrix\_cuSparse\_NewCSR}}{int\sphinxstyleemphasis{ M}, int\sphinxstyleemphasis{ N}, int\sphinxstyleemphasis{ NNZ}, cusparseHandle\_t\sphinxstyleemphasis{ cusp}}{}
This constructor function creates and allocates memory for a SUMATRIX\_CUSPARSE
\sphinxcode{SUNMatrix} that uses the CSR storage format. Its arguments are the
number of rows and columns of the matrix, \sphinxcode{M} and \sphinxcode{N}, the number of
nonzeros to be stored in the matrix, \sphinxcode{NNZ}, and a valid \sphinxcode{cusparseHandle\_t}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_NewBlockCSR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_NewBlockCSR}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNMatrix\_cuSparse\_NewBlockCSR}}{int\sphinxstyleemphasis{ nblocks}, int\sphinxstyleemphasis{ blockrows}, int\sphinxstyleemphasis{ blockcols}, int\sphinxstyleemphasis{ blocknnz}, cusparseHandle\_t\sphinxstyleemphasis{ cusp}}{}
This constructor function creates and allocates memory for a SUNMATRIX\_CUSPARSE
\sphinxcode{SUNMatrix} object that leverages the \sphinxcode{SUNMAT\_CUSPARSE\_BCSR} storage
format to store a block diagonal matrix where each block shares the same
sparsity pattern. The blocks must be square. The function arguments are the
number of blocks,{}`{}`nblocks{}`{}`, the number of rows, \sphinxcode{blockrows}, the number of
columns, \sphinxcode{blockcols}, the number of nonzeros in each each block, \sphinxcode{blocknnz},
and a valid cuSPARSE handle.

\sphinxstylestrong{The {}`{}`SUNMAT\_CUSPARSE\_BCSR{}`{}` format currently only supports square matrices.}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_MakeCSR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_MakeCSR}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNMatrix\_cuSparse\_MakeCSR}}{cusparseMatDescr\_t\sphinxstyleemphasis{ mat\_descr}, int\sphinxstyleemphasis{ M}, int\sphinxstyleemphasis{ N}, int\sphinxstyleemphasis{ NNZ}, int\sphinxstyleemphasis{ *rowptrs}, int\sphinxstyleemphasis{ *colind}, realtype\sphinxstyleemphasis{ *data}, cusparseHandle\_t\sphinxstyleemphasis{ cusp}}{}
This constructor function creates a SUNMATRIX\_CUSPARSE \sphinxcode{SUNMatrix}
object from user provided pointers. Its arguments are a \sphinxcode{cusparseMatDescr\_t}
that must have index base \sphinxcode{CUSPARSE\_INDEX\_BASE\_ZERO}, the number of rows
and columns of the matrix, \sphinxcode{M} and \sphinxcode{N}, the number of nonzeros to be stored
in the matrix, \sphinxcode{NNZ}, and a valid \sphinxcode{cusparseHandle\_t}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_Rows}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_Rows}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of rows in the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_Columns}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_Columns}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of columns in the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_NNZ (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_NNZ}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_NNZ}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of entries allocated for nonzero
storage for the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_SparseType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_SparseType}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_SparseType}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the storage type (\sphinxcode{SUNMAT\_CUSPARSE\_CSR}
or \sphinxcode{SUNMAT\_CUSPARSE\_BCSR}) for the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_Data}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNMatrix\_cuSparse\_Data}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the data array for the
sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_IndexValues (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_IndexValues}}\pysiglinewithargsret{int* \sphinxbfcode{SUNMatrix\_cuSparse\_IndexValues}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the index value array for the sparse
\sphinxcode{SUNMatrix}: for the CSR format this is an array of column indices for
each nonzero entry. For the BCSR format this is an array of the column indices
for each nonzero entry in the first block only.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_IndexPointers (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_IndexPointers}}\pysiglinewithargsret{int* \sphinxbfcode{SUNMatrix\_cuSparse\_IndexPointers}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the index pointer array for the
sparse \sphinxcode{SUNMatrix}: for the CSR format this is an array of the locations
of the first entry of each row in the \sphinxcode{data} and \sphinxcode{indexvalues} arrays,
for the BCSR format this is an array of the locations of each row in the
\sphinxcode{data} and \sphinxcode{indexvalues} arrays in the first block only.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_NumBlocks (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_NumBlocks}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_NumBlocks}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of matrix blocks.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_BlockRows (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_BlockRows}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_BlockRows}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of rows in a matrix block.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_BlockColumns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_BlockColumns}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_BlockColumns}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of columns in a matrix block.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_BlockNNZ (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_BlockNNZ}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_BlockNNZ}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of nonzeros in each
matrix block.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_BlockData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_BlockData}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNMatrix\_cuSparse\_BlockData}}{SUNMatrix\sphinxstyleemphasis{ A}, int\sphinxstyleemphasis{ blockidx}}{}
This function returns a pointer to the location in the \sphinxcode{data} array
where the data for the block, \sphinxcode{blockidx}, begins. Thus, \sphinxcode{blockidx}
must be less than \sphinxcode{SUNMatrix\_cuSparse\_NumBlocks(A)}. The first block
in the SUNMatrix is index 0, the second block is index 1, and so on.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_MatDescr (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_MatDescr}}\pysiglinewithargsret{cusparseMatDescr\_t \sphinxbfcode{SUNMatrix\_cuSparse\_MatDescr}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the \sphinxcode{cusparseMatDescr\_t} object associated with
the matrix.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{int~SUNMatrix\_cuSparse\_CopyToDevice(SUNMatrix~A,~realtype*~h\_data,}}\pysigline{\sphinxbfcode{int*~h\_idxptrs,~int*~h\_idxvals)}}
This functions copies the matrix information to the GPU device from the provided
host arrays. A user may provide \sphinxcode{NULL} for any of \sphinxcode{h\_data}, \sphinxcode{h\_idxptrs}, or
\sphinxcode{h\_idxvals} to avoid copying that information.

The function returns \sphinxcode{SUNMAT\_SUCCESS} if the copy operation(s) were successful,
or a nonzero error code otherwise.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_CopyFromDevice (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_CopyFromDevice}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_CopyFromDevice}}{SUNMatrix\sphinxstyleemphasis{ A}, realtype*\sphinxstyleemphasis{ h\_data}, int*\sphinxstyleemphasis{ h\_idxptrs}, int*\sphinxstyleemphasis{ h\_idxvals}}{}
This functions copies the matrix information from the GPU device to the provided
host arrays. A user may provide \sphinxcode{NULL} for any of \sphinxcode{h\_data}, \sphinxcode{h\_idxptrs}, or
\sphinxcode{h\_idxvals} to avoid copying that information. Otherwise:
\begin{itemize}
\item {} 
The \sphinxcode{h\_data} array must be at least \sphinxcode{SUNMatrix\_cuSparse\_NNZ(A)*sizeof(realtype)}
bytes.

\item {} \begin{description}
\item[{The \sphinxcode{h\_idxptrs} array must be at least}] \leavevmode
\sphinxcode{(SUNMatrix\_cuSparse\_BlockDim(A)+1)*sizeof(int)} bytes.

\end{description}

\item {} \begin{description}
\item[{The \sphinxcode{h\_idxvals} array must be at least}] \leavevmode
\sphinxcode{(SUNMatrix\_cuSparse\_BlockNNZ(A))*sizeof(int)} bytes.

\end{description}

\end{itemize}

The function returns \sphinxcode{SUNMAT\_SUCCESS} if the copy operation(s) were successful,
or a nonzero error code otherwise.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_SetFixedPattern (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_SetFixedPattern}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_SetFixedPattern}}{SUNMatrix\sphinxstyleemphasis{ A}, booleantype\sphinxstyleemphasis{ yesno}}{}
This function changes the behavior of the the \sphinxcode{SUNMatZero} operation on the object
\sphinxcode{A}.  By default the matrix sparsity pattern is not considered to be fixed, thus,
the \sphinxcode{SUNMatZero} operation zeros out all \sphinxcode{data} array as well as the \sphinxcode{indexvalues}
and \sphinxcode{indexpointers} arrays. Providing a value of \sphinxcode{1} or \sphinxcode{SUNTRUE} for the
\sphinxcode{yesno} argument changes the behavior of \sphinxcode{SUNMatZero} on \sphinxcode{A} so that only the
data is zeroed out, but not the \sphinxcode{indexvalues} or \sphinxcode{indexpointers} arrays.
Providing a value of \sphinxcode{0} or \sphinxcode{SUNFALSE} for the \sphinxcode{yesno} argument is equivalent
to the default behavior.

\end{fulllineitems}

\index{SUNMatrix\_cuSparse\_SetKernelExecPolicy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:c.SUNMatrix_cuSparse_SetKernelExecPolicy}}\pysiglinewithargsret{int \sphinxbfcode{SUNMatrix\_cuSparse\_SetKernelExecPolicy}}{SUNMatrix\sphinxstyleemphasis{ A}, SUNCudaExecPolicy*\sphinxstyleemphasis{ exec\_policy}}{}
This function sets the execution policies which control the kernel parameters
utilized when launching the CUDA kernels. By default the matrix is setup to use
a policy which tries to leverage the structure of the matrix. See section
{\hyperref[\detokenize{nvectors/NVector_CUDA:nvectors-cuda-suncudaexecpolicy}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNCudaExecPolicy Class}}}} for more information about the \sphinxcode{SUNCudaExecPolicy} class.

\end{fulllineitems}



\subsection{SUNMATRIX\_CUSPARSE Usage Notes}
\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse-notes}}\label{\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse-usage-notes}}
The SUNMATRIX\_CUSPARSE module only supports 32-bit indexing, thus SUNDIALS must be built
for 32-bit indexing to use this module.

The SUNMATRIX\_CUSPARSE module can be used with CUDA streams by calling the cuSPARSE
function \sphinxcode{cusparseSetStream} on the the \sphinxcode{cusparseHandle\_t} that is provided to the
SUNMATRIX\_CUSPARSE constructor.

\begin{sphinxadmonition}{warning}{Warning:}
When using the SUNMATRIX\_CUSPARSE module with a SUNDIALS package (e.g. ARKODE), the
stream given to cuSPARSE should be the same stream used for the NVECTOR object that
is provided to the package, and the NVECTOR object given to the \sphinxcode{SUNMatvec} operation.
If different streams are utilized, synchronization issues may occur.
\end{sphinxadmonition}


\section{The SUNMATRIX\_SPARSE Module}
\label{\detokenize{sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse}}\label{\detokenize{sunmatrix/SUNMatrix_Sparse:the-sunmatrix-sparse-module}}\label{\detokenize{sunmatrix/SUNMatrix_Sparse::doc}}
The sparse implementation of the \sphinxcode{SUNMatrix} module provided with
SUNDIALS, SUNMATRIX\_SPARSE, is designed to work with either
\sphinxstyleemphasis{compressed-sparse-column} (CSC) or \sphinxstyleemphasis{compressed-sparse-row}
(CSR) sparse matrix formats.  To this end, it defines the \sphinxstyleemphasis{content}
field of \sphinxcode{SUNMatrix} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}Sparse} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{M}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{NNZ}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{NP}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{sparsetype}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{indexvals}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{indexptrs}\PYG{p}{;}
  \PYG{c+cm}{/* CSC indices */}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{rowvals}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{colptrs}\PYG{p}{;}
  \PYG{c+cm}{/* CSR indices */}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{colvals}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{rowptrs}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

A diagram of the underlying data representation in a sparse matrix is
shown in Figure {\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:sunsparsematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNSparseMatrix Diagram}}}}.  A more
complete description of the parts of this \sphinxstyleemphasis{content} field is given below:
\begin{itemize}
\item {} 
\sphinxcode{M} - number of rows

\item {} 
\sphinxcode{N} - number of columns

\item {} 
\sphinxcode{NNZ} - maximum number of nonzero entries in the matrix
(allocated length of \sphinxcode{data} and \sphinxcode{indexvals} arrays)

\item {} 
\sphinxcode{NP} - number of index pointers (e.g. number of column pointers
for CSC matrix). For CSC matrices \sphinxcode{NP=N}, and for CSR matrices
\sphinxcode{NP=M}. This value is set automatically at construction based the
input choice for \sphinxcode{sparsetype}.

\item {} 
\sphinxcode{data} - pointer to a contiguous block of \sphinxcode{realtype}
variables (of length \sphinxcode{NNZ}), containing the values of the
nonzero entries in the matrix

\item {} 
\sphinxcode{sparsetype} - type of the sparse matrix (\sphinxcode{CSC\_MAT} or \sphinxcode{CSR\_MAT})

\item {} 
\sphinxcode{indexvals} - pointer to a contiguous block of \sphinxcode{int} variables
(of length \sphinxcode{NNZ}), containing the row indices (if CSC) or column
indices (if CSR) of each nonzero matrix entry held in \sphinxcode{data}

\item {} 
\sphinxcode{indexptrs} - pointer to a contiguous block of \sphinxcode{int}
variables (of length \sphinxcode{NP+1}). For CSC matrices each entry provides
the index of the first column entry into the \sphinxcode{data} and
\sphinxcode{indexvals} arrays, e.g. if \sphinxcode{indexptr{[}3{]}=7}, then the first
nonzero entry in the fourth column of the matrix is located in
\sphinxcode{data{[}7{]}}, and is located in row \sphinxcode{indexvals{[}7{]}} of the matrix.
The last entry contains the total number of nonzero values in the
matrix and hence points one past the end of the active data in the
\sphinxcode{data} and \sphinxcode{indexvals} arrays. For CSR matrices, each entry
provides the index of the first row entry into the \sphinxcode{data} and
\sphinxcode{indexvals} arrays.

\end{itemize}

The following pointers are added to the SUNMATRIX\_SPARSE content
structure for user convenience, to provide a more intuitive interface
to the CSC and CSR sparse matrix data structures. They are set
automatically when creating a sparse \sphinxcode{SUNMatrix}, based on the
sparse matrix storage type.
\begin{itemize}
\item {} 
\sphinxcode{rowvals} - pointer to \sphinxcode{indexvals} when \sphinxcode{sparsetype} is
\sphinxcode{CSC\_MAT}, otherwise set to \sphinxcode{NULL}.

\item {} 
\sphinxcode{colptrs} - pointer to \sphinxcode{indexptrs} when \sphinxcode{sparsetype} is
\sphinxcode{CSC\_MAT}, otherwise set to \sphinxcode{NULL}.

\item {} 
\sphinxcode{colvals} - pointer to \sphinxcode{indexvals} when \sphinxcode{sparsetype} is
\sphinxcode{CSR\_MAT}, otherwise set to \sphinxcode{NULL}.

\item {} 
\sphinxcode{rowptrs} - pointer to \sphinxcode{indexptrs} when \sphinxcode{sparsetype} is
\sphinxcode{CSR\_MAT}, otherwise set to \sphinxcode{NULL}.

\end{itemize}

For example, the \(5\times 4\) matrix
\begin{equation*}
\begin{split}\left[\begin{array}{cccc}
  0 & 3 & 1 & 0\\
  3 & 0 & 0 & 2\\
  0 & 7 & 0 & 0\\
  1 & 0 & 0 & 9\\
  0 & 0 & 0 & 5
\end{array}\right]\end{split}
\end{equation*}
could be stored as a CSC matrix in this structure as either

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{NNZ} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{n}{NP} \PYG{o}{=} \PYG{n}{N}\PYG{p}{;}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{sparsetype} \PYG{o}{=} \PYG{n}{CSC\PYGZus{}MAT}\PYG{p}{;}
\PYG{n}{indexvals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{indexptrs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

or

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{NNZ} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n}{NP} \PYG{o}{=} \PYG{n}{N}\PYG{p}{;}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{o}{*}\PYG{p}{,} \PYG{o}{*}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{sparsetype} \PYG{o}{=} \PYG{n}{CSC\PYGZus{}MAT}\PYG{p}{;}
\PYG{n}{indexvals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{*}\PYG{p}{,} \PYG{o}{*}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{indexptrs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

where the first has no unused space, and the second has additional
storage (the entries marked with \sphinxcode{*} may contain any values).
Note in both cases that the final value in \sphinxcode{indexptrs} is 8,
indicating the total number of nonzero entries in the matrix.

Similarly, in CSR format, the same matrix could be stored as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{NNZ} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{n}{NP} \PYG{o}{=} \PYG{n}{M}\PYG{p}{;}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{sparsetype} \PYG{o}{=} \PYG{n}{CSR\PYGZus{}MAT}\PYG{p}{;}
\PYG{n}{indexvals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{indexptrs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{cscmat1}.png}
\caption{Diagram of the storage for a compressed-sparse-column matrix of
type SUNMATRIX\_SPARSE: Here \sphinxcode{A} is an \(M \times N\) sparse
CSC matrix with storage for up to \sphinxcode{NNZ} nonzero entries (the
allocated length of both \sphinxcode{data} and \sphinxcode{indexvals}).  The entries
in \sphinxcode{indexvals} may assume values from \sphinxcode{0} to \sphinxcode{M-1},
corresponding to the row index (zero-based) of
each nonzero value.  The entries in \sphinxcode{data} contain the values of
the nonzero entries, with the row \sphinxcode{i}, column \sphinxcode{j} entry of
\sphinxcode{A} (again, zero-based) denoted as \sphinxcode{A(i,j)}.  The \sphinxcode{indexptrs}
array contains \sphinxcode{N+1} entries; the first \sphinxcode{N} denote the starting
index of each column within the \sphinxcode{indexvals} and \sphinxcode{data} arrays,
while the final entry points one past the final nonzero entry.
Here, although \sphinxcode{NNZ} values are allocated, only \sphinxcode{nz} are
actually filled in; the greyed-out portions of \sphinxcode{data} and
\sphinxcode{indexvals} indicate extra allocated space.}\label{\detokenize{sunmatrix/SUNMatrix_Sparse:sunsparsematrix}}\label{\detokenize{sunmatrix/SUNMatrix_Sparse:id1}}\end{figure}

The header file to be included when using this module is
\sphinxcode{sunmatrix/sunmatrix\_sparse.h}.

The following macros are provided to access the content of a
SUNMATRIX\_SPARSE matrix. The prefix \sphinxcode{SM\_} in the names
denotes that these macros are for \sphinxstyleemphasis{SUNMatrix} implementations,
and the suffix \sphinxcode{\_S} denotes that these are specific to
the \sphinxstyleemphasis{sparse} version.
\index{SM\_CONTENT\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_CONTENT_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_CONTENT\_S}}{A}{}
This macro gives access to the contents of the sparse \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

The assignment \sphinxcode{A\_cont = SM\_CONTENT\_S(A)} sets
\sphinxcode{A\_cont} to be a pointer to the sparse \sphinxcode{SUNMatrix} content
structure.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}CONTENT\PYGZus{}S(A)   ( (SUNMatrixContent\PYGZus{}Sparse)(A\PYGZhy{}\PYGZgt{}content) )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_ROWS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_ROWS_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_ROWS\_S}}{A}{}
Access the number of rows in the sparse \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \sphinxcode{A\_rows = SM\_ROWS\_S(A)} sets \sphinxcode{A\_rows}
to be the number of rows in the matrix \sphinxstyleemphasis{A}.  Similarly, the
assignment \sphinxcode{SM\_ROWS\_S(A) = A\_rows} sets the number of
columns in \sphinxstyleemphasis{A} to equal \sphinxcode{A\_rows}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ROWS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}M )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_COLUMNS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_COLUMNS_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_COLUMNS\_S}}{A}{}
Access the number of columns in the sparse \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As
with \sphinxcode{SM\_ROWS\_S}, this may be used either to retrieve or to set
the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMNS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}N )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_NNZ\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_NNZ_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_NNZ\_S}}{A}{}
Access the allocated number of nonzeros in the sparse \sphinxcode{SUNMatrix}
\sphinxstyleemphasis{A}.  As with \sphinxcode{SM\_ROWS\_S}, this may be used either to retrieve or
to set the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}NNZ\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}NNZ )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_NP\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_NP_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_NP\_S}}{A}{}
Access the number of index pointers \sphinxcode{NP} in the sparse
\sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  As with \sphinxcode{SM\_ROWS\_S}, this may be used either
to retrieve or to set the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}NP\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}NP )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_SPARSETYPE\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_SPARSETYPE_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_SPARSETYPE\_S}}{A}{}
Access the sparsity type parameter in the sparse \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.
As with \sphinxcode{SM\_ROWS\_S}, this may be used either to retrieve or to
set the value.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}SPARSETYPE\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}sparsetype )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_DATA\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_DATA_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_DATA\_S}}{A}{}
This macro gives access to the \sphinxcode{data} pointer for the matrix
entries.

The assignment \sphinxcode{A\_data = SM\_DATA\_S(A)} sets \sphinxcode{A\_data} to be
a pointer to the first component of the data array for the sparse
\sphinxcode{SUNMatrix A}.  The assignment \sphinxcode{SM\_DATA\_S(A) = A\_data}
sets the data array of \sphinxstyleemphasis{A} to be \sphinxcode{A\_data} by storing the
pointer \sphinxcode{A\_data}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}DATA\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}data )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_INDEXVALS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_INDEXVALS_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_INDEXVALS\_S}}{A}{}
This macro gives access to the \sphinxcode{indexvals} pointer for the matrix
entries.

The assignment \sphinxcode{A\_indexvals = SM\_INDEXVALS\_S(A)}
sets \sphinxcode{A\_indexvals} to be a pointer to the array of index values
(i.e. row indices for a CSC matrix, or column indices for a CSR
matrix) for the sparse \sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}INDEXVALS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}indexvals )}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SM\_INDEXPTRS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SM_INDEXPTRS_S}}\pysiglinewithargsret{\sphinxbfcode{SM\_INDEXPTRS\_S}}{A}{}
This macro gives access to the \sphinxcode{indexptrs} pointer for the matrix entries.

The assignment \sphinxcode{A\_indexptrs = SM\_INDEXPTRS\_S(A)}
sets \sphinxcode{A\_indexptrs} to be a pointer to the array of index
pointers (i.e. the starting indices in the data/indexvals arrays for
each row or column in CSR or CSC formats, respectively).

Implementation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}INDEXPTRS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}indexptrs )}
\end{sphinxVerbatim}

\end{fulllineitems}


The SUNMATRIX\_SPARSE module defines sparse implementations of all matrix
operations listed in the section {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNMATRIX operations}}}}. Their names are
obtained from those in that section by appending the suffix \sphinxcode{\_Sparse}
(e.g. \sphinxcode{SUNMatCopy\_Sparse}).  The module SUNMATRIX\_SPARSE provides the
following additional user-callable routines:
\index{SUNSparseMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNSparseMatrix}}{sunindextype\sphinxstyleemphasis{ M}, sunindextype\sphinxstyleemphasis{ N}, sunindextype\sphinxstyleemphasis{ NNZ}, int\sphinxstyleemphasis{ sparsetype}}{}
This constructor function creates and allocates memory for a sparse
\sphinxcode{SUNMatrix}.  Its arguments are the number of rows and columns of
the matrix, \sphinxstyleemphasis{M} and \sphinxstyleemphasis{N}, the maximum number of nonzeros to be
stored in the matrix, \sphinxstyleemphasis{NNZ}, and a flag \sphinxstyleemphasis{sparsetype} indicating
whether to use CSR or CSC format (valid choices are \sphinxcode{CSR\_MAT} or
\sphinxcode{CSC\_MAT}).

\end{fulllineitems}

\index{SUNSparseFromDenseMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseFromDenseMatrix}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNSparseFromDenseMatrix}}{SUNMatrix\sphinxstyleemphasis{ A}, realtype\sphinxstyleemphasis{ droptol}, int\sphinxstyleemphasis{ sparsetype}}{}
This constructor function creates a new sparse matrix from an
existing SUNMATRIX\_DENSE object by copying all values with
magnitude larger than \sphinxstyleemphasis{droptol} into the sparse matrix structure.

Requirements:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{A} must have type \sphinxcode{SUNMATRIX\_DENSE}

\item {} 
\sphinxstyleemphasis{droptol} must be non-negative

\item {} 
\sphinxstyleemphasis{sparsetype} must be either \sphinxcode{CSC\_MAT} or \sphinxcode{CSR\_MAT}

\end{itemize}

The function returns \sphinxcode{NULL} if any requirements are violated, or if
the matrix storage request cannot be satisfied.

\end{fulllineitems}

\index{SUNSparseFromBandMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseFromBandMatrix}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNSparseFromBandMatrix}}{SUNMatrix\sphinxstyleemphasis{ A}, realtype\sphinxstyleemphasis{ droptol}, int\sphinxstyleemphasis{ sparsetype}}{}
This constructor function creates a new sparse matrix from an
existing SUNMATRIX\_BAND object by copying all values with
magnitude larger than \sphinxstyleemphasis{droptol} into the sparse matrix structure.

Requirements:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{A} must have type \sphinxcode{SUNMATRIX\_BAND}

\item {} 
\sphinxstyleemphasis{droptol} must be non-negative

\item {} 
\sphinxstyleemphasis{sparsetype} must be either \sphinxcode{CSC\_MAT} or \sphinxcode{CSR\_MAT}.

\end{itemize}

The function returns \sphinxcode{NULL} if any requirements are violated, or if
the matrix storage request cannot be satisfied.

\end{fulllineitems}

\index{SUNSparseMatrix\_Realloc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Realloc}}\pysiglinewithargsret{int \sphinxbfcode{SUNSparseMatrix\_Realloc}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function reallocates internal storage arrays in a sparse matrix
so that the resulting sparse matrix has no wasted space (i.e. the
space allocated for nonzero entries equals the actual number of
nonzeros, \sphinxcode{indexptrs{[}NP{]}}). Returns 0 on success and
1 on failure (e.g. if the input matrix is not sparse).

\end{fulllineitems}

\index{SUNSparseMatrix\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Print}}\pysiglinewithargsret{void \sphinxbfcode{SUNSparseMatrix\_Print}}{SUNMatrix\sphinxstyleemphasis{ A}, FILE*\sphinxstyleemphasis{ outfile}}{}
This function prints the content of a sparse \sphinxcode{SUNMatrix} to the
output stream specified by \sphinxcode{outfile}.  Note: \sphinxcode{stdout}
or \sphinxcode{stderr} may be used as arguments for \sphinxcode{outfile} to print
directly to standard output or standard error, respectively.

\end{fulllineitems}

\index{SUNSparseMatrix\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Rows}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNSparseMatrix\_Rows}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of rows in the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Columns}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNSparseMatrix\_Columns}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of columns in the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_NNZ (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNSparseMatrix\_NNZ}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of entries allocated for nonzero
storage for the sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_NP (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NP}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNSparseMatrix\_NP}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the number of index pointers for the
sparse \sphinxcode{SUNMatrix} (the \sphinxcode{indexptrs} array has \sphinxcode{NP+1}
entries).

\end{fulllineitems}

\index{SUNSparseMatrix\_SparseType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_SparseType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSparseMatrix\_SparseType}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the storage type (\sphinxcode{CSR\_MAT}
or \sphinxcode{CSC\_MAT}) for the sparse  \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Data}}\pysiglinewithargsret{realtype* \sphinxbfcode{SUNSparseMatrix\_Data}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the data array for the
sparse \sphinxcode{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_IndexValues (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_IndexValues}}\pysiglinewithargsret{sunindextype* \sphinxbfcode{SUNSparseMatrix\_IndexValues}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to index value array for the sparse
\sphinxcode{SUNMatrix}: for CSR format this is the column index for each nonzero
entry, for CSC format this is the row index for each nonzero entry.

\end{fulllineitems}

\index{SUNSparseMatrix\_IndexPointers (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_IndexPointers}}\pysiglinewithargsret{sunindextype* \sphinxbfcode{SUNSparseMatrix\_IndexPointers}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns a pointer to the index pointer array for the
sparse \sphinxcode{SUNMatrix}: for CSR format this is the location of the first
entry of each row in the \sphinxcode{data} and \sphinxcode{indexvalues} arrays, for
CSC format this is the location of the first entry of each column.

\end{fulllineitems}


\begin{sphinxadmonition}{note}{Note:}
Within the \sphinxcode{SUNMatMatvec\_Sparse} routine, internal
consistency checks are performed to ensure that the matrix
is called with consistent \sphinxcode{N\_Vector} implementations.
These are currently limited to: NVECTOR\_SERIAL,
NVECTOR\_OPENMP, NVECTOR\_PTHREADS, and NVECTOR\_CUDA when using
managed memory. As additional compatible vector implementations
are added to SUNDIALS, these will be included within this
compatibility check.
\end{sphinxadmonition}

For solvers that include a Fortran interface module, the SUNMATRIX\_SPARSE
module also includes the Fortran-callable function
{\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMatInit}]{\sphinxcrossref{\sphinxcode{FSUNSparseMatInit()}}}} to initialize this SUNMATRIX\_SPARSE module
for a given SUNDIALS solver.
\index{FSUNSparseMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMatInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSparseMatInit}}{\emph{CODE}, \emph{M}, \emph{N}, \emph{NNZ}, \emph{SPARSETYPE}, \emph{IER}}{}
Initializes a sparse \sphinxcode{SUNMatrix} structure for use in a SUNDIALS solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{M} (\sphinxcode{long int}, input) \textendash{} number of matrix rows.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{long int}, input) \textendash{} number of matrix columns.

\item {} 
\sphinxstyleemphasis{NNZ} (\sphinxcode{long int}, input) \textendash{} amount of nonzero storage to allocate.

\item {} 
\sphinxstyleemphasis{SPARSETYPE} (\sphinxcode{int}, input) \textendash{} matrix sparsity type
(\sphinxcode{CSC\_MAT} or \sphinxcode{CSR\_MAT})

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMassMatInit}]{\sphinxcrossref{\sphinxcode{FSUNSparseMassMatInit()}}}} initializes
this SUNMATRIX\_SPARSE module for storing the mass matrix.
\index{FSUNSparseMassMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMassMatInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSparseMassMatInit}}{\emph{M}, \emph{N}, \emph{NNZ}, \emph{SPARSETYPE}, \emph{IER}}{}
Initializes a sparse \sphinxcode{SUNMatrix} structure for use as a mass
matrix in ARKode.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{M} (\sphinxcode{long int}, input) \textendash{} number of matrix rows.

\item {} 
\sphinxstyleemphasis{N} (\sphinxcode{long int}, input) \textendash{} number of matrix columns.

\item {} 
\sphinxstyleemphasis{NNZ} (\sphinxcode{long int}, input) \textendash{} amount of nonzero storage to allocate.

\item {} 
\sphinxstyleemphasis{SPARSETYPE} (\sphinxcode{int}, input) \textendash{} matrix sparsity type
(\sphinxcode{CSC\_MAT} or \sphinxcode{CSR\_MAT})

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNMATRIX\_SLUNRLOC Module}
\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:sunmatrix-slunrloc}}\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc::doc}}\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:the-sunmatrix-slunrloc-module}}
The SUNMATRIX\_SLUNRLOC implementation of the SUNMatrix module provided
with SUNDIALS is an adapter for the \sphinxcode{SuperMatrix} structure provided by
the SuperLU\_DIST sparse matrix factorization and solver library written
by X. Sherry Li (\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:id1}}{\hyperref[\detokenize{References:superludist}]{\sphinxcrossref{{[}SuperLUDIST{]}}}}, \phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:id2}}{\hyperref[\detokenize{References:gdl2007}]{\sphinxcrossref{{[}GDL2007{]}}}}, \phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:id3}}{\hyperref[\detokenize{References:ld2003}]{\sphinxcrossref{{[}LD2003{]}}}}, \phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:id4}}{\hyperref[\detokenize{References:sluug1999}]{\sphinxcrossref{{[}SLUUG1999{]}}}}).
It is designed to be used with the SuperLU\_DIST \sphinxcode{SUNLinearSolver}
discussed in Section {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:sunlinsol-superludist}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinSol\_SuperLUDIST Module}}}}. To this end, it defines
the \sphinxcode{content} field of \sphinxcode{SUNMatrix} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}SLUNRloc} \PYG{p}{\PYGZob{}}
  \PYG{n}{booleantype}   \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{gridinfo\PYGZus{}t}    \PYG{o}{*}\PYG{n}{grid}\PYG{p}{;}
  \PYG{n}{sunindextype}  \PYG{o}{*}\PYG{n}{row\PYGZus{}to\PYGZus{}proc}\PYG{p}{;}
  \PYG{n}{pdgsmv\PYGZus{}comm\PYGZus{}t} \PYG{o}{*}\PYG{n}{gsmv\PYGZus{}comm}\PYG{p}{;}
  \PYG{n}{SuperMatrix}   \PYG{o}{*}\PYG{n}{A\PYGZus{}super}\PYG{p}{;}
  \PYG{n}{SuperMatrix}   \PYG{o}{*}\PYG{n}{ACS\PYGZus{}super}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

A more complete description of the this \sphinxcode{content} field is given below:
\begin{itemize}
\item {} 
\sphinxcode{own\_data} \textendash{} a flag which indicates if the SUNMatrix is responsible for freeing
\sphinxcode{A\_super}

\item {} 
\sphinxcode{grid} \textendash{} pointer to the SuperLU\_DIST structure that stores the 2D process grid

\item {} 
\sphinxcode{row\_to\_proc} \textendash{} a mapping between the rows in the matrix and the process it
resides on; will be \sphinxcode{NULL} until the \sphinxcode{SUNMatMatvecSetup} routine is called

\item {} 
\sphinxcode{gsmv\_comm} \textendash{} pointer to the SuperLU\_DIST structure that stores the
communication information needed for matrix-vector multiplication; will be
\sphinxcode{NULL} until the \sphinxcode{SUNMatMatvecSetup} routine is called

\item {} 
\sphinxcode{A\_super} \textendash{} pointer to the underlying SuperLU\_DIST \sphinxcode{SuperMatrix} with
\sphinxcode{Stype = SLU\_NR\_loc}, \sphinxcode{Dtype = SLU\_D}, \sphinxcode{Mtype = SLU\_GE}; must have the
full diagonal present to be used with \sphinxcode{SUNMatScaleAddI} routine

\item {} 
\sphinxcode{ACS\_super} \textendash{} a column-sorted version of the matrix needed to perform matrix-vector
multiplication; will be \sphinxcode{NULL} until the routine \sphinxcode{SUNMatMatvecSetup}
routine is called

\end{itemize}

The header file to include when using this module is \sphinxcode{sunmatrix/sunmatrix\_slunrloc.h}.
The installed module library to link to is \sphinxcode{libsundials\_sunmatrixslunrloc} \sphinxstyleemphasis{.lib}
where \sphinxstyleemphasis{.lib} is typically \sphinxcode{.so} for shared libraries and \sphinxcode{.a} for static libraries.


\subsection{SUNMATRIX\_SLUNRLOC Functions}
\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:id5}}\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:sunmatrix-slunrloc-functions}}
The SUNMATRIX\_SLUNRLOC module provides the following user-callable routines:
\index{SUNMatrix\_SLUNRloc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:c.SUNMatrix_SLUNRloc}}\pysiglinewithargsret{SUNMatrix \sphinxbfcode{SUNMatrix\_SLUNRloc}}{SuperMatrix\sphinxstyleemphasis{ *Asuper}, gridinfo\_t\sphinxstyleemphasis{ *grid}}{}
This constructor function creates and allocates memory for a SUNMatrix\_SLUNRloc
object. Its arguments are a fully-allocated SuperLU\_DIST \sphinxcode{SuperMatrix} with
\sphinxcode{Stype = SLU\_NR\_loc, Dtype = SLU\_D, Mtype = SLU\_GE} and an initialized SuperLU\_DIST
2D process grid structure. It returns a SUNMatrix object if \sphinxcode{Asuper} is compatible
else it returns \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNMatrix\_SLUNRloc\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:c.SUNMatrix_SLUNRloc_Print}}\pysiglinewithargsret{void \sphinxbfcode{SUNMatrix\_SLUNRloc\_Print}}{SUNMatrix\sphinxstyleemphasis{ A}, FILE\sphinxstyleemphasis{ *fp}}{}
This function prints the underlying \sphinxcode{SuperMatrix} content. It is useful for
debugging. Its arguments are the \sphinxcode{SUNMatrix} object and a \sphinxcode{FILE} pointer
to print to. It returns void.

\end{fulllineitems}

\index{SUNMatrix\_SLUNRloc\_SuperMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:c.SUNMatrix_SLUNRloc_SuperMatrix}}\pysiglinewithargsret{SuperMatrix* \sphinxbfcode{SUNMatrix\_SLUNRloc\_SuperMatrix}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the underlying \sphinxcode{SuperMatrix} of \sphinxcode{A}. Its
only argument is the \sphinxcode{SUNMatrix} object to access.

\end{fulllineitems}

\index{SUNMatrix\_SLUNRloc\_ProcessGrid (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:c.SUNMatrix_SLUNRloc_ProcessGrid}}\pysiglinewithargsret{gridinfo\_t* \sphinxbfcode{SUNMatrix\_SLUNRloc\_ProcessGrid}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns the SuperLU\_DIST 2D process grid associated with
\sphinxcode{A}. Its only argument is the \sphinxcode{SUNMatrix} object to access.

\end{fulllineitems}

\index{SUNMatrix\_SLUNRloc\_OwnData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmatrix/SUNMatrix_SLUNRloc:c.SUNMatrix_SLUNRloc_OwnData}}\pysiglinewithargsret{booleantype \sphinxbfcode{SUNMatrix\_SLUNRloc\_OwnData}}{SUNMatrix\sphinxstyleemphasis{ A}}{}
This function returns true if the \sphinxcode{SUNMatrix} object is responsible
for freeing the underlying \sphinxcode{SuperMatrix}, otherwise it returns false.
Its only argument is the \sphinxcode{SUNMatrix} object to access.

\end{fulllineitems}


The SUNMATRIX\_SLUNRLOC module also defines implementations of all generic
\sphinxcode{SUNMatrix} operations listed in Table {\hyperref[\detokenize{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNMATRIX operations}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNMatGetID\_SLUNRloc} \textendash{} returns \sphinxcode{SUNMATRIX\_SLUNRLOC}

\item {} 
\sphinxcode{SUNMatClone\_SLUNRloc}

\item {} 
\sphinxcode{SUNMatDestroy\_SLUNRloc}

\item {} 
\sphinxcode{SUNMatSpace\_SLUNRloc} \textendash{} this only returns information for the storage within
the matrix interface, i.e. storage for \sphinxcode{row\_to\_proc}

\item {} 
\sphinxcode{SUNMatZero\_SLUNRloc}

\item {} 
\sphinxcode{SUNMatCopy\_SLUNRloc}

\item {} 
\sphinxcode{SUNMatScaleAdd\_SLUNRloc} \textendash{} performs \(A = cA + B\), where \(A\) and \(B\)
must have the same sparsity pattern

\item {} 
\sphinxcode{SUNMatScaleAddI\_SLUNRloc} \textendash{} performs \(A = cA + I\), where the diagonal of \(A\)
must be present

\item {} 
\sphinxcode{SUNMatMatvecSetup\_SLUNRloc} \textendash{} initializes the SuperLU\_DIST parallel communication
structures needed to perform a matrix-vector product; only needs to be called before
the first call to \sphinxcode{SUNMatMatvec} or if the matrix changed since the last setup

\item {} 
\sphinxcode{SUNMatMatvec\_SLUNRloc}

\end{itemize}


\section{SUNMATRIX Examples}
\label{\detokenize{sunmatrix/SUNMatrix_Examples::doc}}\label{\detokenize{sunmatrix/SUNMatrix_Examples:sunmatrix-examples}}\label{\detokenize{sunmatrix/SUNMatrix_Examples:id1}}
There are \sphinxcode{SUNMatrix} examples that may be installed for each
implementation: dense, banded, and sparse.  Each implementation
makes use of the functions in \sphinxcode{test\_sunmatrix.c}.
These example functions show simple usage of the \sphinxcode{SUNMatrix} family
of functions.  The inputs to the examples depend on the matrix type,
and are output to \sphinxcode{stdout} if the example is run without the
appropriate number of command-line arguments.

The following is a list of the example functions in \sphinxcode{test\_sunmatrix.c}:
\begin{itemize}
\item {} 
\sphinxcode{Test\_SUNMatGetID}: Verifies the returned matrix ID against
the value that should be returned.

\item {} 
\sphinxcode{Test\_SUNMatClone}: Creates clone of an existing matrix,
copies the data, and checks that their values match.

\item {} 
\sphinxcode{Test\_SUNMatZero}: Zeros out an existing matrix and checks
that each entry equals 0.0.

\item {} 
\sphinxcode{Test\_SUNMatCopy}: Clones an input matrix, copies its data
to a clone, and verifies that all values match.

\item {} 
\sphinxcode{Test\_SUNMatScaleAdd}: Given an input matrix \(A\) and an
input identity matrix \(I\), this test clones and copies
\(A\) to a new matrix \(B\), computes \(B = -B+B\), and
verifies that the resulting matrix entries equal 0.  Additionally,
if the matrix is square, this test clones and copies \(A\) to a
new matrix \(D\), clones and copies \(I\) to a new matrix
\(C\), computes \(D = D+I\) and \(C = C+A\) using
\sphinxcode{SUNMatScaleAdd}, and then verifies that \(C=D\).

\item {} 
\sphinxcode{Test\_SUNMatScaleAddI}: Given an input matrix \(A\) and an
input identity matrix \(I\), this clones and copies \(I\) to
a new matrix \(B\), computes \(B = -B+I\) using
\sphinxcode{SUNMatScaleAddI}, and verifies that the resulting matrix entries
equal 0.

\item {} 
\sphinxcode{Test\_SUNMatMatvec} Given an input matrix \(A\) and input
vectors \(x\) and \(y\) such that \(y=Ax\), this test
has different behavior depending on whether \(A\) is square.  If
it is square, it clones and copies \(A\) to a new matrix
\(B\), computes \(B = 3B+I\) using \sphinxcode{SUNMatScaleAddI},
clones \(y\) to new vectors \(w\) and \(z\), computes
\(z = Bx\) using \sphinxcode{SUNMatMatvec}, computes \(w = 3y+x\)
using \sphinxcode{N\_VLinearSum}, and verifies that \(w==z\).  If
\(A\) is not square, it just clones \(y\) to a new vector
\(z\), \sphinxtitleref{computes :math:{}`z=Ax} using \sphinxcode{SUNMatMatvec}, and
verifies that \(y=z\).

\item {} 
\sphinxcode{Test\_SUNMatSpace}: verifies that \sphinxcode{SUNMatSpace} can be
called, and outputs the results to \sphinxcode{stdout}.

\end{itemize}


\section{SUNMATRIX functions required by ARKode}
\label{\detokenize{sunmatrix/ARKode_requirements:sunmatrix-functions-required-by-arkode}}\label{\detokenize{sunmatrix/ARKode_requirements::doc}}\label{\detokenize{sunmatrix/ARKode_requirements:sunmatrix-arkode}}
In Table {\hyperref[\detokenize{sunmatrix/ARKode_requirements:sunmatrix-arkode-use}]{\sphinxcrossref{\DUrole{std,std-ref}{List of matrix functions usage by ARKode code modules}}}}, we list the matrix functions in
the \sphinxcode{SUNMatrix} module used within the ARKode package.  The table
also shows, for each function, which of the code modules uses the
function.  The main ARKode time step modules, ARKStep and ERKStep, do
not call any \sphinxcode{SUNMatrix} functions directly, so the table columns
are specific to the ARKLS interface and the ARKBANDPRE and ARKBBDPRE
preconditioner modules.   We further note that the ARKLS interface
only utilizes these routines when supplied with a \sphinxstyleemphasis{matrix-based}
linear solver, i.e. the \sphinxcode{SUNMatrix} object (\sphinxstyleemphasis{J} or \sphinxstyleemphasis{M}) passed to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetLinearSolver()}}}} or
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetMassLinearSolver}]{\sphinxcrossref{\sphinxcode{ARKStepSetMassLinearSolver()}}}} was not \sphinxcode{NULL}.

At this point, we should emphasize that the ARKode user does not need
to know anything about the usage of matrix functions by the ARKode
code modules in order to use ARKode.  The information is presented as
an implementation detail for the interested reader.


\subsection{List of matrix functions usage by ARKode code modules}
\label{\detokenize{sunmatrix/ARKode_requirements:list-of-matrix-functions-usage-by-arkode-code-modules}}\label{\detokenize{sunmatrix/ARKode_requirements:sunmatrix-arkode-use}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Routine
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKLS
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKBANDPRE
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKBBDPRE
\unskip}\relax \\
\hline
SUNMatGetID
&
X
&&\\
\hline
SUNMatClone
&
X
&&\\
\hline
SUNMatDestroy
&
X
&
X
&
X
\\
\hline
SUNMatZero
&
X
&
X
&
X
\\
\hline
SUNMatCopy
&
X
&
X
&
X
\\
\hline
SUNMatScaleAddI
&
X
&
X
&
X
\\
\hline
SUNMatScaleAdd
&
1
&&\\
\hline
SUNMatMatvec
&
1
&&\\
\hline
SUNMatMatvecSetup
&
1,2
&&\\
\hline
SUNMatSpace
&
2
&
2
&
2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{enumerate}
\item {} 
These matrix functions are only used for problems involving a
non-identity mass matrix.

\item {} 
These matrix functions are optionally used, in that these are only
called if they are implemented in the \sphinxcode{SUNMatrix} module that is
being used (i.e. their function pointers are non-\sphinxcode{NULL}).  If not
supplied, these modules will assume that the matrix requires no
storage.

\end{enumerate}

We note that both the ARKBANDPRE and ARKBBDPRE preconditioner modules
are hard-coded to use the SUNDIALS-supplied band \sphinxcode{SUNMatrix} type,
so the most useful information above for user-supplied \sphinxcode{SUNMatrix}
implementations is the column relating to ARKLS requirements.


\chapter{Description of the SUNLinearSolver module}
\label{\detokenize{sunlinsol/index:description-of-the-sunlinearsolver-module}}\label{\detokenize{sunlinsol/index::doc}}\label{\detokenize{sunlinsol/index:sunlinsol}}
For problems that require the solution of linear systems of equations,
the SUNDIALS packages operate using generic linear solver modules
defined through the SUNLinSol API.  This allows SUNDIALS
packages to utilize any valid SUNLinSol implementation that provides
a set of required functions.  These functions can be divided into
three categories.  The first are the core linear solver functions.  The
second group consists of “set” routines to supply the linear solver object
with functions provided by the SUNDIALS package, or for modification
of solver parameters.  The last group consists of “get” routines for
retrieving artifacts (statistics, residual vectors, etc.) from the
linear solver.  All of these functions are defined in the header file
\sphinxcode{sundials/sundials\_linearsolver.h}.

The implementations provided with SUNDIALS work in coordination
with the SUNDIALS generic \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix} modules to
provide a set of compatible data structures and solvers for the
solution of linear systems using direct or iterative (matrix-based or matrix-free)
methods. Moreover, advanced users can provide a customized
\sphinxcode{SUNLinearSolver} implementation to any SUNDIALS package,
particularly in cases where they provide their own \sphinxcode{N\_Vector} and/or
\sphinxcode{SUNMatrix} modules.

Historically, the SUNDIALS packages have been designed to specifically
leverage the use of either \sphinxstyleemphasis{direct linear solvers} or matrix-free,
\sphinxstyleemphasis{scaled, preconditioned, iterative linear solvers}.  However,
matrix-based iterative linear solvers are also supported.

The iterative linear solvers packaged with SUNDIALS leverage scaling
and preconditioning, as applicable, to balance error between solution
components and to accelerate convergence of the linear solver.  To
this end, instead of solving the linear system \(Ax = b\)
directly, these apply the underlying iterative algorithm to the
transformed system

\phantomsection\label{\detokenize{sunlinsol/index:equation-eq-transformed-linear-system}}\begin{equation}\label{equation:sunlinsol/index:eq:transformed_linear_system}
\begin{split}\tilde{A} \tilde{x} = \tilde{b}\end{split}
\end{equation}
where

\phantomsection\label{\detokenize{sunlinsol/index:equation-eq-transformed-linear-system-components}}\begin{equation}\label{equation:sunlinsol/index:eq:transformed_linear_system_components}
\begin{split}\tilde{A} &= S_1 P_1^{-1} A P_2^{-1} S_2^{-1},\\
\tilde{b} &= S_1 P_1^{-1} b,\\
\tilde{x} &= S_2 P_2 x,\end{split}
\end{equation}
and where
\begin{itemize}
\item {} 
\(P_1\) is the left preconditioner,

\item {} 
\(P_2\) is the right preconditioner,

\item {} 
\(S_1\) is a diagonal matrix of scale factors for
\(P_1^{-1} b\),

\item {} 
\(S_2\) is a diagonal matrix of scale factors for \(P_2 x\).

\end{itemize}

SUNDIALS solvers request that iterative linear solvers stop
based on the 2-norm of the scaled preconditioned residual meeting a
prescribed tolerance
\begin{equation*}
\begin{split}\left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}.\end{split}
\end{equation*}
When provided an iterative SUNLinSol implementation that does not
support the scaling matrices \(S_1\) and \(S_2\), SUNDIALS’
packages will adjust the value of \(\text{tol}\) accordingly
(see the section {\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-iterative-tolerance}]{\sphinxcrossref{\DUrole{std,std-ref}{Iterative linear solver tolerance}}}} for more details).  In
this case, they instead request that iterative linear solvers stop
based on the criteria
\begin{equation*}
\begin{split}\left\| P_1^{-1} b - P_1^{-1} A x \right\|_2  <  \text{tol}.\end{split}
\end{equation*}
We note that the corresponding adjustments to \(\text{tol}\) in
this case are non-optimal, in that they cannot balance error between
specific entries of the solution \(x\), only the aggregate error
in the overall solution vector.

We further note that not all of the SUNDIALS-provided iterative linear
solvers support the full range of the above options (e.g., separate
left/right preconditioning), and that some of the SUNDIALS packages
only utilize a subset of these options.  Further details on these
exceptions are described in the documentation for each
\sphinxcode{SUNLinearSolver} implementation, or for each SUNDIALS package.

For users interested in providing their own SUNLinSol module, the
following section presents the SUNLinSol API and its implementation
beginning with the definition of SUNLinSol functions in sections
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver core functions}}}} \textendash{} {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver get functions}}}}. This is followed by
the definition of functions supplied to a linear solver implementation in
section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS packages}}}}. The linear solver return
codes are described in section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}. The
\sphinxcode{SUNLinearSolver} type and the generic SUNLinSol module are defined
in section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlininsol-generic}]{\sphinxcrossref{\DUrole{std,std-ref}{The generic SUNLinearSolver module}}}}.  The section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-compatibility}]{\sphinxcrossref{\DUrole{std,std-ref}{Compatibility of SUNLinearSolver modules}}}} discusses compatibility between the
SUNDIALS-provided SUNLinSol modules and SUNMATRIX modules.  Section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-custom}]{\sphinxcrossref{\DUrole{std,std-ref}{Implementing a custom SUNLinearSolver module}}}} lists the requirements for supplying a
custom SUNLinSol module and discusses some intended use cases. Users wishing to
supply their own SUNLinSol module are encouraged to use the SUNLinSol
implementations provided with SUNDIALS as a template for supplying custom
linear solver modules. The SUNLinSol functions required by this SUNDIALS
package as well as other package specific details are given in
section {\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNLinearSolver interface}}}}. The remaining sections of this chapter
present the SUNLinSol modules provided with SUNDIALS.


\section{The SUNLinearSolver API}
\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}}\label{\detokenize{sunlinsol/SUNLinSol_API::doc}}\label{\detokenize{sunlinsol/SUNLinSol_API:the-sunlinearsolver-api}}
The SUNLinSol API defines several linear solver operations that enable
SUNDIALS packages to utilize any SUNLinSol implementation that
provides the required functions. These functions can be divided into
three categories. The first are the core linear solver functions. The
second group of functions consists of set routines to supply the
linear solver with functions provided by the SUNDIALS time integrators
and to modify solver parameters. The final group consists of get
routines for retrieving linear solver statistics. All of these
functions are defined in the header file
\sphinxcode{sundials/sundials\_linearsolver.h}.


\subsection{SUNLinearSolver core functions}
\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinearsolver-core-functions}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-corefn}}
The core linear solver functions consist of two required functions to get the
linear solver type ({\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolGetType}]{\sphinxcrossref{\sphinxcode{SUNLinSolGetType()}}}}) and solve the linear system
\(Ax=b\) ({\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSolve}]{\sphinxcrossref{\sphinxcode{SUNLinSolSolve()}}}}). The remaining functions are for
getting the solver ID ({\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolGetID}]{\sphinxcrossref{\sphinxcode{SUNLinSolGetID()}}}}), initializing the linear solver
object once all solver-specific options have been set
({\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolInitialize}]{\sphinxcrossref{\sphinxcode{SUNLinSolInitialize()}}}}), setting up the linear solver object to utilize
an updated matrix \(A\) ({\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetup}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetup()}}}}), and for destroying the
linear solver object ({\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolFree}]{\sphinxcrossref{\sphinxcode{SUNLinSolFree()}}}}) are optional.
\index{SUNLinSolGetType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolGetType}}\pysiglinewithargsret{SUNLinearSolver\_Type \sphinxbfcode{SUNLinSolGetType}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
Returns the type identifier for the linear solver \sphinxstyleemphasis{LS}. It is used to
determine the solver type (direct, iterative, or matrix-iterative) from
the abstract \sphinxcode{SUNLinearSolver} interface.  Returned values are
one of the following:
\begin{itemize}
\item {} 
\sphinxcode{SUNLINEARSOLVER\_DIRECT} \textendash{} \sphinxcode{0}, the SUNLinSol module
requires a matrix, and computes an ‘exact’ solution to the linear
system defined by that matrix.

\item {} 
\sphinxcode{SUNLINEARSOLVER\_ITERATIVE} \textendash{} \sphinxcode{1}, the SUNLinSol module does
not require a matrix (though one may be provided), and computes
an inexact solution to the linear system using a matrix-free
iterative algorithm. That is it solves the linear system defined
by the package-supplied \sphinxcode{ATimes} routine (see
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetATimes}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetATimes()}}}} below), even if that linear system
differs from the one encoded in the matrix object (if one is
provided). As the solver computes the solution only inexactly (or
may diverge), the linear solver should check for solution
convergence/accuracy as appropriate.

\item {} 
\sphinxcode{SUNLINEARSOLVER\_MATRIX\_ITERATIVE} \textendash{} \sphinxcode{2}, the SUNLinSol
module requires a matrix, and computes an inexact solution to the
linear system defined by that matrix using an iterative
algorithm. That is it solves the linear system defined by the
matrix object even if that linear system differs from that
encoded by the package-supplied \sphinxcode{ATimes} routine. As the solver
computes the solution only inexactly (or may diverge), the linear
solver should check for solution convergence/accuracy as
appropriate.

\end{itemize}

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{type} \PYG{o}{=} \PYG{n}{SUNLinSolGetType}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Notes: See section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-intended}]{\sphinxcrossref{\DUrole{std,std-ref}{Intended use cases}}}} for more information
on intended use cases corresponding to the linear solver type.

\end{fulllineitems}

\index{SUNLinSolGetID (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolGetID}}\pysiglinewithargsret{SUNLinearSolver\_ID \sphinxbfcode{SUNLinSolGetID}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
Returns the identifier for the linear solver \sphinxstyleemphasis{LS}. It is recommended that a
user-supplied \sphinxcode{SUNLinearSolver} implementation return the
\sphinxcode{SUNLINEARSOLVER\_CUSTOM} identifier.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{id} \PYG{o}{=} \PYG{n}{SUNLinSolGetID}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolInitialize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolInitialize}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolInitialize}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
Performs linear solver initialization (assuming that all
solver-specific options have been set).  This should return zero for a
successful call, and a negative value for a failure, ideally
returning one of the generic error codes listed in section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolInitialize}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolSetup (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetup}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetup}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Performs any linear solver setup needed, based on an updated system
\sphinxcode{SUNMatrix} \sphinxstyleemphasis{A}.  This may be called frequently (e.g., with a full
Newton method) or infrequently (for a modified Newton method), based
on the type of integrator and/or nonlinear solver requesting the
solves.  This should return zero for a successful call, a positive
value for a recoverable failure and a negative value for an
unrecoverable failure, ideally returning one of the generic error
codes listed in section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolSetup}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolSolve (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSolve}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSolve}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, SUNMatrix\sphinxstyleemphasis{ A}, N\_Vector\sphinxstyleemphasis{ x}, N\_Vector\sphinxstyleemphasis{ b}, realtype\sphinxstyleemphasis{ tol}}{}
This \sphinxstyleemphasis{required} function Solves a linear system \(Ax = b\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object.

\item {} 
\sphinxstyleemphasis{A} \textendash{} a \sphinxcode{SUNMatrix} object.

\item {} 
\sphinxstyleemphasis{x} \textendash{} a \sphinxcode{N\_Vector} object containing the initial guess for
the solution of the linear system, and the solution to the
linear system upon return.

\item {} 
\sphinxstyleemphasis{b} \textendash{} a \sphinxcode{N\_Vector} object containing the linear system
right-hand side.

\item {} 
\sphinxstyleemphasis{tol} \textendash{} the desired linear solver tolerance.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  This should return zero for a successful call, a
positive value for a recoverable failure and a negative value for
an unrecoverable failure, ideally returning one of the generic
error codes listed in section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}.

\sphinxstylestrong{Direct solvers:} can ignore the \sphinxstyleemphasis{tol} argument.

\sphinxstylestrong{Matrix-free solvers:} (those that identify as
\sphinxcode{SUNLINEARSOLVER\_ITERATIVE}) can ignore the \sphinxcode{SUNMatrix} input
\sphinxstyleemphasis{A}, and should rely on the matrix-vector product function supplied
through the routine {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetATimes}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetATimes()}}}}.

\sphinxstylestrong{Iterative solvers:} (those that identify as
\sphinxcode{SUNLINEARSOLVER\_ITERATIVE} or
\sphinxcode{SUNLINEARSOLVER\_MATRIX\_ITERATIVE}) should attempt to solve to
the specified tolerance \sphinxstyleemphasis{tol} in a weighted 2-norm. If the solver
does not support scaling then it should just use a 2-norm.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolSolve}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolFree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolFree}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolFree}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
Frees memory allocated by the linear solver.  This should return
zero for a successful call, and a negative value for a failure.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolFree}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{SUNLinearSolver set functions}
\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinearsolver-set-functions}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-setfn}}
The following set functions are used to supply linear solver modules with
functions defined by the SUNDIALS packages and to modify solver
parameters.  Only the routine for setting the matrix-vector product
routine is required, and that is only for matrix-free linear solver
modules.  Otherwise, all other set functions are optional.  SUNLinSol
implementations that do not provide the functionality for any optional
routine should leave the corresponding function pointer \sphinxcode{NULL}
instead of supplying a dummy routine.
\index{SUNLinSolSetATimes (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetATimes}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetATimes}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, void*\sphinxstyleemphasis{ A\_data}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.ATimesFn}]{\sphinxcrossref{ATimesFn}}}\sphinxstyleemphasis{ ATimes}}{}
This function is \sphinxstyleemphasis{required for matrix-free linear solvers};
otherwise it is optional.

Provides a {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.ATimesFn}]{\sphinxcrossref{\sphinxcode{ATimesFn}}}} function pointer, as well as a \sphinxcode{void*}
pointer to a data structure used by this routine, to a linear
solver object.  SUNDIALS packages will call this function to set the
matrix-vector product function to either a solver-provided
difference-quotient via vector operations or a user-supplied
solver-specific routine.  This routine should return zero for a
successful call, and a negative value for a failure, ideally
returning one of the generic error codes listed in section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolSetATimes}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{A\PYGZus{}data}\PYG{p}{,} \PYG{n}{ATimes}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolSetPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetPreconditioner}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetPreconditioner}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, void*\sphinxstyleemphasis{ P\_data}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.PSetupFn}]{\sphinxcrossref{PSetupFn}}}\sphinxstyleemphasis{ Pset}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.PSolveFn}]{\sphinxcrossref{PSolveFn}}}\sphinxstyleemphasis{ Psol}}{}
This \sphinxstyleemphasis{optional} routine provides {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.PSetupFn}]{\sphinxcrossref{\sphinxcode{PSetupFn}}}} and
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.PSolveFn}]{\sphinxcrossref{\sphinxcode{PSolveFn}}}} function pointers that implement the
preconditioner solves \(P_1^{-1}\) and \(P_2^{-1}\). This
routine will be called by a SUNDIALS package, which will provide
translation between the generic \sphinxstyleemphasis{Pset} and \sphinxstyleemphasis{Psol} calls and the
package- or user-supplied routines.
This routine should return zero for a successful call, and a
negative value for a failure, ideally returning one of the generic
error codes listed in section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolSetPreconditioner}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{Pdata}\PYG{p}{,} \PYG{n}{Pset}\PYG{p}{,} \PYG{n}{Psol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolSetScalingVectors (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetScalingVectors}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetScalingVectors}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, N\_Vector\sphinxstyleemphasis{ s1}, N\_Vector\sphinxstyleemphasis{ s2}}{}
This \sphinxstyleemphasis{optional} routine provides left/right scaling vectors for the
linear system solve.  Here, \sphinxstyleemphasis{s1} and \sphinxstyleemphasis{s2} are \sphinxcode{N\_Vectors} of positive
scale factors containing the diagonal of the matrices \(S_1\)
and \(S_2\), respectively.  Neither of these vectors need
to be tested for positivity, and a \sphinxcode{NULL} argument for either
indicates that the corresponding scaling matrix is the
identity. This routine should return zero for a successful call,
and a negative value for a failure, ideally returning one of the
generic error codes listed in section {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver return codes}}}}.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolSetScalingVectors}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{SUNLinearSolver get functions}
\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinearsolver-get-functions}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-getfn}}
The following get functions allow SUNDIALS packages to retrieve
results from a linear solve.  All routines are optional.
\index{SUNLinSolNumIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolNumIters}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolNumIters}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This \sphinxstyleemphasis{optional} routine should return the number of linear
iterations performed in the last “solve” call.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{its} \PYG{o}{=} \PYG{n}{SUNLinSolNumIters}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolResNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolResNorm}}\pysiglinewithargsret{realtype \sphinxbfcode{SUNLinSolResNorm}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This \sphinxstyleemphasis{optional} routine should return the final residual norm from
the last “solve” call.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rnorm} \PYG{o}{=} \PYG{n}{SUNLinSolResNorm}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolResid (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolResid}}\pysiglinewithargsret{N\_Vector \sphinxbfcode{SUNLinSolResid}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
If an iterative method computes the preconditioned initial residual
and returns with a successful solve without performing any
iterations (i.e., either the initial guess or the preconditioner is
sufficiently accurate), then this \sphinxstyleemphasis{optional} routine may be called
by the SUNDIALS package.  This routine should return the \sphinxcode{N\_Vector}
containing the preconditioned initial residual vector.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rvec} \PYG{o}{=} \PYG{n}{SUNLinSolResid}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note: since \sphinxcode{N\_Vector} is actually a pointer, and the results are
not modified, this routine should \sphinxstyleemphasis{not} require additional memory
allocation.  If the SUNLinSol object does not retain a vector for
this purpose, then this function pointer should be set to \sphinxcode{NULL}
in the implementation.

\end{fulllineitems}

\index{SUNLinSolLastFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolLastFlag}}\pysiglinewithargsret{sunindextype \sphinxbfcode{SUNLinSolLastFlag}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This \sphinxstyleemphasis{optional} routine should return the last error flag
encountered within the linear solver. This is not called by the
SUNDIALS packages directly; it allows the user to investigate
linear solver issues after a failed solve.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lflag} \PYG{o}{=} \PYG{n}{SUNLinLastFlag}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SUNLinSolSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSpace}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSpace}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, long int\sphinxstyleemphasis{ *lenrwLS}, long int\sphinxstyleemphasis{ *leniwLS}}{}
This \sphinxstyleemphasis{optional} routine should return the storage requirements for
the linear solver \sphinxstyleemphasis{LS}.  \sphinxstyleemphasis{lrw} is a \sphinxcode{long int} containing the
number of realtype words and \sphinxstyleemphasis{liw} is a \sphinxcode{long int} containing the
number of integer words.  The return value is an integer flag
denoting success/failure of the operation.

This function is advisory only, for use by users to help determine
their total space requirements.

Usage:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{retval} \PYG{o}{=} \PYG{n}{SUNLinSolSpace}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{lrw}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{liw}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}



\subsection{Functions provided by SUNDIALS packages}
\label{\detokenize{sunlinsol/SUNLinSol_API:functions-provided-by-sundials-packages}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-sunsuppliedfn}}
To interface with SUNLinSol modules, the SUNDIALS packages supply a
variety of routines for evaluating the matrix-vector product, and
setting up and applying the preconditioniner.  These package-provided
routines translate between the user-supplied ODE, DAE, or nonlinear
systems and the generic interfaces to the linear systems of equations
that result in their solution. The types for functions provided to a
SUNLinSol module are defined in the header file
\sphinxcode{sundials/sundials\_iterative.h}, and are described below.
\index{ATimesFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.ATimesFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*ATimesFn)}}{void\sphinxstyleemphasis{ *A\_data}, N\_Vector\sphinxstyleemphasis{ v}, N\_Vector\sphinxstyleemphasis{ z}}{}
These functions compute the action of a matrix on a vector,
performing the operation \(z = Av\).  Memory for \sphinxstyleemphasis{z} will
already be allocated prior to calling this function.  The parameter
\sphinxstyleemphasis{A\_data} is a pointer to any information about \(A\) which the
function needs in order to do its job. The vector \(v\) should
be left unchanged.  This routine should return 0 if successful and a
non-zero value if unsuccessful.

\end{fulllineitems}

\index{PSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.PSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*PSetupFn)}}{void\sphinxstyleemphasis{ *P\_data}}{}
These functions set up any requisite problem data in preparation
for calls to the corresponding {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.PSolveFn}]{\sphinxcrossref{\sphinxcode{PSolveFn}}}}. This routine
should return 0 if successful and a non-zero value if
unsuccessful.

\end{fulllineitems}

\index{PSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.PSolveFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*PSolveFn)}}{void\sphinxstyleemphasis{ *P\_data}, N\_Vector\sphinxstyleemphasis{ r}, N\_Vector\sphinxstyleemphasis{ z}, realtype\sphinxstyleemphasis{ tol}, int\sphinxstyleemphasis{ lr}}{}
These functions solve the preconditioner equation \(Pz = r\)
for the vector \(z\).  Memory for \sphinxstyleemphasis{z} will already be allocated
prior to calling this function.  The parameter \sphinxstyleemphasis{P\_data} is a
pointer to any information about \(P\) which the function needs
in order to do its job (set up by the corresponding
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.PSetupFn}]{\sphinxcrossref{\sphinxcode{PSetupFn}}}}). The parameter \sphinxstyleemphasis{lr} is input, and indicates
whether \(P\) is to be taken as the left or right
preconditioner: \sphinxstyleemphasis{lr} = 1 for left and \sphinxstyleemphasis{lr} = 2 for right.  If
preconditioning is on one side only, \sphinxstyleemphasis{lr} can be ignored.  If the
preconditioner is iterative, then it should strive to solve the
preconditioner equation so that
\begin{equation*}
\begin{split}\| Pz - r \|_{\text{wrms}} < tol\end{split}
\end{equation*}
where the error weight vector for the WRMS norm may be accessed
from the main package memory structure.  The vector \sphinxstyleemphasis{r} should not
be modified by the \sphinxstyleemphasis{PSolveFn}.  This routine should return 0 if
successful and a non-zero value if unsuccessful.  On a failure, a
negative return value indicates an unrecoverable condition, while a
positive value indicates a recoverable one, in which the calling
routine may reattempt the solution after updating preconditioner
data.

\end{fulllineitems}



\subsection{SUNLinearSolver return codes}
\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-errorcodes}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinearsolver-return-codes}}
The functions provided to SUNLinSol modules by each SUNDIALS package,
and functions within the SUNDIALS-provided SUNLinSol implementations
utilize a common set of return codes, listed below.  These adhere to a
common pattern: 0 indicates success, a postitive value corresponds to
a recoverable failure, and a negative value indicates a
non-recoverable failure.  Aside from this pattern, the actual values
of each error code are primarily to provide additional information to
the user in case of a linear solver failure.
\begin{itemize}
\item {} 
\sphinxcode{SUNLS\_SUCCESS} (0) \textendash{} successful call or converged solve

\item {} 
\sphinxcode{SUNLS\_MEM\_NULL} (-801) \textendash{} the memory argument to the function is \sphinxcode{NULL}

\item {} 
\sphinxcode{SUNLS\_ILL\_INPUT} (-802) \textendash{} an illegal input has been provided to the function

\item {} 
\sphinxcode{SUNLS\_MEM\_FAIL} (-803) \textendash{} failed memory access or allocation

\item {} 
\sphinxcode{SUNLS\_ATIMES\_NULL} (-804) \textendash{} the Atimes function is \sphinxcode{NULL}

\item {} 
\sphinxcode{SUNLS\_ATIMES\_FAIL\_UNREC} (-805) \textendash{} an unrecoverable failure occurred in the \sphinxcode{ATimes} routine

\item {} 
\sphinxcode{SUNLS\_PSET\_FAIL\_UNREC} (-806) \textendash{} an unrecoverable failure occurred in the \sphinxcode{Pset} routine

\item {} 
\sphinxcode{SUNLS\_PSOLVE\_NULL} (-807) \textendash{} the preconditioner solve function is \sphinxcode{NULL}

\item {} 
\sphinxcode{SUNLS\_PSOLVE\_FAIL\_UNREC} (-808) \textendash{} an unrecoverable failure occurred in the \sphinxcode{Psolve} routine

\item {} 
\sphinxcode{SUNLS\_PACKAGE\_FAIL\_UNREC} (-809) \textendash{} an unrecoverable failure occurred in an external linear solver package

\item {} 
\sphinxcode{SUNLS\_GS\_FAIL} (-810) \textendash{} a failure occurred during Gram-Schmidt orthogonalization (SPGMR/SPFGMR)

\item {} 
\sphinxcode{SUNLS\_QRSOL\_FAIL} (-811) \textendash{} a singular \$R\$ matrix was encountered in a QR factorization (SPGMR/SPFGMR)

\item {} 
\sphinxcode{SUNLS\_VECTOROP\_ERR} (-812) \textendash{} a vector operation error occurred

\item {} 
\sphinxcode{SUNLS\_RES\_REDUCED} (801) \textendash{} an iterative solver reduced the residual, but did not converge to the desired tolerance

\item {} 
\sphinxcode{SUNLS\_CONV\_FAIL} (802) \textendash{} an iterative solver did not converge (80and the residual was not reduced)

\item {} 
\sphinxcode{SUNLS\_ATIMES\_FAIL\_REC} (803) \textendash{} a recoverable failure occurred in the \sphinxcode{ATimes} routine

\item {} 
\sphinxcode{SUNLS\_PSET\_FAIL\_REC} (804) \textendash{} a recoverable failure occurred in the \sphinxcode{Pset} routine

\item {} 
\sphinxcode{SUNLS\_PSOLVE\_FAIL\_REC} (805) \textendash{} a recoverable failure occurred in the \sphinxcode{Psolve} routine

\item {} 
\sphinxcode{SUNLS\_PACKAGE\_FAIL\_REC} (806) \textendash{} a recoverable failure occurred in an external linear solver package

\item {} 
\sphinxcode{SUNLS\_QRFACT\_FAIL} (807) \textendash{} a singular matrix was encountered during a QR factorization (SPGMR/SPFGMR)

\item {} 
\sphinxcode{SUNLS\_LUFACT\_FAIL} (808) \textendash{} a singular matrix was encountered during a LU factorization

\end{itemize}


\subsection{The generic SUNLinearSolver module}
\label{\detokenize{sunlinsol/SUNLinSol_API:the-generic-sunlinearsolver-module}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlininsol-generic}}
SUNDIALS packages interact with specific SUNLinSol implementations
through the generic SUNLinSol module on which all other SUNLinSol
iplementations are built.  The \sphinxcode{SUNLinearSolver} type is a pointer
to a structure containing an implementation-dependent \sphinxstyleemphasis{content} field,
and an \sphinxstyleemphasis{ops} field.  The type \sphinxcode{SUNLinearSolver} is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver} \PYG{o}{*}\PYG{n}{SUNLinearSolver}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
  \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

where the \sphinxcode{\_generic\_SUNLinearSolver\_Ops} structure is a list of
pointers to the various actual linear solver operations provided by a
specific implementation.  The \sphinxcode{\_generic\_SUNLinearSolver\_Ops}
structure is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
  \PYG{n}{SUNLinearSolver\PYGZus{}Type} \PYG{p}{(}\PYG{o}{*}\PYG{n}{gettype}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{SUNLinearSolver\PYGZus{}ID}   \PYG{p}{(}\PYG{o}{*}\PYG{n}{getid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setatimes}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{,} \PYG{n}{ATimesFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setpreconditioner}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{,}
                                            \PYG{n}{PSetupFn}\PYG{p}{,} \PYG{n}{PSolveFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setscalingvectors}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,}
                                            \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{initialize}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setup}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{solve}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,}
                                \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{numiters}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{realtype}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{resnorm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{sunindextype}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{lastflag}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{space}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{resid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{free}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The generic SUNLinSol module defines and implements the linear solver
operations defined in Sections {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver core functions}}}} through
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNLinearSolver get functions}}}}.  These routines are in fact only wrappers to
the linear solver operations defined by a particular SUNLinSol
implementation, which are accessed through the \sphinxstyleemphasis{ops} field of the
\sphinxcode{SUNLinearSolver} structure.  To illustrate this point we show below
the implementation of a typical linear solver operation from the
generic \sphinxcode{SUNLinearSolver} module, namely \sphinxcode{SUNLinSolInitialize},
which initializes a \sphinxcode{SUNLinearSolver} object for use after it has
been created and configured, and returns a flag denoting a
successful or failed operation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{SUNLinSolInitialize}\PYG{p}{(}\PYG{n}{SUNLinearSolver} \PYG{n}{S}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{initialize}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Compatibility of SUNLinearSolver modules}
\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-compatibility}}\label{\detokenize{sunlinsol/SUNLinSol_API:compatibility-of-sunlinearsolver-modules}}
We note that not all \sphinxcode{SUNLinearSolver} types are compatible with all
\sphinxcode{SUNMatrix} and \sphinxcode{N\_Vector} types provided with SUNDIALS.  In Table
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-linsol-matrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Compatible SUNLinearSolver and SUNMatrix implementations}}}} we show the matrix-based linear solvers
available as \sphinxcode{SUNLinearSolver} modules, and the compatible matrix
implementations.  Recall that Table {\hyperref[\detokenize{ARKStep_c_interface/Skeleton:arkstep-cinterface-solver-vector}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNDIALS linear solver interfaces and vector implementations that can be used for each}}}}
shows the compatibility between all \sphinxcode{SUNLinearSolver} modules and vector
implementations.


\subsubsection{Compatible SUNLinearSolver and SUNMatrix implementations}
\label{\detokenize{sunlinsol/SUNLinSol_API:compatible-sunlinearsolver-and-sunmatrix-implementations}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-linsol-matrix}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Linear Solver
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Dense
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Banded
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
Sparse
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
User Supplied
\unskip}\relax \\
\hline
Dense
&
X
&&&
X
\\
\hline
LapackDense
&
X
&&&
X
\\
\hline
Band
&&
X
&&
X
\\
\hline
LapackBand
&&
X
&&
X
\\
\hline
KLU
&&&
X
&
X
\\
\hline
SuperLU\_MT
&&&
X
&
X
\\
\hline
User supplied
&
X
&
X
&
X
&
X
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Implementing a custom SUNLinearSolver module}
\label{\detokenize{sunlinsol/SUNLinSol_API:implementing-a-custom-sunlinearsolver-module}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-custom}}
A particular implementation of the \sphinxcode{SUNLinearSolver} module must:
\begin{itemize}
\item {} 
Specify the \sphinxstyleemphasis{content} field of the SUNLinSol module.

\item {} 
Define and implement the required linear solver operations.  See the
section {\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNLinearSolver interface}}}} to determine which SUNLinSol
operations are required for this SUNDIALS package.

Note that the names of these routines should be unique to that
implementation in order to permit using more than one
SUNLinSol module (each with different \sphinxcode{SUNLinearSolver}
internal data representations) in the same code.

\item {} 
Define and implement user-callable constructor and destructor
routines to create and free a \sphinxcode{SUNLinearSolver} with
the new \sphinxstyleemphasis{content} field and with \sphinxstyleemphasis{ops} pointing to the
new linear solver operations.

\end{itemize}

We note that the function pointers for all unsupported optional
routines should be set to \sphinxcode{NULL} in the \sphinxstyleemphasis{ops} structure.  This
allows the SUNDIALS package that is using the SUNLinSol object
to know that the associated functionality is not supported.

To aid in the creation of custom \sphinxcode{SUNLinearSolver} modules the generic
\sphinxcode{SUNLinearSolver} module provides the utility function
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolNewEmpty}]{\sphinxcrossref{\sphinxcode{SUNLinSolNewEmpty()}}}}. When used in custom \sphinxcode{SUNLinearSolver}
constructors this function will ease the introduction of any new optional linear
solver operations to the \sphinxcode{SUNLinearSolver} API by ensuring only required
operations need to be set.
\index{SUNLinSolNewEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolNewEmpty}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSolNewEmpty}}{}{}
This function allocates a new generic \sphinxcode{SUNLinearSolver} object and
initializes its content pointer and the function pointers in the operations
structure to \sphinxcode{NULL}.

\sphinxstylestrong{Return value:} If successful, this function returns a \sphinxcode{SUNLinearSolver}
object. If an error occurs when allocating the object, then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNLinSolFreeEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolFreeEmpty}}\pysiglinewithargsret{void \sphinxbfcode{SUNLinSolFreeEmpty}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This routine frees the generic \sphinxcode{SUNLinearSolver} object, under the assumption that any
implementation-specific data that was allocated within the underlying content structure
has already been freed. It will additionally test whether the ops pointer is \sphinxcode{NULL},
and, if it is not, it will free it as well.
\begin{quote}
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinearSolver object

\end{itemize}

\end{description}
\end{quote}

\end{fulllineitems}


Additionally, a \sphinxcode{SUNLinearSolver} implementation \sphinxstyleemphasis{may} do the following:
\begin{itemize}
\item {} 
Define and implement additional user-callable “set” routines
acting on the \sphinxcode{SUNLinearSolver}, e.g., for setting various
configuration options to tune the linear solver to a particular
problem.

\item {} 
Provide additional user-callable “get” routines acting on the
\sphinxcode{SUNLinearSolver} object, e.g., for returning various solve
statistics.

\end{itemize}


\subsubsection{Intended use cases}
\label{\detokenize{sunlinsol/SUNLinSol_API:intended-use-cases}}\label{\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-intended}}
The SUNLinSol (and SUNMATRIX) APIs are designed to require a minimal set
of routines to ease interfacing with custom or third-party linear solver
libraries. External solvers provide similar routines with
the necessary functionality and thus will require minimal effort to wrap within
custom SUNMATRIX and SUNLinSol implementations. Sections
{\hyperref[\detokenize{sunmatrix/ARKode_requirements:sunmatrix-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNMATRIX functions required by ARKode}}}} and {\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNLinearSolver interface}}}} include a list of
the required set of routines that compatible SUNMATRIX and SUNLinSol
implementations must provide. As SUNDIALS packages utilize generic
SUNLinSol modules allowing for user-supplied \sphinxcode{SUNLinearSolver}
implementations, there exists a wide range of possible linear solver
combinations. Some intended use cases for both the SUNDIALS-provided
and user-supplied SUNLinSol modules are discussd in the following
sections.


\paragraph{Direct linear solvers}
\label{\detokenize{sunlinsol/SUNLinSol_API:direct-linear-solvers}}
Direct linear solver modules require a matrix and compute an ‘exact’ solution to
the linear system \sphinxstyleemphasis{defined by the matrix}. Multiple matrix formats and
associated direct linear solvers are supplied with SUNDIALS through different
SUNMATRIX and SUNLinSol implementations. SUNDIALS packages strive to
amortize the high cost of matrix construction by reusing matrix information for
multiple nonlinear iterations. As a result, each package’s linear solver
interface recomputes Jacobian information as infrequently as possible.

Alternative matrix storage formats and compatible linear solvers that are not
currently provided by or interfaced with SUNDIALS can leverage this
infrastructure with minimal effort. To do so, a user must implement custom
SUNMATRIX and SUNLinSol wrappers for the desired matrix format and/or linear
solver following the APIs described in the sections {\hyperref[\detokenize{sunmatrix/index:sunmatrix}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix Data Structures}}}}
and {\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.  \sphinxstyleemphasis{This user-supplied SUNLinSol module must then
self-identify as having} \sphinxcode{SUNLINEARSOLVER\_DIRECT} \sphinxstyleemphasis{type}.


\paragraph{Matrix-free iterative linear solvers}
\label{\detokenize{sunlinsol/SUNLinSol_API:matrix-free-iterative-linear-solvers}}
Matrix-free iterative linear solver modules do not require a matrix and compute
an inexact solution to the linear system \sphinxstyleemphasis{defined by the package-supplied}
\sphinxcode{ATimes} \sphinxstyleemphasis{routine}. SUNDIALS supplies multiple scaled, preconditioned
iterative linear solver (spils) SUNLinSol modules that support scaling to
allow users to handle non-dimensionalization (as best as possible) within each
SUNDIALS package and retain variables and define equations as desired in
their applications. For linear solvers that do not support left/right scaling,
the tolerance supplied to the linear solver is adjusted to compensate (see
section {\hyperref[\detokenize{sunlinsol/ARKode_requirements:sunlinsol-iterative-tolerance}]{\sphinxcrossref{\DUrole{std,std-ref}{Iterative linear solver tolerance}}}} for more details); however, this
use case may be non-optimal and cannot handle situations where the magnitudes of
different solution components or equations vary dramatically within a single
problem.

To utilize alternative linear solvers that are not currently provided by or
interfaced with SUNDIALS a user must implement a custom SUNLinSol wrapper
for the linear solver following the API described in the section
{\hyperref[\detokenize{sunlinsol/index:sunlinsol}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the SUNLinearSolver module}}}}.  \sphinxstyleemphasis{This user-supplied SUNLinSol module must then
self-identify as having} \sphinxcode{SUNLINEARSOLVER\_ITERATIVE} \sphinxstyleemphasis{type}.


\paragraph{Matrix-based iterative linear solvers (reusing \protect\(A\protect\))}
\label{\detokenize{sunlinsol/SUNLinSol_API:matrix-based-iterative-linear-solvers-reusing}}
Matrix-based iterative linear solver modules require a matrix and compute an
inexact solution to the linear system \sphinxstyleemphasis{defined by the matrix}.  This
matrix will be updated infrequently and resued across multiple solves
to amortize cost of matrix construction. As in the direct linear
solver case, only wrappers for the matrix and linear solver in
SUNMATRIX and SUNLinSol implementations need to be created to utilize
a new linear solver. \sphinxstyleemphasis{This user-supplied SUNLinSol module must then
self-identify as having} \sphinxcode{SUNLINEARSOLVER\_MATRIX\_ITERATIVE} \sphinxstyleemphasis{type}.

At present, SUNDIALS has one example problem that uses this approach for
wrapping a structured-grid matrix, linear solver, and preconditioner from the
\sphinxstyleemphasis{hypre} library that may be used as a template for other customized
implementations
(see \sphinxcode{examples/arkode/CXX\_parhyp/ark\_heat2D\_hypre.cpp}).


\paragraph{Matrix-based iterative linear solvers (current \protect\(A\protect\))}
\label{\detokenize{sunlinsol/SUNLinSol_API:matrix-based-iterative-linear-solvers-current}}
For users who wish to utilize a matrix-based iterative linear solver module
where the matrix is \sphinxstyleemphasis{purely for preconditioning} and the linear system is
\sphinxstyleemphasis{defined by the package-supplied} \sphinxcode{ATimes} \sphinxstyleemphasis{routine}, we envision two
current possibilities.

The preferred approach is for users to employ one of the SUNDIALS
scaled, preconditioned iterative linear solver (spils) implementations
({\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMR()}}}}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMR()}}}},
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGS()}}}}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMR()}}}}, or
{\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCG()}}}}) as the outer solver. The creation and storage of the
preconditioner matrix, and interfacing with the corresponding linear solver, can
be handled through a package’s preconditioner ‘setup’ and ‘solve’ functionality
(see the sections {\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-precsetupfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Preconditioner setup (iterative linear solvers)}}}} and
{\hyperref[\detokenize{ARKStep_c_interface/User_supplied:arkstep-cinterface-precsolvefn}]{\sphinxcrossref{\DUrole{std,std-ref}{Preconditioner solve (iterative linear solvers)}}}}, respectively) without creating
SUNMATRIX and SUNLinSol implementations. This usage mode is
recommended primarily because the SUNDIALS-provided spils modules
support the scaling as described above.

A second approach supported by the linear solver APIs is as follows. If the
SUNLinSol implementation is matrix-based, \sphinxstyleemphasis{self-identifies
as having} \sphinxcode{SUNLINEARSOLVER\_ITERATIVE} \sphinxstyleemphasis{type}, and \sphinxstyleemphasis{also provides a non-NULL
:c:func:{}`SUNLinSolSetATimes(){}` routine}, then each SUNDIALS package
will call that routine to attach its package-specific matrix-vector
product routine to the SUNLinSol object. The SUNDIALS package will
then call the SUNLinSol-provided {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetup}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetup()}}}} routine
(infrequently) to update matrix information, but will provide current
matrix-vector products to the SUNLinSol implementation through the
package-supplied \sphinxcode{ATimesFn} routine.


\section{ARKode SUNLinearSolver interface}
\label{\detokenize{sunlinsol/ARKode_requirements:arkode-sunlinearsolver-interface}}\label{\detokenize{sunlinsol/ARKode_requirements::doc}}\label{\detokenize{sunlinsol/ARKode_requirements:sunlinsol-arkode}}
In the table below, we list the SUNLinSol module linear solver
functions used within the ARKLS interface.  As with the SUNMATRIX module, we
emphasize that the ARKode user does not need to know detailed usage of linear
solver functions by the ARKode code modules in order to use ARKode. The
information is presented as an implementation detail for the interested reader.

The linear solver functions listed below are marked with “X” to
indicate that they are required, or with “O” to indicate that they are
only called if they are non-\sphinxcode{NULL} in the \sphinxcode{SUNLinearSolver}
implementation that is being used.  Note:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolNumIters}]{\sphinxcrossref{\sphinxcode{SUNLinSolNumIters()}}}} is only used to accumulate overall
iterative linear solver statistics.  If it is not implemented by
the \sphinxcode{SUNLinearSolver} module, then ARKLS will consider all
solves as requiring zero iterations.

\item {} 
Although {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolResNorm}]{\sphinxcrossref{\sphinxcode{SUNLinSolResNorm()}}}} is optional, if it is not
implemented by the \sphinxcode{SUNLinearSolver} then ARKLS will consider all
solves a being \sphinxstyleemphasis{exact}.

\item {} 
Although ARKLS does not call {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolLastFlag}]{\sphinxcrossref{\sphinxcode{SUNLinSolLastFlag()}}}}
directly, this routine is available for users to query linear
solver failure modes directly.

\item {} 
Although ARKLS does not call {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolFree}]{\sphinxcrossref{\sphinxcode{SUNLinSolFree()}}}}
directly, this routine should be available for users to call when
cleaning up from a simulation.

\end{enumerate}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Routine
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
DIRECT
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ITERATIVE
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
MATRIX\_ITERATIVE
\unskip}\relax \\
\hline
SUNLinSolGetType
&
X
&
X
&
X
\\
\hline
SUNLinSolSetATimes
&
O
&
X
&
O
\\
\hline
SUNLinSolSetPreconditioner
&
O
&
O
&
O
\\
\hline
SUNLinSolSetScalingVectors
&
O
&
O
&
O
\\
\hline
SUNLinSolInitialize
&
X
&
X
&
X
\\
\hline
SUNLinSolSetup
&
X
&
X
&
X
\\
\hline
SUNLinSolSolve
&
X
&
X
&
X
\\
\hline
SUNLinSolNumIters$^{\text{1}}$
&&
O
&
O
\\
\hline
SUNLinSolResNorm$^{\text{2}}$
&&
O
&
O
\\
\hline
SUNLinSolLastFlag$^{\text{3}}$
&&&\\
\hline
SUNLinSolFree$^{\text{4}}$
&&&\\
\hline
SUNLinSolSpace
&
O
&
O
&
O
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Since there are a wide range of potential SUNLinSol use cases, the following
subsections describe some details of the ARKLS interface, in the case that
interested users wish to develop custom SUNLinSol modules.


\subsection{Lagged matrix information}
\label{\detokenize{sunlinsol/ARKode_requirements:sunlinsol-lagged-matrix}}\label{\detokenize{sunlinsol/ARKode_requirements:lagged-matrix-information}}
If the SUNLinSol identifies as having type
\sphinxcode{SUNLINEARSOLVER\_DIRECT} or \sphinxcode{SUNLINEARSOLVER\_MATRIX\_ITERATIVE},
then the SUNLinSol object solves a
linear system \sphinxstyleemphasis{defined} by a SUNMATRIX object. ARKLS will update the
matrix information infrequently according to the strategies outlined in
the section {\hyperref[\detokenize{Mathematics:mathematics-linear-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{Updating the linear solver}}}}.  To this end, we
differentiate between the \sphinxstyleemphasis{desired} linear system
\(\mathcal A x = b\) with \(\mathcal A = (M-\gamma J)\)
and the \sphinxstyleemphasis{actual} linear system
\begin{equation*}
\begin{split}\tilde{\mathcal A} \tilde{x} = b \quad\Leftrightarrow\quad (M-\tilde{\gamma} J)\tilde{x} = b.\end{split}
\end{equation*}
Since ARKLS updates the SUNMATRIX object infrequently, it is likely
that \(\gamma\ne\tilde{\gamma}\), and in turn \(\mathcal
A\ne\tilde{\mathcal A}\).  Therefore, after calling the
SUNLinSol-provided {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSolve}]{\sphinxcrossref{\sphinxcode{SUNLinSolSolve()}}}} routine, we test whether
\(\gamma / \tilde{\gamma} \ne 1\), and if this is the case we
scale the solution \(\tilde{x}\) to obtain the desired linear
system solution \(x\) via

\phantomsection\label{\detokenize{sunlinsol/ARKode_requirements:equation-eq-rescaling}}\begin{equation}\label{equation:sunlinsol/ARKode_requirements:eq:rescaling}
\begin{split}x = \frac{2}{1 + \gamma / \tilde{\gamma}} \tilde{x}.\end{split}
\end{equation}
The motivation for this selection of the scaling factor
\(c = 2/(1 + \gamma/\tilde{\gamma})\) follows the derivation in
\phantomsection\label{\detokenize{sunlinsol/ARKode_requirements:id1}}{\hyperref[\detokenize{References:bbh1989}]{\sphinxcrossref{{[}BBH1989{]}}}} and \phantomsection\label{\detokenize{sunlinsol/ARKode_requirements:id2}}{\hyperref[\detokenize{References:h2000}]{\sphinxcrossref{{[}H2000{]}}}}.  In short, if we consider a stationary
iteration for the linear system as consisting of a solve with
\(\tilde{\mathcal A}\) followed by scaling by \(c\),
then for a linear constant-coefficient problem, the error in the
solution vector will be reduced at each iteration by the error matrix
\(E = I - c \tilde{\mathcal A}^{-1} \mathcal A\), with a
convergence rate given by the spectral radius of \(E\).  Assuming
that stiff systems have a spectrum spread widely over the left
half-plane, \(c\) is chosen to minimize the magnitude of the
eigenvalues of \(E\).


\subsection{Iterative linear solver tolerance}
\label{\detokenize{sunlinsol/ARKode_requirements:iterative-linear-solver-tolerance}}\label{\detokenize{sunlinsol/ARKode_requirements:sunlinsol-iterative-tolerance}}
If the SUNLinSol object self-identifies as having type
\sphinxcode{SUNLINEARSOLVER\_ITERATIVE} or \sphinxcode{SUNLINEARSOLVER\_MATRIX\_ITERATIVE},
then ARKLS will set the input tolerance \sphinxcode{delta} as described in
{\hyperref[\detokenize{Mathematics:mathematics-error-linear}]{\sphinxcrossref{\DUrole{std,std-ref}{Linear iteration error control}}}}.  However, if the iterative linear
solver does not support scaling matrices (i.e., the
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:c.SUNLinSolSetScalingVectors}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetScalingVectors()}}}} routine is \sphinxcode{NULL}), then
ARKLS will attempt to adjust the linear solver tolerance to account
for this lack of functionality.  To this end, the following
assumptions are made:
\begin{itemize}
\item {} 
All solution components have similar magnitude; hence the residual
weight vector \(w\) used in the WRMS norm (see the section
{\hyperref[\detokenize{Mathematics:mathematics-error-norm}]{\sphinxcrossref{\DUrole{std,std-ref}{Error norms}}}}), corresponding to the left scaling
matrix \(S_1\), should satisfy the assumption
\begin{equation*}
\begin{split}w_i \approx w_{mean},\quad \text{for}\quad i=0,\ldots,n-1.\end{split}
\end{equation*}
\item {} 
The SUNLinSol object uses a standard 2-norm to measure convergence.

\end{itemize}

Under these assumptions, ARKLS adjusts the linear solver
convergence requirement as follows
(using the notation from the beginning of this chapter):
\begin{equation*}
\begin{split}&\left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}\\
\Leftrightarrow \quad & \left\| S_1 P_1^{-1} b - S_1 P_1^{-1} A x \right\|_2  <  \text{tol}\\
\Leftrightarrow \quad & \sum_{i=0}^{n-1} \left[w_i \left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \text{tol}^2\\
\Leftrightarrow \quad & w_{mean}^2 \sum_{i=0}^{n-1} \left[\left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \text{tol}^2\\
\Leftrightarrow \quad & \sum_{i=0}^{n-1} \left[\left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \left(\frac{\text{tol}}{w_{mean}}\right)^2\\
\Leftrightarrow \quad & \left\| P_1^{-1} (b - A x)\right\|_2  <  \frac{\text{tol}}{w_{mean}}\end{split}
\end{equation*}
Therefore the tolerance scaling factor
\begin{equation*}
\begin{split}w_{mean} = \|w\|_2 / \sqrt{n}\end{split}
\end{equation*}
is computed and the scaled tolerance \sphinxcode{delta} \(= \text{tol} /
w_{mean}\) is supplied to the SUNLinSol object.


\subsection{Providing a custom SUNLinearSolver}
\label{\detokenize{sunlinsol/ARKode_requirements:sunlinsol-custom}}\label{\detokenize{sunlinsol/ARKode_requirements:providing-a-custom-sunlinearsolver}}
In certain instances, users may wish to provide a custom SUNLinearSolver
implementation to ARKode in order to leverage the structure of a problem.  While
the ‘standard’ API for these routines is typically sufficient for most users,
others may need additional ARKode-specific information on top of what is
provided.  For these purposes, we note the following advanced ouptut functions
available in ARKStep and MRIStep:

\sphinxstylestrong{ARKStep advanced outputs}: when solving the Newton nonlinear system of
equations in predictor-corrector form,
\begin{equation*}
\begin{split}G(z_{cor}) &\equiv z_{cor} - \gamma f^I\left(t^I_{n,i}, z_{i} \right) - \tilde{a}_i = 0 \qquad\qquad\qquad\text{[$M=I$]},\\
G(z_{cor}) &\equiv M z_{cor} - \gamma f^I\left(t^I_{n,i}, z_{i} \right) - \tilde{a}_i = 0 \quad\qquad\qquad\text{[$M$ static]},\\
G(z_{cor}) &\equiv M(t^I_{n,i}) (z_{cor} - \tilde{a}_i) - \gamma f^I\left(t^I_{n,i}, z_{i}\right) = 0 \qquad\text{[$M$ time-dependent]}.\end{split}
\end{equation*}\begin{itemize}
\item {} 
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}} \textendash{} when called within the computation of a
step (i.e., within a solve) this returns \(t^I_{n,i}\). Otherwise the
current internal solution time is returned.

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentState}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentState()}}}} \textendash{} when called within the computation of a
step (i.e., within a solve) this returns the current stage vector
\(z_{i} = z_{cor} + z_{pred}\). Otherwise the current internal solution
is returned.

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentGamma}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentGamma()}}}} \textendash{} returns \(\gamma\).

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentMassMatrix}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentMassMatrix()}}}} \textendash{} returns \(M(t)\).

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{ARKStepGetNonlinearSystemData()}}}} \textendash{} returns
\(z_{i}\), \(z_{pred}\), \(f^I(t^I_{n,i}, y_{cur})\),
\(\tilde{a}_i\), and \(\gamma\).

\end{itemize}

\sphinxstylestrong{MRIStep advanced outputs}: when solving the Newton nonlinear system of
equations in predictor-corrector form,
\begin{equation*}
\begin{split}G(z_{cor}) \equiv z_{cor} - \gamma f^S\left(t^S_{n,i}, z_{i}\right) - \tilde{a}_i = 0\end{split}
\end{equation*}\begin{itemize}
\item {} 
{\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentTime()}}}} \textendash{} when called within the computation of a
step (i.e., within a solve) this returns \(t^S_{n,i}\). Otherwise the
current internal solution time is returned.

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetCurrentState}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentState()}}}} \textendash{} when called within the computation of a
step (i.e., within a solve) this returns the current stage vector
\(z_{i} = z_{cor} + z_{pred}\). Otherwise the current internal solution
is returned.

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetCurrentGamma}]{\sphinxcrossref{\sphinxcode{MRIStepGetCurrentGamma()}}}} \textendash{} returns \(\gamma\).

\item {} 
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{MRIStepGetNonlinearSystemData()}}}} \textendash{} returns
\(z_{i}\), \(z_{pred}\), \(f^I(t^I_{n,i}, y_{cur})\),
\(\tilde{a}_i\), and \(\gamma\).

\end{itemize}


\section{The SUNLinSol\_Dense Module}
\label{\detokenize{sunlinsol/SUNLinSol_Dense:the-sunlinsol-dense-module}}\label{\detokenize{sunlinsol/SUNLinSol_Dense::doc}}\label{\detokenize{sunlinsol/SUNLinSol_Dense:sunlinsol-dense}}
The dense implementation of the \sphinxcode{SUNLinearSolver} module provided with
SUNDIALS, SUNLinSol\_Dense, is designed to be used with the
corresponding SUNMATRIX\_DENSE matrix type, and one of the serial or
shared-memory \sphinxcode{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP or
NVECTOR\_PTHREADS).


\subsection{SUNLinSol\_Dense Usage}
\label{\detokenize{sunlinsol/SUNLinSol_Dense:sunlinsol-dense-usage}}\label{\detokenize{sunlinsol/SUNLinSol_Dense:id1}}
The header file to be included when using this module is
\sphinxcode{sunlinsol/sunlinsol\_dense.h}.  The SUNLinSol\_Dense module is
accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the \sphinxcode{libsundials\_sunlinsoldense} module library.

The module SUNLinSol\_Dense provides the following user-callable constructor routine:
\index{SUNLinSol\_Dense (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Dense:c.SUNLinSol_Dense}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_Dense}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
This function creates and allocates memory for a dense \sphinxcode{SUNLinearSolver}.
Its arguments are an \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix}, that it uses to
determine the linear system size and to assess compatibility with
the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_DENSE matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector types.  As
additional compatible matrix and vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

If either \sphinxcode{A} or \sphinxcode{y} are incompatible then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper function,
\index{SUNDenseLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Dense:c.SUNDenseLinearSolver}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNDenseLinearSolver}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_Dense:c.SUNLinSol_Dense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Dense()}}}}, with identical input and
output arguments

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_Dense module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_Dense:f/_/FSUNDenseLinSolInit}]{\sphinxcrossref{\sphinxcode{FSUNDenseLinSolInit()}}}} to initialize
this SUNLinSol\_Dense module for a given SUNDIALS solver.
\index{FSUNDenseLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Dense:f/_/FSUNDenseLinSolInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNDenseLinSolInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a dense \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_Dense:f/_/FSUNMassDenseLinSolInit}]{\sphinxcrossref{\sphinxcode{FSUNMassDenseLinSolInit()}}}}
initializes this SUNLinSol\_Dense module for solving mass matrix linear
systems.
\index{FSUNMassDenseLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Dense:f/_/FSUNMassDenseLinSolInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassDenseLinSolInit}}{\emph{IER}}{}
Initializes a dense \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\subsection{SUNLinSol\_Dense Description}
\label{\detokenize{sunlinsol/SUNLinSol_Dense:sunlinsol-dense-description}}\label{\detokenize{sunlinsol/SUNLinSol_Dense:id2}}
The SUNLinSol\_Dense module defines the \sphinxstyleemphasis{content}
field of a \sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Dense} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{N} - size of the linear system,

\item {} 
\sphinxcode{pivots} - index array for partial pivoting in LU factorization,

\item {} 
\sphinxcode{last\_flag} - last error return flag from internal function evaluations.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The “setup” call performs a \(LU\) factorization with
partial (row) pivoting (\(\mathcal O(N^3)\) cost),
\(PA=LU\), where \(P\) is a permutation matrix, \(L\) is
a lower triangular matrix with 1’s on the diagonal, and \(U\) is
an upper triangular matrix.  This factorization is stored in-place
on the input SUNMATRIX\_DENSE object \(A\), with pivoting
information encoding \(P\) stored in the \sphinxcode{pivots} array.

\item {} 
The “solve” call performs pivoting and forward and
backward substitution using the stored \sphinxcode{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_DENSE object
(\(\mathcal O(N^2)\) cost).

\end{itemize}

The SUNLinSol\_Dense module defines dense implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_Dense}

\item {} 
\sphinxcode{SUNLinSolInitialize\_Dense} \textendash{} this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\sphinxcode{SUNLinSolSetup\_Dense} \textendash{} this performs the \(LU\) factorization.

\item {} 
\sphinxcode{SUNLinSolSolve\_Dense} \textendash{} this uses the \(LU\) factors
and \sphinxcode{pivots} array to perform the solve.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_Dense}

\item {} 
\sphinxcode{SUNLinSolSpace\_Dense} \textendash{} this only returns information for
the storage \sphinxstyleemphasis{within} the solver object, i.e. storage
for \sphinxcode{N}, \sphinxcode{last\_flag}, and \sphinxcode{pivots}.

\item {} 
\sphinxcode{SUNLinSolFree\_Dense}

\end{itemize}


\section{The SUNLinSol\_Band Module}
\label{\detokenize{sunlinsol/SUNLinSol_Band::doc}}\label{\detokenize{sunlinsol/SUNLinSol_Band:sunlinsol-band}}\label{\detokenize{sunlinsol/SUNLinSol_Band:the-sunlinsol-band-module}}
The band implementation of the \sphinxcode{SUNLinearSolver} module provided with
SUNDIALS, SUNLinSol\_Band, is designed to be used with the
corresponding SUNMATRIX\_BAND matrix type, and one of the serial or
shared-memory \sphinxcode{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP or
NVECTOR\_PTHREADS).


\subsection{SUNLinSol\_Band Usage}
\label{\detokenize{sunlinsol/SUNLinSol_Band:sunlinsol-band-usage}}\label{\detokenize{sunlinsol/SUNLinSol_Band:id1}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_band.h}.  The SUNLinSol\_Band module
is accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the
\sphinxcode{libsundials\_sunlinsolband} module library.

The module SUNLinSol\_Band provides the following user-callable constructor routine:
\index{SUNLinSol\_Band (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Band:c.SUNLinSol_Band}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_Band}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
This function creates and allocates memory for a band \sphinxcode{SUNLinearSolver}.
Its arguments are an \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix}, that it uses to
determine the linear system size and to assess compatibility with
the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_BAND matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector types.  As
additional compatible matrix and vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

Additionally, this routine will verify that the input matrix \sphinxcode{A}
is allocated with appropriate upper bandwidth storage for the \(LU\)
factorization.

If either \sphinxcode{A} or \sphinxcode{y} are incompatible then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper function,
\index{SUNBandLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Band:c.SUNBandLinearSolver}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNBandLinearSolver}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_Band:c.SUNLinSol_Band}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_Band()}}}}, with identical input and
output arguments.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_Band module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_Band:f/_/FSUNBandLinSolInit}]{\sphinxcrossref{\sphinxcode{FSUNBandLinSolInit()}}}} to initialize
this SUNLinSol\_Band module for a given SUNDIALS solver.
\index{FSUNBandLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Band:f/_/FSUNBandLinSolInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNBandLinSolInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a banded \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_Band:f/_/FSUNMassBandLinSolInit}]{\sphinxcrossref{\sphinxcode{FSUNMassBandLinSolInit()}}}}
initializes this SUNLinSol\_Band module for solving mass matrix linear
systems.
\index{FSUNMassBandLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_Band:f/_/FSUNMassBandLinSolInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassBandLinSolInit}}{\emph{IER}}{}
Initializes a banded \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\subsection{SUNLinSol\_Band Description}
\label{\detokenize{sunlinsol/SUNLinSol_Band:sunlinsol-band-description}}\label{\detokenize{sunlinsol/SUNLinSol_Band:id2}}
The SUNLinSol\_Band module defines the \sphinxstyleemphasis{content}
field of a \sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Band} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{N} - size of the linear system,

\item {} 
\sphinxcode{pivots} - index array for partial pivoting in LU factorization,

\item {} 
\sphinxcode{last\_flag} - last error return flag from internal function evaluations.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The “setup” call performs a \(LU\) factorization with
partial (row) pivoting, \(PA=LU\), where \(P\) is a permutation matrix,
\(L\) is a lower triangular matrix with 1’s on the diagonal, and \(U\)
is an upper triangular matrix.  This factorization is stored
in-place on the input SUNMATRIX\_BAND object \(A\), with pivoting
information encoding \(P\) stored in the \sphinxcode{pivots} array.

\item {} 
The “solve” call performs pivoting and forward and
backward substitution using the stored \sphinxcode{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_BAND object.

\item {} 
\(A\) must be allocated to accommodate the increase in upper
bandwidth that occurs during factorization.  More precisely, if \(A\)
is a band matrix with upper bandwidth \sphinxcode{mu} and lower bandwidth
\sphinxcode{ml}, then the upper triangular factor \(U\) can have upper
bandwidth as big as \sphinxcode{smu = MIN(N-1,mu+ml)}. The lower triangular
factor \(L\) has lower bandwidth \sphinxcode{ml}.

\end{itemize}

The SUNLinSol\_Band module defines band implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_Band}

\item {} 
\sphinxcode{SUNLinSolInitialize\_Band} \textendash{} this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\sphinxcode{SUNLinSolSetup\_Band} \textendash{} this performs the \(LU\) factorization.

\item {} 
\sphinxcode{SUNLinSolSolve\_Band} \textendash{} this uses the \(LU\) factors
and \sphinxcode{pivots} array to perform the solve.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_Band}

\item {} 
\sphinxcode{SUNLinSolSpace\_Band} \textendash{} this only returns information for
the storage \sphinxstyleemphasis{within} the solver object, i.e. storage
for \sphinxcode{N}, \sphinxcode{last\_flag}, and \sphinxcode{pivots}.

\item {} 
\sphinxcode{SUNLinSolFree\_Band}

\end{itemize}


\section{The SUNLinSol\_LapackDense Module}
\label{\detokenize{sunlinsol/SUNLinSol_LapackDense::doc}}\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:the-sunlinsol-lapackdense-module}}\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:sunlinsol-lapackdense}}
The LAPACK dense implementation of the \sphinxcode{SUNLinearSolver} module provided
with SUNDIALS, SUNLinSol\_LapackDense, is designed to be used with the
corresponding SUNMATRIX\_DENSE matrix type, and one of the serial or
shared-memory \sphinxcode{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP, or
NVECTOR\_PTHREADS).


\subsection{SUNLinSol\_LapackDense Usage}
\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:sunlinsol-lapackdense-usage}}\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:id1}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_lapackdense.h}.  The installed module
library to link to is \sphinxcode{libsundials\_sunlinsollapackdense} \sphinxstyleemphasis{.lib}
where \sphinxstyleemphasis{.lib} is typically \sphinxcode{.so} for shared libraries and
\sphinxcode{.a} for static libraries.

The module SUNLinSol\_LapackDense provides the following additional
user-callable constructor routine:
\index{SUNLinSol\_LapackDense (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:c.SUNLinSol_LapackDense}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_LapackDense}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
This function creates and allocates memory for a LAPACK dense
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix}, that it uses to determine the linear system size and
to assess compatibility with the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_DENSE matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector
types.  As additional compatible matrix and vector implementations
are added to SUNDIALS, these will be included within this
compatibility check.

If either \sphinxcode{A} or \sphinxcode{y} are incompatible then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper function,
\index{SUNLapackDense (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:c.SUNLapackDense}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLapackDense}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackDense:c.SUNLinSol_LapackDense}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackDense()}}}}, with
identical input and output arguments.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_LapackDense module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackDense:f/_/FSUNLapackDenseInit}]{\sphinxcrossref{\sphinxcode{FSUNLapackDenseInit()}}}} to initialize
this SUNLinSol\_LapackDense module for a given SUNDIALS solver.
\index{FSUNLapackDenseInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:f/_/FSUNLapackDenseInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNLapackDenseInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a dense LAPACK \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackDense:f/_/FSUNMassLapackDenseInit}]{\sphinxcrossref{\sphinxcode{FSUNMassLapackDenseInit()}}}}
initializes this SUNLinSol\_LapackDense module for solving mass matrix
linear systems.
\index{FSUNMassLapackDenseInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:f/_/FSUNMassLapackDenseInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassLapackDenseInit}}{\emph{IER}}{}
Initializes a dense LAPACK \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\subsection{SUNLinSol\_LapackDense Description}
\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:id2}}\label{\detokenize{sunlinsol/SUNLinSol_LapackDense:sunlinsol-lapackdense-description}}
The SUNLinSol\_LapackDense module defines the
\sphinxstyleemphasis{content} field of a \sphinxcode{SUNLinearSolver} to be the following
structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Dense} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{N} - size of the linear system,

\item {} 
\sphinxcode{pivots} - index array for partial pivoting in LU
factorization,

\item {} 
\sphinxcode{last\_flag} - last error return flag from internal function
evaluations.

\end{itemize}

The SUNLinSol\_LapackDense module is a \sphinxcode{SUNLinearSolver} wrapper for
the LAPACK dense matrix factorization and solve routines, \sphinxcode{*GETRF}
and \sphinxcode{*GETRS}, where \sphinxcode{*} is either \sphinxcode{D} or \sphinxcode{S}, depending on
whether SUNDIALS was configured to have \sphinxcode{realtype} set to
\sphinxcode{double} or \sphinxcode{single}, respectively (see section
{\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}} for details).  In order to use the
SUNLinSol\_LapackDense module it is assumed that LAPACK has been
installed on the system prior to installation of
SUNDIALS, and that SUNDIALS has been configured appropriately to
link with LAPACK (see section
{\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}} for details).
We note that since there do not exist 128-bit floating-point
factorization and solve routines in LAPACK, this interface cannot be
compiled when using \sphinxcode{extended} precision for \sphinxcode{realtype}.
Similarly, since there do not exist 64-bit integer LAPACK routines,
the SUNLinSol\_LapackDense module also cannot be compiled when using
\sphinxcode{int64\_t} for the \sphinxcode{sunindextype}.

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The “setup” call performs a \(LU\) factorization with
partial (row) pivoting (\(\mathcal O(N^3)\) cost),
\(PA=LU\), where \(P\) is a permutation matrix, \(L\) is
a lower triangular matrix with 1’s on the diagonal, and \(U\) is
an upper triangular matrix.  This factorization is stored in-place
on the input SUNMATRIX\_DENSE object \(A\), with pivoting
information encoding \(P\) stored in the \sphinxcode{pivots} array.

\item {} 
The “solve” call performs pivoting and forward and
backward substitution using the stored \sphinxcode{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_DENSE object
(\(\mathcal O(N^2)\) cost).

\end{itemize}

The SUNLinSol\_LapackDense module defines dense implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_LapackDense}

\item {} 
\sphinxcode{SUNLinSolInitialize\_LapackDense} \textendash{} this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\sphinxcode{SUNLinSolSetup\_LapackDense} \textendash{} this calls either
\sphinxcode{DGETRF} or \sphinxcode{SGETRF} to perform the \(LU\) factorization.

\item {} 
\sphinxcode{SUNLinSolSolve\_LapackDense} \textendash{} this calls either
\sphinxcode{DGETRS} or \sphinxcode{SGETRS} to use the \(LU\) factors and
\sphinxcode{pivots} array to perform the solve.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_LapackDense}

\item {} 
\sphinxcode{SUNLinSolSpace\_LapackDense} \textendash{} this only returns information for
the storage \sphinxstyleemphasis{within} the solver object, i.e. storage
for \sphinxcode{N}, \sphinxcode{last\_flag}, and \sphinxcode{pivots}.

\item {} 
\sphinxcode{SUNLinSolFree\_LapackDense}

\end{itemize}


\section{The SUNLinSol\_LapackBand Module}
\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:sunlinsol-lapackband}}\label{\detokenize{sunlinsol/SUNLinSol_LapackBand::doc}}\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:the-sunlinsol-lapackband-module}}
The LAPACK band implementation of the \sphinxcode{SUNLinearSolver} module provided
with SUNDIALS, SUNLinSol\_LapackBand, is designed to be used with the
corresponding SUNMATRIX\_BAND matrix type, and one of the serial or
shared-memory \sphinxcode{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP, or
NVECTOR\_PTHREADS).  The


\subsection{SUNLinSol\_LapackBand Usage}
\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:sunlinsol-lapackband-usage}}\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:id1}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_lapackband.h}.  The installed module
library to link to is
\sphinxcode{libsundials\_sunlinsollapackband} \sphinxstyleemphasis{.lib}
where \sphinxstyleemphasis{.lib} is typically \sphinxcode{.so} for shared libraries and
\sphinxcode{.a} for static libraries.

The module SUNLinSol\_LapackBand provides the following
user-callable routine:
\index{SUNLinSol\_LapackBand (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:c.SUNLinSol_LapackBand}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_LapackBand}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
This function creates and allocates memory for a LAPACK band
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix}, that it uses to determine the linear system size and
to assess compatibility with the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_BAND matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector
types.  As additional compatible matrix and vector implementations
are added to SUNDIALS, these will be included within this
compatibility check.

Additionally, this routine will verify that the input matrix \sphinxcode{A}
is allocated with appropriate upper bandwidth storage for the
\(LU\) factorization.

If either \sphinxcode{A} or \sphinxcode{y} are incompatible then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper function,
\index{SUNLapackBand (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:c.SUNLapackBand}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLapackBand}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackBand:c.SUNLinSol_LapackBand}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_LapackBand()}}}}, with
identical input and output arguments.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_LapackBand module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackBand:f/_/FSUNLapackBandInit}]{\sphinxcrossref{\sphinxcode{FSUNLapackBandInit()}}}} to initialize this
SUNLinSol\_LapackBand module for a given SUNDIALS solver.
\index{FSUNLapackBandInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:f/_/FSUNLapackBandInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNLapackBandInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a banded LAPACK \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_LapackBand:f/_/FSUNMassLapackBandInit}]{\sphinxcrossref{\sphinxcode{FSUNMassLapackBandInit()}}}}
initializes this SUNLinSol\_LapackBand module for solving mass matrix
linear systems.
\index{FSUNMassLapackBandInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:f/_/FSUNMassLapackBandInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassLapackBandInit}}{\emph{IER}}{}
Initializes a banded LAPACK \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\subsection{SUNLinSol\_LapackBand Description}
\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:sunlinsol-lapackband-description}}\label{\detokenize{sunlinsol/SUNLinSol_LapackBand:id2}}
SUNLinSol\_LapackBand module defines the
\sphinxstyleemphasis{content} field of a \sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Band} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{N} - size of the linear system,

\item {} 
\sphinxcode{pivots} - index array for partial pivoting in LU
factorization,

\item {} 
\sphinxcode{last\_flag} - last error return flag from internal function
evaluations.

\end{itemize}

The SUNLinSol\_LapackBand module is a \sphinxcode{SUNLinearSolver} wrapper for
the LAPACK band matrix factorization and solve routines, \sphinxcode{*GBTRF}
and \sphinxcode{*GBTRS}, where \sphinxcode{*} is either \sphinxcode{D} or \sphinxcode{S}, depending on
whether SUNDIALS was configured to have \sphinxcode{realtype} set to
\sphinxcode{double} or \sphinxcode{single}, respectively (see section
{\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}} for details).
In order to use the SUNLinSol\_LapackBand module it is assumed
that LAPACK has been installed on the system prior to installation of
SUNDIALS, and that SUNDIALS has been configured appropriately to
link with LAPACK (see section
{\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}} for details).  We note
that since there do not exist 128-bit floating-point factorization and
solve routines in LAPACK, this interface cannot be compiled when
using \sphinxcode{extended} precision for \sphinxcode{realtype}.  Similarly, since
there do not exist 64-bit integer LAPACK routines, the
SUNLinSol\_LapackBand module also cannot be compiled when using
\sphinxcode{int64\_t} for the \sphinxcode{sunindextype}.

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The “setup” call performs a \(LU\) factorization with
partial (row) pivoting, \(PA=LU\), where \(P\) is a
permutation matrix, \(L\) is a lower triangular matrix with 1’s
on the diagonal, and \(U\) is an upper triangular matrix.  This
factorization is stored in-place on the input SUNMATRIX\_BAND object
\(A\), with pivoting information encoding \(P\) stored in
the \sphinxcode{pivots} array.

\item {} 
The “solve” call performs pivoting and forward and
backward substitution using the stored \sphinxcode{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_BAND object.

\item {} 
\(A\) must be allocated to accommodate the increase in upper
bandwidth that occurs during factorization.  More precisely, if
\(A\) is a band matrix with upper bandwidth \sphinxcode{mu} and lower
bandwidth \sphinxcode{ml}, then the upper triangular factor \(U\) can
have upper bandwidth as big as \sphinxcode{smu = MIN(N-1,mu+ml)}. The lower
triangular factor \(L\) has lower bandwidth \sphinxcode{ml}.

\end{itemize}

The SUNLinSol\_LapackBand module defines band implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_LapackBand}

\item {} 
\sphinxcode{SUNLinSolInitialize\_LapackBand} \textendash{} this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\sphinxcode{SUNLinSolSetup\_LapackBand} \textendash{} this calls either
\sphinxcode{DGBTRF} or \sphinxcode{SGBTRF} to perform the \(LU\) factorization.

\item {} 
\sphinxcode{SUNLinSolSolve\_LapackBand} \textendash{} this calls either
\sphinxcode{DGBTRS} or \sphinxcode{SGBTRS} to use the \(LU\) factors and
\sphinxcode{pivots} array to perform the solve.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_LapackBand}

\item {} 
\sphinxcode{SUNLinSolSpace\_LapackBand} \textendash{} this only returns information for
the storage \sphinxstyleemphasis{within} the solver object, i.e. storage for \sphinxcode{N},
\sphinxcode{last\_flag}, and \sphinxcode{pivots}.

\item {} 
\sphinxcode{SUNLinSolFree\_LapackBand}

\end{itemize}


\section{The SUNLinSol\_KLU Module}
\label{\detokenize{sunlinsol/SUNLinSol_KLU:the-sunlinsol-klu-module}}\label{\detokenize{sunlinsol/SUNLinSol_KLU::doc}}\label{\detokenize{sunlinsol/SUNLinSol_KLU:sunlinsol-klu}}
The KLU implementation of the \sphinxcode{SUNLinearSolver} module provided with
SUNDIALS, SUNLinSol\_KLU, is designed to be used with the
corresponding SUNMATRIX\_SPARSE matrix type, and one of the serial or
shared-memory \sphinxcode{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP, or
NVECTOR\_PTHREADS).


\subsection{SUNLinSol\_KLU Usage}
\label{\detokenize{sunlinsol/SUNLinSol_KLU:sunlinsol-klu-usage}}\label{\detokenize{sunlinsol/SUNLinSol_KLU:id1}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_klu.h}.  The installed module
library to link to is \sphinxcode{libsundials\_sunlinsolklu} \sphinxstyleemphasis{.lib}
where \sphinxstyleemphasis{.lib} is typically \sphinxcode{.so} for shared libraries and
\sphinxcode{.a} for static libraries.

The module SUNLinSol\_KLU provides the following additional
user-callable routines:
\index{SUNLinSol\_KLU (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLU}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_KLU}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
This constructor function creates and allocates memory for a SUNLinSol\_KLU
object.  Its arguments are an \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix}, that it
uses to determine the linear system size and to assess compatibility
with the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_SPARSE matrix type
(using either CSR or CSC storage formats) and the NVECTOR\_SERIAL,
NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector types.  As additional
compatible matrix and vector implementations are added to
SUNDIALS, these will be included within this compatibility
check.

If either \sphinxcode{A} or \sphinxcode{y} are incompatible then this routine will
return \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNLinSol\_KLUReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUReInit}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_KLUReInit}}{SUNLinearSolver\sphinxstyleemphasis{ S}, SUNMatrix\sphinxstyleemphasis{ A}, sunindextype\sphinxstyleemphasis{ nnz}, int\sphinxstyleemphasis{ reinit\_type}}{}
This function reinitializes memory and flags for a new factorization
(symbolic and numeric) to be conducted at the next solver setup
call.  This routine is useful in the cases where the number of
nonzeroes has changed or if the structure of the linear system has
changed which would require a new symbolic (and numeric
factorization).

The \sphinxcode{reinit\_type} argument governs the level of
reinitialization.  The allowed values are:
\begin{enumerate}
\item {} 
The Jacobian matrix will be destroyed and a new one will be
allocated based on the \sphinxcode{nnz} value passed to this call.  New
symbolic and numeric factorizations will be completed at the next
solver setup.

\item {} 
Only symbolic and numeric factorizations will be completed.
It is assumed that the Jacobian size has not exceeded the size of
\sphinxcode{nnz} given in the sparse matrix provided to the original
constructor routine (or the previous \sphinxcode{SUNKLUReInit} call).

\end{enumerate}

This routine assumes no other changes to solver use are necessary.

The return values from this function are \sphinxcode{SUNLS\_MEM\_NULL}
(either \sphinxcode{S} or \sphinxcode{A} are \sphinxcode{NULL}), \sphinxcode{SUNLS\_ILL\_INPUT}
(\sphinxcode{A} does not have type \sphinxcode{SUNMATRIX\_SPARSE} or
\sphinxcode{reinit\_type} is invalid), \sphinxcode{SUNLS\_MEM\_FAIL} (reallocation
of the sparse matrix failed) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_KLUSetOrdering (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUSetOrdering}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_KLUSetOrdering}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ ordering\_choice}}{}
This function sets the ordering used by KLU for reducing fill in
the linear solve.  Options for \sphinxcode{ordering\_choice} are:
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
AMD,

\item {} 
COLAMD, and

\item {} 
the natural ordering.

\end{enumerate}

The default is 1 for COLAMD.

The return values from this function are \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}), \sphinxcode{SUNLS\_ILL\_INPUT}
(invalid \sphinxcode{ordering\_choice}), or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_KLUGetSymbolic (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUGetSymbolic}}\pysiglinewithargsret{sun\_klu\_symbolic* \sphinxbfcode{SUNLinSol\_KLUGetSymbolic}}{SUNLinearSolver\sphinxstyleemphasis{ S}}{}
This function returns a pointer to the KLU symbolic factorization
stored in the SUNLinSol\_KLU \sphinxcode{content} structure.

When SUNDIALS is compiled with 32-bit indices (\sphinxcode{SUNDIALS\_INDEX\_SIZE=32}),
\sphinxcode{sun\_klu\_symbolic} is mapped to the KLU type \sphinxcode{klu\_symbolic}; when
SUNDIALS compiled with 64-bit indices (\sphinxcode{SUNDIALS\_INDEX\_SIZE=64}) this is
mapped to the KLU type \sphinxcode{klu\_l\_symbolic}.

\end{fulllineitems}

\index{SUNLinSol\_KLUGetNumeric (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUGetNumeric}}\pysiglinewithargsret{sun\_klu\_numeric* \sphinxbfcode{SUNLinSol\_KLUGetNumeric}}{SUNLinearSolver\sphinxstyleemphasis{ S}}{}
This function returns a pointer to the KLU numeric factorization
stored in the SUNLinSol\_KLU \sphinxcode{content} structure.

When SUNDIALS is compiled with 32-bit indices (\sphinxcode{SUNDIALS\_INDEX\_SIZE=32}),
\sphinxcode{sun\_klu\_numeric} is mapped to the KLU type \sphinxcode{klu\_numeric}; when
SUNDIALS is compiled with 64-bit indices (\sphinxcode{SUNDIALS\_INDEX\_SIZE=64}) this is
mapped to the KLU type \sphinxcode{klu\_l\_numeric}.

\end{fulllineitems}

\index{SUNLinSol\_KLUGetCommon (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUGetCommon}}\pysiglinewithargsret{sun\_klu\_common* \sphinxbfcode{SUNLinSol\_KLUGetCommon}}{SUNLinearSolver\sphinxstyleemphasis{ S}}{}
This function returns a pointer to the KLU common structure
stored in the SUNLinSol\_KLU \sphinxcode{content} structure.

When SUNDIALS is compiled with 32-bit indices (\sphinxcode{SUNDIALS\_INDEX\_SIZE=32}),
\sphinxcode{sun\_klu\_common} is mapped to the KLU type \sphinxcode{klu\_common}; when
SUNDIALS is compiled with 64-bit indices  (\sphinxcode{SUNDIALS\_INDEX\_SIZE=64}) this is
mapped to the KLU type \sphinxcode{klu\_l\_common}.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNKLU (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNKLU}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNKLU}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLU}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLU()}}}}

\end{fulllineitems}

\index{SUNKLUReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNKLUReInit}}\pysiglinewithargsret{int \sphinxbfcode{SUNKLUReInit}}{SUNLinearSolver\sphinxstyleemphasis{ S}, SUNMatrix\sphinxstyleemphasis{ A}, sunindextype\sphinxstyleemphasis{ nnz}, int\sphinxstyleemphasis{ reinit\_type}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUReInit}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUReInit()}}}}

\end{fulllineitems}

\index{SUNKLUSetOrdering (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNKLUSetOrdering}}\pysiglinewithargsret{int \sphinxbfcode{SUNKLUSetOrdering}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ ordering\_choice}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUSetOrdering()}}}}

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_KLU module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit}]{\sphinxcrossref{\sphinxcode{FSUNKLUInit()}}}} to initialize this SUNLinSol\_KLU
module for a given SUNDIALS solver.
\index{FSUNKLUInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNKLUInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a KLU sparse \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit}]{\sphinxcrossref{\sphinxcode{FSUNMassKLUInit()}}}} initializes this
SUNLinSol\_KLU module for solving mass matrix linear systems.
\index{FSUNMassKLUInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassKLUInit}}{\emph{IER}}{}
Initializes a KLU sparse \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUReInit}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUReInit()}}}} and {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUSetOrdering()}}}}
routines also support Fortran interfaces for the system and mass
matrix solvers:
\index{FSUNKLUReInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUReInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNKLUReInit}}{\emph{CODE}, \emph{NNZ}, \emph{REINIT\_TYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUReInit}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUReInit()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after}
{\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit}]{\sphinxcrossref{\sphinxcode{FSUNKLUInit()}}}} has been called.

\sphinxstylestrong{Arguments:} \sphinxstyleemphasis{NNZ} should have type \sphinxcode{long int}, all others
should have type \sphinxcode{int}; all arguments have meanings identical to
those listed above.

\end{fulllineitems}

\index{FSUNMassKLUReInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUReInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassKLUReInit}}{\emph{NNZ}, \emph{REINIT\_TYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUReInit}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUReInit()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after}
{\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit}]{\sphinxcrossref{\sphinxcode{FSUNMassKLUInit()}}}} has been called.

\sphinxstylestrong{Arguments:} \sphinxstyleemphasis{NNZ} should have type \sphinxcode{long int}, all others
should have type \sphinxcode{int}; all arguments have meanings identical to
those listed above.

\end{fulllineitems}

\index{FSUNKLUSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUSetOrdering}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNKLUSetOrdering}}{\emph{CODE}, \emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUSetOrdering()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit}]{\sphinxcrossref{\sphinxcode{FSUNKLUInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassKLUSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUSetOrdering}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassKLUSetOrdering}}{\emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:c.SUNLinSol_KLUSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_KLUSetOrdering()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit}]{\sphinxcrossref{\sphinxcode{FSUNMassKLUInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\subsection{SUNLinSol\_KLU Description}
\label{\detokenize{sunlinsol/SUNLinSol_KLU:sunlinsol-klu-description}}\label{\detokenize{sunlinsol/SUNLinSol_KLU:id2}}
The SUNLinSol\_KLU module defines the \sphinxstyleemphasis{content}
field of a \sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}KLU} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int}              \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{k+kt}{int}              \PYG{n}{first\PYGZus{}factorize}\PYG{p}{;}
  \PYG{n}{sun\PYGZus{}klu\PYGZus{}symbolic} \PYG{o}{*}\PYG{n}{symbolic}\PYG{p}{;}
  \PYG{n}{sun\PYGZus{}klu\PYGZus{}numeric}  \PYG{o}{*}\PYG{n}{numeric}\PYG{p}{;}
  \PYG{n}{sun\PYGZus{}klu\PYGZus{}common}   \PYG{n}{common}\PYG{p}{;}
  \PYG{n}{sunindextype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{klu\PYGZus{}solver}\PYG{p}{)}\PYG{p}{(}\PYG{n}{sun\PYGZus{}klu\PYGZus{}symbolic}\PYG{o}{*}\PYG{p}{,} \PYG{n}{sun\PYGZus{}klu\PYGZus{}numeric}\PYG{o}{*}\PYG{p}{,}
                                 \PYG{n}{sunindextype}\PYG{p}{,} \PYG{n}{sunindextype}\PYG{p}{,}
                                 \PYG{k+kt}{double}\PYG{o}{*}\PYG{p}{,} \PYG{n}{sun\PYGZus{}klu\PYGZus{}common}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{last\_flag} - last error return flag from internal function
evaluations,

\item {} 
\sphinxcode{first\_factorize} - flag indicating whether the factorization
has ever been performed,

\item {} 
\sphinxcode{Symbolic} - KLU storage structure for symbolic
factorization components, with underlying type \sphinxcode{klu\_symbolic}
or \sphinxcode{klu\_l\_symbolic}, depending on whether SUNDIALS was
installed with 32-bit versus 64-bit indices, respectively,

\item {} 
\sphinxcode{Numeric} - KLU storage structure for numeric factorization
components, with underlying type \sphinxcode{klu\_numeric}
or \sphinxcode{klu\_l\_numeric}, depending on whether SUNDIALS was
installed with 32-bit versus 64-bit indices, respectively,

\item {} 
\sphinxcode{Common} - storage structure for common KLU solver
components, with underlying type \sphinxcode{klu\_common}
or \sphinxcode{klu\_l\_common}, depending on whether SUNDIALS was
installed with 32-bit versus 64-bit indices, respectively,

\item {} 
\sphinxcode{klu\_solver} \textendash{} pointer to the appropriate KLU solver function
(depending on whether it is using a CSR or CSC sparse matrix, and
on whether SUNDIALS was installed with 32-bit or 64-bit indices).

\end{itemize}

The SUNLinSol\_KLU module is a \sphinxcode{SUNLinearSolver} wrapper for
the KLU sparse matrix factorization and solver library written by Tim
Davis (\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:id3}}{\hyperref[\detokenize{References:klu}]{\sphinxcrossref{{[}KLU{]}}}}, \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_KLU:id4}}{\hyperref[\detokenize{References:dp2010}]{\sphinxcrossref{{[}DP2010{]}}}}).  In order to use the
SUNLinSol\_KLU interface to KLU, it is assumed that KLU has
been installed on the system prior to installation of SUNDIALS, and
that SUNDIALS has been configured appropriately to link with KLU
(see section {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}} for details).
Additionally, this wrapper only supports double-precision
calculations, and therefore cannot be compiled if SUNDIALS is
configured to have \sphinxcode{realtype} set to either \sphinxcode{extended} or
\sphinxcode{single} (see section {\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}} for
details). Since the KLU library supports both 32-bit and 64-bit
integers, this interface will be compiled for either of the available
\sphinxcode{sunindextype} options.

The KLU library has a symbolic factorization routine that computes
the permutation of the linear system matrix to block triangular form
and the permutations that will pre-order the diagonal blocks (the only
ones that need to be factored) to reduce fill-in (using AMD, COLAMD,
CHOLAMD, natural, or an ordering given by the user).  Of these
ordering choices, the default value in the SUNLinSol\_KLU
module is the COLAMD ordering.

KLU breaks the factorization into two separate parts.  The first is
a symbolic factorization and the second is a numeric factorization
that returns the factored matrix along with final pivot information.
KLU also has a refactor routine that can be called instead of the numeric
factorization.  This routine will reuse the pivot information.  This routine
also returns diagnostic information that a user can examine to determine if
numerical stability is being lost and a full numerical factorization should
be done instead of the refactor.

Since the linear systems that arise within the context of SUNDIALS
calculations will typically have identical sparsity patterns, the
SUNLinSol\_KLU module is constructed to perform the
following operations:
\begin{itemize}
\item {} 
The first time that the “setup” routine is called, it
performs the symbolic factorization, followed by an initial
numerical factorization.

\item {} 
On subsequent calls to the “setup” routine, it calls the
appropriate KLU “refactor” routine, followed by estimates of
the numerical conditioning using the relevant “rcond”, and if
necessary “condest”, routine(s).  If these estimates of the
condition number are larger than \(\varepsilon^{-2/3}\) (where
\(\varepsilon\) is the double-precision unit roundoff), then a new
factorization is performed.

\item {} 
The module includes the routine \sphinxcode{SUNKLUReInit}, that
can be called by the user to force a full refactorization at the
next “setup” call.

\item {} 
The “solve” call performs pivoting and forward and
backward substitution using the stored KLU data structures.  We
note that in this solve KLU operates on the native data arrays
for the right-hand side and solution vectors, without requiring
costly data copies.

\end{itemize}

The SUNLinSol\_KLU module defines implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_KLU}

\item {} 
\sphinxcode{SUNLinSolInitialize\_KLU} \textendash{} this sets the
\sphinxcode{first\_factorize} flag to 1, forcing both symbolic and numerical
factorizations on the subsequent “setup” call.

\item {} 
\sphinxcode{SUNLinSolSetup\_KLU} \textendash{} this performs either a \(LU\)
factorization or refactorization of the input matrix.

\item {} 
\sphinxcode{SUNLinSolSolve\_KLU} \textendash{} this calls the appropriate KLU
solve routine to utilize the \(LU\) factors to solve the linear
system.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_KLU}

\item {} 
\sphinxcode{SUNLinSolSpace\_KLU} \textendash{} this only returns information for
the storage within the solver \sphinxstyleemphasis{interface}, i.e. storage for the
integers \sphinxcode{last\_flag} and \sphinxcode{first\_factorize}.  For additional
space requirements, see the KLU documentation.

\item {} 
\sphinxcode{SUNLinSolFree\_KLU}

\end{itemize}


\section{The SUNLinSol\_SuperLUDIST Module}
\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:the-sunlinsol-superludist-module}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST::doc}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:sunlinsol-superludist}}
The SuperLU\_DIST implementation of the SUNLinearSolver module provided with SUNDIALS,
SUNLinsol\_SuperLUDIST, is designed to be used with the SUNMatrix\_SLUNRloc SUNMatrix,
and one of the serial, threaded or parallel N\_Vector implementations (NVECTOR\_SERIAL,
NVECTOR\_OPENMP, NVECTOR\_PTHREADS, NVECTOR\_PARALLEL, NVECTOR\_PARHYP).


\subsection{SUNLinSol\_SuperLUDIST Usage}
\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:sunlinsol-superludist-usage}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:id1}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_superludist.h}.  The installed module
library to link to is \sphinxcode{libsundials\_sunlinsolsuperludist} \sphinxstyleemphasis{.lib}
where \sphinxstyleemphasis{.lib} is typically \sphinxcode{.so} for shared libraries and
\sphinxcode{.a} for static libraries.

The module SUNLinSol\_SuperLUDIST provides the following user-callable routines:
\begin{quote}\begin{description}
\item[{.. warning:}] \leavevmode
Starting with SuperLU\_DIST version 6.3.0, some structures were

\end{description}\end{quote}

renamed to have a prefix for the floating point type. The double precision API
functions have the prefix ‘d’. To maintain backwards compatibility with the
unprefixed types, SUNDIALS provides macros to these SuperLU\_DIST types with an
‘x’ prefix that expand to the correct prefix. E.g., the SUNDIALS macro
\sphinxcode{xLUstruct\_t} expands to \sphinxcode{dLUstruct\_t} or \sphinxcode{LUstruct\_t} based on the
SuperLU\_DIST version.
\index{SUNLinSol\_SuperLUDIST (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_SuperLUDIST}}{N\_Vector\sphinxstyleemphasis{ y}, SuperMatrix\sphinxstyleemphasis{ *A}, gridinfo\_t\sphinxstyleemphasis{ *grid}, xLUstruct\_t\sphinxstyleemphasis{ *lu}, xScalePermstruct\_t\sphinxstyleemphasis{ *scaleperm}, xSOLVEstruct\_t\sphinxstyleemphasis{ *solve}, SuperLUStat\_t\sphinxstyleemphasis{ *stat}, superlu\_dist\_options\_t\sphinxstyleemphasis{ *options}}{}
This constructor function creates and allocates memory for a SUNLinSol\_SuperLUDIST
object. Its arguments are an \sphinxcode{N\_Vector}, a \sphinxcode{SUNMatrix}, and SuperLU\_DIST
\sphinxcode{gridinfo\_t*}, \sphinxcode{LUstuct\_t*}, \sphinxcode{xScalePermstruct\_t*}, \sphinxcode{xSOLVEstruct\_t*},
\sphinxcode{SuperLUStat\_t*}, and \sphinxcode{superlu\_dist\_options\_t*} pointers. This routine
analyzes the input matrix and vector to determine the linear system size and
to assess the compatibility with the SuperLU\_DIST library.

This routine will perform consistency checks to ensure that it is called with
consistent N\_Vector and SUNMatrix implementations. These are currently limited
to the SUNMatrix\_SLUNRloc matrix type and the NVECTOR\_SERIAL, NVECTOR\_OPENMP,
NVECTOR\_PTHREADS, NVECTOR\_PARALLEL, and NVECTOR\_PARHYP vector types. As
additional compatible matrix and vector implementations are added to SUNDIALS,
these will be included within this compatibility check.

The \sphinxcode{grid}, \sphinxcode{lu}, \sphinxcode{scaleperm}, \sphinxcode{solve}, and \sphinxcode{options} arguments are
not checked and are passed directly to SuperLU\_DIST routines.

Some struct members of the \sphinxcode{options} argument are modified internally by
the SUNLinSol\_SuperLUDIST solver. Specifically, the member \sphinxcode{Fact}
is modified in the setup and solve routines.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetBerr (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetBerr}}\pysiglinewithargsret{realtype \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetBerr}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns the componentwise relative backward error of the
computed solution. It takes one argument, the \sphinxcode{SUNLinearSolver} object.
The return type is \sphinxcode{realtype}.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetGridinfo (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetGridinfo}}\pysiglinewithargsret{gridinfo\_t* \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetGridinfo}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns a pointer to the SuperLU\_DIST structure that
contains the 2D process grid. It takes one argument, the \sphinxcode{SUNLinearSolver}
object.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetLUstruct (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetLUstruct}}\pysiglinewithargsret{xLUstruct\_t* \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetLUstruct}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns a pointer to the SuperLU\_DIST structure that contains
the distributed \sphinxcode{L} and \sphinxcode{U} structures. It takes one argument, the
\sphinxcode{SUNLinearSolver} object.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetSuperLUOptions (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetSuperLUOptions}}\pysiglinewithargsret{superlu\_dist\_options\_t* \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetSuperLUOptions}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns a pointer to the SuperLU\_DIST structure that contains the
options which control how the linear system is factorized and solved. It takes
one argument, the \sphinxcode{SUNLinearSolver} object.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetScalePermstruct (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetScalePermstruct}}\pysiglinewithargsret{xScalePermstruct\_t* \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetScalePermstruct}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns a pointer to the SuperLU\_DIST structure that contains
the vectors that describe the transformations done to the matrix \sphinxcode{A}. It
takes one argument, the \sphinxcode{SUNLinearSolver} object.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetSOLVEstruct (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetSOLVEstruct}}\pysiglinewithargsret{xSOLVEstruct\_t* \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetSOLVEstruct}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns a pointer to the SuperLU\_DIST structure that contains
information for communication during the solution phase. It takes one argument
the \sphinxcode{SUNLinearSolver} object.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUDIST\_GetSuperLUStat (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:c.SUNLinSol_SuperLUDIST_GetSuperLUStat}}\pysiglinewithargsret{SuperLUStat\_t* \sphinxbfcode{SUNLinSol\_SuperLUDIST\_GetSuperLUStat}}{SUNLinearSolver\sphinxstyleemphasis{ LS}}{}
This function returns a pointer to the SuperLU\_DIST structure that stores
information about runtime and flop count. It takes one argument, the
\sphinxcode{SUNLinearSolver} object.

\end{fulllineitems}



\subsection{SUNLinSol\_SuperLUDIST Description}
\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:sunlinsol-superludist-description}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:id2}}
The SUNLinSol\_SuperLUDIST module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SuperLUDIST} \PYG{p}{\PYGZob{}}
  \PYG{n}{booleantype}             \PYG{n}{first\PYGZus{}factorize}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{realtype}                \PYG{n}{berr}\PYG{p}{;}
  \PYG{n}{gridinfo\PYGZus{}t}              \PYG{o}{*}\PYG{n}{grid}\PYG{p}{;}
  \PYG{n}{xLUstruct\PYGZus{}t}             \PYG{o}{*}\PYG{n}{lu}\PYG{p}{;}
  \PYG{n}{superlu\PYGZus{}dist\PYGZus{}options\PYGZus{}t}  \PYG{o}{*}\PYG{n}{options}\PYG{p}{;}
  \PYG{n}{xScalePermstruct\PYGZus{}t}      \PYG{o}{*}\PYG{n}{scaleperm}\PYG{p}{;}
  \PYG{n}{xSOLVEstruct\PYGZus{}t}          \PYG{o}{*}\PYG{n}{solve}\PYG{p}{;}
  \PYG{n}{SuperLUStat\PYGZus{}t}           \PYG{o}{*}\PYG{n}{stat}\PYG{p}{;}
  \PYG{n}{sunindextype}            \PYG{n}{N}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{first\_factorize} \textendash{} flag indicating whether the factorization
has ever been performed,

\item {} 
\sphinxcode{last\_flag} \textendash{} last error return flag from internal function
evaluations,

\item {} 
\sphinxcode{berr} \textendash{} the componentwise relative backward error of the computed solution,

\item {} 
\sphinxcode{grid} \textendash{} pointer to the SuperLU\_DIST structure that strores the 2D process grid

\item {} 
\sphinxcode{lu} \textendash{} pointer to the SuperLU\_DIST structure that stores the distributed \sphinxcode{L}
and \sphinxcode{U} factors,

\item {} 
\sphinxcode{scaleperm} \textendash{} pointer to the SuperLU\_DIST structure that stores vectors describing
the transformations done to the matrix \sphinxcode{A},

\item {} 
\sphinxcode{options} \textendash{} pointer to the SuperLU\_DIST stucture which contains options that control
how the linear system is factorized and solved,

\item {} 
\sphinxcode{solve} \textendash{} pointer to the SuperLU\_DIST solve structure,

\item {} 
\sphinxcode{stat} \textendash{} pointer to the SuperLU\_DIST structure that stores information about runtime
and flop count,

\item {} 
\sphinxcode{N} \textendash{} the number of equations in the system.

\end{itemize}

The SUNLinSol\_SuperLUDIST module is a SUNLinearSolver adapter for the
SuperLU\_DIST sparse matrix factorization and solver library written by
X. Sherry Li (\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:id3}}{\hyperref[\detokenize{References:superludist}]{\sphinxcrossref{{[}SuperLUDIST{]}}}}, \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:id4}}{\hyperref[\detokenize{References:gdl2007}]{\sphinxcrossref{{[}GDL2007{]}}}}, \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:id5}}{\hyperref[\detokenize{References:ld2003}]{\sphinxcrossref{{[}LD2003{]}}}}, \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUDIST:id6}}{\hyperref[\detokenize{References:sluug1999}]{\sphinxcrossref{{[}SLUUG1999{]}}}}).
The package uses a SPMD parallel programming model and multithreading
to enhance efficiency in distributed-memory parallel environments with
multicore nodes and possibly GPU accelerators. It uses MPI for communication,
OpenMP for threading, and CUDA for GPU support. In order to use the
SUNLinSol\_SuperLUDIST interface to SuperLU\_DIST, it is assumed that SuperLU\_DIST
has been installed on the system prior to installation of SUNDIALS, and
that SUNDIALS has been configured appropriately to link with SuperLU\_DIST
(see Appendix {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}} for details).
Additionally, the wrapper only
supports double-precision calculations, and therefore cannot be compiled if SUNDIALS
is configured to use single or extended precision. Moreover, since the SuperLU\_DIST
library may be installed to support either 32-bit or 64-bit integers,
it is assumed that the SuperLU\_DIST library is installed using the same
integer size as SUNDIALS.

The SuperLU\_DIST library provides many options to control how a linear
system will be factorized and solved. These options may be set by a user
on an instance of the \sphinxcode{superlu\_dist\_options\_t} struct, and then it may be provided
as an argument to the SUNLinSol\_SuperLUDIST constructor. The SUNLinSol\_SuperLUDIST
module will respect all options set except for \sphinxcode{Fact} \textendash{} this option is
necessarily modified by the SUNLinSol\_SuperLUDIST module in the setup and solve routines.

Since the linear systems that arise within the context of SUNDIALS calculations will
typically have identical sparsity patterns, the SUNLinSol\_SuperLUDIST module is
constructed to perform the following operations:
\begin{itemize}
\item {} 
The first time that the “setup” routine is called, it
sets the SuperLU\_DIST option \sphinxcode{Fact} to \sphinxcode{DOFACT} so that a subsequent
call to the “solve” routine will perform a symbolic factorization,
followed by an initial numerical factorization before continuing
to solve the system.

\item {} 
On subsequent calls to the “setup” routine, it sets the
SuperLU\_DIST option \sphinxcode{Fact} to \sphinxcode{SamePattern} so that
a subsequent call to “solve” will perform factorization assuming
the same sparsity pattern as prior, i.e. it will reuse the column
permutation vector.

\item {} 
If “setup” is called prior to the “solve” routine, then the “solve” routine
will perform a symbolic factorization, followed by an initial
numerical factorization before continuing to the sparse triangular
solves, and, potentially, iterative refinement. If “setup” is not
called prior, “solve” will skip to the triangular solve step. We
note that in this solve SuperLU\_DIST operates on the native data arrays
for the right-hand side and solution vectors, without requiring costly data copies.

\end{itemize}

The SUNLinSol\_SuperLUDIST module defines implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_SuperLUDIST}

\item {} 
\sphinxcode{SUNLinSolInitialize\_SuperLUDIST} \textendash{} this sets the
\sphinxcode{first\_factorize} flag to 1 and resets the internal SuperLU\_DIST
statistics variables.

\item {} 
\sphinxcode{SUNLinSolSetup\_SuperLUDIST} \textendash{} this sets the appropriate
SuperLU\_DIST options so that a subsequent solve will perform a
symbolic and numerical factorization before proceeding with the
triangular solves

\item {} 
\sphinxcode{SUNLinSolSolve\_SuperLUDIST} \textendash{} this calls the SuperLU\_DIST
solve routine to perform factorization (if the setup routine
was called prior) and then use the \$LU\$ factors to solve the
linear system.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_SuperLUDIST}

\item {} 
\sphinxcode{SUNLinSolSpace\_SuperLUDIST} \textendash{} this only returns information for
the storage within the solver \sphinxstyleemphasis{interface}, i.e. storage for the
integers \sphinxcode{last\_flag} and \sphinxcode{first\_factorize}.  For additional
space requirements, see the SuperLU\_DIST documentation.

\item {} 
\sphinxcode{SUNLinSolFree\_SuperLUDIST}

\end{itemize}


\section{The SUNLinSol\_SuperLUMT Module}
\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:sunlinsol-superlumt}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT::doc}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:the-sunlinsol-superlumt-module}}
The SuperLU\_MT implementation of the \sphinxcode{SUNLinearSolver} module
provided with SUNDIALS, SUNLinSol\_SuperLUMT, is designed to be used
with the corresponding SUNMATRIX\_SPARSE matrix type, and one of the
serial or shared-memory \sphinxcode{N\_Vector} implementations (NVECTOR\_SERIAL,
NVECTOR\_OPENMP, or NVECTOR\_PTHREADS).  While these are compatible, it
is not recommended to use a threaded vector module with
SUNLinSol\_SuperLUMT unless it is the NVECTOR\_OPENMP module and the
SuperLU\_MT library has also been compiled with OpenMP.


\subsection{SUNLinSol\_SuperLUMT Usage}
\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:sunlinsol-superlumt-usage}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:id1}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_superlumt.h}.  The installed module
library to link to is \sphinxcode{libsundials\_sunlinsolsuperlumt} \sphinxstyleemphasis{.lib}
where \sphinxstyleemphasis{.lib} is typically \sphinxcode{.so} for shared libraries and
\sphinxcode{.a} for static libraries.

The module SUNLinSol\_SuperLUMT provides the following user-callable routines:
\index{SUNLinSol\_SuperLUMT (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMT}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_SuperLUMT}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}, int\sphinxstyleemphasis{ num\_threads}}{}
This constructor function creates and allocates memory for a
SUNLinSol\_SuperLUMT object.  Its arguments are an \sphinxcode{N\_Vector}, a
\sphinxcode{SUNMatrix}, and a desired number of threads (OpenMP or Pthreads,
depending on how SuperLU\_MT was installed) to use during the
factorization steps. This routine analyzes the input matrix and
vector to determine the linear system size and to assess
compatibility with the SuperLU\_MT library.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector} and \sphinxcode{SUNMatrix}
implementations.  These are currently limited to the
SUNMATRIX\_SPARSE matrix type (using either CSR or CSC storage
formats) and the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and
NVECTOR\_PTHREADS vector types.  As additional compatible matrix and
vector implementations are added to SUNDIALS, these will be
included within this compatibility check.

If either \sphinxcode{A} or \sphinxcode{y} are incompatible then this routine will
return \sphinxcode{NULL}.  The \sphinxcode{num\_threads} argument is not checked
and is passed directly to SuperLU\_MT routines.

\end{fulllineitems}

\index{SUNLinSol\_SuperLUMTSetOrdering (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMTSetOrdering}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SuperLUMTSetOrdering}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ ordering\_choice}}{}
This function sets the ordering used by SuperLU\_MT for reducing fill in
the linear solve.  Options for \sphinxcode{ordering\_choice} are:
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
natural ordering

\item {} 
minimal degree ordering on \(A^TA\)

\item {} 
minimal degree ordering on \(A^T+A\)

\item {} 
COLAMD ordering for unsymmetric matrices

\end{enumerate}

The default is 3 for COLAMD.

The return values from this function are \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}), \sphinxcode{SUNLS\_ILL\_INPUT}
(invalid \sphinxcode{ordering\_choice}), or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNSuperLUMT (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMT}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNSuperLUMT}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}, int\sphinxstyleemphasis{ num\_threads}}{}
Wrapper for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMT}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMT()}}}}.

\end{fulllineitems}


and
\index{SUNSuperLUMTSetOrdering (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMTSetOrdering}}\pysiglinewithargsret{int \sphinxbfcode{SUNSuperLUMTSetOrdering}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ ordering\_choice}}{}
Wrapper for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMTSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMTSetOrdering()}}}}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_SuperLUMT module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTInit}]{\sphinxcrossref{\sphinxcode{FSUNSuperLUMTInit()}}}} to initialize this
SUNLinSol\_SuperLUMT module for a given SUNDIALS solver.
\index{FSUNSuperLUMTInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSuperLUMTInit}}{\emph{CODE}, \emph{NUM\_THREADS}, \emph{IER}}{}
Initializes a SuperLU\_MT sparse \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
\sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{NUM\_THREADS} (\sphinxcode{int}, input) \textendash{} desired number of
OpenMP/Pthreads threads to use in the factorization.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSuperLUMTInit()}}}}
initializes this SUNLinSol\_SuperLUMT module for solving mass matrix
linear systems.
\index{FSUNMassSuperLUMTInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSuperLUMTInit}}{\emph{NUM\_THREADS}, \emph{IER}}{}
Initializes a SuperLU\_MT sparse \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} both the \sphinxcode{N\_Vector} and
the mass \sphinxcode{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NUM\_THREADS} (\sphinxcode{int}, input) \textendash{} desired number of
OpenMP/Pthreads threads to use in the factorization.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMTSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMTSetOrdering()}}}} routine also supports Fortran
interfaces for the system and mass matrix solvers:
\index{FSUNSuperLUMTSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTSetOrdering}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSuperLUMTSetOrdering}}{\emph{CODE}, \emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMTSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMTSetOrdering()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after}
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTInit}]{\sphinxcrossref{\sphinxcode{FSUNSuperLUMTInit()}}}} has been called

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int} and have meanings
identical to those listed above

\end{fulllineitems}

\index{FSUNMassSuperLUMTSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTSetOrdering}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSuperLUMTSetOrdering}}{\emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:c.SUNLinSol_SuperLUMTSetOrdering}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SuperLUMTSetOrdering()}}}} for mass
matrix linear solves in ARKode.

This routine must be called \sphinxstyleemphasis{after}
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSuperLUMTInit()}}}} has been called

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int} and have meanings
identical to those listed above

\end{fulllineitems}



\subsection{SUNLinSol\_SuperLUMT Description}
\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:id2}}\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:sunlinsol-superlumt-description}}
The SUNLinSol\_SuperLUMT module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SuperLUMT} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int}          \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{first\PYGZus{}factorize}\PYG{p}{;}
  \PYG{n}{SuperMatrix}  \PYG{o}{*}\PYG{n}{A}\PYG{p}{,} \PYG{o}{*}\PYG{n}{AC}\PYG{p}{,} \PYG{o}{*}\PYG{n}{L}\PYG{p}{,} \PYG{o}{*}\PYG{n}{U}\PYG{p}{,} \PYG{o}{*}\PYG{n}{B}\PYG{p}{;}
  \PYG{n}{Gstat\PYGZus{}t}      \PYG{o}{*}\PYG{n}{Gstat}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{perm\PYGZus{}r}\PYG{p}{,} \PYG{o}{*}\PYG{n}{perm\PYGZus{}c}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{num\PYGZus{}threads}\PYG{p}{;}
  \PYG{n}{realtype}     \PYG{n}{diag\PYGZus{}pivot\PYGZus{}thresh}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{ordering}\PYG{p}{;}
  \PYG{n}{superlumt\PYGZus{}options\PYGZus{}t} \PYG{o}{*}\PYG{n}{options}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{last\_flag} - last error return flag from internal function
evaluations,

\item {} 
\sphinxcode{first\_factorize} - flag indicating whether the factorization
has ever been performed,

\item {} 
\sphinxcode{A, AC, L, U, B} - \sphinxcode{SuperMatrix} pointers used in solve,

\item {} 
\sphinxcode{Gstat} - \sphinxcode{GStat\_t} object used in solve,

\item {} 
\sphinxcode{perm\_r, perm\_c} - permutation arrays used in solve,

\item {} 
\sphinxcode{N} - size of the linear system,

\item {} 
\sphinxcode{num\_threads} - number of OpenMP/Pthreads threads to use,

\item {} 
\sphinxcode{diag\_pivot\_thresh} - threshold on diagonal pivoting,

\item {} 
\sphinxcode{ordering} - flag for which reordering algorithm to use,

\item {} 
\sphinxcode{options} - pointer to SuperLU\_MT options structure.

\end{itemize}

The SUNLinSol\_SuperLUMT module is a \sphinxcode{SUNLinearSolver} wrapper for
the SuperLU\_MT sparse matrix factorization and solver library
written by X. Sherry Li (\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:id3}}{\hyperref[\detokenize{References:superlumt}]{\sphinxcrossref{{[}SuperLUMT{]}}}}, \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:id4}}{\hyperref[\detokenize{References:l2005}]{\sphinxcrossref{{[}L2005{]}}}}, \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SuperLUMT:id5}}{\hyperref[\detokenize{References:dgl1999}]{\sphinxcrossref{{[}DGL1999{]}}}}).  The
package performs matrix factorization using threads to enhance
efficiency in shared memory parallel environments.  It should be noted
that threads are only used in the factorization step.  In
order to use the SUNLinSol\_SuperLUMT interface to SuperLU\_MT, it is
assumed that SuperLU\_MT has been installed on the system prior to
installation of SUNDIALS, and that SUNDIALS has been configured
appropriately to link with SuperLU\_MT (see section
{\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}} for details).
Additionally, this wrapper only supports single- and
double-precision calculations, and therefore cannot be compiled if
SUNDIALS is configured to have \sphinxcode{realtype} set to \sphinxcode{extended}
(see section {\hyperref[\detokenize{ARKStep_c_interface/General:arkstep-cinterface-datatypes}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Types}}}} for details).  Moreover,
since the SuperLU\_MT library may be installed to support either 32-bit
or 64-bit integers, it is assumed that the SuperLU\_MT library is
installed using the same integer precision as the SUNDIALS
\sphinxcode{sunindextype} option.

The SuperLU\_MT library has a symbolic factorization routine that
computes the permutation of the linear system matrix to reduce fill-in
on subsequent \(LU\) factorizations (using COLAMD, minimal degree
ordering on \(A^T*A\), minimal degree ordering on \(A^T+A\),
or natural ordering).  Of these ordering choices, the default value in
the SUNLinSol\_SuperLUMT module is the COLAMD ordering.

Since the linear systems that arise within the context of SUNDIALS
calculations will typically have identical sparsity patterns, the
SUNLinSol\_SuperLUMT module is constructed to perform the
following operations:
\begin{itemize}
\item {} 
The first time that the “setup” routine is called, it
performs the symbolic factorization, followed by an initial
numerical factorization.

\item {} 
On subsequent calls to the “setup” routine, it skips the
symbolic factorization, and only refactors the input matrix.

\item {} 
The “solve” call performs pivoting and forward and
backward substitution using the stored SuperLU\_MT data
structures.  We note that in this solve SuperLU\_MT operates on the
native data arrays for the right-hand side and solution vectors,
without requiring costly data copies.

\end{itemize}

The SUNLinSol\_SuperLUMT module defines implementations of all
“direct” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_SuperLUMT}

\item {} 
\sphinxcode{SUNLinSolInitialize\_SuperLUMT} \textendash{} this sets the
\sphinxcode{first\_factorize} flag to 1 and resets the internal SuperLU\_MT
statistics variables.

\item {} 
\sphinxcode{SUNLinSolSetup\_SuperLUMT} \textendash{} this performs either a \(LU\)
factorization or refactorization of the input matrix.

\item {} 
\sphinxcode{SUNLinSolSolve\_SuperLUMT} \textendash{} this calls the appropriate
SuperLU\_MT solve routine to utilize the \(LU\) factors to solve the
linear system.

\item {} 
\sphinxcode{SUNLinSolLastFlag\_SuperLUMT}

\item {} 
\sphinxcode{SUNLinSolSpace\_SuperLUMT} \textendash{} this only returns information for
the storage within the solver \sphinxstyleemphasis{interface}, i.e. storage for the
integers \sphinxcode{last\_flag} and \sphinxcode{first\_factorize}.  For additional
space requirements, see the SuperLU\_MT documentation.

\item {} 
\sphinxcode{SUNLinSolFree\_SuperLUMT}

\end{itemize}


\section{The SUNLinSol\_cuSolverSp\_batchQR Module}
\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp}}\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp::doc}}\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:the-sunlinsol-cusolversp-batchqr-module}}
The \sphinxcode{SUNLinearSolver\_cuSolverSp\_batchQR} implementation of the SUNLinearSolver API is
designed to be used with the SUNMATRIX\_CUSPARSE matrix, and the NVECTOR\_CUDA vector.
The header file to include when using this module is
\sphinxcode{sunlinsol/sunlinsol\_cusolversp\_batchqr.h}. The installed library to link to
is \sphinxcode{libsundials\_sunlinsolcusolversp.lib} where \sphinxcode{.lib} is typically
\sphinxcode{.so} for shared libraries and \sphinxcode{.a} for static libraries.

\sphinxstylestrong{The SUNLinearSolver\_cuSolverSp\_batchQR module is experimental and subject to change.}


\subsection{SUNLinSol\_cuSolverSp\_batchQR description}
\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp-batchqr-description}}\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp-description}}
The SUNLinearSolver\_cuSolverSp\_batchQR implementation provides an interface to
the batched sparse QR factorization method provided by the NVIDIA cuSOLVER library (\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:id1}}{\hyperref[\detokenize{References:cusolver}]{\sphinxcrossref{{[}cuSOLVER{]}}}}).
The module is designed for solving block diagonal linear systems of the form
\begin{equation*}
\begin{split}\begin{bmatrix}
   \mathbf{A_1} & 0 & \cdots & 0\\
   0 & \mathbf{A_2} & \cdots & 0\\
   \vdots & \vdots & \ddots & \vdots\\
   0 & 0 & \cdots & \mathbf{A_n}\\
\end{bmatrix}
x_j
=
b_j\end{split}
\end{equation*}
where all block matrices \(\mathbf{A_j}\) share the same sparsisty pattern. The matrix
must be the {\hyperref[\detokenize{sunmatrix/SUNMatrix_cuSparse:sunmatrix-cusparse}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNMATRIX\_CUSPARSE Module}}}}.


\subsection{SUNLinSol\_cuSolverSp\_batchQR functions}
\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp-batchqr-functions}}\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp-functions}}
The \sphinxcode{SUNLinearSolver\_cuSolverSp\_batchQR} module defines implementations of
all “direct” linear solver operations listed in {\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_cuSolverSp\_batchQR}

\item {} 
\sphinxcode{SUNLinSolInitialize\_cuSolverSp\_batchQR} \textendash{} this sets the
\sphinxcode{first\_factorize} flag to 1

\item {} 
\sphinxcode{SUNLinSolSetup\_cuSolverSp\_batchQR} \textendash{} this always copies the
relevant SUNMATRIX\_SPARSE data to the GPU; if this is the first setup
it will perform symbolic analysis on the system

\item {} 
\sphinxcode{SUNLinSolSolve\_cuSolverSp\_batchQR} \textendash{} this calls the
\sphinxcode{cusolverSpXcsrqrsvBatched} routine to perform factorization

\item {} 
\sphinxcode{SUNLinSolLastFlag\_cuSolverSp\_batchQR}

\item {} 
\sphinxcode{SUNLinSolFree\_cuSolverSp\_batchQR}

\end{itemize}

In addition, the module provides the following user-callable routines:
\index{SUNLinSol\_cuSolverSp\_batchQR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:c.SUNLinSol_cuSolverSp_batchQR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_cuSolverSp\_batchQR}}{N\_Vector\sphinxstyleemphasis{ y}, SUNMatrix\sphinxstyleemphasis{ A}, cusolverHandle\_t\sphinxstyleemphasis{ cusol}}{}
The function \sphinxcode{SUNLinSol\_cuSolverSp\_batchQR} creates and allocates
memory for a SUNLinearSolver object.

This returns a SUNLinearSolver object.  If either \sphinxcode{A} or
\sphinxcode{y} are incompatible then this routine will return \sphinxcode{NULL}.

This routine analyzes the input matrix and vector to determine the
linear system size and to assess compatibility with the solver.

This routine will perform consistency checks to ensure that it is
called with consistent \sphinxcode{N\_Vector}  and \sphinxcode{SUNMatrix}  implementations.
These are currently limited to the SUNMATRIX\_CUSPARSE matrix type
and the NVECTOR\_CUDA vector type. Since the SUNMATRIX\_CUSPARSE matrix
type is only compatible with the NVECTOR\_CUDA the restriction is also
in place for the linear solver. As additional compatible matrix and
vector implementations are added to SUNDIALS, these will be included
within this compatibility check.

\end{fulllineitems}

\index{SUNLinSol\_cuSolverSp\_batchQR\_GetDescription (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:c.SUNLinSol_cuSolverSp_batchQR_GetDescription}}\pysiglinewithargsret{void \sphinxbfcode{SUNLinSol\_cuSolverSp\_batchQR\_GetDescription}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, char\sphinxstyleemphasis{ **desc}}{}
The function \sphinxcode{SUNLinSol\_cuSolverSp\_batchQR\_GetDescription}
accesses the string description of the object (empty by default).

\end{fulllineitems}

\index{SUNLinSol\_cuSolverSp\_batchQR\_SetDescription (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:c.SUNLinSol_cuSolverSp_batchQR_SetDescription}}\pysiglinewithargsret{void \sphinxbfcode{SUNLinSol\_cuSolverSp\_batchQR\_SetDescription}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, const char\sphinxstyleemphasis{ *desc}}{}
The function \sphinxcode{SUNLinSol\_cuSolverSp\_batchQR\_SetDescription}
sets the string description of the object (empty by default).

\end{fulllineitems}

\index{SUNLinSol\_cuSolverSp\_batchQR\_GetDeviceSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:c.SUNLinSol_cuSolverSp_batchQR_GetDeviceSpace}}\pysiglinewithargsret{void \sphinxbfcode{SUNLinSol\_cuSolverSp\_batchQR\_GetDeviceSpace}}{SUNLinearSolver\sphinxstyleemphasis{ S}, size\_t*\sphinxstyleemphasis{ cuSolverInternal}, size\_t*\sphinxstyleemphasis{ cuSolverWorkspace}}{}
The function \sphinxcode{SUNLinSol\_cuSolverSp\_batchQR\_GetDeviceSpace}
returns the cuSOLVER batch QR method internal buffer size, in bytes,
in the argument \sphinxcode{cuSolverInternal} and the cuSOLVER
batch QR workspace buffer size, in bytes, in the agrument
\sphinxcode{cuSolverWorkspace}. The size of the internal buffer is
proportional to the number of matrix blocks while the size
of the workspace is almost independent of the number of blocks.

\end{fulllineitems}



\subsection{SUNLinSol\_cuSolverSp\_batchQR content}
\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp-content}}\label{\detokenize{sunlinsol/SUNLinSol_cuSolverSp:sunlinsol-cusolversp-batchqr-content}}
The SUNLinSol\_cuSolverSp\_batchQR module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}cuSolverSp\PYGZus{}batchQR} \PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}                \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}       \PYG{c+cm}{/* last return flag                          */}
   \PYG{n}{booleantype}        \PYG{n}{first\PYGZus{}factorize}\PYG{p}{;} \PYG{c+cm}{/* is this the first factorization?          */}
   \PYG{k+kt}{size\PYGZus{}t}             \PYG{n}{internal\PYGZus{}size}\PYG{p}{;}   \PYG{c+cm}{/* size of cusolver buffer for Q and R       */}
   \PYG{k+kt}{size\PYGZus{}t}             \PYG{n}{workspace\PYGZus{}size}\PYG{p}{;}  \PYG{c+cm}{/* size of cusolver memory for factorization */}
   \PYG{n}{cusolverSpHandle\PYGZus{}t} \PYG{n}{cusolver\PYGZus{}handle}\PYG{p}{;} \PYG{c+cm}{/* cuSolverSp context                        */}
   \PYG{n}{csrqrInfo\PYGZus{}t}        \PYG{n}{info}\PYG{p}{;}            \PYG{c+cm}{/* opaque cusolver data structure            */}
   \PYG{k+kt}{void}\PYG{o}{*}              \PYG{n}{workspace}\PYG{p}{;}       \PYG{c+cm}{/* memory block used by cusolver             */}
   \PYG{k}{const} \PYG{k+kt}{char}\PYG{o}{*}        \PYG{n}{desc}\PYG{p}{;}            \PYG{c+cm}{/* description of this linear solver         */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{The SUNLinSol\_SPGMR Module}
\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:the-sunlinsol-spgmr-module}}\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:sunlinsol-spgmr}}\label{\detokenize{sunlinsol/SUNLinSol_SPGMR::doc}}
The SPGMR (Scaled, Preconditioned, Generalized Minimum
Residual \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:id1}}{\hyperref[\detokenize{References:ss1986}]{\sphinxcrossref{{[}SS1986{]}}}}) implementation of the \sphinxcode{SUNLinearSolver} module
provided with SUNDIALS, SUNLinSol\_SPGMR, is an iterative linear
solver that is designed to be compatible with any \sphinxcode{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScale}]{\sphinxcrossref{\sphinxcode{N\_VScale()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VProd}]{\sphinxcrossref{\sphinxcode{N\_VProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConst}]{\sphinxcrossref{\sphinxcode{N\_VConst()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDiv}]{\sphinxcrossref{\sphinxcode{N\_VDiv()}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}}).


\subsection{SUNLinSol\_SPGMR Usage}
\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:sunlinsol-spgmr-usage}}\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:id2}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_spgmr.h}.  The SUNinSol\_SPGMR module
is accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the \sphinxcode{libsundials\_sunlinsolspgmr} module library.

The module SUNLinSol\_SPGMR provides the following
user-callable routines:
\index{SUNLinSol\_SPGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_SPGMR}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
This constructor function creates and allocates memory for a SPGMR
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector}, the desired
type of preconditioning, and the number of Krylov basis vectors to use.

This routine will perform consistency checks to ensure that it is
called with a consistent \sphinxcode{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \sphinxcode{y} is
incompatible, then this routine will return \sphinxcode{NULL}.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

Allowable inputs for \sphinxcode{pretype} are \sphinxcode{PREC\_NONE} (0),
\sphinxcode{PREC\_LEFT} (1), \sphinxcode{PREC\_RIGHT} (2) and \sphinxcode{PREC\_BOTH} (3);
any other integer input will result in the default (no
preconditioning).  We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS) and others
with only right preconditioning (KINSOL). While it is possible to
configure a SUNLinSol\_SPGMR object to use any of the
preconditioning options with these solvers, this use mode is not
supported and may result in inferior performance.

\end{fulllineitems}

\index{SUNLinSol\_SPGMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPGMRSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
This function updates the type of preconditioning to use.  Supported
values are \sphinxcode{PREC\_NONE} (0), \sphinxcode{PREC\_LEFT} (1),
\sphinxcode{PREC\_RIGHT} (2) and \sphinxcode{PREC\_BOTH} (3).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_ILL\_INPUT} (illegal \sphinxcode{pretype}), \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_SPGMRSetGSType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetGSType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPGMRSetGSType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ gstype}}{}
This function sets the type of Gram-Schmidt orthogonalization to
use.  Supported values are \sphinxcode{MODIFIED\_GS} (1) and
\sphinxcode{CLASSICAL\_GS} (2).  Any other integer input will result in a
failure, returning error code \sphinxcode{SUNLS\_ILL\_INPUT}.

This routine will return with one of the error codes
\sphinxcode{SUNLS\_ILL\_INPUT} (illegal \sphinxcode{gstype}), \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_SPGMRSetMaxRestarts (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetMaxRestarts}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPGMRSetMaxRestarts}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxrs}}{}
This function sets the number of GMRES restarts to
allow.  A negative input will result in the default of 0.

This routine will return with one of the error codes
\sphinxcode{SUNLS\_MEM\_NULL} (\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSolSetInfoFile\_SPGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSolSetInfoFile_SPGMR}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetInfoFile\_SPGMR}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSolSetInfoFile_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetInfoFile\_SPGMR()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} 
\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);
a \sphinxcode{NULL} input will disable output

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNLinSolSetPrintLevel\_SPGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSolSetPrintLevel_SPGMR}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetPrintLevel\_SPGMR}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSolSetPrintLevel_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetPrintLevel\_SPGMR()}}}} specifies the
level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each linear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled, or
if the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNSPGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNSPGMR}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMR()}}}}

\end{fulllineitems}

\index{SUNSPGMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPGMRSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetPrecType()}}}}

\end{fulllineitems}

\index{SUNSPGMRSetGSType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetGSType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPGMRSetGSType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ gstype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetGSType()}}}}

\end{fulllineitems}

\index{SUNSPGMRSetMaxRestarts (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetMaxRestarts}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPGMRSetMaxRestarts}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxrs}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetMaxRestarts}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetMaxRestarts()}}}}

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_SPGMR module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPGMRInit()}}}} to initialize
this SUNLinSol\_SPGMR module for a given SUNDIALS solver.
\index{FSUNSPGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPGMRInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPGMR \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of GMRES basis vectors to use.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPGMRInit()}}}} initializes
this SUNLinSol\_SPGMR module for solving mass matrix linear systems.
\index{FSUNMassSPGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPGMRInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPGMR \sphinxcode{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of GMRES basis vectors to use.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetGSType()}}}}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetPrecType()}}}} and
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetMaxRestarts}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetMaxRestarts()}}}} routines also support Fortran
interfaces for the system and mass matrix solvers:
\index{FSUNSPGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRSetGSType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPGMRSetGSType}}{\emph{CODE}, \emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetGSType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRSetGSType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPGMRSetGSType}}{\emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetGSType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPGMRSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetPrecType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPGMRSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:c.SUNLinSol_SPGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPGMRSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRSetMaxRS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPGMRSetMaxRS}}{\emph{CODE}, \emph{MAXRS}, \emph{IER}}{}
Fortran interface to \sphinxcode{SUNLinSol\_SPGMRSetMaxRS()} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRSetMaxRS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPGMRSetMaxRS}}{\emph{MAXRS}, \emph{IER}}{}
Fortran interface to \sphinxcode{SUNLinSol\_SPGMRSetMaxRS()} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\subsection{SUNLinSol\_SPGMR Description}
\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:sunlinsol-spgmr-description}}\label{\detokenize{sunlinsol/SUNLinSol_SPGMR:id3}}
The SUNLinSol\_SPGMR module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPGMR} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{gstype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}restarts}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{V}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{Hes}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{givens}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{xcor}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{yg}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp}\PYG{p}{;}
  \PYG{k+kt}{int}      \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}    \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{maxl} - number of GMRES basis vectors to use (default is 5),

\item {} 
\sphinxcode{pretype} - flag for type of preconditioning to employ
(default is none),

\item {} 
\sphinxcode{gstype} - flag for type of Gram-Schmidt orthogonalization
(default is modified Gram-Schmidt),

\item {} 
\sphinxcode{max\_restarts} - number of GMRES restarts to allow
(default is 0),

\item {} 
\sphinxcode{numiters} - number of iterations from the most-recent solve,

\item {} 
\sphinxcode{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\sphinxcode{last\_flag} - last error return flag from an internal
function,

\item {} 
\sphinxcode{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\sphinxcode{ATData} - pointer to structure for \sphinxcode{ATimes},

\item {} 
\sphinxcode{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\sphinxcode{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\sphinxcode{PData} - pointer to structure for \sphinxcode{Psetup} and \sphinxcode{Psolve},

\item {} 
\sphinxcode{s1, s2} - vector pointers for supplied scaling matrices
(default is \sphinxcode{NULL}),

\item {} 
\sphinxcode{V} - the array of Krylov basis vectors
\(v_1, \ldots, v_{\text{maxl}+1}\), stored in
\sphinxcode{V{[}0{]}, ... V{[}maxl{]}}. Each \(v_i\) is a vector of type
\sphinxcode{N\_Vector},

\item {} 
\sphinxcode{Hes} - the \((\text{maxl}+1)\times\text{maxl}\)
Hessenberg matrix. It is stored row-wise so that the (i,j)th
element is given by \sphinxcode{Hes{[}i{]}{[}j{]}},

\item {} 
\sphinxcode{givens} - a length \(2\,\text{maxl}\) array which represents
the Givens rotation matrices that arise in the GMRES
algorithm. These matrices are \(F_0, F_1, \ldots, F_j\), where
\begin{equation*}
\begin{split}F_i = \begin{bmatrix}
   1 &        &   &     &      &   &        &   \\
     & \ddots &   &     &      &   &        &   \\
     &        & 1 &     &      &   &        &   \\
     &        &   & c_i & -s_i &   &        &   \\
     &        &   & s_i &  c_i &   &        &   \\
     &        &   &     &      & 1 &        &   \\
     &        &   &     &      &   & \ddots &   \\
     &        &   &     &      &   &        & 1\end{bmatrix},\end{split}
\end{equation*}
are represented in the \sphinxcode{givens} vector as
\sphinxcode{givens{[}0{]}} \(= c_0\),
\sphinxcode{givens{[}1{]}} \(= s_0\),
\sphinxcode{givens{[}2{]}} \(= c_1\),
\sphinxcode{givens{[}3{]}} \(= s_1\), \(\ldots\),
\sphinxcode{givens{[}2j{]}} \(= c_j\),
\sphinxcode{givens{[}2j+1{]}} \(= s_j\),

\item {} 
\sphinxcode{xcor} - a vector which holds the scaled, preconditioned
correction to the initial guess,

\item {} 
\sphinxcode{yg} - a length \((\text{maxl}+1)\) array of \sphinxcode{realtype}
values used to hold “short” vectors (e.g. \(y\) and \(g\)),

\item {} 
\sphinxcode{vtemp} - temporary vector storage.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction, the \sphinxcode{xcor} and \sphinxcode{vtemp} arrays are
cloned from a template \sphinxcode{N\_Vector} that is input, and default
solver parameters are set.

\item {} 
User-facing “set” routines may be called to modify default
solver parameters.

\item {} 
Additional “set” routines are called by the SUNDIALS solver
that interfaces with SUNLinSol\_SPGMR to supply the
\sphinxcode{ATimes}, \sphinxcode{PSetup}, and \sphinxcode{Psolve} function pointers and
\sphinxcode{s1} and \sphinxcode{s2} scaling vectors.

\item {} 
In the “initialize” call, the remaining solver data is
allocated (\sphinxcode{V}, \sphinxcode{Hes}, \sphinxcode{givens}, and \sphinxcode{yg} )

\item {} 
In the “setup” call, any non-\sphinxcode{NULL}
\sphinxcode{PSetup} function is called.  Typically, this is provided by
the SUNDIALS solver itself, that translates between the generic
\sphinxcode{PSetup} function and the solver-specific routine (solver-supplied
or user-supplied).

\item {} 
In the “solve” call, the GMRES iteration is performed.  This
will include scaling, preconditioning, and restarts if those options
have been supplied.

\end{itemize}

The SUNLinSol\_SPGMR module defines implementations of all
“iterative” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolInitialize\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolSetATimes\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolSetPreconditioner\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolSetScalingVectors\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolSetup\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolSolve\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolNumIters\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolResNorm\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolResid\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolLastFlag\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolSpace\_SPGMR}

\item {} 
\sphinxcode{SUNLinSolFree\_SPGMR}

\end{itemize}


\section{The SUNLinSol\_SPFGMR Module}
\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:the-sunlinsol-spfgmr-module}}\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR::doc}}\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:sunlinsol-spfgmr}}
The SPFGMR (Scaled, Preconditioned, Flexible, Generalized Minimum
Residual \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:id1}}{\hyperref[\detokenize{References:s1993}]{\sphinxcrossref{{[}S1993{]}}}}) implementation of the \sphinxcode{SUNLinearSolver} module
provided with SUNDIALS, SUNLinSol\_SPFGMR, is an iterative linear
solver that is designed to be compatible with any \sphinxcode{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScale}]{\sphinxcrossref{\sphinxcode{N\_VScale()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VProd}]{\sphinxcrossref{\sphinxcode{N\_VProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConst}]{\sphinxcrossref{\sphinxcode{N\_VConst()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDiv}]{\sphinxcrossref{\sphinxcode{N\_VDiv()}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}}).  Unlike the other
Krylov iterative linear solvers supplied with SUNDIALS, FGMRES is
specifically designed to work with a changing preconditioner
(e.g. from an iterative method).


\subsection{SUNLinSol\_SPFGMR Usage}
\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:sunlinsol-spfgmr-usage}}\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:id2}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_spfgmr.h}.  The SUNLinSol\_SPFGMR module is
accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the \sphinxcode{libsundials\_sunlinsolspfgmr} module library.

The module SUNLinSol\_SPFGMR provides the following
user-callable routines:
\index{SUNLinSol\_SPFGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_SPFGMR}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
This constructor function creates and allocates memory for a SPFGMR
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector}, a flag
indicating to use preconditioning, and the number of Krylov basis
vectors to use.

This routine will perform consistency checks to ensure that it is
called with a consistent \sphinxcode{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \sphinxcode{y} is
incompatible, then this routine will return \sphinxcode{NULL}.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

Since the FGMRES algorithm is designed to only support right
preconditioning, then any of the \sphinxcode{pretype}
inputs \sphinxcode{PREC\_LEFT} (1), \sphinxcode{PREC\_RIGHT} (2), or \sphinxcode{PREC\_BOTH}
(3) will result in use of \sphinxcode{PREC\_RIGHT};  any other integer input
will result in the default (no preconditioning).
We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS). While it is
possible to use a right-preconditioned SUNLinSol\_SPFGMR object for
these packages, this use mode is not supported and may result in
inferior performance.

\end{fulllineitems}

\index{SUNLinSol\_SPFGMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPFGMRSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
This function updates the flag indicating use of preconditioning.
Since the FGMRES algorithm is designed to only support right
preconditioning, then any of the \sphinxcode{pretype}
inputs \sphinxcode{PREC\_LEFT} (1), \sphinxcode{PREC\_RIGHT} (2), or \sphinxcode{PREC\_BOTH}
(3) will result in use of \sphinxcode{PREC\_RIGHT};  any other integer input
will result in the default (no preconditioning).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_MEM\_NULL} (\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_SPFGMRSetGSType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetGSType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPFGMRSetGSType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ gstype}}{}
This function sets the type of Gram-Schmidt orthogonalization to
use.  Supported values are \sphinxcode{MODIFIED\_GS} (1) and
\sphinxcode{CLASSICAL\_GS} (2).  Any other integer input will result in a
failure, returning error code \sphinxcode{SUNLS\_ILL\_INPUT}.

This routine will return with one of the error codes
\sphinxcode{SUNLS\_ILL\_INPUT} (illegal \sphinxcode{gstype}), \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}), or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_SPFGMRSetMaxRestarts (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetMaxRestarts}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPFGMRSetMaxRestarts}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxrs}}{}
This function sets the number of FGMRES restarts to
allow.  A negative input will result in the default of 0.

This routine will return with one of the error codes
\sphinxcode{SUNLS\_MEM\_NULL} (\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSolSetInfoFile\_SPFGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSolSetInfoFile_SPFGMR}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetInfoFile\_SPFGMR}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSolSetInfoFile_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetInfoFile\_SPFGMR()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} \begin{description}
\item[{\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);}] \leavevmode
a \sphinxcode{NULL} input will disable output

\end{description}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNLinSolSetPrintLevel\_SPFGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSolSetPrintLevel_SPFGMR}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetPrintLevel\_SPFGMR}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSolSetPrintLevel_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetPrintLevel\_SPFGMR()}}}} specifies the
level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each linear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled, or
if the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNSPFGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNSPFGMR}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMR()}}}}

\end{fulllineitems}

\index{SUNSPFGMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPFGMRSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetPrecType()}}}}

\end{fulllineitems}

\index{SUNSPFGMRSetGSType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetGSType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPFGMRSetGSType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ gstype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetGSType()}}}}

\end{fulllineitems}

\index{SUNSPFGMRSetMaxRestarts (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetMaxRestarts}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPFGMRSetMaxRestarts}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxrs}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetMaxRestarts}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetMaxRestarts()}}}}

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_SPFGMR module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPFGMRInit()}}}} to initialize this
SUNLinSol\_SPFGMR module for a given SUNDIALS solver.
\index{FSUNSPFGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPFGMRInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPFGMR \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting whether to use
preconditioning: no=0, yes=1.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of FGMRES basis vectors to use.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPFGMRInit()}}}} initializes
this SUNLinSol\_SPFGMR module for solving mass matrix linear systems.
\index{FSUNMassSPFGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPFGMRInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPFGMR \sphinxcode{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting whether to use
preconditioning: no=0, yes=1.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of FGMRES basis vectors to use.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetGSType()}}}}, {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetPrecType()}}}}
and {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetMaxRestarts}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetMaxRestarts()}}}} routines also support Fortran
interfaces for the system and mass matrix solvers:
\index{FSUNSPFGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRSetGSType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPFGMRSetGSType}}{\emph{CODE}, \emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetGSType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPFGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPFGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRSetGSType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPFGMRSetGSType}}{\emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetGSType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetGSType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPFGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPFGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPFGMRSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetPrecType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPFGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPFGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPFGMRSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:c.SUNLinSol_SPFGMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPFGMRSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPFGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPFGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRSetMaxRS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPFGMRSetMaxRS}}{\emph{CODE}, \emph{MAXRS}, \emph{IER}}{}
Fortran interface to \sphinxcode{SUNLinSol\_SPFGMRSetMaxRS()} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPFGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPFGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRSetMaxRS}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPFGMRSetMaxRS}}{\emph{MAXRS}, \emph{IER}}{}
Fortran interface to \sphinxcode{SUNLinSol\_SPFGMRSetMaxRS()} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPFGMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\subsection{SUNLinSol\_SPFGMR Description}
\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:id3}}\label{\detokenize{sunlinsol/SUNLinSol_SPFGMR:sunlinsol-spfgmr-description}}
The SUNLinSol\_SPFGMR module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPFGMR} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{gstype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}restarts}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{V}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{Z}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{Hes}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{givens}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{xcor}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{yg}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp}\PYG{p}{;}
  \PYG{k+kt}{int}      \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}    \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{maxl} - number of FGMRES basis vectors to use (default is 5),

\item {} 
\sphinxcode{pretype} - flag for use of preconditioning (default is none),

\item {} 
\sphinxcode{gstype} - flag for type of Gram-Schmidt orthogonalization
(default is modified Gram-Schmidt),

\item {} 
\sphinxcode{max\_restarts} - number of FGMRES restarts to allow
(default is 0),

\item {} 
\sphinxcode{numiters} - number of iterations from the most-recent solve,

\item {} 
\sphinxcode{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\sphinxcode{last\_flag} - last error return flag from an internal
function,

\item {} 
\sphinxcode{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\sphinxcode{ATData} - pointer to structure for \sphinxcode{ATimes},

\item {} 
\sphinxcode{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\sphinxcode{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\sphinxcode{PData} - pointer to structure for \sphinxcode{Psetup} and \sphinxcode{Psolve},

\item {} 
\sphinxcode{s1, s2} - vector pointers for supplied scaling matrices
(default is \sphinxcode{NULL}),

\item {} 
\sphinxcode{V} - the array of Krylov basis vectors
\(v_1, \ldots, v_{\text{maxl}+1}\), stored in
\sphinxcode{V{[}0{]}, ..., V{[}maxl{]}}. Each \(v_i\) is a vector of type \sphinxcode{N\_Vector},

\item {} 
\sphinxcode{Z} - the array of preconditioned Krylov basis vectors
\(z_1, \ldots, z_{\text{maxl}+1}\), stored in
\sphinxcode{Z{[}0{]}, ..., Z{[}maxl{]}}. Each \(z_i\) is a vector of type \sphinxcode{N\_Vector},

\item {} 
\sphinxcode{Hes} - the \((\text{maxl}+1)\times\text{maxl}\)
Hessenberg matrix. It is stored row-wise so that the (i,j)th
element is given by \sphinxcode{Hes{[}i{]}{[}j{]}},

\item {} 
\sphinxcode{givens} - a length \(2\,\text{maxl}\) array which represents
the Givens rotation matrices that arise in the FGMRES
algorithm. These matrices are \(F_0, F_1, \ldots, F_j\), where
\begin{equation*}
\begin{split}F_i = \begin{bmatrix}
   1 &        &   &     &      &   &        &   \\
     & \ddots &   &     &      &   &        &   \\
     &        & 1 &     &      &   &        &   \\
     &        &   & c_i & -s_i &   &        &   \\
     &        &   & s_i &  c_i &   &        &   \\
     &        &   &     &      & 1 &        &   \\
     &        &   &     &      &   & \ddots &   \\
     &        &   &     &      &   &        & 1\end{bmatrix},\end{split}
\end{equation*}
are represented in the \sphinxcode{givens} vector as
\sphinxcode{givens{[}0{]}} \(= c_0\),
\sphinxcode{givens{[}1{]}} \(= s_0\),
\sphinxcode{givens{[}2{]}} \(= c_1\),
\sphinxcode{givens{[}3{]}} \(= s_1\), \(\ldots\),
\sphinxcode{givens{[}2j{]}} \(= c_j\),
\sphinxcode{givens{[}2j+1{]}} \(= s_j\),

\item {} 
\sphinxcode{xcor} - a vector which holds the scaled, preconditioned
correction to the initial guess,

\item {} 
\sphinxcode{yg} - a length \((\text{maxl}+1)\) array of \sphinxcode{realtype}
values used to hold “short” vectors (e.g. \(y\) and \(g\)),

\item {} 
\sphinxcode{vtemp} - temporary vector storage.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction, the \sphinxcode{xcor} and \sphinxcode{vtemp} arrays are cloned
from a template \sphinxcode{N\_Vector} that is input, and default solver
parameters are set.

\item {} 
User-facing “set” routines may be called to modify default
solver parameters.

\item {} 
Additional “set” routines are called by the SUNDIALS solver
that interfaces with SUNLinSol\_SPFGMR to supply the
\sphinxcode{ATimes}, \sphinxcode{PSetup}, and \sphinxcode{Psolve} function pointers and
\sphinxcode{s1} and \sphinxcode{s2} scaling vectors.

\item {} 
In the “initialize” call, the remaining solver data is
allocated (\sphinxcode{V}, \sphinxcode{Hes}, \sphinxcode{givens}, and \sphinxcode{yg} )

\item {} 
In the “setup” call, any non-\sphinxcode{NULL} \sphinxcode{PSetup} function is called.
Typically, this is provided by the SUNDIALS solver itself, that
translates between the generic \sphinxcode{PSetup} function and the
solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the “solve” call, the FGMRES iteration is performed.  This
will include scaling, preconditioning, and restarts if those options
have been supplied.

\end{itemize}

The SUNLinSol\_SPFGMR module defines implementations of all
“iterative” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolInitialize\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolSetATimes\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolSetPreconditioner\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolSetScalingVectors\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolSetup\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolSolve\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolNumIters\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolResNorm\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolResid\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolLastFlag\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolSpace\_SPFGMR}

\item {} 
\sphinxcode{SUNLinSolFree\_SPFGMR}

\end{itemize}


\section{The SUNLinSol\_SPBCGS Module}
\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS::doc}}\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:the-sunlinsol-spbcgs-module}}\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:sunlinsol-spbcgs}}
The SPBCGS (Scaled, Preconditioned, Bi-Conjugate Gradient,
Stabilized \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:id1}}{\hyperref[\detokenize{References:v1992}]{\sphinxcrossref{{[}V1992{]}}}}) implementation of the \sphinxcode{SUNLinearSolver} module
provided with SUNDIALS, SUNLinSol\_SPBCGS, is an iterative linear
solver that is designed to be compatible with any \sphinxcode{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScale}]{\sphinxcrossref{\sphinxcode{N\_VScale()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VProd}]{\sphinxcrossref{\sphinxcode{N\_VProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDiv}]{\sphinxcrossref{\sphinxcode{N\_VDiv()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}}).  Unlike the SPGMR and SPFGMR algorithms,
SPBCGS requires a fixed amount of memory that does not increase with
the number of allowed iterations.


\subsection{SUNLinSol\_SPBCGS Usage}
\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:id2}}\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:sunlinsol-spbcgs-usage}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_spbcgs.h}.  The SUNLinSol\_SPBCGS module
is accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the \sphinxcode{libsundials\_sunlinsolspbcgs} module library.

The module SUNLinSol\_SPBCGS provides the following
user-callable routines:
\index{SUNLinSol\_SPBCGS (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGS}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_SPBCGS}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
This constructor function creates and allocates memory for a SPBCGS
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector}, the desired
type of preconditioning, and the number of linear iterations to allow.

This routine will perform consistency checks to ensure that it is
called with a consistent \sphinxcode{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \sphinxcode{y} is
incompatible, then this routine will return \sphinxcode{NULL}.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

Allowable inputs for \sphinxcode{pretype} are \sphinxcode{PREC\_NONE} (0),
\sphinxcode{PREC\_LEFT} (1), \sphinxcode{PREC\_RIGHT} (2) and \sphinxcode{PREC\_BOTH} (3);
any other integer input will result in the default (no
preconditioning).  We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS) and others
with only right preconditioning (KINSOL). While it is possible to
configure a SUNLinSol\_SPBCGS object to use any of the
preconditioning options with these solvers, this use mode is not
supported and may result in inferior performance.

\end{fulllineitems}

\index{SUNLinSol\_SPBCGSSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPBCGSSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
This function updates the type of preconditioning to use.  Supported
values are \sphinxcode{PREC\_NONE} (0), \sphinxcode{PREC\_LEFT} (1),
\sphinxcode{PREC\_RIGHT} (2), and \sphinxcode{PREC\_BOTH} (3).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_ILL\_INPUT} (illegal \sphinxcode{pretype}), \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}), or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_SPBCGSSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetMaxl}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPBCGSSetMaxl}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxl}}{}
This function updates the number of linear solver iterations to allow.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_MEM\_NULL} (\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSolSetInfoFile\_SPBCGS (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSolSetInfoFile_SPBCGS}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetInfoFile\_SPBCGS}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSolSetInfoFile_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetInfoFile\_SPBCGS()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} \begin{description}
\item[{\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);}] \leavevmode
a \sphinxcode{NULL} input will disable output

\end{description}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNLinSolSetPrintLevel\_SPBCGS (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSolSetPrintLevel_SPBCGS}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetPrintLevel\_SPBCGS}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSolSetPrintLevel_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetPrintLevel\_SPBCGS()}}}} specifies the
level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each linear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled, or
if the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNSPBCGS (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGS}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNSPBCGS}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGS}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGS()}}}}

\end{fulllineitems}

\index{SUNSPBCGSSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPBCGSSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetPrecType()}}}}

\end{fulllineitems}

\index{SUNSPBCGSSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetMaxl}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPBCGSSetMaxl}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetMaxl()}}}}

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_SPBCGS module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit}]{\sphinxcrossref{\sphinxcode{FSUNSPBCGSInit()}}}} to initialize this
SUNLinSol\_SPBCGS module for a given SUNDIALS solver.
\index{FSUNSPBCGSInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPBCGSInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPBCGS \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of SPBCGS iterations to allow.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPBCGSInit()}}}} initializes
this SUNLinSol\_SPBCGS module for solving mass matrix linear systems.
\index{FSUNMassSPBCGSInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPBCGSInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPBCGS \sphinxcode{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of SPBCGS iterations to allow.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetPrecType()}}}} and {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetMaxl()}}}}
routines also support Fortran interfaces for the system and mass
matrix solvers:
\index{FSUNSPBCGSSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPBCGSSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetPrecType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit}]{\sphinxcrossref{\sphinxcode{FSUNSPBCGSInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPBCGSSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPBCGSSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPBCGSInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPBCGSSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSSetMaxl}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPBCGSSetMaxl}}{\emph{CODE}, \emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetMaxl()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit}]{\sphinxcrossref{\sphinxcode{FSUNSPBCGSInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPBCGSSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSSetMaxl}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPBCGSSetMaxl}}{\emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:c.SUNLinSol_SPBCGSSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPBCGSSetMaxl()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPBCGSInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\subsection{SUNLinSol\_SPBCGS Description}
\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:id3}}\label{\detokenize{sunlinsol/SUNLinSol_SPBCGS:sunlinsol-spbcgs-description}}
The SUNLinSol\_SPBCGS module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPBCGS} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r\PYGZus{}star}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{q}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{u}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{Ap}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp}\PYG{p}{;}
  \PYG{k+kt}{int}      \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}    \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{maxl} - number of SPBCGS iterations to allow (default is 5),

\item {} 
\sphinxcode{pretype} - flag for type of preconditioning to employ
(default is none),

\item {} 
\sphinxcode{numiters} - number of iterations from the most-recent solve,

\item {} 
\sphinxcode{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\sphinxcode{last\_flag} - last error return flag from an internal
function,

\item {} 
\sphinxcode{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\sphinxcode{ATData} - pointer to structure for \sphinxcode{ATimes},

\item {} 
\sphinxcode{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\sphinxcode{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\sphinxcode{PData} - pointer to structure for \sphinxcode{Psetup} and \sphinxcode{Psolve},

\item {} 
\sphinxcode{s1, s2} - vector pointers for supplied scaling matrices
(default is \sphinxcode{NULL}),

\item {} 
\sphinxcode{r} - a \sphinxcode{N\_Vector} which holds the current scaled,
preconditioned linear system residual,

\item {} 
\sphinxcode{r\_star} - a \sphinxcode{N\_Vector} which holds the initial scaled,
preconditioned linear system residual,

\item {} 
\sphinxcode{p, q, u, Ap, vtemp} - \sphinxcode{N\_Vector} used for workspace by the
SPBCGS algorithm.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction all \sphinxcode{N\_Vector} solver data is allocated, with
vectors cloned from a template \sphinxcode{N\_Vector} that is input, and
default solver parameters are set.

\item {} 
User-facing “set” routines may be called to modify default
solver parameters.

\item {} 
Additional “set” routines are called by the SUNDIALS solver
that interfaces with SUNLinSol\_SPBCGS to supply the \sphinxcode{ATimes},
\sphinxcode{PSetup}, and \sphinxcode{Psolve} function pointers and \sphinxcode{s1} and \sphinxcode{s2}
scaling vectors.

\item {} 
In the “initialize” call, the solver parameters are checked
for validity.

\item {} 
In the “setup” call, any non-\sphinxcode{NULL} \sphinxcode{PSetup} function is
called.  Typically, this is provided by the SUNDIALS solver itself,
that translates between the generic \sphinxcode{PSetup} function and the
solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the “solve” call the SPBCGS iteration is performed.  This
will include scaling and preconditioning if those options have been
supplied.

\end{itemize}

The SUNLinSol\_SPBCGS module defines implementations of all
“iterative” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolInitialize\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolSetATimes\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolSetPreconditioner\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolSetScalingVectors\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolSetup\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolSolve\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolNumIters\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolResNorm\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolResid\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolLastFlag\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolSpace\_SPBCGS}

\item {} 
\sphinxcode{SUNLinSolFree\_SPBCGS}

\end{itemize}


\section{The SUNLinSol\_SPTFQMR Module}
\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:sunlinsol-sptfqmr}}\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR::doc}}\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:the-sunlinsol-sptfqmr-module}}
The SPTFQMR (Scaled, Preconditioned, Transpose-Free Quasi-Minimum
Residual \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:id1}}{\hyperref[\detokenize{References:f1993}]{\sphinxcrossref{{[}F1993{]}}}}) implementation of the \sphinxcode{SUNLinearSolver} module
provided with SUNDIALS, SUNLinSol\_SPTFQMR, is an iterative linear
solver that is designed to be compatible with any \sphinxcode{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScale}]{\sphinxcrossref{\sphinxcode{N\_VScale()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VProd}]{\sphinxcrossref{\sphinxcode{N\_VProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VConst}]{\sphinxcrossref{\sphinxcode{N\_VConst()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDiv}]{\sphinxcrossref{\sphinxcode{N\_VDiv()}}}}, and {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}}).  Unlike the SPGMR and
SPFGMR algorithms, SPTFQMR requires a fixed amount of memory that does
not increase with the number of allowed iterations.


\subsection{SUNLinSol\_SPTFQMR Usage}
\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:id2}}\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:sunlinsol-sptfqmr-usage}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_sptfqmr.h}.  The SUNLinSol\_SPTFQMR module
is accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the \sphinxcode{libsundials\_sunlinsolsptfqmr} module library.

The module SUNLinSol\_SPTFQMR provides the following user-callable routines:
\index{SUNLinSol\_SPTFQMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_SPTFQMR}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
This constructor function creates and allocates memory for a SPTFQMR
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector}, the desired
type of preconditioning, and the number of linear iterations to
allow.

This routine will perform consistency checks to ensure that it is
called with a consistent \sphinxcode{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \sphinxcode{y} is
incompatible, then this routine will return \sphinxcode{NULL}.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

Allowable inputs for \sphinxcode{pretype} are \sphinxcode{PREC\_NONE} (0),
\sphinxcode{PREC\_LEFT} (1), \sphinxcode{PREC\_RIGHT} (2) and \sphinxcode{PREC\_BOTH} (3);
any other integer input will result in the default (no
preconditioning).  We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS) and others
with only right preconditioning (KINSOL). While it is possible to
configure a SUNLinSol\_SPTFQMR object to use any of the
preconditioning options with these solvers, this use mode is not
supported and may result in inferior performance.

\end{fulllineitems}

\index{SUNLinSol\_SPTFQMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPTFQMRSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
This function updates the type of preconditioning to use.  Supported
values are \sphinxcode{PREC\_NONE} (0), \sphinxcode{PREC\_LEFT} (1),
\sphinxcode{PREC\_RIGHT} (2), and \sphinxcode{PREC\_BOTH} (3).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_ILL\_INPUT} (illegal \sphinxcode{pretype}), \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}), or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_SPTFQMRSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetMaxl}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_SPTFQMRSetMaxl}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxl}}{}
This function updates the number of linear solver iterations to
allow.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_MEM\_NULL} (\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSolSetInfoFile\_SPTFQMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSolSetInfoFile_SPTFQMR}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetInfoFile\_SPTFQMR}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSolSetInfoFile_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetInfoFile\_SPTFQMR()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} \begin{description}
\item[{\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);}] \leavevmode
a \sphinxcode{NULL} input will disable output

\end{description}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNLinSolSetPrintLevel\_SPTFQMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSolSetPrintLevel_SPTFQMR}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetPrintLevel\_SPTFQMR}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSolSetPrintLevel_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetPrintLevel\_SPTFQMR()}}}} specifies the
level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each linear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled, or
if the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNSPTFQMR (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMR}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNSPTFQMR}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMR}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMR()}}}}

\end{fulllineitems}

\index{SUNSPTFQMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPTFQMRSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetPrecType()}}}}

\end{fulllineitems}

\index{SUNSPTFQMRSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetMaxl}}\pysiglinewithargsret{int \sphinxbfcode{SUNSPTFQMRSetMaxl}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetMaxl()}}}}

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_SPTFQMR module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPTFQMRInit()}}}} to initialize
this SUNLinSol\_SPTFQMR module for a given SUNDIALS solver.
\index{FSUNSPTFQMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPTFQMRInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPTFQMR \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of SPTFQMR iterations to allow.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function  {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPTFQMRInit()}}}} initializes
this SUNLinSol\_SPTFQMR module for solving mass matrix linear systems.
\index{FSUNMassSPTFQMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPTFQMRInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPTFQMR \sphinxcode{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of SPTFQMR iterations to allow.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetPrecType()}}}} and
{\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetMaxl()}}}} routines also support Fortran interfaces
for the system and mass matrix solvers:
\index{FSUNSPTFQMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPTFQMRSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetPrecType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPTFQMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPTFQMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPTFQMRSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPTFQMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPTFQMRSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRSetMaxl}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNSPTFQMRSetMaxl}}{\emph{CODE}, \emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetMaxl()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit}]{\sphinxcrossref{\sphinxcode{FSUNSPTFQMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPTFQMRSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRSetMaxl}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassSPTFQMRSetMaxl}}{\emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:c.SUNLinSol_SPTFQMRSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_SPTFQMRSetMaxl()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit}]{\sphinxcrossref{\sphinxcode{FSUNMassSPTFQMRInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\subsection{SUNLinSol\_SPTFQMR Description}
\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:id3}}\label{\detokenize{sunlinsol/SUNLinSol_SPTFQMR:sunlinsol-sptfqmr-description}}
The SUNLinSol\_SPTFQMR module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPTFQMR} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r\PYGZus{}star}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{q}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{d}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{v}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{u}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp3}\PYG{p}{;}
  \PYG{k+kt}{int}      \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}    \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{maxl} - number of TFQMR iterations to allow (default is 5),

\item {} 
\sphinxcode{pretype} - flag for type of preconditioning to employ
(default is none),

\item {} 
\sphinxcode{numiters} - number of iterations from the most-recent solve,

\item {} 
\sphinxcode{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\sphinxcode{last\_flag} - last error return flag from an internal
function,

\item {} 
\sphinxcode{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\sphinxcode{ATData} - pointer to structure for \sphinxcode{ATimes},

\item {} 
\sphinxcode{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\sphinxcode{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\sphinxcode{PData} - pointer to structure for \sphinxcode{Psetup} and \sphinxcode{Psolve},

\item {} 
\sphinxcode{s1, s2} - vector pointers for supplied scaling matrices
(default is \sphinxcode{NULL}),

\item {} 
\sphinxcode{r\_star} - a \sphinxcode{N\_Vector} which holds the initial scaled,
preconditioned linear system residual,

\item {} 
\sphinxcode{q, d, v, p, u} - \sphinxcode{N\_Vector} used for workspace by the SPTFQMR
algorithm,

\item {} 
\sphinxcode{r} - array of two \sphinxcode{N\_Vector} used for workspace within the
SPTFQMR algorithm,

\item {} 
\sphinxcode{vtemp1, vtemp2, vtemp3} - temporary vector storage.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction all \sphinxcode{N\_Vector} solver data is allocated,
with vectors cloned from a template \sphinxcode{N\_Vector} that is input, and
default solver parameters are set.

\item {} 
User-facing “set” routines may be called to modify default
solver parameters.

\item {} 
Additional “set” routines are called by the SUNDIALS solver
that interfaces with SUNLinSol\_SPTFQMR to supply the
\sphinxcode{ATimes}, \sphinxcode{PSetup}, and \sphinxcode{Psolve} function pointers and
\sphinxcode{s1} and \sphinxcode{s2} scaling vectors.

\item {} 
In the “initialize” call, the solver parameters are checked
for validity.

\item {} 
In the “setup” call, any non-\sphinxcode{NULL} \sphinxcode{PSetup} function is
called.  Typically, this is provided by the SUNDIALS solver itself,
that translates between the generic \sphinxcode{PSetup} function and the
solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the “solve” call the TFQMR iteration is performed.  This
will include scaling and preconditioning if those options have been
supplied.

\end{itemize}

The SUNLinSol\_SPTFQMR module defines implementations of all
“iterative” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolInitialize\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolSetATimes\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolSetPreconditioner\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolSetScalingVectors\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolSetup\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolSolve\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolNumIters\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolResNorm\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolResid\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolLastFlag\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolSpace\_SPTFQMR}

\item {} 
\sphinxcode{SUNLinSolFree\_SPTFQMR}

\end{itemize}


\section{The SUNLinSol\_PCG Module}
\label{\detokenize{sunlinsol/SUNLinSol_PCG:sunlinsol-pcg}}\label{\detokenize{sunlinsol/SUNLinSol_PCG::doc}}\label{\detokenize{sunlinsol/SUNLinSol_PCG:the-sunlinsol-pcg-module}}
The PCG (Preconditioned Conjugate Gradient \phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:id1}}{\hyperref[\detokenize{References:hs1952}]{\sphinxcrossref{{[}HS1952{]}}}} implementation of
the \sphinxcode{SUNLinearSolver} module provided with SUNDIALS, SUNLinSol\_PCG,
is an iterative linear solver that is designed to be compatible with
any \sphinxcode{N\_Vector} implementation (serial, threaded, parallel, and
user-supplied) that supports a minimal subset of operations
({\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VClone}]{\sphinxcrossref{\sphinxcode{N\_VClone()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDotProd}]{\sphinxcrossref{\sphinxcode{N\_VDotProd()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VScale}]{\sphinxcrossref{\sphinxcode{N\_VScale()}}}},
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VLinearSum}]{\sphinxcrossref{\sphinxcode{N\_VLinearSum()}}}}, {\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VProd}]{\sphinxcrossref{\sphinxcode{N\_VProd()}}}}, and
{\hyperref[\detokenize{nvectors/NVector_Operations:c.N_VDestroy}]{\sphinxcrossref{\sphinxcode{N\_VDestroy()}}}}).  Unlike the SPGMR and SPFGMR algorithms, PCG
requires a fixed amount of memory that does not increase with the
number of allowed iterations.

Unlike all of the other iterative linear solvers supplied with
SUNDIALS, PCG should only be used on \sphinxstyleemphasis{symmetric} linear
systems (e.g. mass matrix linear systems encountered in
ARKode). As a result, the explanation of the role of scaling and
preconditioning matrices given in general must be modified in this
scenario.  The PCG algorithm solves a linear system \(Ax = b\) where
\(A\) is a symmetric (\(A^T=A\)), real-valued matrix.  Preconditioning is
allowed, and is applied in a symmetric fashion on both the right and
left.  Scaling is also allowed and is applied symmetrically.  We
denote the preconditioner and scaling matrices as follows:
\begin{itemize}
\item {} 
\(P\) is the preconditioner (assumed symmetric),

\item {} 
\(S\) is a diagonal matrix of scale factors.

\end{itemize}

The matrices \(A\) and \(P\) are not required explicitly; only routines
that provide \(A\) and \(P^{-1}\) as operators are required.  The diagonal
of the matrix \(S\) is held in a single \sphinxcode{N\_Vector}, supplied by the user.

In this notation, PCG applies the underlying CG algorithm to the
equivalent transformed system

\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:equation-eq-transformed-linear-systempcg}}\begin{equation}\label{equation:sunlinsol/SUNLinSol_PCG:eq:transformed_linear_systemPCG}
\begin{split}\tilde{A} \tilde{x} = \tilde{b}\end{split}
\end{equation}
where

\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:equation-eq-transformed-linear-system-componentspcg}}\begin{equation}\label{equation:sunlinsol/SUNLinSol_PCG:eq:transformed_linear_system_componentsPCG}
\begin{split}\tilde{A} &= S P^{-1} A P^{-1} S,\\
\tilde{b} &= S P^{-1} b,\\
\tilde{x} &= S^{-1} P x.\end{split}
\end{equation}
The scaling matrix must be chosen so that the vectors \(SP^{-1}b\) and
\(S^{-1}Px\) have dimensionless components.

The stopping test for the PCG iterations is on the L2 norm of the
scaled preconditioned residual:
\begin{equation*}
\begin{split}&\| \tilde{b} - \tilde{A} \tilde{x} \|_2  <  \delta\\
\Leftrightarrow\quad &\\
&\| S P^{-1} b - S P^{-1} A x \|_2  <  \delta\\
\Leftrightarrow\quad &\\
&\| P^{-1} b - P^{-1} A x \|_S  <  \delta\end{split}
\end{equation*}
where \(\| v \|_S = \sqrt{v^T S^T S v}\), with an input tolerance
\(\delta\).


\subsection{SUNLinSol\_PCG Usage}
\label{\detokenize{sunlinsol/SUNLinSol_PCG:id2}}\label{\detokenize{sunlinsol/SUNLinSol_PCG:sunlinsol-pcg-usage}}
The header file to be included when using this module
is \sphinxcode{sunlinsol/sunlinsol\_pcg.h}.  The SUNLinSol\_PCG module
is accessible from all SUNDIALS solvers \sphinxstyleemphasis{without}
linking to the \sphinxcode{libsundials\_sunlinsolpcg} module library.

The module SUNLinSol\_PCG provides the following user-callable routines:
\index{SUNLinSol\_PCG (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCG}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNLinSol\_PCG}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
This constructor function creates and allocates memory for a PCG
\sphinxcode{SUNLinearSolver}.  Its arguments are an \sphinxcode{N\_Vector}, a flag
indicating to use preconditioning, and the number of linear
iterations to allow.

This routine will perform consistency checks to ensure that it is
called with a consistent \sphinxcode{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \sphinxcode{y} is
incompatible then this routine will return \sphinxcode{NULL}.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

Since the PCG algorithm is designed to only support symmetric
preconditioning, then any of the \sphinxcode{pretype} inputs \sphinxcode{PREC\_LEFT}
(1), \sphinxcode{PREC\_RIGHT} (2), or \sphinxcode{PREC\_BOTH} (3) will result in use
of the symmetric preconditioner;  any other integer input will
result in the default (no preconditioning).  Although some SUNDIALS
solvers are designed to only work with left preconditioning (IDA
and IDAS) and others with only right preconditioning (KINSOL), PCG
should \sphinxstyleemphasis{only} be used with these packages when the linear systems
are known to be \sphinxstyleemphasis{symmetric}.  Since the scaling of matrix rows and
columns must be identical in a symmetric matrix, symmetric
preconditioning should work appropriately even for packages
designed with one-sided preconditioning in mind.

\end{fulllineitems}

\index{SUNLinSol\_PCGSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_PCGSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
This function updates the flag indicating use of preconditioning.
As above, any one of the input values, \sphinxcode{PREC\_LEFT} (1),
\sphinxcode{PREC\_RIGHT} (2), or \sphinxcode{PREC\_BOTH} (3) will enable
preconditioning; \sphinxcode{PREC\_NONE} (0) disables preconditioning.

This routine will return with one of the error codes
\sphinxcode{SUNLS\_ILL\_INPUT} (illegal \sphinxcode{pretype}), \sphinxcode{SUNLS\_MEM\_NULL}
(\sphinxcode{S} is \sphinxcode{NULL}), or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSol\_PCGSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetMaxl}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSol\_PCGSetMaxl}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxl}}{}
This function updates the number of linear solver iterations to
allow.

A \sphinxcode{maxl} argument that is \(\le0\) will result in the default
value (5).

This routine will return with one of the error codes
\sphinxcode{SUNLS\_MEM\_NULL} (\sphinxcode{S} is \sphinxcode{NULL}) or \sphinxcode{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNLinSolSetInfoFile\_PCG (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSolSetInfoFile_PCG}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetInfoFile\_PCG}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSolSetInfoFile_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetInfoFile\_PCG()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} \begin{description}
\item[{\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);}] \leavevmode
a \sphinxcode{NULL} input will disable output

\end{description}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNLinSolSetPrintLevel\_PCG (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSolSetPrintLevel_PCG}}\pysiglinewithargsret{int \sphinxbfcode{SUNLinSolSetPrintLevel\_PCG}}{SUNLinearSolver\sphinxstyleemphasis{ LS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSolSetPrintLevel_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSolSetPrintLevel\_PCG()}}}} specifies the
level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{LS} \textendash{} a SUNLinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each linear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUNLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUNLS\_MEM\_NULL} if the SUNLinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUNLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled, or
if the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the linear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}


For backwards compatibility, we also provide the wrapper functions,
each with identical input and output arguments to the routines that
they wrap:
\index{SUNPCG (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNPCG}}\pysiglinewithargsret{SUNLinearSolver \sphinxbfcode{SUNPCG}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ pretype}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCG}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCG()}}}}

\end{fulllineitems}

\index{SUNPCGSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNPCGSetPrecType}}\pysiglinewithargsret{int \sphinxbfcode{SUNPCGSetPrecType}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ pretype}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetPrecType()}}}}

\end{fulllineitems}

\index{SUNPCGSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNPCGSetMaxl}}\pysiglinewithargsret{int \sphinxbfcode{SUNPCGSetMaxl}}{SUNLinearSolver\sphinxstyleemphasis{ S}, int\sphinxstyleemphasis{ maxl}}{}
Wrapper function for {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetMaxl()}}}}

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLinSol\_PCG module also includes the Fortran-callable
function {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit}]{\sphinxcrossref{\sphinxcode{FSUNPCGInit()}}}} to initialize
this SUNLinSol\_PCG module for a given SUNDIALS solver.
\index{FSUNPCGInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNPCGInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a PCG \sphinxcode{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting whether to use
symmetric preconditioning: no=0, yes=1.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of PCG iterations to allow.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity
mass matrix, the Fortran-callable function
{\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit}]{\sphinxcrossref{\sphinxcode{FSUNMassPCGInit()}}}} initializes this
SUNLinSol\_PCG module for solving mass matrix linear systems.
\index{FSUNMassPCGInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassPCGInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a PCG \sphinxcode{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{PRETYPE} (\sphinxcode{int}, input) \textendash{} flag denoting whether to use
symmetric preconditioning: no=0, yes=1.

\item {} 
\sphinxstyleemphasis{MAXL} (\sphinxcode{int}, input) \textendash{} number of PCG iterations to allow.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetPrecType()}}}} and {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetMaxl()}}}}
routines also support Fortran interfaces for the system and mass
matrix solvers:
\index{FSUNPCGSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNPCGSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetPrecType()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit}]{\sphinxcrossref{\sphinxcode{FSUNPCGInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassPCGSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGSetPrecType}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassPCGSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetPrecType}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit}]{\sphinxcrossref{\sphinxcode{FSUNMassPCGInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNPCGSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGSetMaxl}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNPCGSetMaxl}}{\emph{CODE}, \emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetMaxl()}}}} for system
linear solvers.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit}]{\sphinxcrossref{\sphinxcode{FSUNPCGInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassPCGSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGSetMaxl}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNMassPCGSetMaxl}}{\emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:c.SUNLinSol_PCGSetMaxl}]{\sphinxcrossref{\sphinxcode{SUNLinSol\_PCGSetMaxl()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \sphinxstyleemphasis{after} {\hyperref[\detokenize{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit}]{\sphinxcrossref{\sphinxcode{FSUNMassPCGInit()}}}} has
been called.

\sphinxstylestrong{Arguments:} all should have type \sphinxcode{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\subsection{SUNLinSol\_PCG Description}
\label{\detokenize{sunlinsol/SUNLinSol_PCG:id3}}\label{\detokenize{sunlinsol/SUNLinSol_PCG:sunlinsol-pcg-description}}
The SUNLinSol\_PCG module defines the \sphinxstyleemphasis{content} field of a
\sphinxcode{SUNLinearSolver} to be the following structure:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}PCG} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{z}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{Ap}\PYG{p}{;}
  \PYG{k+kt}{int}      \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}    \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{maxl} - number of PCG iterations to allow (default is 5),

\item {} 
\sphinxcode{pretype} - flag for use of preconditioning (default is none),

\item {} 
\sphinxcode{numiters} - number of iterations from the most-recent solve,

\item {} 
\sphinxcode{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\sphinxcode{last\_flag} - last error return flag from an internal
function,

\item {} 
\sphinxcode{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\sphinxcode{ATData} - pointer to structure for \sphinxcode{ATimes},

\item {} 
\sphinxcode{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\sphinxcode{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\sphinxcode{PData} - pointer to structure for \sphinxcode{Psetup} and \sphinxcode{Psolve},

\item {} 
\sphinxcode{s} - vector pointer for supplied scaling matrix
(default is \sphinxcode{NULL}),

\item {} 
\sphinxcode{r} - a \sphinxcode{N\_Vector} which holds the preconditioned linear system
residual,

\item {} 
\sphinxcode{p, z, Ap} - \sphinxcode{N\_Vector} used for workspace by the
PCG algorithm.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction all \sphinxcode{N\_Vector} solver data is allocated, with
vectors cloned from a template \sphinxcode{N\_Vector} that is input, and
default solver parameters are set.

\item {} 
User-facing “set” routines may be called to modify default
solver parameters.

\item {} 
Additional “set” routines are called by the SUNDIALS solver
that interfaces with SUNLinSol\_PCG to supply the
\sphinxcode{ATimes}, \sphinxcode{PSetup}, and \sphinxcode{Psolve} function pointers and
\sphinxcode{s} scaling vector.

\item {} 
In the “initialize” call, the solver parameters are checked
for validity.

\item {} 
In the “setup” call, any non-\sphinxcode{NULL} \sphinxcode{PSetup} function is
called.  Typically, this is provided by the SUNDIALS solver
itself, that translates between the generic \sphinxcode{PSetup} function and
the solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the “solve” call the PCG iteration is performed.  This
will include scaling and preconditioning if those options have been
supplied.

\end{itemize}

The SUNLinSol\_PCG module defines implementations of all
“iterative” linear solver operations listed in the section
{\hyperref[\detokenize{sunlinsol/SUNLinSol_API:sunlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNLinearSolver API}}}}:
\begin{itemize}
\item {} 
\sphinxcode{SUNLinSolGetType\_PCG}

\item {} 
\sphinxcode{SUNLinSolInitialize\_PCG}

\item {} 
\sphinxcode{SUNLinSolSetATimes\_PCG}

\item {} 
\sphinxcode{SUNLinSolSetPreconditioner\_PCG}

\item {} 
\sphinxcode{SUNLinSolSetScalingVectors\_PCG} \textendash{} since PCG only supports
symmetric scaling, the second \sphinxcode{N\_Vector} argument to this function
is ignored

\item {} 
\sphinxcode{SUNLinSolSetup\_PCG}

\item {} 
\sphinxcode{SUNLinSolSolve\_PCG}

\item {} 
\sphinxcode{SUNLinSolNumIters\_PCG}

\item {} 
\sphinxcode{SUNLinSolResNorm\_PCG}

\item {} 
\sphinxcode{SUNLinSolResid\_PCG}

\item {} 
\sphinxcode{SUNLinSolLastFlag\_PCG}

\item {} 
\sphinxcode{SUNLinSolSpace\_PCG}

\item {} 
\sphinxcode{SUNLinSolFree\_PCG}

\end{itemize}


\section{SUNLinearSolver Examples}
\label{\detokenize{sunlinsol/SUNLinSol_Examples:sunlinearsolver-examples}}\label{\detokenize{sunlinsol/SUNLinSol_Examples::doc}}\label{\detokenize{sunlinsol/SUNLinSol_Examples:sunlinsol-examples}}
There are \sphinxcode{SUNLinearSolver} examples that may be installed for each
implementation; these make use of the functions in \sphinxcode{test\_sunlinsol.c}.
These example functions show simple usage of the \sphinxcode{SUNLinearSolver} family
of modules.  The inputs to the examples depend on the linear solver type,
and are output to \sphinxcode{stdout} if the example is run without the
appropriate number of command-line arguments.

The following is a list of the example functions in \sphinxcode{test\_sunlinsol.c}:
\begin{itemize}
\item {} 
\sphinxcode{Test\_SUNLinSolGetType}: Verifies the returned solver type against
the value that should be returned.

\item {} 
\sphinxcode{Test\_SUNLinSolInitialize}: Verifies that \sphinxcode{SUNLinSolInitialize}
can be called and returns successfully.

\item {} 
\sphinxcode{Test\_SUNLinSolSetup}: Verifies that \sphinxcode{SUNLinSolSetup} can
be called and returns successfully.

\item {} 
\sphinxcode{Test\_SUNLinSolSolve}: Given a \sphinxcode{SUNMatrix} object \(A\),
\sphinxcode{N\_Vector} objects \(x\) and \(b\) (where \(Ax=b\))
and a desired solution tolerance \sphinxcode{tol}, this routine clones
\(x\) into a new vector \(y\), calls \sphinxcode{SUNLinSolSolve} to
fill \(y\) as the solution to \(Ay=b\) (to the input
tolerance), verifies that each entry in \(x\) and \(y\)
match to within \sphinxcode{10*tol}, and overwrites \(x\) with \(y\)
prior to returning (in case the calling routine would like to
investigate further).

\item {} 
\sphinxcode{Test\_SUNLinSolSetATimes} (iterative solvers only): Verifies that
\sphinxcode{SUNLinSolSetATimes} can be called and returns successfully.

\item {} 
\sphinxcode{Test\_SUNLinSolSetPreconditioner} (iterative solvers only):
Verifies that \sphinxcode{SUNLinSolSetPreconditioner} can be called and
returns successfully.

\item {} 
\sphinxcode{Test\_SUNLinSolSetScalingVectors} (iterative solvers only):
Verifies that \sphinxcode{SUNLinSolSetScalingVectors} can be called and
returns successfully.

\item {} 
\sphinxcode{Test\_SUNLinSolLastFlag}: Verifies that \sphinxcode{SUNLinSolLastFlag} can
be called, and outputs the result to \sphinxcode{stdout}.

\item {} 
\sphinxcode{Test\_SUNLinSolNumIters} (iterative solvers only): Verifies that
\sphinxcode{SUNLinSolNumIters} can be called, and outputs the result to
\sphinxcode{stdout}.

\item {} 
\sphinxcode{Test\_SUNLinSolResNorm} (iterative solvers only): Verifies that
\sphinxcode{SUNLinSolResNorm} can be called, and that the result is
non-negative.

\item {} 
\sphinxcode{Test\_SUNLinSolResid} (iterative solvers only): Verifies that
\sphinxcode{SUNLinSolResid} can be called.

\item {} 
\sphinxcode{Test\_SUNLinSolSpace} verifies that \sphinxcode{SUNLinSolSpace} can be
called, and outputs the results to \sphinxcode{stdout}.

\end{itemize}

We’ll note that these tests should be performed in a particular
order.  For either direct or iterative linear
solvers, \sphinxcode{Test\_SUNLinSolInitialize} must be called
before \sphinxcode{Test\_SUNLinSolSetup}, which must be called
before \sphinxcode{Test\_SUNLinSolSolve}.  Additionally, for iterative linear
solvers \sphinxcode{Test\_SUNLinSolSetATimes}, \sphinxcode{Test\_SUNLinSolSetPreconditioner}
and \sphinxcode{Test\_SUNLinSolSetScalingVectors} should be called
before \sphinxcode{Test\_SUNLinSolInitialize};
similarly \sphinxcode{Test\_SUNLinSolNumIters}, \sphinxcode{Test\_SUNLinSolResNorm}
and \sphinxcode{Test\_SUNLinSolResid} should be called
after \sphinxcode{Test\_SUNLinSolSolve}.  These are called in the appropriate
order in all of the example problems.


\chapter{Description of the SUNNonlinearSolver Module}
\label{\detokenize{sunnonlinsol/index:description-of-the-sunnonlinearsolver-module}}\label{\detokenize{sunnonlinsol/index::doc}}\label{\detokenize{sunnonlinsol/index:sunnonlinsol}}
SUNDIALS time integration packages are written in terms of generic nonlinear
solver operations defined by the SUNNonlinSol API and implemented by a
particular SUNNonlinSol module of type \sphinxcode{SUNNonlinearSolver}.
Users can supply their own SUNNonlinSol module, or use one of the modules
provided with SUNDIALS. Depending on the package, nonlinear solver modules
can either target system presented in a rootfinding (\(F(y) = 0\)) or
fixed-point (\(G(y) = y\)) formulation. For more information on the
formulation of the nonlinear system(s) see the {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:sunnonlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNNonlinearSolver interface}}}}
section.

The time integrators in SUNDIALS specify a default nonlinear solver module
and as such this chapter is intended for users that wish to use a non-default
nonlinear solver module or would like to provide their own nonlinear solver
implementation. Users interested in using a non-default solver module may skip
the description of the SUNNonlinSol API in section {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-api}]{\sphinxcrossref{\DUrole{std,std-ref}{The SUNNonlinearSolver API}}}}
and proceeded to the subsequent sections in this chapter that describe the
SUNNonlinSol modules provided with SUNDIALS.

For users interested in providing their own SUNNonlinSol module, the
following section presents the SUNNonlinSol API and its implementation
beginning with the definition of SUNNonlinSol functions in the
sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-setfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver set functions}}}} and
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}}. This is followed by the definition of
functions supplied to a nonlinear solver implementation in the section
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}}.  The nonlinear solver return
codes are given in the section {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-returncodes}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver return codes}}}}. The
\sphinxcode{SUNNonlinearSolver} type and the generic SUNNonlinSol module are defined
in the section {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-generic}]{\sphinxcrossref{\DUrole{std,std-ref}{The generic SUNNonlinearSolver module}}}}. Finally, the section
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-custom}]{\sphinxcrossref{\DUrole{std,std-ref}{Implementing a Custom SUNNonlinearSolver Module}}}} lists the requirements for supplying a custom
SUNNonlinSol module. Users wishing to supply their own SUNNonlinSol module
are encouraged to use the SUNNonlinSol implementations provided with
SUNDIALS as a template for supplying custom nonlinear solver modules.


\section{The SUNNonlinearSolver API}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:the-sunnonlinearsolver-api}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API::doc}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-api}}
The SUNNonlinSol API defines several nonlinear solver operations that enable
SUNDIALS integrators to utilize any SUNNonlinSol implementation that
provides the required functions. These functions can be divided into three
categories. The first are the core nonlinear solver functions. The second group
of functions consists of set routines to supply the nonlinear solver with
functions provided by the SUNDIALS time integrators and to modify solver
parameters. The final group consists of get routines for retrieving nonlinear
solver statistics. All of these functions are defined in the header file
\sphinxcode{sundials/sundials\_nonlinearsolver.h}.


\subsection{SUNNonlinearSolver core functions}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinearsolver-core-functions}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}}
The core nonlinear solver functions consist of two required functions to get the
nonlinear solver type (\sphinxcode{SUNNonlinsSolGetType}) and solve the nonlinear system
(\sphinxcode{SUNNonlinSolSolve}). The remaining three functions for nonlinear solver
initialization (\sphinxcode{SUNNonlinSolInitialization}), setup
(\sphinxcode{SUNNonlinSolSetup}), and destruction (\sphinxcode{SUNNonlinSolFree}) are optional.
\index{SUNNonlinSolGetType (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetType}}\pysiglinewithargsret{SUNNonlinearSolver\_Type \sphinxbfcode{SUNNonlinSolGetType}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}}{}
The \sphinxstyleemphasis{required} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetType}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetType()}}}} returns the
nonlinear solver type.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the SUNNonlinSol type identifier (of type
\sphinxcode{int}) will be one of the following:
\begin{itemize}
\item {} 
\sphinxcode{SUNNONLINEARSOLVER\_ROOTFIND} \textendash{} \sphinxcode{0}, the SUNNonlinSol module
solves \(F(y) = 0\).

\item {} 
\sphinxcode{SUNNONLINEARSOLVER\_FIXEDPOINT} \textendash{} \sphinxcode{1}, the SUNNonlinSol
module solves \(G(y) = y\).

\end{itemize}

\end{fulllineitems}

\index{SUNNonlinSolInitialize (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolInitialize}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolInitialize}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolInitialize}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolInitialize()}}}} performs
nonlinear solver initialization and may perform any necessary memory
allocations.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value is zero for a
successful call and a negative value for a failure.

\sphinxstylestrong{Notes:} It is assumed all solver-specific options have been set
prior to calling {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolInitialize}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolInitialize()}}}}. SUNNonlinSol
implementations that do not require initialization may set this
operation to \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNNonlinSolSetup (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetup}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetup}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, N\_Vector\sphinxstyleemphasis{ y}, void*\sphinxstyleemphasis{ mem}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetup}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetup()}}}} performs any
solver setup needed for a nonlinear solve.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{y} \textendash{} the initial iteration passed to the nonlinear solver.

\item {} 
\sphinxstyleemphasis{mem} \textendash{} the SUNDIALS integrator memory structure.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value is zero for a
successful call and a negative value for a failure.

\sphinxstylestrong{Notes:} SUNDIALS integrators call \sphinxcode{SUNonlinSolSetup()}
before each step attempt. SUNNonlinSol implementations that do not
require setup may set this operation to \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNNonlinSolSolve (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSolve}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSolve}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, N\_Vector\sphinxstyleemphasis{ y0}, N\_Vector\sphinxstyleemphasis{ ycor}, N\_Vector\sphinxstyleemphasis{ w}, realtype\sphinxstyleemphasis{ tol}, booleantype\sphinxstyleemphasis{ callLSetup}, void\sphinxstyleemphasis{ *mem}}{}
The \sphinxstyleemphasis{required} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSolve}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSolve()}}}} solves the
nonlinear system \(F(y)=0\) or \(G(y)=y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{y0} \textendash{} the predicted value for the new solution state. This
\sphinxstyleemphasis{must} remain unchanged throughout the solution process. See the
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:sunnonlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNNonlinearSolver interface}}}} section for more detail on the nonlinear
system formulation.

\item {} 
\sphinxstyleemphasis{ycor} \textendash{} on input the initial guess for the correction to the predicted
state (zero) and on output the final correction to the predicted
state. See the {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:sunnonlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNNonlinearSolver interface}}}} section for more detail on the
nonlinear system formulation.

\item {} 
\sphinxstyleemphasis{w} \textendash{} the solution error weight vector used for computing weighted error norms.

\item {} 
\sphinxstyleemphasis{tol} \textendash{} the requested solution tolerance in the weighted root-mean-squared norm.

\item {} 
\sphinxstyleemphasis{callLSetup} \textendash{} a flag indicating that the integrator
recommends for the linear solver setup function to be called.

\item {} 
\sphinxstyleemphasis{mem} \textendash{} the SUNDIALS integrator memory structure.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value is zero for a successul solve, a positive
value for a recoverable error (i.e., the solve failed and the integrator
should reduce the step size and reattempt the step), and a negative value for
an unrecoverable error (i.e., the solve failed the and the integrator should
halt and return an error to the user).

\end{fulllineitems}

\index{SUNNonlinSolFree (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolFree}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolFree}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolFree}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolFree()}}}} frees any
memory allocated by the nonlinear solver.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure. SUNNonlinSol
implementations that do not allocate data may set this operation
to \sphinxcode{NULL}.

\end{fulllineitems}



\subsection{SUNNonlinearSolver set functions}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-setfn}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinearsolver-set-functions}}
The following set functions are used to supply nonlinear solver modules with
functions defined by the SUNDIALS integrators and to modify solver
parameters. Only the routine for setting the nonlinear system defining function
(\sphinxcode{SUNNonlinSolSetSysFn}) is required. All other set functions are optional.
\index{SUNNonlinSolSetSysFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetSysFn}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetSysFn}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{SUNNonlinSolSysFn}}}\sphinxstyleemphasis{ SysFn}}{}
The \sphinxstyleemphasis{required} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetSysFn()}}}} is used to
provide the nonlinear solver with the function defining the
nonlinear system. This is the function \(F(y)\) in
\(F(y)=0\) for \sphinxcode{SUNNONLINEARSOLVER\_ROOTFIND} modules or
\(G(y)\) in \(G(y)=y\) for \sphinxcode{SUNNONLINEARSOLVER\_FIXEDPOINT} modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{SysFn} \textendash{} the function defining the nonlinear system. See the
section {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for the definition of
\sphinxcode{SUNNonlinSolSysFn()}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\end{fulllineitems}

\index{SUNNonlinSolSetLSetupFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSetupFn}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetLSetupFn}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{SUNNonlinSolLSetupFn}}}\sphinxstyleemphasis{ SetupFn}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn()}}}} is called
by SUNDIALS integrators to provide the nonlinear solver with access
to its linear solver setup function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{SetupFn} \textendash{} a wrapper function to the SUNDIALS integrator’s linear solver setup
function. See the section {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}}  for the
definition of {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\sphinxstylestrong{Notes:} The {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn}}}} function sets up the
linear system \(Ax=b\) where \(A = \frac{\partial
F}{\partial y}\) is the linearization of the nonlinear residual
function \(F(y) = 0\) (when using SUNLinSol direct linear
solvers) or calls the user-defined preconditioner setup function
(when using SUNLinSol iterative linear solvers). SUNNonlinSol
implementations that do not require solving this system, do not
utilize SUNLinSol linear solvers, or use SUNLinSol linear solvers
that do not require setup may set this operation to \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNNonlinSolSetLSolveFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSolveFn}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetLSolveFn}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{SUNNonlinSolLSolveFn}}}\sphinxstyleemphasis{ SolveFn}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSolveFn()}}}} is
called by SUNDIALS integrators to provide the nonlinear solver with
access to its linear solver solve function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{SolveFn} \textendash{} a wrapper function to the SUNDIALS integrator’s
linear solver solve function. See the section
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for the definition of
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSolveFn}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\sphinxstylestrong{Notes:} The {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSolveFn}}}} function solves the
linear system \(Ax=b\) where \(A = \frac{\partial
F}{\partial y}\) is the linearization of the nonlinear residual
function \(F(y) = 0\).  SUNNonlinSol implementations that do
not require solving this system or do not use SUNLinSol linear
solvers may set this operation to \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNNonlinSolSetConvTestFn (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetConvTestFn}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetConvTestFn}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolConvTestFn}]{\sphinxcrossref{SUNNonlinSolConvTestFn}}}\sphinxstyleemphasis{ CTestFn}, void*\sphinxstyleemphasis{ ctest\_data}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetConvTestFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetConvTestFn()}}}} is
used to provide the nonlinear solver with a function for
determining if the nonlinear solver iteration has converged. This
is typically called by SUNDIALS integrators to define their
nonlinear convergence criteria, but may be replaced by the user.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{CTestFn} \textendash{} a SUNDIALS integrator’s nonlinear solver
convergence test function. See the section
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}]{\sphinxcrossref{\DUrole{std,std-ref}{Functions provided by SUNDIALS integrators}}}} for the definition of
\sphinxcode{SUNNonlinSolConvTestFn()}.

\item {} 
\sphinxstyleemphasis{ctest\_data} \textendash{} is a data pointer passed to \sphinxstyleemphasis{CTestFn} every time it is
called.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\sphinxstylestrong{Notes:} SUNNonlinSol implementations utilizing their own
convergence test criteria may set this function to \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNNonlinSolSetMaxIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetMaxIters}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetMaxIters}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, int\sphinxstyleemphasis{ maxiters}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetMaxIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetMaxIters()}}}} sets
the maximum number of nonlinear solver iterations. This is
typically called by SUNDIALS integrators to define their default
iteration limit, but may be adjusted by the user.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{maxiters} \textendash{} the maximum number of nonlinear iterations.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure
(e.g., \(maxiters < 1\)).

\end{fulllineitems}



\subsection{SUNNonlinearSolver get functions}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinearsolver-get-functions}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}}
The following get functions allow SUNDIALS integrators to retrieve nonlinear
solver statistics. The routines to get the number of iterations in the most
recent solve (\sphinxcode{SUNNonlinSolGetNumIters}) and number of convergence failures
are optional. The routine to get the current nonlinear solver iteration
(\sphinxcode{SUNNonlinSolGetCurIter}) is required when using the convergence test
provided by the SUNDIALS integrator or when using a SUNLinSol spils linear
solver otherwise, \sphinxcode{SUNNonlinSolGetCurIter} is optional.
\index{SUNNonlinSolGetNumIters (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetNumIters}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetNumIters}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, long int\sphinxstyleemphasis{ *niters}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetNumIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetNumIters()}}}} returns the
number of nonlinear solver iterations in the most recent solve. This is
typically called by the SUNDIALS integrator to store the nonlinear solver
statistics, but may also be called by the user.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{niters} \textendash{} the total number of nonlinear solver iterations.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\end{fulllineitems}

\index{SUNNonlinSolGetCurIter (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetCurIter}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetCurIter}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, int\sphinxstyleemphasis{ *iter}}{}~\begin{quote}

The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetCurIter}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetCurIter()}}}} returns the
iteration index of the current nonlinear solve. This function is
\sphinxstyleemphasis{required} when using SUNDIALS integrator-provided convergence
tests or when using a SUNLinSol spils linear solver; otherwise it
is \sphinxstyleemphasis{optional}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{iter} \textendash{} the nonlinear solver iteration in the current solve
starting from zero.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.
\end{quote}
\index{SUNNonlinSolGetNumConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetNumConvFails}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetNumConvFails}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, long int\sphinxstyleemphasis{ *nconvfails}}{}
The \sphinxstyleemphasis{optional} function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolGetNumConvFails}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetNumConvFails()}}}} returns the
number of nonlinear solver convergence failures in the most recent solve.
This is typically called by the SUNDIALS integrator to store the nonlinear
solver statistics, but may also be called by the user.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{nconvfails} \textendash{} the total number of nonlinear solver convergence failures.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\end{fulllineitems}


\end{fulllineitems}



\subsection{Functions provided by SUNDIALS integrators}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-sunsuppliedfn}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:functions-provided-by-sundials-integrators}}
To interface with SUNNonlinSol modules, the SUNDIALS integrators
supply a variety of routines for evaluating the nonlinear system,
calling the SUNLinSol setup and solve functions, and testing the
nonlinear iteration for convergence.  These integrator-provided routines
translate between the user-supplied ODE or DAE systems and the generic
interfaces to the nonlinear or linear systems of equations that result
in their solution. The types for functions provided to a SUNNonlinSol
module are defined in the header file
\sphinxcode{sundials/sundials\_nonlinearsolver.h}, and are described below.
\index{SUNNonlinSolSysFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*SUNNonlinSolSysFn)}}{N\_Vector\sphinxstyleemphasis{ ycor}, N\_Vector\sphinxstyleemphasis{ F}, void*\sphinxstyleemphasis{ mem}}{}
These functions evaluate the nonlinear system \(F(y)\)
for \sphinxcode{SUNNONLINEARSOLVER\_ROOTFIND} type modules or \(G(y)\)
for \sphinxcode{SUNNONLINEARSOLVER\_FIXEDPOINT} type modules. Memory
for \sphinxstyleemphasis{F} must by be allocated prior to calling this function. The
vector \sphinxstyleemphasis{ycor} will be left unchanged.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ycor} \textendash{} is the current correction to the predicted state at which the
nonlinear system should be evaluated. See the {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:sunnonlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNNonlinearSolver interface}}}}
section for more detail on the nonlinear system function.

\item {} 
\sphinxstyleemphasis{F} \textendash{} is the output vector containing \(F(y)\) or
\(G(y)\), depending on the solver type.

\item {} 
\sphinxstyleemphasis{mem} \textendash{} is the SUNDIALS integrator memory structure.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value is zero for a
successul solve, a positive value for a recoverable error, and a
negative value for an unrecoverable error.

As discussed in section {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:sunnonlinsol-arkode}]{\sphinxcrossref{\DUrole{std,std-ref}{ARKode SUNNonlinearSolver interface}}}}, SUNDIALS integrators
formulate nonlinear systems as a function of the correction to the predicted
solution. On each call to the nonlinear system function the integrator will
compute and store the current solution based on the input correction.
Additionally, the residual will store the value of the ODE right-hand side
function or DAE residual used in computing the nonlinear system. These stored
values are then directly used in the integrator-supplied linear solver setup
and solve functions as applicable.

\end{fulllineitems}

\index{SUNNonlinSolLSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*SUNNonlinSolLSetupFn)}}{booleantype\sphinxstyleemphasis{ jbad}, booleantype*\sphinxstyleemphasis{ jcur}, void*\sphinxstyleemphasis{ mem}}{}
These functions are wrappers to the SUNDIALS integrator’s function
for setting up linear solves with SUNLinSol modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{jbad} \textendash{} is an input indicating whether the nonlinear solver
believes that \(A\) has gone stale (\sphinxcode{SUNTRUE}) or not (\sphinxcode{SUNFALSE}).

\item {} 
\sphinxstyleemphasis{jcur} \textendash{} is an output indicating whether the routine has updated the
Jacobian \(A\) (\sphinxcode{SUNTRUE}) or not (\sphinxcode{SUNFALSE}).

\item {} 
\sphinxstyleemphasis{mem} \textendash{} is the SUNDIALS integrator memory structure.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value is zero for a
successul solve, a positive value for a recoverable error, and a
negative value for an unrecoverable error.

\sphinxstylestrong{Notes:}  The {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn}}}} function sets up the
linear system \(Ax=b\) where \(A = \frac{\partial
F}{\partial y}\) is the linearization of the nonlinear residual
function \(F(y) = 0\) (when using SUNLinSol direct linear
solvers) or calls the user-defined preconditioner setup function
(when using SUNLinSol iterative linear solvers). SUNNonlinSol
implementations that do not require solving this system, do not
utilize SUNLinSol linear solvers, or use SUNLinSol linear solvers
that do not require setup may ignore these functions.

As discussed in the description of \sphinxcode{SUNNonlinSolSysFn()}, the linear
solver setup function assumes that the nonlinear system function has been
called prior to the linear solver setup function as the setup will utilize
saved values from the nonlinear system evaluation (e.g., the updated
solution).

\end{fulllineitems}

\index{SUNNonlinSolLSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}}\pysiglinewithargsret{typedef int \sphinxbfcode{(*SUNNonlinSolLSolveFn)}}{N\_Vector\sphinxstyleemphasis{ b}, void*\sphinxstyleemphasis{ mem}}{}
These functions are wrappers to the SUNDIALS integrator’s function
for solving linear systems with SUNLinSol modules.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{b} \textendash{} contains the right-hand side vector for the linear
solve on input and the solution to the linear system on output.

\item {} 
\sphinxstyleemphasis{mem} \textendash{} is the SUNDIALS integrator memory structure.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value is zero for a
successul solve, a positive value for a recoverable error, and a
negative value for an unrecoverable error.

\sphinxstylestrong{Notes:}  The {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSolveFn}}}} function solves the
linear system \(Ax=b\) where \(A = \frac{\partial
F}{\partial y}\) is the linearization of the nonlinear residual
function \(F(y) = 0\). SUNNonlinSol implementations that do not
require solving this system or do not use SUNLinSol linear solvers
may ignore these functions.

As discussed in the description of \sphinxcode{SUNNonlinSolSysFn()}, the linear
solver solve function assumes that the nonlinear system function has been
called prior to the linear solver solve function as the setup may utilize
saved values from the nonlinear system evaluation (e.g., the updated
solution).

\end{fulllineitems}

\index{SUNNonlinSolConvTestFn (C type)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolConvTestFn}}\pysiglinewithargsret{int \sphinxbfcode{(*SUNNonlinSolConvTestFn)}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, N\_Vector\sphinxstyleemphasis{ ycor}, N\_Vector\sphinxstyleemphasis{ del}, realtype\sphinxstyleemphasis{ tol}, N\_Vector\sphinxstyleemphasis{ ewt}, void*\sphinxstyleemphasis{ ctest\_data}}{}
These functions are SUNDIALS integrator-specific convergence tests for
nonlinear solvers and are typically supplied by each SUNDIALS integrator,
but users may supply custom problem-specific versions as desired.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} is the SUNNonlinSol object.

\item {} 
\sphinxstyleemphasis{ycor} \textendash{} is the current correction (nonlinear iterate).

\item {} 
\sphinxstyleemphasis{del} \textendash{} is the difference between the current and prior nonlinear iterates.

\item {} 
\sphinxstyleemphasis{tol} \textendash{} is the nonlinear solver tolerance.

\item {} 
\sphinxstyleemphasis{ewt} \textendash{} is the weight vector used in computing weighted norms.

\item {} 
\sphinxstyleemphasis{ctest\_data} \textendash{} is the data pointer provided to
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetConvTestFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetConvTestFn()}}}}.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value of this routine will be a
negative value if an unrecoverable error occurred or one of the
following:
\begin{itemize}
\item {} 
\sphinxcode{SUN\_NLS\_SUCCESS} \textendash{} the iteration is converged.

\item {} 
\sphinxcode{SUN\_NLS\_CONTINUE} \textendash{} the iteration has not converged, keep
iterating.

\item {} 
\sphinxcode{SUN\_NLS\_CONV\_RECVR} \textendash{} the iteration appears to be
diverging, try to recover.

\end{itemize}

\sphinxstylestrong{Notes:}  The tolerance passed to this routine by SUNDIALS
integrators is the tolerance in a weighted root-mean-squared norm
with error weight vector \sphinxcode{ewt}. SUNNonlinSol modules utilizing
their own convergence criteria may ignore these functions.

\end{fulllineitems}



\subsection{SUNNonlinearSolver return codes}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinearsolver-return-codes}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-returncodes}}
The functions provided to SUNNonlinSol modules by each SUNDIALS
integrator, and functions within the SUNDIALS-provided SUNNonlinSol
implementations utilize a common set of return codes, shown in the
table below.  Here, negative values correspond to non-recoverable
failures, positive values to recoverable failures, and zero to a
successful call.

Description of the \sphinxcode{SUNNonlinearSolver} return codes:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

Name
&
Value
&
Description
\\
\hline
SUN\_NLS\_SUCCESS
&
0
&
successful call or converged solve
\\
\hline
SUN\_NLS\_CONTINUE
&
901
&
the nonlinear solver is not converged, keep iterating
\\
\hline
SUN\_NLS\_CONV\_RECVR
&
902
&
the nonlinear solver appears to be diverging, try to recover
\\
\hline
SUN\_NLS\_MEM\_NULL
&
-901
&
a memory argument is \sphinxcode{NULL}
\\
\hline
SUN\_NLS\_MEM\_FAIL
&
-902
&
a memory access or allocation failed
\\
\hline
SUN\_NLS\_ILL\_INPUT
&
-903
&
an illegal input option was provided
\\
\hline
SUN\_NLS\_VECTOROP\_ERR
&
-904
&
a NVECTOR operation failed
\\
\hline
SUN\_NLS\_EXT\_FAIL
&
-905
&
an external library call returned an error
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{The generic SUNNonlinearSolver module}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-generic}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:the-generic-sunnonlinearsolver-module}}
SUNDIALS integrators interact with specific SUNNonlinSol
implementations through the generic SUNNonlinSol module on which all
other SUNNonlinSol implementations are built. The
\sphinxcode{SUNNonlinearSolver} type is a pointer to a structure containing an
implementation-dependent \sphinxstyleemphasis{content} field and an \sphinxstyleemphasis{ops}
field. The type \sphinxcode{SUNNonlinearSolver} is defined as follows:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNNonlinearSolver} \PYG{o}{*}\PYG{n}{SUNNonlinearSolver}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNNonlinearSolver} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
  \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNNonlinearSolver\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

where the \sphinxcode{\_generic\_SUNNonlinearSolver\_Ops} structure is a list of
pointers to the various actual nonlinear solver operations provided by a
specific implementation. The \sphinxcode{\_generic\_SUNNonlinearSolver\_Ops}
structure is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNNonlinearSolver\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
  \PYG{n}{SUNNonlinearSolver\PYGZus{}Type} \PYG{p}{(}\PYG{o}{*}\PYG{n}{gettype}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{initialize}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{setup}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{solve}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,}
                                   \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{booleantype}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{free}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{setsysfn}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{n}{SUNNonlinSolSysFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{setlsetupfn}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{n}{SUNNonlinSolLSetupFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{setlsolvefn}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{n}{SUNNonlinSolLSolveFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{setctestfn}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{n}{SUNNonlinSolConvTestFn}\PYG{p}{,}
                                        \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{setmaxiters}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{getnumiters}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{getcuriter}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                     \PYG{p}{(}\PYG{o}{*}\PYG{n}{getnumconvfails}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The generic SUNNonlinSol module defines and implements the nonlinear
solver operations defined in Sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}}
through {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}}. These routines are in fact only
wrappers to the nonlinear solver operations provided by a particular
SUNNonlinSol implementation, which are accessed through the ops
field of the \sphinxcode{SUNNonlinearSolver} structure. To illustrate this
point we show below the implementation of a typical nonlinear solver
operation from the generic SUNNonlinSol module, namely
\sphinxcode{SUNNonlinSolSolve}, which solves the nonlinear system and returns a flag
denoting a successful or failed solve:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{SUNNonlinSolSolve}\PYG{p}{(}\PYG{n}{SUNNonlinearSolver} \PYG{n}{NLS}\PYG{p}{,}
                      \PYG{n}{N\PYGZus{}Vector} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{y}\PYG{p}{,}
                      \PYG{n}{N\PYGZus{}Vector} \PYG{n}{w}\PYG{p}{,} \PYG{n}{realtype} \PYG{n}{tol}\PYG{p}{,}
                      \PYG{n}{booleantype} \PYG{n}{callLSetup}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{mem}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{NLS}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{NLS}\PYG{p}{,} \PYG{n}{y0}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{tol}\PYG{p}{,} \PYG{n}{callLSetup}\PYG{p}{,} \PYG{n}{mem}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Implementing a Custom SUNNonlinearSolver Module}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-custom}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:implementing-a-custom-sunnonlinearsolver-module}}
A SUNNonlinSol implementation \sphinxstyleemphasis{must} do the following:
\begin{itemize}
\item {} 
Specify the content of the SUNNonlinSol module.

\item {} 
Define and implement the required nonlinear solver operations
defined in Sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}} through
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}}. Note that the names of the module
routines should be unique to that implementation in order to permit
using more than one SUNNonlinSol module (each with different
\sphinxcode{SUNNonlinearSolver} internal data representations) in
the same code.

\item {} 
Define and implement a user-callable constructor to create a
\sphinxcode{SUNNonlinearSolver} object.

\end{itemize}

To aid in the creation of custom \sphinxcode{SUNNonlinearSolver} modules the generic
\sphinxcode{SUNNonlinearSolver} module provides the utility functions
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolNewEmpty}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolNewEmpty()}}}} and \sphinxcode{SUNNonlinsolFreeEmpty()}. When used
in custom \sphinxcode{SUNNonlinearSolver} constructors this function will ease the introduction
of any new optional nonlinear solver operations to the \sphinxcode{SUNNonlinearSolver} API
by ensuring only required operations need to be set.
\index{SUNNonlinSolNewEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolNewEmpty}}\pysiglinewithargsret{SUNNonlinearSolver \sphinxbfcode{SUNNonlinSolNewEmpty}}{}{}
This function allocates a new generic \sphinxcode{SUNNonlinearSolver} object and
initializes its content pointer and the function pointers in the operations
structure to \sphinxcode{NULL}.

\sphinxstylestrong{Return value:} If successful, this function returns a
\sphinxcode{SUNNonlinearSolver} object. If an error occurs when allocating the object,
then this routine will return \sphinxcode{NULL}.

\end{fulllineitems}

\index{SUNNonlinSolFreeEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolFreeEmpty}}\pysiglinewithargsret{void \sphinxbfcode{SUNNonlinSolFreeEmpty}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}}{}
This routine frees the generic \sphinxcode{SUNNonlinearSolver} object, under the assumption that any
implementation-specific data that was allocated within the underlying content structure
has already been freed. It will additionally test whether the ops pointer is \sphinxcode{NULL},
and, if it is not, it will free it as well.
\begin{quote}
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinearSolver object

\end{itemize}

\end{description}
\end{quote}

\end{fulllineitems}


Additionally, a \sphinxcode{SUNNonlinearSolver} implementation \sphinxstyleemphasis{may} do
the following:
\begin{itemize}
\item {} 
Define and implement additional user-callable “set” routines
acting on the \sphinxcode{SUNNonlinearSolver} object, e.g., for setting
various configuration options to tune the performance of the
nonlinear solve algorithm.

\item {} 
Provide additional user-callable “get” routines acting on the
\sphinxcode{SUNNonlinearSolver} object, e.g., for returning various solve
statistics.

\end{itemize}


\section{ARKode SUNNonlinearSolver interface}
\label{\detokenize{sunnonlinsol/ARKode_Interface:arkode-sunnonlinearsolver-interface}}\label{\detokenize{sunnonlinsol/ARKode_Interface::doc}}\label{\detokenize{sunnonlinsol/ARKode_Interface:sunnonlinsol-arkode}}
As discussed in {\hyperref[\detokenize{Mathematics:mathematics}]{\sphinxcrossref{\DUrole{std,std-ref}{Mathematical Considerations}}}} integration steps often require the
(approximate) solution of a nonlinear system. This system can be formulated as
the rootfinding problem
\begin{equation*}
\begin{split}G(z_i) &\equiv z_i - \gamma f^I\left(t^I_{n,i}, z_i\right) - a_i = 0 \qquad\qquad\qquad\text{[$M=I$]},\\
G(z_i) &\equiv M z_i - \gamma f^I\left(t^I_{n,i}, z_i\right) - a_i = 0 \qquad\qquad\quad\text{[$M$ static]},\\
G(z_i) &\equiv M(t^I_{n,i}) (z_i - a_i) - \gamma f^I\left(t^I_{n,i}, z_i\right) = 0 \qquad\text{[$M$ time-dependent]},\end{split}
\end{equation*}
where \(z_i\) is the i-th stage at time \(t_i\) and \(a_i\) is known
data that depends on the integration method.

Alternately, the nonlinear system above may be formulated as the fixed-point
problem
\begin{equation*}
\begin{split}z_i = z_i - M(t^I_{n,i})^{-1} G(z_i),\end{split}
\end{equation*}
where \(G(z_i)\) is the variant of the rootfinding problem listed above, and
\(M(t^I_{n,i})\) may equal either \(M\) or \(I\), as applicable.

Rather than solving the above nonlinear systems for the stage value \(z_i\)
directly, ARKode modules solve for the correction \(z_{cor}\) to the
predicted stage value \(z_{pred}\) so that \(z_i = z_{pred} + z_{cor}\).
Thus these nonlinear systems rewritten in terms of \(z_{cor}\) are

\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:equation-residual-corrector-arkstep}}\begin{equation}\label{equation:sunnonlinsol/ARKode_Interface:Residual_corrector_ARKStep}
\begin{split}G(z_{cor}) &\equiv z_{cor} - \gamma f^I\left(t^I_{n,i}, z_{i}\right) - \tilde{a}_i = 0 \qquad\qquad\qquad\text{[$M=I$]},\\
G(z_{cor}) &\equiv M z_{cor} - \gamma f^I\left(t^I_{n,i}, z_{i}\right) - \tilde{a}_i = 0 \quad\qquad\qquad\text{[$M$ static]},\\
G(z_{cor}) &\equiv M(t^I_{n,i}) (z_{cor} - \tilde{a}_i) - \gamma f^I\left(t^I_{n,i}, z_{i}\right) = 0 \qquad\text{[$M$ time-dependent]},\end{split}
\end{equation}
for the rootfinding problem and

\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:equation-fixedpt-corrector-arkstep}}\begin{equation}\label{equation:sunnonlinsol/ARKode_Interface:FixedPt_corrector_ARKStep}
\begin{split}z_{cor} = z_{cor} - M(t^I_{n,i})^{-1} G(z_{i}),\end{split}
\end{equation}
for the fixed-point problem.

Similarly, in MRIStep (that always assumes \(M=I\)), we have the nonlinear
residual in predictor-corrector form,

\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:equation-residual-corrector-mristep}}\begin{equation}\label{equation:sunnonlinsol/ARKode_Interface:Residual_corrector_MRIStep}
\begin{split}G(z_{cor}) \equiv z_{cor} - \gamma f^S\left(t^S_{n,i}, z_{i}\right) - \tilde{a}_i = 0,\end{split}
\end{equation}
and the corresponding fixed-point problem,

\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:equation-fixedpt-corrector-mristep}}\begin{equation}\label{equation:sunnonlinsol/ARKode_Interface:FixedPt_corrector_MRIStep}
\begin{split}z_{cor} = z_{cor} - G(z_{i}).\end{split}
\end{equation}
The nonlinear system functions provided by ARKode modules to the nonlinear
solver module internally update the current value of the stage based on the
input correction vector i.e., \(z_i = z_{pred} + z_{cor}\). The updated
vector \(z_i\) is used when calling the ODE right-hand side function and
when setting up linear solves (e.g., updating the Jacobian or preconditioner).

ARKode modules also provide several advanced functions that will not be needed
by most users, but might be useful for users who choose to provide their own
SUNNonlinearSolver implementation for use by ARKode. These routines provide
access to the internal integrator data required to evaluate
\eqref{equation:sunnonlinsol/ARKode_Interface:Residual_corrector_ARKStep} or \eqref{equation:sunnonlinsol/ARKode_Interface:FixedPt_corrector_ARKStep} for ARKStep
and \eqref{equation:sunnonlinsol/ARKode_Interface:Residual_corrector_MRIStep} or \eqref{equation:sunnonlinsol/ARKode_Interface:FixedPt_corrector_MRIStep} for
MRIStep.


\subsection{ARKStep advanced output functions}
\label{\detokenize{sunnonlinsol/ARKode_Interface:arkstep-advanced-output-functions}}\index{ARKStepGetCurrentState (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentState}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentState}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector*\sphinxstyleemphasis{ state}}{}
Returns the current state vector. When called within the computation of a
step (i.e., during a nonlinear solve) this is the current stage state vector
\(z_i = z_{pred} + z_{cor}\). Otherwise this is the current internal
solution state vector \(y(t)\). In either case the corresponding stage or
solution time can be obtained from {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{state} \textendash{} N\_Vector pointer that will get set to the current stage or
\(z_i\) or solution state vector \(y(t)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetCurrentGamma (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentGamma}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentGamma}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ gamma}}{}
Returns the current value of the scalar \(\gamma\)
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the current value of the scalar \(\gamma\) appearing in
the Newton equation \(A = M - \gamma J\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetCurrentMassMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetCurrentMassMatrix}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetCurrentMassMatrix}}{void*\sphinxstyleemphasis{ arkode\_mem}, SUNMatrix*\sphinxstyleemphasis{ M}}{}
Returns the current mass matrix. For a time dependent mass matrix the
corresponding time can be obtained from {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{M} \textendash{} SUNMatrix pointer that will get set to the current mass matrix
\(M(t)\). If a matrix-free method is used the output is \sphinxcode{NULL}.

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKStepGetNonlinearSystemData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetNonlinearSystemData}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepGetNonlinearSystemData}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ *tcur}, N\_Vector\sphinxstyleemphasis{ *zpred}, N\_Vector\sphinxstyleemphasis{ *z}, N\_Vector\sphinxstyleemphasis{ *Fi}, realtype\sphinxstyleemphasis{ *gamma}, N\_Vector\sphinxstyleemphasis{ *sdata}, void\sphinxstyleemphasis{ **user\_data}}{}
Returns all internal data required to construct the current nonlinear
implicit system \eqref{equation:sunnonlinsol/ARKode_Interface:Residual_corrector_ARKStep} or
\eqref{equation:sunnonlinsol/ARKode_Interface:FixedPt_corrector_ARKStep}:
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} value of the independent variable corresponding to implicit
stage, \(t^I_{n,i}\).

\item {} 
\sphinxstyleemphasis{zpred} \textendash{} the predicted stage vector \(z_{pred}\) at
\(t^I_{n,i}\). This vector must not be changed.

\item {} 
\sphinxstyleemphasis{z} \textendash{} the stage vector \(z_{i}\) above. This vector may be not
current and may need to be filled (see the note below).

\item {} 
\sphinxstyleemphasis{Fi} \textendash{} the implicit function evaluated at the current time and state,
\(f^I(t^I_{n,i}, z_{i})\). This vector may be not current and may
need to be filled (see the note below).

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} current \(\gamma\) for implicit stage calculation.

\item {} 
\sphinxstyleemphasis{sdata} \textendash{} accumulated data from previous solution and stages,
\(\tilde{a}_i\). This vector must not be changed.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} pointer to the user-defined data structure (as specified
through {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetUserData}]{\sphinxcrossref{\sphinxcode{ARKStepSetUserData()}}}}, or \sphinxcode{NULL} otherwise)

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\begin{sphinxadmonition}{note}{Note:}
This routine is intended for users who whish to attach a custom
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} to an existing SUNNonlinearSolver object
(through a call to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetSysFn()}}}}) or who need access to
nonlinear system data to compute the nonlinear system fucntion as part of
a custom SUNNonlinearSolver object.

When supplying a custom {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} to an existing
SUNNonlinearSolver object, the user should call
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{ARKStepGetNonlinearSystemData()}}}} \sphinxstylestrong{inside} the nonlinear system
function to access the requisite data for evaluting the nonlinear systen
function of their choosing. Additionlly, if the SUNNonlinearSolver object
(existing or custom) leverages the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn}}}} and/or
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSolveFn}}}} functions supplied by ARKStep (through
calls to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSetupFn()}}}} and
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSolveFn()}}}} respectively) the vectors \sphinxstyleemphasis{z} and \sphinxstyleemphasis{Fi}
\sphinxstylestrong{must be filled} in by the user’s {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} with the
current state and corresponding evaluation of the right-hand side function
respectively i.e.,
\begin{equation*}
\begin{split}z  &= z_{pred} + z_{cor}, \\
Fi &= f^I\left(t^I_{n,i}, z_{i}\right),\end{split}
\end{equation*}
where \(z_{cor}\) was the first argument supplied to the
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}}.

If this function is called as part of a custom linear solver (i.e., the
default {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} is used) then the vectors \sphinxstyleemphasis{z} and
\sphinxstyleemphasis{Fi} are only current when {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{ARKStepGetNonlinearSystemData()}}}} is
called after an evaluation of the nonlinear system function.
\end{sphinxadmonition}

\end{fulllineitems}

\index{ARKStepComputeState (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.ARKStepComputeState}}\pysiglinewithargsret{int \sphinxbfcode{ARKStepComputeState}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ zcor}, N\_Vector\sphinxstyleemphasis{ z}}{}
Computes the current stage state vector using the stored prediction and the
supplied correction from the nonlinear solver i.e.,
\(z_i(t) = z_{pred} + z_{cor}\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{zcor} \textendash{} the correction from the nonlinear solver

\item {} 
\sphinxstyleemphasis{z} \textendash{} on output, the current stage state vector \(z_i\)

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsection{MRIStep advanced output functions}
\label{\detokenize{sunnonlinsol/ARKode_Interface:mristep-advanced-output-functions}}\index{MRIStepGetCurrentState (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetCurrentState}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetCurrentState}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector*\sphinxstyleemphasis{ state}}{}
Returns the current state vector. When called within the computation of a
step (i.e., during a nonlinear solve) this is the current stage state vector
\(z_i = z_{pred} + z_{cor}\). Otherwise this is the current internal
solution state vector \(y(t)\). In either case the corresponding stage or
solution time can be obtained from {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepGetCurrentTime}]{\sphinxcrossref{\sphinxcode{ARKStepGetCurrentTime()}}}}.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{state} \textendash{} N\_Vector pointer that will get set to the current stage
\(z_i\) or solution state vector \(y(t)\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetCurrentGamma (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetCurrentGamma}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetCurrentGamma}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype*\sphinxstyleemphasis{ gamma}}{}
Returns the current value of the scalar \(\gamma\)
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the ARKStep memory block.

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} the current value of the scalar \(\gamma\) appearing in
the Newton equation \(A = I - \gamma J\).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the ARKStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{MRIStepGetNonlinearSystemData (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetNonlinearSystemData}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepGetNonlinearSystemData}}{void*\sphinxstyleemphasis{ arkode\_mem}, realtype\sphinxstyleemphasis{ *tcur}, N\_Vector\sphinxstyleemphasis{ *zpred}, N\_Vector\sphinxstyleemphasis{ *z}, N\_Vector\sphinxstyleemphasis{ *F}, realtype\sphinxstyleemphasis{ *gamma}, N\_Vector\sphinxstyleemphasis{ *sdata}, void\sphinxstyleemphasis{ **user\_data}}{}
Returns all internal data required to construct the current nonlinear
implicit system \eqref{equation:sunnonlinsol/ARKode_Interface:Residual_corrector_MRIStep} or
\eqref{equation:sunnonlinsol/ARKode_Interface:FixedPt_corrector_MRIStep}:
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{tcur} \textendash{} value of independent variable corresponding to slow stage
(\(t^S_{n,i}\) above).

\item {} 
\sphinxstyleemphasis{zpred} \textendash{} predicted nonlinear solution (\(z_{pred}\) above). This
vector must not be changed.

\item {} 
\sphinxstyleemphasis{z} \textendash{} stage vector (\(z_{i}\) above). This vector may be not
current and may need to be filled (see the note below).

\item {} 
\sphinxstyleemphasis{F} \textendash{} memory available for evaluating the slow RHS
(\(f^S(t^S_{n,i}, z_{i})\) above). This vector may be
not current and may need to be filled (see the note below).

\item {} 
\sphinxstyleemphasis{gamma} \textendash{} current \(\gamma\) for slow stage calculation.

\item {} 
\sphinxstyleemphasis{sdata} \textendash{} accumulated data from previous solution and stages
(\(\tilde{a}_i\) above). This vector must not be changed.

\item {} 
\sphinxstyleemphasis{user\_data} \textendash{} pointer to the user-defined data structure (as specified
through {\hyperref[\detokenize{MRIStep_c_interface/User_callable:c.MRIStepSetUserData}]{\sphinxcrossref{\sphinxcode{MRIStepSetUserData()}}}}, or \sphinxcode{NULL} otherwise).

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\begin{sphinxadmonition}{note}{Note:}
This routine is intended for users who whish to attach a custom
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} to an existing SUNNonlinearSolver object
(through a call to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetSysFn()}}}}) or who need access to
nonlinear system data to compute the nonlinear system fucntion as part of
a custom SUNNonlinearSolver object.

When supplying a custom {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} to an existing
SUNNonlinearSolver object, the user should call
{\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{MRIStepGetNonlinearSystemData()}}}} \sphinxstylestrong{inside} the nonlinear system
function to access the requisite data for evaluting the nonlinear systen
function of their choosing. Additionlly, if the SUNNonlinearSolver object
(existing or custom) leverages the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSetupFn}}}} and/or
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolLSolveFn}}}} functions supplied by MRIStep (through
calls to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSetupFn()}}}} and
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSolveFn()}}}} respectively) the vectors \sphinxstyleemphasis{z} and \sphinxstyleemphasis{F}
\sphinxstylestrong{must be filled} in by the user’s {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} with the
current state and corresponding evaluation of the right-hand side function
respectively i.e.,
\begin{equation*}
\begin{split}z &= z_{pred} + z_{cor}, \\
F &= f^S\left(t^S_{n,i}, z_{i}\right),\end{split}
\end{equation*}
where \(z_{cor}\) was the first argument supplied to the
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}}.

If this function is called as part of a custom linear solver (i.e., the
default {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSysFn}}}} is used) then the vectors \sphinxstyleemphasis{z} and
\sphinxstyleemphasis{F} are only current when {\hyperref[\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepGetNonlinearSystemData}]{\sphinxcrossref{\sphinxcode{MRIStepGetNonlinearSystemData()}}}} is
called after an evaluation of the nonlinear system function.
\end{sphinxadmonition}

\end{fulllineitems}

\index{MRIStepComputeState (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/ARKode_Interface:c.MRIStepComputeState}}\pysiglinewithargsret{int \sphinxbfcode{MRIStepComputeState}}{void*\sphinxstyleemphasis{ arkode\_mem}, N\_Vector\sphinxstyleemphasis{ zcor}, N\_Vector\sphinxstyleemphasis{ z}}{}
Computes the current stage state vector using the stored prediction and the
supplied correction from the nonlinear solver i.e.,
\(z_i = z_{pred} + z_{cor}\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{arkode\_mem} \textendash{} pointer to the MRIStep memory block.

\item {} 
\sphinxstyleemphasis{zcor} \textendash{} the correction from the nonlinear solver

\item {} 
\sphinxstyleemphasis{z} \textendash{} on output, the current stage state vector \(z_i\)

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{ARK\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{ARK\_MEM\_NULL} if the MRIStep memory was \sphinxcode{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNNonlinearSolver\_Newton implementation}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsol-newton}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton::doc}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:the-sunnonlinearsolver-newton-implementation}}
This section describes the SUNNonlinSol implementation of Newton’s method. To
access the SUNNonlinSol\_Newton module, include the header file
\sphinxcode{sunnonlinsol/sunnonlinsol\_newton.h}. We note that the SUNNonlinSol\_Newton
module is accessible from SUNDIALS integrators \sphinxstyleemphasis{without} separately
linking to the \sphinxcode{libsundials\_sunnonlinsolnewton} module library.


\subsection{SUNNonlinearSolver\_Newton description}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinearsolver-newton-description}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsolnewton-math}}
To find the solution to

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:equation-e-newton-sys}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_Newton:e:newton_sys}
\begin{split}F(y) = 0\end{split}
\end{equation}
given an initial guess \(y^{(0)}\), Newton’s method computes a series of
approximate solutions
\begin{equation*}
\begin{split}y^{(m+1)} = y^{(m)} + \delta^{(m+1)}\end{split}
\end{equation*}
where \(m\) is the Newton iteration index, and the Newton update \(\delta^{(m+1)}\)
is the solution of the linear system

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:equation-e-newton-linsys}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_Newton:e:newton_linsys}
\begin{split}A(y^{(m)}) \delta^{(m+1)} = -F(y^{(m)}) \, ,\end{split}
\end{equation}
in which \(A\) is the Jacobian matrix

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:equation-e-newton-mat}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_Newton:e:newton_mat}
\begin{split}A \equiv \partial F / \partial y \, .\end{split}
\end{equation}
Depending on the linear solver used, the SUNNonlinSol\_Newton module
will employ either a Modified Newton method, or an Inexact Newton
method \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:id1}}{\hyperref[\detokenize{References:b1987}]{\sphinxcrossref{{[}B1987{]}}}}, \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:id2}}{\hyperref[\detokenize{References:bs1990}]{\sphinxcrossref{{[}BS1990{]}}}}, \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:id3}}{\hyperref[\detokenize{References:des1982}]{\sphinxcrossref{{[}DES1982{]}}}}, \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:id4}}{\hyperref[\detokenize{References:ds1996}]{\sphinxcrossref{{[}DS1996{]}}}}, \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:id5}}{\hyperref[\detokenize{References:k1995}]{\sphinxcrossref{{[}K1995{]}}}}. When used
with a direct linear solver, the Jacobian matrix \(A\) is held
constant during the Newton iteration, resulting in a Modified Newton
method. With a matrix-free iterative linear solver, the iteration is
an Inexact Newton method.

In both cases, calls to the integrator-supplied \sphinxcode{SUNNonlinSolLSetupFn()}
function are made infrequently to amortize the increased cost of
matrix operations (updating \(A\) and its factorization within direct
linear solvers, or updating the preconditioner within iterative linear
solvers).  Specifically, SUNNonlinSol\_Newton will call the
\sphinxcode{SUNNonlinSolLSetupFn()} function in two instances:
\begin{enumerate}
\item {} 
when requested by the integrator (the input \sphinxcode{callLSetSetup} is
\sphinxcode{SUNTRUE}) before attempting the Newton iteration, or

\item {} 
when reattempting the nonlinear solve after a recoverable failure
occurs in the Newton iteration with stale Jacobian information
(\sphinxcode{jcur} is \sphinxcode{SUNFALSE}).  In this case, SUNNonlinSol\_Newton
will set \sphinxcode{jbad} to \sphinxcode{SUNTRUE} before calling the
\sphinxcode{SUNNonlinSolLSetupFn()} function.

\end{enumerate}

Whether the Jacobian matrix \(A\) is fully or partially updated depends
on logic unique to each integrator-supplied \sphinxcode{SUNNonlinSolSetupFn()}
routine. We refer to the discussion of nonlinear solver strategies
provided in Chapter {\hyperref[\detokenize{Mathematics:mathematics}]{\sphinxcrossref{\DUrole{std,std-ref}{Mathematical Considerations}}}} for details on this decision.

The default maximum number of iterations and the stopping criteria for
the Newton iteration are supplied by the SUNDIALS integrator when
SUNNonlinSol\_Newton is attached to it.  Both the maximum number of
iterations and the convergence test function may be modified by the
user by calling the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetMaxIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetMaxIters()}}}} and/or
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetConvTestFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetConvTestFn()}}}} functions after attaching the
SUNNonlinSol\_Newton object to the integrator.


\subsection{SUNNonlinearSolver\_Newton functions}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsolnewton-functions}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinearsolver-newton-functions}}
The SUNNonlinSol\_Newton module provides the following constructor
for creating the \sphinxcode{SUNNonlinearSolver} object.
\index{SUNNonlinSol\_Newton (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSol_Newton}}\pysiglinewithargsret{SUNNonlinearSolver \sphinxbfcode{SUNNonlinSol\_Newton}}{N\_Vector\sphinxstyleemphasis{ y}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSol_Newton}]{\sphinxcrossref{\sphinxcode{SUNNonlinSol\_Newton()}}}} creates a
\sphinxcode{SUNNonlinearSolver} object for use with SUNDIALS integrators to
solve nonlinear systems of the form \(F(y) = 0\) using Newton’s
method.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} a template for cloning vectors needed within the solver.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  a SUNNonlinSol object if the constructor exits
successfully, otherwise it will be \sphinxcode{NULL}.

\end{fulllineitems}


The SUNNonlinSol\_Newton module implements all of the functions
defined in sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}} through
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}} except for the {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetup}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetup()}}}}
function. The SUNNonlinSol\_Newton functions have the same names as
those defined by the generic SUNNonlinSol API with \sphinxcode{\_Newton}
appended to the function name. Unless using the SUNNonlinSol\_Newton
module as a standalone nonlinear solver the generic functions defined
in sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}} through
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}} should be called in favor of the
SUNNonlinSol\_Newton-specific implementations.

The SUNNonlinSol\_Newton module also defines the following additional
user-callable function.
\index{SUNNonlinSolGetSysFn\_Newton (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSolGetSysFn_Newton}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetSysFn\_Newton}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{SUNNonlinSolSysFn}}}\sphinxstyleemphasis{ *SysFn}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSolGetSysFn_Newton}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetSysFn\_Newton()}}}} returns the
residual function that defines the nonlinear system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{SysFn} \textendash{} the function defining the nonlinear system.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  the return value should be zero for a
successful call, and a negative value for a failure.

\sphinxstylestrong{Notes:} This function is intended for users that wish to
evaluate the nonlinear residual in a custom convergence test
function for the SUNNonlinSol\_Newton module.  We note that
SUNNonlinSol\_Newton will not leverage the results from any user
calls to \sphinxstyleemphasis{SysFn}.

\end{fulllineitems}

\index{SUNNonlinSolSetInfoFile\_Newton (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSolSetInfoFile_Newton}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetInfoFile\_Newton}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSolSetInfoFile_Newton}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetInfoFile\_Newton()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} \begin{description}
\item[{\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);}] \leavevmode
a \sphinxcode{NULL} input will disable output

\end{description}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUN\_NLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_MEM\_NULL} if the SUNNonlinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the nonlinear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNNonlinSolSetPrintLevel\_Newton (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSolSetPrintLevel_Newton}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetPrintLevel\_Newton}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:c.SUNNonlinSolSetPrintLevel_Newton}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetPrintLevel\_Newton()}}}} specifies
the level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each nonlinear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUN\_NLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_MEM\_NULL} if the SUNNonlinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled,
or the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the nonlinear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}



\subsection{SUNNonlinearSolver\_Newton content}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinearsolver-newton-content}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsolnewton-content}}
The \sphinxstyleemphasis{content} field of the SUNNonlinSol\_Newton module is the
following structure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNNonlinearSolverContent\PYGZus{}Newton} \PYG{p}{\PYGZob{}}

  \PYG{n}{SUNNonlinSolSysFn}      \PYG{n}{Sys}\PYG{p}{;}
  \PYG{n}{SUNNonlinSolLSetupFn}   \PYG{n}{LSetup}\PYG{p}{;}
  \PYG{n}{SUNNonlinSolLSolveFn}   \PYG{n}{LSolve}\PYG{p}{;}
  \PYG{n}{SUNNonlinSolConvTestFn} \PYG{n}{CTest}\PYG{p}{;}

  \PYG{n}{N\PYGZus{}Vector}    \PYG{n}{delta}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{jcur}\PYG{p}{;}
  \PYG{k+kt}{int}         \PYG{n}{curiter}\PYG{p}{;}
  \PYG{k+kt}{int}         \PYG{n}{maxiters}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int}    \PYG{n}{niters}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int}    \PYG{n}{nconvfails}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*}       \PYG{n}{ctest\PYGZus{}data}\PYG{p}{;}

  \PYG{k+kt}{int}         \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}       \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following
information:
\begin{itemize}
\item {} 
\sphinxcode{Sys} \textendash{} the function for evaluating the nonlinear system,

\item {} 
\sphinxcode{LSetup} \textendash{} the package-supplied function for setting up the
linear solver,

\item {} 
\sphinxcode{LSolve} \textendash{} the package-supplied function for performing a linear
solve,

\item {} 
\sphinxcode{CTest} \textendash{} the function for checking convergence of the Newton iteration,

\item {} 
\sphinxcode{delta} \textendash{} the Newton iteration update vector,

\item {} 
\sphinxcode{jcur} \textendash{} the Jacobian status (\sphinxcode{SUNTRUE} = current, \sphinxcode{SUNFALSE} = stale),

\item {} 
\sphinxcode{curiter}  \textendash{} the current number of iterations in the solve attempt,

\item {} 
\sphinxcode{maxiters} \textendash{} the maximum number of Newton iterations allowed in a solve,

\item {} 
\sphinxcode{niters} \textendash{} the total number of nonlinear iterations across all solves,

\item {} 
\sphinxcode{nconvfails} \textendash{} the total number of nonlinear convergence failures across
all solves,

\item {} 
\sphinxcode{ctest\_data} \textendash{} the data pointer passed to the convergence test function.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}


\subsection{SUNNonlinearSolver\_Newton Fortran interface}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinearsolver-newton-fortran-interface}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:sunnonlinsolnewton-fortran}}
For SUNDIALS integrators that include a Fortran interface, the
SUNNonlinSol\_Newton module also includes a Fortran-callable
function for creating a \sphinxcode{SUNNonlinearSolver} object.
\index{FSUNNewtonInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_Newton:f/_/FSUNNewtonInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNNewtonInit}}{\emph{CODE}, \emph{IER}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_Newton:f/_/FSUNNewtonInit}]{\sphinxcrossref{\sphinxcode{FSUNNewtonInit()}}}} can be called for Fortran
programs to create a \sphinxcode{SUNNonlinearSolver} object for use with
SUNDIALS integrators to solve nonlinear systems of the form
\(F(y) = 0\) with Newton’s method.

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, ARKode=4.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for
failure).  See printed message for details in case
of failure.

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNNonlinearSolver\_FixedPoint implementation}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsol-fixedpoint}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint::doc}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:the-sunnonlinearsolver-fixedpoint-implementation}}
This section describes the SUNNonlinSol implementation of a fixed point
(functional) iteration with optional Anderson acceleration. To access the
SUNNonlinSol\_FixedPoint module, include the header file
\sphinxcode{sunnonlinsol/sunnonlinsol\_fixedpoint.h}. We note that the
SUNNonlinSol\_FixedPoint module is accessible from SUNDIALS integrators
\sphinxstyleemphasis{without} separately linking to the
\sphinxcode{libsundials\_sunnonlinsolfixedpoint} module library.


\subsection{SUNNonlinearSolver\_FixedPoint description}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinearsolver-fixedpoint-description}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsolfixedpoint-math}}
To find the solution to

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:equation-e-fixed-point-sys}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:fixed_point_sys}
\begin{split}G(y) = y \,\end{split}
\end{equation}
given an initial guess \(y^{(0)}\), the fixed point iteration
computes a series of approximate solutions

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:equation-e-fixed-point-iteration}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:fixed_point_iteration}
\begin{split}y^{(n+1)} = G(y^{(n)})\end{split}
\end{equation}
where \(n\) is the iteration index. The convergence of this
iteration may be accelerated using Anderson’s method \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:id1}}{\hyperref[\detokenize{References:a1965}]{\sphinxcrossref{{[}A1965{]}}}}, \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:id2}}{\hyperref[\detokenize{References:wn2011}]{\sphinxcrossref{{[}WN2011{]}}}},
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:id3}}{\hyperref[\detokenize{References:fs2009}]{\sphinxcrossref{{[}FS2009{]}}}}, \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:id4}}{\hyperref[\detokenize{References:lwwy2012}]{\sphinxcrossref{{[}LWWY2012{]}}}}.  With Anderson acceleration using subspace
size \(m\), the series of approximate solutions can be formulated
as the linear combination

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:equation-e-accelerated-fixed-point-iteration}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:accelerated_fixed_point_iteration}
\begin{split}y^{(n+1)} = \beta \sum_{i=0}^{m_n} \alpha_i^{(n)} G(y^{(n-m_n+i)}) + (1 - \beta) \sum_{i=0}^{m_n} \alpha_i^{(n)} y_{n-m_n+i}\end{split}
\end{equation}
where \(m_n = \min{\{m,n\}}\) and the factors
\begin{equation*}
\begin{split}\alpha^{(n)} =(\alpha_0^{(n)}, \ldots, \alpha_{m_n}^{(n)})\end{split}
\end{equation*}
solve the minimization problem \(\min_\alpha  \| F_n \alpha^T
\|_2\) under the constraint that \(\sum_{i=0}^{m_n} \alpha_i = 1\) where
\begin{equation*}
\begin{split}F_{n} = (f_{n-m_n}, \ldots, f_{n})\end{split}
\end{equation*}
with \(f_i = G(y^{(i)}) - y^{(i)}\). Due to this constraint, in
the limit of \(m=0\) the accelerated fixed point iteration formula
\eqref{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:accelerated_fixed_point_iteration} simplifies to the standard
fixed point iteration \eqref{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:fixed_point_iteration}.

Following the recommendations made in \phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:id5}}{\hyperref[\detokenize{References:wn2011}]{\sphinxcrossref{{[}WN2011{]}}}}, the
SUNNonlinSol\_FixedPoint implementation computes the series of
approximate solutions as

\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:equation-e-accelerated-fixed-point-iteration-impl}}\begin{equation}\label{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:accelerated_fixed_point_iteration_impl}
\begin{split}y^{(n+1)} = G(y^{(n)})-\sum_{i=0}^{m_n-1} \gamma_i^{(n)} \Delta g_{n-m_n+i} - (1 - \beta) (f(y^{(n)}) - \sum_{i=0}^{m_n-1} \gamma_i^{(n)} \Delta f_{n-m_n+i})\end{split}
\end{equation}
with \(\Delta g_i = G(y^{(i+1)}) - G(y^{(i)})\) and where the
factors
\begin{equation*}
\begin{split}\gamma^{(n)} =(\gamma_0^{(n)}, \ldots, \gamma_{m_n-1}^{(n)})\end{split}
\end{equation*}
solve the unconstrained minimization problem
\(\min_\gamma \| f_n - \Delta F_n \gamma^T \|_2\) where
\begin{equation*}
\begin{split}\Delta F_{n} = (\Delta f_{n-m_n}, \ldots, \Delta f_{n-1}),\end{split}
\end{equation*}
with \(\Delta f_i = f_{i+1} - f_i\). The least-squares problem is
solved by applying a QR factorization to \(\Delta F_n = Q_n R_n\)
and solving  \(R_n \gamma = Q_n^T f_n\).

The acceleration subspace size \(m\) is required when constructing
the SUNNonlinSol\_FixedPoint object.  The default maximum number of
iterations and the stopping criteria for the fixed point iteration are
supplied by the SUNDIALS integrator when SUNNonlinSol\_FixedPoint
is attached to it.  Both the maximum number of iterations and the
convergence test function may be modified by the user by calling
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetMaxIters}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetMaxIters()}}}} and
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetConvTestFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetConvTestFn()}}}} functions after attaching the
SUNNonlinSol\_FixedPoint object to the integrator.


\subsection{SUNNonlinearSolver\_FixedPoint functions}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsolfixedpoint-functions}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinearsolver-fixedpoint-functions}}
The SUNNonlinSol\_FixedPoint module provides the following constructor
for creating the \sphinxcode{SUNNonlinearSolver} object.
\index{SUNNonlinSol\_FixedPoint (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSol_FixedPoint}}\pysiglinewithargsret{SUNNonlinearSolver \sphinxbfcode{SUNNonlinSol\_FixedPoint}}{N\_Vector\sphinxstyleemphasis{ y}, int\sphinxstyleemphasis{ m}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSol_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSol\_FixedPoint()}}}} creates a
\sphinxcode{SUNNonlinearSolver} object for use with SUNDIALS integrators to
solve nonlinear systems of the form \(G(y) = y\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{y} \textendash{} a template for cloning vectors needed within the solver.

\item {} 
\sphinxstyleemphasis{m} \textendash{} the number of acceleration vectors to use.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  a SUNNonlinSol object if the constructor exits
successfully, otherwise it will be \sphinxcode{NULL}.

\end{fulllineitems}


Since the accelerated fixed point iteration
\eqref{equation:sunnonlinsol/SUNNonlinSol_FixedPoint:e:fixed_point_iteration} does not require the setup or solution
of any linear systems, the SUNNonlinSol\_FixedPoint module implements
all of the functions defined in sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}}
through {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}} except for the
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetup}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetup()}}}}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSetupFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSetupFn()}}}},
and {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSetLSolveFn}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetLSolveFn()}}}} functions, that are set to
\sphinxcode{NULL}. The SUNNonlinSol\_FixedPoint functions have the same names as
those defined by the generic SUNNonlinSol API with \sphinxcode{\_FixedPoint}
appended to the function name.  Unless using the
SUNNonlinSol\_FixedPoint module as a standalone nonlinear solver the
generic functions defined in sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}}
through {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}} should be called in favor of the
SUNNonlinSol\_FixedPoint-specific implementations.

The SUNNonlinSol\_FixedPoint module also defines the following additional
user-callable functions.
\index{SUNNonlinSolGetSysFn\_FixedPoint (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolGetSysFn_FixedPoint}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetSysFn\_FixedPoint}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{SUNNonlinSolSysFn}}}\sphinxstyleemphasis{ *SysFn}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolGetSysFn_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolGetSysFn\_FixedPoint()}}}} returns
the fixed-point function that defines the nonlinear system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object.

\item {} 
\sphinxstyleemphasis{SysFn} \textendash{} the function defining the nonlinear system.

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:}  The return value is zero for a
successful call, and a negative value for a failure.

\sphinxstylestrong{Notes:} This function is intended for users that wish to
evaluate the fixed-point function in a custom convergence test
function for the SUNNonlinSol\_FixedPoint module. We note that
SUNNonlinSol\_FixedPoint will not leverage the results from any user
calls to \sphinxstyleemphasis{SysFn}.

\end{fulllineitems}

\index{SUNNonlinSolSetDamping\_FixedPoint (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetDamping_FixedPoint}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetDamping\_FixedPoint}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, realtype\sphinxstyleemphasis{ beta}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetDamping_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetDamping\_FixedPoint()}}}} sets the damping
parameter \(\beta\) to use with Anderson acceleration. By default damping
is disabled i.e., \(\beta = 1.0\).
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object.

\item {} 
\sphinxstyleemphasis{beta} \textendash{} the damping parameter \(0 < \beta \leq 1\).

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value is zero for a successful call,
\sphinxcode{SUN\_NLS\_MEM\_NULL} if \sphinxcode{NLS} is \sphinxcode{NULL}, or \sphinxcode{SUN\_NLS\_ILL\_INPUT} if
\sphinxcode{beta} is negative.

\sphinxstylestrong{Notes:} A \sphinxcode{beta} value should be great than zero and less than one if
damping is to be used. A value of one or more will disable damping.

\end{fulllineitems}

\index{SUNNonlinSolSetInfoFile\_FixedPoint (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetInfoFile_FixedPoint}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetInfoFile\_FixedPoint}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, FILE*\sphinxstyleemphasis{ info\_file}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetInfoFile_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetInfoFile\_FixedPoint()}}}} sets the
output file where all informative (non-error) messages should be directed.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} \begin{description}
\item[{\sphinxstyleemphasis{info\_file} \textendash{} pointer to output file (\sphinxcode{stdout} by default);}] \leavevmode
a \sphinxcode{NULL} input will disable output

\end{description}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUN\_NLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_MEM\_NULL} if the SUNNonlinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the nonlinear
solver progress. By default, the file pointer is set to \sphinxcode{stdout}.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}

\index{SUNNonlinSolSetPrintLevel\_FixedPoint (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetPrintLevel_FixedPoint}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolSetPrintLevel\_FixedPoint}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, int\sphinxstyleemphasis{ print\_level}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSolSetPrintLevel_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSolSetPrintLevel\_FixedPoint()}}}} specifies
the level of verbosity of the output.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a SUNNonlinSol object

\item {} 
\sphinxstyleemphasis{print\_level} \textendash{} flag indicating level of verbosity;
must be one of:
\begin{itemize}
\item {} 
0, no information is printed (default)

\item {} 
1, for each nonlinear iteration the residual norm is printed

\end{itemize}

\end{itemize}

\item[{\sphinxstylestrong{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{SUN\_NLS\_SUCCESS} if successful

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_MEM\_NULL} if the SUNNonlinearSolver memory was \sphinxcode{NULL}

\item {} 
\sphinxstyleemphasis{SUN\_NLS\_ILL\_INPUT} if SUNDIALS was not built with monitoring enabled,
or the print level value was invalid

\end{itemize}

\end{description}

\sphinxstylestrong{Notes:}
This function is intended for users that wish to monitor the nonlinear
solver progress. By default, the print level is 0.

\sphinxstylestrong{SUNDIALS must be built with the CMake option
{}`{}`SUNDIALS\_BUILD\_WITH\_MONITORING{}`{}`, to utilize this function.}
See section {\hyperref[\detokenize{Install:installation-cmake-options}]{\sphinxcrossref{\DUrole{std,std-ref}{Configuration options (Unix/Linux)}}}} for more information.

\end{fulllineitems}



\subsection{SUNNonlinearSolver\_FixedPoint content}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinearsolver-fixedpoint-content}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsolfixedpoint-content}}
The \sphinxstyleemphasis{content} field of the SUNNonlinSol\_FixedPoint module is the
following structure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNNonlinearSolverContent\PYGZus{}FixedPoint} \PYG{p}{\PYGZob{}}

  \PYG{n}{SUNNonlinSolSysFn}      \PYG{n}{Sys}\PYG{p}{;}
  \PYG{n}{SUNNonlinSolConvTestFn} \PYG{n}{CTest}\PYG{p}{;}

  \PYG{k+kt}{int}          \PYG{n}{m}\PYG{p}{;}
  \PYG{k+kt}{int}         \PYG{o}{*}\PYG{n}{imap}\PYG{p}{;}
  \PYG{n}{realtype}    \PYG{o}{*}\PYG{n}{R}\PYG{p}{;}
  \PYG{n}{booleantype}  \PYG{n}{damping}
  \PYG{n}{realtype}     \PYG{n}{beta}
  \PYG{n}{realtype}    \PYG{o}{*}\PYG{n}{gamma}\PYG{p}{;}
  \PYG{n}{realtype}    \PYG{o}{*}\PYG{n}{cvals}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}    \PYG{o}{*}\PYG{n}{df}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}    \PYG{o}{*}\PYG{n}{dg}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}    \PYG{o}{*}\PYG{n}{q}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}    \PYG{o}{*}\PYG{n}{Xvecs}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}     \PYG{n}{yprev}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}     \PYG{n}{gy}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}     \PYG{n}{fold}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}     \PYG{n}{gold}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}     \PYG{n}{delta}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{curiter}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{maxiters}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int}     \PYG{n}{niters}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int}     \PYG{n}{nconvfails}\PYG{p}{;}
  \PYG{k+kt}{void}        \PYG{o}{*}\PYG{n}{ctest\PYGZus{}data}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{print\PYGZus{}level}\PYG{p}{;}
  \PYG{k+kt}{FILE}\PYG{o}{*}        \PYG{n}{info\PYGZus{}file}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The following entries of the \sphinxstyleemphasis{content} field are always
allocated:
\begin{itemize}
\item {} 
\sphinxcode{Sys}        \textendash{} function for evaluating the nonlinear system,

\item {} 
\sphinxcode{CTest}      \textendash{} function for checking convergence of the fixed point iteration,

\item {} 
\sphinxcode{yprev}      \textendash{} \sphinxcode{N\_Vector} used to store previous fixed-point iterate,

\item {} 
\sphinxcode{gy}         \textendash{} \sphinxcode{N\_Vector} used to store \(G(y)\) in fixed-point algorithm,

\item {} 
\sphinxcode{delta}      \textendash{} \sphinxcode{N\_Vector} used to store difference between successive fixed-point iterates,

\item {} 
\sphinxcode{curiter}    \textendash{} the current number of iterations in the solve attempt,

\item {} 
\sphinxcode{maxiters}   \textendash{} the maximum number of fixed-point iterations allowed in
a solve,

\item {} 
\sphinxcode{niters}     \textendash{} the total number of nonlinear iterations across all
solves,

\item {} 
\sphinxcode{nconvfails} \textendash{} the total number of nonlinear convergence failures across all solves,

\item {} 
\sphinxcode{ctest\_data} \textendash{} the data pointer passed to the convergence test function, and

\item {} 
\sphinxcode{m}          \textendash{} number of acceleration vectors.

\item {} 
\sphinxcode{print\_level} - controls the amount of information to be printed to the info file

\item {} 
\sphinxcode{info\_file}   - the file where all informative (non-error) messages will be directed

\end{itemize}

If Anderson acceleration is requested (i.e., \(m>0\) in the call
to {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:c.SUNNonlinSol_FixedPoint}]{\sphinxcrossref{\sphinxcode{SUNNonlinSol\_FixedPoint()}}}}), then the following items are also
allocated within the \sphinxstyleemphasis{content} field:
\begin{itemize}
\item {} 
\sphinxcode{imap}    \textendash{} index array used in acceleration algorithm (length \sphinxcode{m}),

\item {} 
\sphinxcode{damping} \textendash{} a flag indicating if damping is enabled,

\item {} 
\sphinxcode{beta}    \textendash{} the damping parameter,

\item {} 
\sphinxcode{R}       \textendash{} small matrix used in acceleration algorithm (length \sphinxcode{m*m}),

\item {} 
\sphinxcode{gamma}   \textendash{} small vector used in acceleration algorithm (length \sphinxcode{m}),

\item {} 
\sphinxcode{cvals}   \textendash{} small vector used in acceleration algorithm (length \sphinxcode{m+1}),

\item {} 
\sphinxcode{df}      \textendash{} array of \sphinxcode{N\_Vectors} used in acceleration algorithm (length \sphinxcode{m}),

\item {} 
\sphinxcode{dg}      \textendash{} array of \sphinxcode{N\_Vectors} used in acceleration algorithm (length \sphinxcode{m}),

\item {} 
\sphinxcode{q}       \textendash{} array of \sphinxcode{N\_Vectors} used in acceleration algorithm (length \sphinxcode{m}),

\item {} 
\sphinxcode{Xvecs}   \textendash{} \sphinxcode{N\_Vector} pointer array used in acceleration algorithm (length \sphinxcode{m+1}),

\item {} 
\sphinxcode{fold}    \textendash{} \sphinxcode{N\_Vector} used in acceleration algorithm, and

\item {} 
\sphinxcode{gold}    \textendash{} \sphinxcode{N\_Vector} used in acceleration algorithm.

\end{itemize}


\subsection{SUNNonlinearSolver\_FixedPoint Fortran interface}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinearsolver-fixedpoint-fortran-interface}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:sunnonlinsolfixedpoint-fortran}}
For SUNDIALS integrators that include a Fortran interface, the
SUNNonlinSol\_FixedPoint module also includes a Fortran-callable
function for creating a \sphinxcode{SUNNonlinearSolver} object.
\index{FSUNFixedPointInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:f/_/FSUNFixedPointInit}}\pysiglinewithargsret{\sphinxbfcode{subroutine  }\sphinxbfcode{FSUNFixedPointInit}}{\emph{CODE}, \emph{M}, \emph{IER}}{}
The function {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_FixedPoint:f/_/FSUNFixedPointInit}]{\sphinxcrossref{\sphinxcode{FSUNFixedPointInit()}}}} can be called for
Fortran programs to create a \sphinxcode{SUNNonlinearSolver} object for use
with SUNDIALS integrators to solve nonlinear systems of the form
\(G(y) = y\).

This routine must be called \sphinxstyleemphasis{after} the \sphinxcode{N\_Vector} object has
been initialized.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{CODE} (\sphinxcode{int}, input) \textendash{} flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, ARKode=4.

\item {} 
\sphinxstyleemphasis{M} (\sphinxcode{int}, input) \textendash{} the number of acceleration vectors.

\item {} 
\sphinxstyleemphasis{IER} (\sphinxcode{int}, output) \textendash{} return flag (0 success, -1 for
failure).  See printed message for details in case
of failure.

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNNonlinearSolver\_PetscSNES implementation}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:the-sunnonlinearsolver-petscsnes-implementation}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES::doc}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunonlinsol-petscsnes}}
This section describes the SUNNonlinSol interface to the PETSc SNES nonlinear
solver(s).To enable the SUNonlinSol\_PetscSNES module, SUNDIALS must be
configured to use PETSc. Instructions on how to do thus are given in Chapter
{\hyperref[\detokenize{Install:installation-cmake-externallibraries-petsc}]{\sphinxcrossref{\DUrole{std,std-ref}{Building with PETSc}}}}. To access the
SUNNonlinSol\_PetscSNES module, include the header file
\sphinxcode{sunnonlinsol/sunnonlinsol\_petscsnes.h}. The library to link to is
\sphinxcode{libsundials\_sunnonlinsolpetsc.lib} where \sphinxcode{.lib} is typically \sphinxcode{.so} for
shared libaries and \sphinxcode{.a} for static libraries. Users of the
\sphinxcode{SUNNonlinearSolver\_PetscSNES} should also see the section
{\hyperref[\detokenize{nvectors/NVector_PETSc:nvectors-nvpetsc}]{\sphinxcrossref{\DUrole{std,std-ref}{The NVECTOR\_PETSC Module}}}} which discusses the NVECTOR interface to the PETSc Vec
API.


\subsection{SUNNonlinearSolver\_PetscSNES description}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunnonlinearsolver-petscsnes-description}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunnonlinsolpetscsnes-description}}
The \sphinxcode{SUNNonlinearSolver\_PetscSNES} implementation allows users to utilize a
PETSc SNES nonlinear solver to solve the nonlinear systems that arise in the
SUNDIALS integrators. Since SNES uses the KSP linear solver interface underneath
it, the \sphinxcode{SUNNonlinearSolver\_PetscSNES} implementation does not interface with
SUNDIALS linear solvers. Instead, users should set nonlinear solver options,
linear solver options, and preconditioner options through the PETSc SNES, KSP,
and PC APIs.

\sphinxstyleemphasis{Important usage notes for the {}`{}`SUNNonlinearSolver\_PetscSNES{}`{}` implementation
are provided below:}
\begin{itemize}
\item {} 
The \sphinxcode{SUNNonlinearSolver\_PetscSNES} implementation handles calling
\sphinxcode{SNESSetFunction} at construction. The actual residual function \(F(y)\)
is set by the SUNDIALS integrator when the \sphinxcode{SUNNonlinearSolver\_PetscSNES}
object is attached to it. Therefore, a user should not call \sphinxcode{SNESSetFunction}
on a \sphinxcode{SNES} object that is being used with \sphinxcode{SUNNonlinearSolver\_PetscSNES}.
For these reasons, it is recommended, although not always necessary, that the
user calls \sphinxcode{SUNNonlinSol\_PetscSNES} with the new \sphinxcode{SNES} object immediately
after calling \sphinxcode{SNESCreate}.

\item {} 
The number of nonlinear iterations is tracked by SUNDIALS separately from the
count kept by SNES. As such, the function \sphinxcode{SUNNonlinSolGetNumIters} reports
the cumulative number of iterations across the lifetime of the
\sphinxcode{SUNNonlinearSolver} object.

\item {} 
Some “converged” and “diverged” convergence reasons returned by SNES are
treated as recoverable convergence failures by SUNDIALS. Therefore, the count of
convergence failures returned by \sphinxcode{SUNNonlinSolGetNumConvFails} will reflect
the number of recoverable convergence failures as determined by SUNDIALS, and
may differ from the count returned by \sphinxcode{SNESGetNonlinearStepFailures}.

\item {} 
The \sphinxcode{SUNNonlinearSolver\_PetscSNES} module is not currently compatible with
the CVODES or IDAS staggered or simultaneous sensitivity strategies.

\end{itemize}


\subsection{SUNNonlinearSolver\_PetscSNES functions}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunnonlinsolpetscsnes-functions}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunnonlinearsolver-petscsnes-functions}}
The \sphinxcode{SUNNonlinearSolver\_PetscSNES} module provides the following constructor
for creating a \sphinxcode{SUNNonlinearSolver} object.
\index{SUNNonlinSol\_PetscSNES (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:c.SUNNonlinSol_PetscSNES}}\pysiglinewithargsret{SUNNonlinearSolver \sphinxbfcode{SUNNonlinSol\_PetscSNES}}{N\_Vector\sphinxstyleemphasis{ y}, SNES\sphinxstyleemphasis{ snes}}{}
The function \sphinxcode{SUNNonlinSol\_PetscSNES} creates a \sphinxcode{SUNNonlinearSolver}
object that wraps a PETSc \sphinxcode{SNES} object for use with SUNDIALS. This
will call \sphinxcode{SNESSetFunction} on the provided \sphinxcode{SNES} object.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{snes} \textendash{} a PETSc \sphinxcode{SNES} object

\item {} 
\sphinxstyleemphasis{y} \textendash{} a \sphinxcode{N\_Vector} object of type NVECTOR\_PETSC that is used as a template
for the residual vector

\end{itemize}

\item[{\sphinxstylestrong{Return value:} a SUNNonlinSol object if the constructor exits}] \leavevmode
successfully, otherwise it will be \sphinxcode{NULL}.

\end{description}

\sphinxstyleemphasis{This function calls {}`{}`SNESSetFunction{}`{}` and will overwrite whatever
function was previously set. Users should not call {}`{}`SNESSetFunction{}`{}`
on the {}`{}`SNES{}`{}` object provided to the constructor.}

\end{fulllineitems}


The \sphinxcode{SUNNonlinSol\_PetscSNES} module implements all of the functions defined in
sections {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}} through {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}} except for
\sphinxcode{SUNNonlinSolSetup}, \sphinxcode{SUNNonlinSolSetLSetupFn}, \sphinxcode{SUNNonlinSolSetLSolveFn},
\sphinxcode{SUNNonlinSolSetConvTestFn}, and \sphinxcode{SUNNonlinSolSetMaxIters}.

The \sphinxcode{SUNNonlinSol\_PetscSNES} functions have the same names as those defined by
the generic \sphinxcode{SUNNonlinearSolver} API with \sphinxcode{\_PetscSNES} appended to the
function name. Unless using the \sphinxcode{SUNNonlinSol\_PetscSNES} module as a
standalone nonlinear solver the generic functions defined in sections
{\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-corefn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver core functions}}}} through {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:sunnonlinsol-getfn}]{\sphinxcrossref{\DUrole{std,std-ref}{SUNNonlinearSolver get functions}}}} should be called in
favor of the \sphinxcode{SUNNonlinSol\_PetscSNES} specific implementations.

The \sphinxcode{SUNNonlinSol\_PetscSNES} module also defines the following additional
user-callable functions.
\index{SUNNonlinSolGetSNES\_PetscSNES (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:c.SUNNonlinSolGetSNES_PetscSNES}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetSNES\_PetscSNES}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, SNES*\sphinxstyleemphasis{ snes}}{}
The function \sphinxcode{SUNNonlinSolGetSNES\_PetscSNES} gets the \sphinxcode{SNES} object that
was wrapped.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a \sphinxcode{SUNNonlinearSolver} object

\item {} 
\sphinxstyleemphasis{snes} \textendash{} a pointer to a PETSc \sphinxcode{SNES} object that will be set upon return

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value (of type \sphinxcode{int}) should be zero
for a successful call, and a negative value for a failure.

\end{fulllineitems}

\index{SUNNonlinSolGetPetscError\_PetscSNES (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:c.SUNNonlinSolGetPetscError_PetscSNES}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetPetscError\_PetscSNES}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, PestcErrorCode*\sphinxstyleemphasis{ error}}{}
The function \sphinxcode{SUNNonlinSolGetPetscError\_PetscSNES} gets the last error code
returned by the last internal call to a PETSc API function.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a \sphinxcode{SUNNonlinearSolver} object

\item {} 
\sphinxstyleemphasis{error} \textendash{} a pointer to a PETSc error integer that will be set upon return

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value (of type \sphinxcode{int}) should be zero
for a successful call, and a negative value for a failure.

\end{fulllineitems}

\index{SUNNonlinSolGetSysFn\_PetscSNES (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:c.SUNNonlinSolGetSysFn_PetscSNES}}\pysiglinewithargsret{int \sphinxbfcode{SUNNonlinSolGetSysFn\_PetscSNES}}{SUNNonlinearSolver\sphinxstyleemphasis{ NLS}, {\hyperref[\detokenize{sunnonlinsol/SUNNonlinSol_API:c.SUNNonlinSolSysFn}]{\sphinxcrossref{SUNNonlinSolSysFn}}}*\sphinxstyleemphasis{ SysFn}}{}
The function \sphinxcode{SUNNonlinSolGetSysFn\_PetscSNES} returns the residual
function that defines the nonlinear system.
\begin{description}
\item[{\sphinxstylestrong{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleemphasis{NLS} \textendash{} a \sphinxcode{SUNNonlinearSolver} object

\item {} 
\sphinxstyleemphasis{SysFn} \textendash{} the function defining the nonlinear system

\end{itemize}

\end{description}

\sphinxstylestrong{Return value:} The return value (of type \sphinxcode{int}) should be zero
for a successful call, and a negative value for a failure.

\end{fulllineitems}



\subsection{SUNNonlinearSolver\_PetscSNES content}
\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunnonlinsolpetscsnes-content}}\label{\detokenize{sunnonlinsol/SUNNonlinSol_PetscSNES:sunnonlinearsolver-petscsnes-content}}
The \sphinxstyleemphasis{content} field of the SUNNonlinSol\_Newton module is the following
structure.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNNonlinearSolverContent\PYGZus{}PetscSNES} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{sysfn\PYGZus{}last\PYGZus{}err}\PYG{p}{;}
  \PYG{n}{PetscErrorCode} \PYG{n}{petsc\PYGZus{}last\PYGZus{}err}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{nconvfails}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{nni}\PYG{p}{;}
  \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{imem}\PYG{p}{;}
  \PYG{n}{SNES} \PYG{n}{snes}\PYG{p}{;}
  \PYG{n}{Vec} \PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{y}\PYG{p}{,} \PYG{n}{f}\PYG{p}{;}
  \PYG{n}{SUNNonlinSolSysFn} \PYG{n}{Sys}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

These entries of the \sphinxstyleemphasis{content} field contain the following information:
\begin{itemize}
\item {} 
\sphinxcode{sysfn\_last\_err}  \textendash{} last error returned by the system defining function,

\item {} 
\sphinxcode{petsc\_last\_err}  \textendash{} last error returned by PETSc

\item {} 
\sphinxcode{nconvfails}      \textendash{} number of nonlinear converge failures (recoverable or not),

\item {} 
\sphinxcode{nni}             \textendash{} number of nonlinear iterations,

\item {} 
\sphinxcode{imem}            \textendash{} SUNDIALS integrator memory,

\item {} 
\sphinxcode{snes}            \textendash{} PETSc \sphinxcode{SNES} object,

\item {} 
\sphinxcode{r}               \textendash{} the nonlinear residual,

\item {} 
\sphinxcode{y}               \textendash{} wrapper for PETSc vectors used in the system function,

\item {} 
\sphinxcode{f}               \textendash{} wrapper for PETSc vectors used in the system function,

\item {} 
\sphinxcode{Sys}             \textendash{} nonlinear system definining function.

\end{itemize}


\chapter{Tools for Memory Management}
\label{\detokenize{sunmemory/index:tools-for-memory-management}}\label{\detokenize{sunmemory/index:sunmemory}}\label{\detokenize{sunmemory/index::doc}}
To support applications which leverage memory pools, or utilize a memory
abstraction layer, sundials provides a set of utilities we will
collectively refer to as the SUNMemoryHelper API. The goal of this API
is to allow users to leverage operations defined by native sundials
data structures while allowing the user to have finer-grained control of
the memory management.


\section{The SUNMemoryHelper API}
\label{\detokenize{sunmemory/SUNMemory_Description::doc}}\label{\detokenize{sunmemory/SUNMemory_Description:the-sunmemoryhelper-api}}\label{\detokenize{sunmemory/SUNMemory_Description:sunmemory-description}}
This API consists of three new sundials types: \sphinxcode{SUNMemoryType}, \sphinxcode{SUNMemory},
and \sphinxcode{SUNMemoryHelper}, which we now define.

The \sphinxcode{SUNMemory} structure wraps a pointer to actual data. This structure
is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMemory}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void}\PYG{o}{*}         \PYG{n}{ptr}\PYG{p}{;}
  \PYG{n}{SUNMemoryType} \PYG{n}{type}\PYG{p}{;}
  \PYG{n}{booleantype}   \PYG{n}{own}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{o}{*}\PYG{n}{SUNMemory}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{SUNMemoryType} type is an enumeration that defines the four supported
memory types:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{enum}
\PYG{p}{\PYGZob{}}
  \PYG{n}{SUNMEMTYPE\PYGZus{}HOST}\PYG{p}{,}      \PYG{c+cm}{/* pageable memory accessible on the host     */}
  \PYG{n}{SUNMEMTYPE\PYGZus{}PINNED}\PYG{p}{,}    \PYG{c+cm}{/* page\PYGZhy{}locked memory accesible on the host   */}
  \PYG{n}{SUNMEMTYPE\PYGZus{}DEVICE}\PYG{p}{,}    \PYG{c+cm}{/* memory accessible from the device          */}
  \PYG{n}{SUNMEMTYPE\PYGZus{}UVM}        \PYG{c+cm}{/* memory accessible from the host or device  */}
\PYG{p}{\PYGZcb{}} \PYG{n}{SUNMemoryType}\PYG{p}{;}
\end{sphinxVerbatim}

Finally, the \sphinxcode{SUNMemoryHelper} structure is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMemoryHelper}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void}\PYG{o}{*}               \PYG{n}{content}\PYG{p}{;}
  \PYG{n}{SUNMemoryHelper\PYGZus{}Ops} \PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{o}{*}\PYG{n}{SUNMemoryHelper}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{SUNMemoryHelper\_Ops} is defined as

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMemoryHelper\PYGZus{}Ops}
\PYG{p}{\PYGZob{}}
  \PYG{c+cm}{/* operations that implementations are required to provide */}
  \PYG{k+kt}{int}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{alloc}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMemoryHelper}\PYG{p}{,} \PYG{n}{SUNMemory}\PYG{o}{*} \PYG{n}{memptr}
                           \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{mem\PYGZus{}size}\PYG{p}{,} \PYG{n}{SUNMemoryType} \PYG{n}{mem\PYGZus{}type}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{dealloc}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMemoryHelper}\PYG{p}{,} \PYG{n}{SUNMemory} \PYG{n}{mem}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{copy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMemoryHelper}\PYG{p}{,} \PYG{n}{SUNMemory} \PYG{n}{dst}\PYG{p}{,} \PYG{n}{SUNMemory} \PYG{n}{src}\PYG{p}{,}
                          \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{mem\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

  \PYG{c+cm}{/* operations that provide default implementations */}
  \PYG{k+kt}{int}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{copyasync}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMemoryHelper}\PYG{p}{,} \PYG{n}{SUNMemory} \PYG{n}{dst}\PYG{p}{,} \PYG{n}{SUNMemory} \PYG{n}{src}\PYG{p}{,}
                               \PYG{k+kt}{size\PYGZus{}t} \PYG{n}{mem\PYGZus{}size}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ctx}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{SUNMemoryHelper} \PYG{p}{(}\PYG{o}{*}\PYG{n}{clone}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMemoryHelper}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{destroy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMemoryHelper}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{o}{*}\PYG{n}{SUNMemoryHelper\PYGZus{}Ops}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Implementation defined operations}
\label{\detokenize{sunmemory/SUNMemory_Description:sunmemory-required}}\label{\detokenize{sunmemory/SUNMemory_Description:implementation-defined-operations}}
The SUNMemory API also defines the following operations which do require
a SUNMemoryHelper instance and \sphinxstylestrong{require} the implementation to define
them:
\index{SUNMemoryHelper\_Alloc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Alloc}}\pysiglinewithargsret{SUNMemory \sphinxbfcode{SUNMemoryHelper\_Alloc}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory*\sphinxstyleemphasis{ memptr}, size\_t\sphinxstyleemphasis{ mem\_size}, SUNMemoryType\sphinxstyleemphasis{ mem\_type}}{}
Allocates a \sphinxcode{SUNMemory} object whose \sphinxcode{ptr} field is allocated for
\sphinxcode{mem\_size} bytes and is of type \sphinxcode{mem\_type}. The new object will have
ownership of \sphinxcode{ptr} and will be deallocated when \sphinxcode{SUNMemoryHelper\_Dealloc}
is called.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper}  \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{memptr} \textendash{} pointer to the allocated \sphinxcode{SUNMemory}

\item {} 
\sphinxstyleemphasis{mem\_size} \textendash{} the size in bytes of the \sphinxcode{ptr}

\item {} 
\sphinxstyleemphasis{mem\_type} \textendash{} the \sphinxcode{SUNMemoryType} of the \sphinxcode{ptr}

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_Dealloc (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Dealloc}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_Dealloc}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ mem}}{}
Deallocates the \sphinxcode{mem-\textgreater{}ptr} field if it is owned by \sphinxcode{mem}, and then
deallocates the \sphinxcode{mem} object.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{mem} \textendash{} the \sphinxcode{SUNMemory} object

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_Copy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Copy}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_Copy}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ dst}, SUNMemory\sphinxstyleemphasis{ src}, size\_t\sphinxstyleemphasis{ mem\_size}}{}
Synchronously copies \sphinxcode{mem\_size} bytes from the the source memory to the
destination memory.  The copy can be across memory spaces, e.g. host to
device, or within a memory space, e.g. host to host.  The \sphinxcode{helper}
object should use the memory types of \sphinxcode{dst} and \sphinxcode{src} to determine
the appropriate transfer type necessary.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{dst} \textendash{} the destination memory to copy to

\item {} 
\sphinxstyleemphasis{src} \textendash{} the source memory to copy from

\item {} 
\sphinxstyleemphasis{mem\_size} \textendash{} the number of bytes to copy

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}



\subsection{Utility Functions}
\label{\detokenize{sunmemory/SUNMemory_Description:utility-functions}}\label{\detokenize{sunmemory/SUNMemory_Description:sunmemory-utilities}}
The SUNMemoryHelper API defines the following functions which do not
require a SUNMemoryHelper instance:
\index{SUNMemoryHelper\_Alias (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Alias}}\pysiglinewithargsret{SUNMemory \sphinxbfcode{SUNMemoryHelper\_Alias}}{SUNMemory\sphinxstyleemphasis{ mem1}}{}
Returns a \sphinxcode{SUNMemory} object whose \sphinxcode{ptr} field points to the same address
as \sphinxcode{mem1}. The new object \sphinxstyleemphasis{will not} have ownership of \sphinxcode{ptr}, therefore,
it will not free \sphinxcode{ptr} when \sphinxcode{SUNMemoryHelper\_Dealloc} is called.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{mem1} \textendash{} a \sphinxcode{SUNMemory} object

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

A \sphinxcode{SUNMemory} object.
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_Wrap (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Wrap}}\pysiglinewithargsret{SUNMemory \sphinxbfcode{SUNMemoryHelper\_Wrap}}{void*\sphinxstyleemphasis{ ptr}, SUNMemoryType\sphinxstyleemphasis{ mem\_type}}{}
Returns a \sphinxcode{SUNMemory} object whose \sphinxcode{ptr} field points to the \sphinxcode{ptr}
argument passed to the function. The new object \sphinxstyleemphasis{will not} have ownership of
\sphinxcode{ptr}, therefore, it will not free \sphinxcode{ptr} when \sphinxcode{SUNMemoryHelper\_Dealloc}
is called.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{ptr} \textendash{} the data pointer to wrap in a \sphinxcode{SUNMemory} object

\item {} 
\sphinxstyleemphasis{mem\_type} \textendash{} the \sphinxcode{SUNMemoryType} of the \sphinxcode{ptr}

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

A \sphinxcode{SUNMemory} object.
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_NewEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_NewEmpty}}\pysiglinewithargsret{SUNMemoryHelper \sphinxbfcode{SUNMemoryHelper\_NewEmpty}}{}{}
Returns an empty \sphinxcode{SUNMemoryHelper}. This is useful for building custom
\sphinxcode{SUNMemoryHelper} implementations.

\sphinxstylestrong{Returns:}
\begin{quote}

A \sphinxcode{SUNMemoryHelper} object.
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_CopyOps (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_CopyOps}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_CopyOps}}{SUNMemoryHelper\sphinxstyleemphasis{ src}, SUNMemoryHelper\sphinxstyleemphasis{ dst}}{}
Copies the \sphinxcode{ops} field of \sphinxcode{src} to the \sphinxcode{ops} field of \sphinxcode{dst}.
This is useful for building custom \sphinxcode{SUNMemoryHelper} implementations.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{src} \textendash{} the object to copy from

\item {} 
\sphinxstyleemphasis{dst} \textendash{} the object to copy to

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}



\subsection{Implementation overridable operations with defaults}
\label{\detokenize{sunmemory/SUNMemory_Description:implementation-overridable-operations-with-defaults}}\label{\detokenize{sunmemory/SUNMemory_Description:sunmemory-overridable}}
In addition, the SUNMemoryHelper API defines the following \sphinxstyleemphasis{optionally
overridable} operations which do require a SUNMemoryHelper instance:
\index{SUNMemoryHelper\_CopyAsync (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_CopyAsync}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_CopyAsync}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ dst}, SUNMemory\sphinxstyleemphasis{ src}, size\_t\sphinxstyleemphasis{ mem\_size}, void*\sphinxstyleemphasis{ ctx}}{}
Asynchronously copies \sphinxcode{mem\_size} bytes from the the source memory to the
destination memory.  The copy can be across memory spaces, e.g. host to
device, or within a memory space, e.g. host to host.  The \sphinxcode{helper} object
should use the memory types of \sphinxcode{dst} and \sphinxcode{src} to determine the
appropriate transfer type necessary.  The \sphinxcode{ctx} argument is used when a
different execution stream needs to be provided to perform the copy in,
e.g. with \sphinxcode{CUDA} this would be a \sphinxcode{cudaStream\_t}.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{dst} \textendash{} the destination memory to copy to

\item {} 
\sphinxstyleemphasis{src} \textendash{} the source memory to copy from

\item {} 
\sphinxstyleemphasis{mem\_size} \textendash{} the number of bytes to copy

\item {} 
\sphinxstyleemphasis{ctx} \textendash{} typically a handle for an object representing an alternate
execution stream, but it can be any implementation specific data

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
If this operation is not defined by the implementation, then
\sphinxcode{SUNMemoryHelper\_Copy} will be used.
\end{sphinxadmonition}

\end{fulllineitems}

\index{SUNMemoryHelper\_Clone (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Clone}}\pysiglinewithargsret{SUNMemoryHelper \sphinxbfcode{SUNMemoryHelper\_Clone}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}}{}
Clones the \sphinxcode{SUNMemoryHelper} object itself.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object to clone

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

A \sphinxcode{SUNMemoryHelper} object.
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
If this operation is not defined by the implementation, then the default
clone will only copy the \sphinxcode{SUNMemoryHelper\_Ops} structure stored in
\sphinxcode{helper-\textgreater{}ops}, and not the \sphinxcode{helper-\textgreater{}content} field.
\end{sphinxadmonition}

\end{fulllineitems}

\index{SUNMemoryHelper\_Destroy (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_Description:c.SUNMemoryHelper_Destroy}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_Destroy}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}}{}
Destroys (frees) the \sphinxcode{SUNMemoryHelper} object itself.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object to destroy

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
If this operation is not defined by the implementation, then the default
destroy will only free the \sphinxcode{helper-\textgreater{}ops} field and the \sphinxcode{helper} itself.
The \sphinxcode{helper-\textgreater{}content} field will not be freed.
\end{sphinxadmonition}

\end{fulllineitems}



\subsection{Implementing a custom SUNMemoryHelper}
\label{\detokenize{sunmemory/SUNMemory_Description:implementing-a-custom-sunmemoryhelper}}
A particular implementation of the SUNMemoryHelper API must:
\begin{itemize}
\item {} 
Define and implement the required operations. Note that the names of
these routines should be unique to that implementation in order to
permit using more than one SUNMemoryHelper module in the same code.

\item {} 
Optionally, specify the \sphinxstyleemphasis{content} field of SUNMemoryHelper.

\item {} 
Optionally, define and implement additional user-callable routines
acting on the newly defined SUNMemoryHelper.

\end{itemize}

An example of a custom SUNMemoryHelper is given in
examples/utilities/custom\_memory\_helper.h.


\section{The SUNMemoryHelper\_Cuda Implementation}
\label{\detokenize{sunmemory/SUNMemory_CUDA:the-sunmemoryhelper-cuda-implementation}}\label{\detokenize{sunmemory/SUNMemory_CUDA::doc}}\label{\detokenize{sunmemory/SUNMemory_CUDA:sunmemory-cuda}}
The \sphinxcode{SUNMemoryHelper\_Cuda} module is an implementation of the
\sphinxcode{SUNMemoryHelper} API that interfaces to the NVIDIA \phantomsection\label{\detokenize{sunmemory/SUNMemory_CUDA:id1}}{\hyperref[\detokenize{References:cuda}]{\sphinxcrossref{{[}CUDA{]}}}} library.  The
implementation defines the constructor
\index{SUNMemoryHelper\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_CUDA:c.SUNMemoryHelper_Cuda}}\pysiglinewithargsret{SUNMemoryHelper \sphinxbfcode{SUNMemoryHelper\_Cuda}}{}{}
Allocates and returns a \sphinxcode{SUNMemoryHelper} object for handling CUDA memory.
A \sphinxcode{SUNMemoryHelper} object if successful, or \sphinxcode{NULL} if not.

\end{fulllineitems}



\subsection{SUNMemoryHelper API Functions}
\label{\detokenize{sunmemory/SUNMemory_CUDA:sunmemoryhelper-api-functions}}\label{\detokenize{sunmemory/SUNMemory_CUDA:sunmemory-cuda-operations}}
The implementation provides the following operations defined by the
\sphinxcode{SUNMemoryHelper} API:
\index{SUNMemoryHelper\_Alloc\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_CUDA:c.SUNMemoryHelper_Alloc_Cuda}}\pysiglinewithargsret{SUNMemory \sphinxbfcode{SUNMemoryHelper\_Alloc\_Cuda}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ memptr}, size\_t\sphinxstyleemphasis{ mem\_size}, SUNMemoryType\sphinxstyleemphasis{ mem\_type}}{}
Allocates a \sphinxcode{SUNMemory} object whose \sphinxcode{ptr} field is allocated for
\sphinxcode{mem\_size} bytes and is of type \sphinxcode{mem\_type}. The new object will have
ownership of \sphinxcode{ptr} and will be deallocated when \sphinxcode{SUNMemoryHelper\_Dealloc}
is called.

The \sphinxcode{SUNMemoryType} supported are
\begin{itemize}
\item {} 
\sphinxcode{SUNMEMTYPE\_HOST} \textendash{} memory is allocated with a call to \sphinxcode{malloc}

\item {} 
\sphinxcode{SUNMEMTYPE\_PINNED} \textendash{} memory is allocated with a call to
\sphinxcode{cudaMallocHost}

\item {} 
\sphinxcode{SUNMEMTYPE\_DEVICE} \textendash{} memory is allocated with a call to \sphinxcode{cudaMalloc}

\item {} 
\sphinxcode{SUNMEMTYPE\_UVM} \textendash{} memory is allocated with a call to
\sphinxcode{cudaMallocManaged}

\end{itemize}

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper}  \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{memptr} \textendash{} pointer to the allocated \sphinxcode{SUNMemory}

\item {} 
\sphinxstyleemphasis{mem\_size} \textendash{} the size in bytes of the \sphinxcode{ptr}

\item {} 
\sphinxstyleemphasis{mem\_type} \textendash{} the \sphinxcode{SUNMemoryType} of the \sphinxcode{ptr}

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_Dealloc\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_CUDA:c.SUNMemoryHelper_Dealloc_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_Dealloc\_Cuda}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ mem}}{}
Deallocates the \sphinxcode{mem-\textgreater{}ptr} field if it is owned by \sphinxcode{mem}, and then
deallocates the \sphinxcode{mem} object.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{mem} \textendash{} the \sphinxcode{SUNMemory} object

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_Copy\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_CUDA:c.SUNMemoryHelper_Copy_Cuda}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_Copy\_Cuda}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ dst}, SUNMemory\sphinxstyleemphasis{ src}, size\_t\sphinxstyleemphasis{ mem\_size}}{}
Synchronously copies \sphinxcode{mem\_size} bytes from the the source memory to the
destination memory.  The copy can be across memory spaces, e.g. host to
device, or within a memory space, e.g. host to host.  The \sphinxcode{helper}
object should use the memory types of \sphinxcode{dst} and \sphinxcode{src} to determine
the appropriate transfer type necessary.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{dst} \textendash{} the destination memory to copy to

\item {} 
\sphinxstyleemphasis{src} \textendash{} the source memory to copy from

\item {} 
\sphinxstyleemphasis{mem\_size} \textendash{} the number of bytes to copy

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}

\index{SUNMemoryHelper\_CopyAsync (C function)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{sunmemory/SUNMemory_CUDA:c.SUNMemoryHelper_CopyAsync}}\pysiglinewithargsret{int \sphinxbfcode{SUNMemoryHelper\_CopyAsync}}{SUNMemoryHelper\sphinxstyleemphasis{ helper}, SUNMemory\sphinxstyleemphasis{ dst}, SUNMemory\sphinxstyleemphasis{ src}, size\_t\sphinxstyleemphasis{ mem\_size}, void*\sphinxstyleemphasis{ ctx}}{}
Asynchronously copies \sphinxcode{mem\_size} bytes from the the source memory to the
destination memory.  The copy can be across memory spaces, e.g. host to
device, or within a memory space, e.g. host to host.  The \sphinxcode{helper} object
should use the memory types of \sphinxcode{dst} and \sphinxcode{src} to determine the
appropriate transfer type necessary.

\sphinxstylestrong{Arguments:}
\begin{itemize}
\item {} 
\sphinxstyleemphasis{helper} \textendash{} the \sphinxcode{SUNMemoryHelper} object

\item {} 
\sphinxstyleemphasis{dst} \textendash{} the destination memory to copy to

\item {} 
\sphinxstyleemphasis{src} \textendash{} the source memory to copy from

\item {} 
\sphinxstyleemphasis{mem\_size} \textendash{} the number of bytes to copy

\item {} 
\sphinxstyleemphasis{ctx} \textendash{} the \sphinxcode{cudaStream\_t} handle for the stream that the copy will be
performed on

\end{itemize}

\sphinxstylestrong{Returns:}
\begin{quote}

An \sphinxcode{int} flag indicating success (zero) or failure (non-zero).
\end{quote}

\end{fulllineitems}



\chapter{ARKode Installation Procedure}
\label{\detokenize{Install:installation}}\label{\detokenize{Install::doc}}\label{\detokenize{Install:arkode-installation-procedure}}
The installation of any SUNDIALS package is accomplished by installing
the SUNDIALS suite as a whole, according to the instructions that
follow.  The same procedure applies whether or not the downloaded
file contains one or all solvers in SUNDIALS.

The SUNDIALS suite (or individual solvers) are distributed as
compressed archives (\sphinxcode{.tar.gz}).  The name of the distribution
archive is of the form \sphinxcode{SOLVER-X.Y.Z.tar.gz}, where \sphinxcode{SOLVER} is
one of: \sphinxcode{sundials}, \sphinxcode{cvode}, \sphinxcode{cvodes}, \sphinxcode{arkode}, \sphinxcode{ida},
\sphinxcode{idas}, or \sphinxcode{kinsol}, and \sphinxcode{X.Y.Z} represents the version number
(of the SUNDIALS suite or of the individual solver).
To begin the installation, first uncompress and expand the sources, by
issuing

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{} tar \PYGZhy{}zxf SOLVER\PYGZhy{}X.Y.Z.tar.gz
\end{sphinxVerbatim}

This will extract source files under a directory \sphinxcode{SOLVER-X.Y.Z}.

Starting with version 2.6.0 of SUNDIALS, CMake is the only supported
method of installation.  The explanations of the installation
procedure begins with a few common observations:
\begin{itemize}
\item {} 
The remainder of this chapter will follow these conventions:
\begin{description}
\item[{\sphinxcode{SOLVERDIR}}] \leavevmode
is the directory \sphinxcode{SOLVER-X.Y.Z} created above; i.e. the
directory containing the SUNDIALS sources.

\item[{\sphinxcode{BUILDDIR}}] \leavevmode
is the (temporary) directory under which SUNDIALS is built.

\item[{\sphinxcode{INSTDIR}}] \leavevmode
is the directory under which the SUNDIALS exported header files
and libraries will be installed. Typically, header files are
exported under a directory \sphinxcode{INSTDIR/include} while libraries
are installed under \sphinxcode{INSTDIR/lib}, with \sphinxcode{INSTDIR}
specified at configuration time.

\end{description}

\item {} 
For SUNDIALS’ CMake-based installation, in-source builds are prohibited;
in other words, the build directory \sphinxcode{BUILDDIR} can \sphinxstylestrong{not} be the
same as \sphinxcode{SOLVERDIR} and such an attempt will lead to an error.  This
prevents “polluting” the source tree and allows efficient builds for
different configurations and/or options.

\item {} 
The installation directory \sphinxcode{INSTDIR} can not be the same as
the source directory \sphinxcode{SOLVERDIR}.

\item {} 
By default, only the libraries and header files are exported to the
installation directory \sphinxcode{INSTDIR}.  If enabled by the user (with the
appropriate toggle for CMake), the
examples distributed with SUNDIALS will be built together with
the solver libraries but the installation step will result in
exporting (by default in a subdirectory of the installation
directory) the example sources and sample outputs together with
automatically generated configuration files that reference the
\sphinxstyleemphasis{installed} SUNDIALS headers and libraries.  As such, these
configuration files for the SUNDIALS examples can be used as
“templates” for your own problems. CMake installs
\sphinxcode{CMakeLists.txt} files and also (as an option available only under
Unix/Linux) \sphinxcode{Makefile} files. Note this installation approach also
allows the option of building the SUNDIALS examples without having
to install them.  (This can be used as a sanity check for the
freshly built libraries.)

\item {} 
Even if generation of shared libraries is enabled, only static
libraries are created for the FCMIX modules.  Because of the use of
fixed names for the Fortran user-provided subroutines, FCMIX shared
libraries would result in “undefined symbol” errors at link time.

\end{itemize}

Further details on the CMake-based installation procedures,
instructions for manual compilation, and a roadmap of the resulting
installed libraries and exported header files, are provided in the
following subsections:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{Install:installation-cmake}]{\sphinxcrossref{\DUrole{std,std-ref}{CMake-based installation}}}}

\item {} 
{\hyperref[\detokenize{Install:installation-results}]{\sphinxcrossref{\DUrole{std,std-ref}{Installed libraries and exported header files}}}}

\end{itemize}


\section{CMake-based installation}
\label{\detokenize{Install:installation-cmake}}\label{\detokenize{Install:cmake-based-installation}}
CMake-based installation provides a platform-independent build
system. CMake can generate Unix and Linux Makefiles, as well as
KDevelop, Visual Studio, and (Apple) XCode project files from the same
configuration file.  In addition, CMake also provides a GUI front end
and which allows an interactive build and installation process.

The SUNDIALS build process requires CMake version 3.0.2 or
higher and a working C compiler.  On Unix-like operating systems, it
also requires Make (and \sphinxcode{curses}, including its development libraries,
for the GUI front end to CMake, \sphinxcode{ccmake} or \sphinxcode{cmake-gui}), while on
Windows it requires Visual Studio.  While many Linux distributions
offer CMake, the version included may be out of date.  Many new CMake
features have been added recently, and you should download the latest
version from \sphinxurl{http://www.cmake.org}.  Build instructions for CMake
(only necessary for Unix-like systems) can be found on the CMake website.
Once CMake is installed, Linux/Unix users will be able to use
\sphinxcode{ccmake} or \sphinxcode{cmake-gui} (depending on the version of CMake),
while Windows users will be able to use \sphinxcode{CMakeSetup}.

As previously noted, when using CMake to configure, build and install
SUNDIALS, it is always required to use a separate build
directory. While in-source builds are possible, they are explicitly
prohibited by the SUNDIALS CMake scripts (one of the reasons being
that, unlike autotools, CMake does not provide a \sphinxcode{make distclean}
procedure and it is therefore difficult to clean-up the source tree
after an in-source build). By ensuring a separate build directory, it
is an easy task for the user to clean-up all traces of the build by
simply removing the build directory. CMake does generate a \sphinxcode{make
clean} which will remove files generated by the compiler and linker.

\index{ccmake}\ignorespaces 

\subsection{Configuring, building, and installing on Unix-like systems}
\label{\detokenize{Install:configuring-building-and-installing-on-unix-like-systems}}\label{\detokenize{Install:index-0}}\label{\detokenize{Install:installation-cmake-unix}}
The default CMake configuration will build all included solvers and
associated examples and will build static and shared libraries. The
INSTDIR defaults to \sphinxcode{/usr/local} and can be changed by setting
the \sphinxcode{CMAKE\_INSTALL\_PREFIX} variable. Support for FORTRAN and all
other options are disabled.

CMake can be used from the command line with the \sphinxcode{cmake} command, or
from a \sphinxcode{curses}-based GUI by using the \sphinxcode{ccmake} command, or from
a wxWidgets or QT based GUI by using the \sphinxcode{cmake-gui}
command. Examples for using both text and graphical methods will be
presented.  For the examples shown it is assumed that there is a top
level SUNDIALS directory with appropriate source, build and install
directories:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} mkdir \PYG{o}{(}...\PYG{o}{)}/INSTDIR
\PYGZdl{} mkdir \PYG{o}{(}...\PYG{o}{)}/BUILDDIR
\PYGZdl{} \PYG{n+nb}{cd} \PYG{o}{(}...\PYG{o}{)}/BUILDDIR
\end{sphinxVerbatim}

\index{cmake-gui}\ignorespaces 
\index{ccmake}\ignorespaces 

\subsubsection{Building with the GUI}
\label{\detokenize{Install:index-2}}\label{\detokenize{Install:building-with-the-gui}}
Using CMake with the \sphinxcode{ccmake} GUI follows the general process:
\begin{itemize}
\item {} 
Select and modify values, run configure (\sphinxcode{c} key)

\item {} 
New values are denoted with an asterisk

\item {} 
To set a variable, move the cursor to the variable and press enter
\begin{itemize}
\item {} 
If it is a boolean (ON/OFF) it will toggle the value

\item {} 
If it is string or file, it will allow editing of the string

\item {} 
For file and directories, the \sphinxcode{\textless{}tab\textgreater{}} key can be used to complete

\end{itemize}

\item {} 
Repeat until all values are set as desired and the generate option
is available (\sphinxcode{g} key)

\item {} 
Some variables (advanced variables) are not visible right away

\item {} 
To see advanced variables, toggle to advanced mode (\sphinxcode{t} key)

\item {} 
To search for a variable press \sphinxcode{/} key, and to repeat the search,
press the \sphinxcode{n} key

\end{itemize}

Using CMake with the \sphinxcode{cmake-gui} GUI follows a similar process:
\begin{itemize}
\item {} 
Select and modify values, click \sphinxcode{Configure}

\item {} 
The first time you click \sphinxcode{Configure}, make sure to pick the
appropriate generator (the following will ssume generation of Unix
Makfiles).

\item {} 
New values are highlighted in red

\item {} 
To set a variable, click on or move the cursor to the variable and press enter
\begin{itemize}
\item {} 
If it is a boolean (\sphinxcode{ON/OFF}) it will check/uncheck the box

\item {} 
If it is string or file, it will allow editing of the string.
Additionally, an ellipsis button will appear \sphinxcode{...} on the far
right of the entry.  Clicking this button will bring up the file
or directory selection dialog.

\item {} 
For files and directories, the \sphinxcode{\textless{}tab\textgreater{}} key can be used to
complete

\end{itemize}

\item {} 
Repeat until all values are set as desired and click the
\sphinxcode{Generate} button

\item {} 
Some variables (advanced variables) are not visible right away

\item {} 
To see advanced variables, click the \sphinxcode{advanced} button

\end{itemize}

To build the default configuration using the curses GUI, from the
BUILDDIR enter the \sphinxcode{ccmake} command and point to the \sphinxcode{SOLVERDIR}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ccmake \PYG{o}{(}...\PYG{o}{)}/SOLVERDIR
\end{sphinxVerbatim}

Similarly, to build the default configuration using the wxWidgets GUI,
from the BUILDDIR enter the \sphinxcode{cmake-gui} command and point to the
\sphinxcode{SOLVERDIR}:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cmake\PYGZhy{}gui \PYG{o}{(}...\PYG{o}{)}/SOLVERDIR
\end{sphinxVerbatim}

The default curses configuration screen is shown in
the following figure.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{ccmakedefault}.png}
\caption{Default configuration screen. Note: Initial screen is empty.
To get this default configuration, press ‘c’ repeatedly (accepting
default values denoted with asterisk) until the ‘g’ option is
available.}\label{\detokenize{Install:ccmakedefault}}\label{\detokenize{Install:id1}}\end{figure}

The default INSTDIR for both SUNDIALS and corresponding examples
can be changed by setting the \sphinxcode{CMAKE\_INSTALL\_PREFIX} and
the \sphinxcode{EXAMPLES\_INSTALL\_PATH} as shown in the following figure.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{ccmakeprefix}.png}
\caption{Changing the INSTDIR for SUNDIALS and corresponding EXAMPLES.}\label{\detokenize{Install:ccmakeprefix}}\label{\detokenize{Install:id2}}\end{figure}

Pressing the \sphinxcode{g} key or clicking \sphinxcode{generate} will generate
makefiles including all dependencies and all rules to build SUNDIALS
on this system.  Back at the command prompt, you can now run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make
\end{sphinxVerbatim}

or for a faster parallel build (e.g. using 4 threads), you can run

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make \PYGZhy{}j \PYG{l+m}{4}
\end{sphinxVerbatim}

To install SUNDIALS in the installation directory specified in the configuration, simply run:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make install
\end{sphinxVerbatim}

\index{cmake}\ignorespaces 

\subsubsection{Building from the command line}
\label{\detokenize{Install:building-from-the-command-line}}\label{\detokenize{Install:index-3}}
Using CMake from the command line is simply a matter of specifying
CMake variable settings with the \sphinxcode{cmake} command.  The following
will build the default configuration:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cmake \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{}  \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{}  ../srcdir
\PYGZdl{} make
\PYGZdl{} make install
\end{sphinxVerbatim}


\subsection{Configuration options (Unix/Linux)}
\label{\detokenize{Install:configuration-options-unix-linux}}\label{\detokenize{Install:installation-cmake-options}}
A complete list of all available options for a CMake-based SUNDIALS
configuration is provide below.  Note that the default values shown
are for a typical configuration on a Linux system and are provided as
illustration only.
\begin{description}
\item[{\index{BUILD\_ARKODE (CMake option)}BUILD\_ARKODE}] \leavevmode
Build the ARKODE library

Default: \sphinxcode{ON}

\item[{\index{BUILD\_CVODE (CMake option)}BUILD\_CVODE}] \leavevmode
Build the CVODE library

Default: \sphinxcode{ON}

\item[{\index{BUILD\_CVODES (CMake option)}BUILD\_CVODES}] \leavevmode
Build the CVODES library

Default: \sphinxcode{ON}

\item[{\index{BUILD\_IDA (CMake option)}BUILD\_IDA}] \leavevmode
Build the IDA library

Default: \sphinxcode{ON}

\item[{\index{BUILD\_IDAS (CMake option)}BUILD\_IDAS}] \leavevmode
Build the IDAS library

Default: \sphinxcode{ON}

\item[{\index{BUILD\_KINSOL (CMake option)}BUILD\_KINSOL}] \leavevmode
Build the KINSOL library

Default: \sphinxcode{ON}

\item[{\index{BUILD\_SHARED\_LIBS (CMake option)}BUILD\_SHARED\_LIBS}] \leavevmode
Build shared libraries

Default: \sphinxcode{ON}

\item[{\index{BUILD\_STATIC\_LIBS (CMake option)}BUILD\_STATIC\_LIBS}] \leavevmode
Build static libraries

Default: \sphinxcode{ON}

\item[{\index{CMAKE\_BUILD\_TYPE (CMake option)}CMAKE\_BUILD\_TYPE}] \leavevmode
Choose the type of build, options are:
\sphinxcode{None} (\sphinxcode{CMAKE\_C\_FLAGS} used), \sphinxcode{Debug}, \sphinxcode{Release},
\sphinxcode{RelWithDebInfo}, and \sphinxcode{MinSizeRel}

Default:

\begin{sphinxadmonition}{note}{Note:}
Specifying a build type will trigger the corresponding
build type specific compiler flag options below which
will be appended to the flags set by
\sphinxcode{CMAKE\_\textless{}language\textgreater{}\_FLAGS}.
\end{sphinxadmonition}

\item[{\index{CMAKE\_C\_COMPILER (CMake option)}CMAKE\_C\_COMPILER}] \leavevmode
C compiler

Default: \sphinxcode{/usr/bin/cc}

\item[{\index{CMAKE\_C\_FLAGS (CMake option)}CMAKE\_C\_FLAGS}] \leavevmode
Flags for C compiler

Default:

\item[{\index{CMAKE\_C\_FLAGS\_DEBUG (CMake option)}CMAKE\_C\_FLAGS\_DEBUG}] \leavevmode
Flags used by the C compiler during debug
builds

Default: \sphinxcode{-g}

\item[{\index{CMAKE\_C\_FLAGS\_MINSIZEREL (CMake option)}CMAKE\_C\_FLAGS\_MINSIZEREL}] \leavevmode
Flags used by the C compiler during release minsize builds

Default: \sphinxcode{-Os -DNDEBUG}

\item[{\index{CMAKE\_C\_FLAGS\_RELEASE (CMake option)}CMAKE\_C\_FLAGS\_RELEASE}] \leavevmode
Flags used by the C compiler during release
builds

Default: \sphinxcode{-O3 -DNDEBUG}

\item[{\index{CMAKE\_CXX\_COMPILER (CMake option)}CMAKE\_CXX\_COMPILER}] \leavevmode
C++ compiler

Default: \sphinxcode{/usr/bin/c++}

\begin{sphinxadmonition}{note}{Note:}
A C++ compiler (and all related options) are only are
triggered if C++ examples are enabled
(\sphinxcode{EXAMPLES\_ENABLE\_CXX} is ON). All SUNDIALS solvers can
be used from C++ applications by default without setting
any additional configuration options.
\end{sphinxadmonition}

\item[{\index{CMAKE\_CXX\_FLAGS (CMake option)}CMAKE\_CXX\_FLAGS}] \leavevmode
Flags for C++ compiler

Default:

\item[{\index{CMAKE\_CXX\_FLAGS\_DEBUG (CMake option)}CMAKE\_CXX\_FLAGS\_DEBUG}] \leavevmode
Flags used by the C++ compiler during debug builds

Default: \sphinxcode{-g}

\item[{\index{CMAKE\_CXX\_FLAGS\_MINSIZEREL (CMake option)}CMAKE\_CXX\_FLAGS\_MINSIZEREL}] \leavevmode
Flags used by the C++ compiler during release minsize builds

Default: \sphinxcode{-Os -DNDEBUG}

\item[{\index{CMAKE\_CXX\_FLAGS\_RELEASE (CMake option)}CMAKE\_CXX\_FLAGS\_RELEASE}] \leavevmode
Flags used by the C++ compiler during release builds

Default: \sphinxcode{-O3 -DNDEBUG}

\item[{\index{CMAKE\_Fortran\_COMPILER (CMake option)}CMAKE\_Fortran\_COMPILER}] \leavevmode
Fortran compiler

Default: \sphinxcode{/usr/bin/gfortran}

\begin{sphinxadmonition}{note}{Note:}
Fortran support (and all related options) are triggered only if
either Fortran-C support is (\sphinxcode{FCMIX\_ENABLE} is ON) or
LAPACK support is enabled (\sphinxcode{ENABLE\_LAPACK} is \sphinxcode{ON}).
\end{sphinxadmonition}

\item[{\index{CMAKE\_Fortran\_FLAGS (CMake option)}CMAKE\_Fortran\_FLAGS}] \leavevmode
Flags for Fortran compiler

Default:

\item[{\index{CMAKE\_Fortran\_FLAGS\_DEBUG (CMake option)}CMAKE\_Fortran\_FLAGS\_DEBUG}] \leavevmode
Flags used by the Fortran compiler during debug builds

Default: \sphinxcode{-g}

\item[{\index{CMAKE\_Fortran\_FLAGS\_MINSIZEREL (CMake option)}CMAKE\_Fortran\_FLAGS\_MINSIZEREL}] \leavevmode
Flags used by the Fortran compiler during release minsize builds

Default: \sphinxcode{-Os}

\item[{\index{CMAKE\_Fortran\_FLAGS\_RELEASE (CMake option)}CMAKE\_Fortran\_FLAGS\_RELEASE}] \leavevmode
Flags used by the Fortran compiler during release builds

Default: \sphinxcode{-O3}

\item[{\index{CMAKE\_INSTALL\_PREFIX (CMake option)}CMAKE\_INSTALL\_PREFIX}] \leavevmode
Install path prefix, prepended onto install directories

Default: \sphinxcode{/usr/local}

\begin{sphinxadmonition}{note}{Note:}\begin{description}
\item[{The user must have write access to the location specified}] \leavevmode
through this option. Exported SUNDIALS header files and libraries
will be installed under subdirectories \sphinxcode{include} and \sphinxcode{lib} of

\end{description}

\sphinxcode{CMAKE\_INSTALL\_PREFIX}, respectively.
\end{sphinxadmonition}

\item[{\index{ENABLE\_CUDA (CMake option)}ENABLE\_CUDA}] \leavevmode
Build the SUNDIALS CUDA modules.

Default: \sphinxcode{OFF}

\item[{\index{CMAKE\_CUDA\_ARCHITECTURES (CMake option)}CMAKE\_CUDA\_ARCHITECTURES}] \leavevmode
Specifies the CUDA architecture to compile for.

Default: \sphinxcode{sm\_30}

\item[{\index{ENABLE\_XBRAID (CMake option)}ENABLE\_XBRAID}] \leavevmode
Enable or disable the ARKStep + XBraid interface.

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
See additional information on building with \sphinxstyleemphasis{XBraid}
enabled in  {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{EXAMPLES\_ENABLE\_C (CMake option)}EXAMPLES\_ENABLE\_C}] \leavevmode
Build the SUNDIALS C examples

Default: \sphinxcode{ON}

\item[{\index{EXAMPLES\_ENABLE\_CXX (CMake option)}EXAMPLES\_ENABLE\_CXX}] \leavevmode
Build the SUNDIALS C++ examples

Default: \sphinxcode{OFF}

\item[{\index{EXAMPLES\_ENABLE\_CUDA (CMake option)}EXAMPLES\_ENABLE\_CUDA}] \leavevmode
Build the SUNDIALS CUDA examples

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
You need to enable CUDA support to build these examples.
\end{sphinxadmonition}

\item[{\index{EXAMPLES\_ENABLE\_F77 (CMake option)}EXAMPLES\_ENABLE\_F77}] \leavevmode
Build the SUNDIALS Fortran77 examples

Default: \sphinxcode{ON} (if \sphinxcode{FCMIX\_ENABLE} is \sphinxcode{ON})

\item[{\index{EXAMPLES\_ENABLE\_F90 (CMake option)}EXAMPLES\_ENABLE\_F90}] \leavevmode
Build the SUNDIALS Fortran90 examples

Default: \sphinxcode{ON} (if \sphinxcode{BUILD\_FORTRAN77\_INTERFACE} is \sphinxcode{ON})

\item[{\index{EXAMPLES\_ENABLE\_F2003 (CMake option)}EXAMPLES\_ENABLE\_F2003}] \leavevmode
Build the SUNDIALS Fortran2003 examples

Default: \sphinxcode{ON} (if \sphinxcode{BUILD\_FORTRAN\_MODULE\_INTERFACE} is \sphinxcode{ON})

\item[{\index{EXAMPLES\_INSTALL (CMake option)}EXAMPLES\_INSTALL}] \leavevmode
Install example files

Default: \sphinxcode{ON}

\begin{sphinxadmonition}{note}{Note:}
This option is triggered when any of the SUNDIALS
example programs are enabled
(\sphinxcode{EXAMPLES\_ENABLE\_\textless{}language\textgreater{}} is \sphinxcode{ON}). If the user
requires installation of example programs then the
sources and sample output files for all SUNDIALS modules
that are currently enabled will be exported to the
directory specified by \sphinxcode{EXAMPLES\_INSTALL\_PATH}. A CMake
configuration script will also be automatically generated
and exported to the same directory. Additionally, if the
configuration is done under a Unix-like system, makefiles
for the compilation of the example programs (using the
installed SUNDIALS libraries) will be automatically
generated and exported to the directory specified by
\sphinxcode{EXAMPLES\_INSTALL\_PATH}.
\end{sphinxadmonition}

\item[{\index{EXAMPLES\_INSTALL\_PATH (CMake option)}EXAMPLES\_INSTALL\_PATH}] \leavevmode
Output directory for installing example
files

Default: \sphinxcode{/usr/local/examples}

\begin{sphinxadmonition}{note}{Note:}
The actual default value for this option will be an
\sphinxcode{examples} subdirectory created under \sphinxcode{CMAKE\_INSTALL\_PREFIX}.
\end{sphinxadmonition}

\item[{\index{BUILD\_FORTRAN77\_INTERFACE (CMake option)}BUILD\_FORTRAN77\_INTERFACE}] \leavevmode
Enable Fortran77-C interface

Default: \sphinxcode{OFF}

\item[{\index{BUILD\_FORTRAN\_MODULE\_INTERFACE (CMake option)}BUILD\_FORTRAN\_MODULE\_INTERFACE}] \leavevmode
Enable Fortran2003 interface

Default: \sphinxcode{OFF}

\item[{\index{ENABLE\_HYPRE (CMake option)}ENABLE\_HYPRE}] \leavevmode
Flag to enable \sphinxstyleemphasis{hypre} support

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
See additional information on building with \sphinxstyleemphasis{hypre}
enabled in  {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{HYPRE\_INCLUDE\_DIR (CMake option)}HYPRE\_INCLUDE\_DIR}] \leavevmode
Path to \sphinxstyleemphasis{hypre} header files

Default: none

\item[{\index{HYPRE\_LIBRARY (CMake option)}HYPRE\_LIBRARY}] \leavevmode
Path to \sphinxstyleemphasis{hypre} installed library files

Default: none

\item[{\index{F90\_ENABLE (CMake option)}ENABLE\_KLU}] \leavevmode
Enable KLU support

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
See additional information on building with KLU
enabled in {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{KLU\_INCLUDE\_DIR (CMake option)}KLU\_INCLUDE\_DIR}] \leavevmode
Path to SuiteSparse header files

Default: none

\item[{\index{KLU\_LIBRARY\_DIR (CMake option)}KLU\_LIBRARY\_DIR}] \leavevmode
Path to SuiteSparse installed library files

Default: none

\item[{\index{ENABLE\_LAPACK (CMake option)}ENABLE\_LAPACK}] \leavevmode
Enable LAPACK support

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
Setting this option to \sphinxcode{ON} will trigger additional CMake
options. See additional information on building with
LAPACK enabled in {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{LAPACK\_LIBRARIES (CMake option)}LAPACK\_LIBRARIES}] \leavevmode
LAPACK (and BLAS) libraries

Default: \sphinxcode{/usr/lib/liblapack.so;/usr/lib/libblas.so}

\begin{sphinxadmonition}{note}{Note:}
CMake will search for libraries in your
\sphinxcode{LD\_LIBRARY\_PATH} prior to searching default system
paths.
\end{sphinxadmonition}

\item[{\index{ENABLE\_MPI (CMake option)}ENABLE\_MPI}] \leavevmode
Enable MPI support. This will build the parallel nvector
and the MPI-aware version of the ManyVector library.

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
Setting this option to \sphinxcode{ON} will trigger several additional
options related to MPI.
\end{sphinxadmonition}

\item[{\index{MPI\_C\_COMPILER (CMake option)}MPI\_C\_COMPILER}] \leavevmode
\sphinxcode{mpicc} program

Default:

\item[{\index{MPI\_CXX\_COMPILER (CMake option)}MPI\_CXX\_COMPILER}] \leavevmode
\sphinxcode{mpicxx} program

Default:

\begin{sphinxadmonition}{note}{Note:}
This option is triggered only if MPI is enabled
(\sphinxcode{ENABLE\_MPI} is \sphinxcode{ON}) and C++ examples are enabled
(\sphinxcode{EXAMPLES\_ENABLE\_CXX} is \sphinxcode{ON}). All SUNDIALS
solvers can be used from C++ MPI applications by default
without setting any additional configuration options
other than \sphinxcode{ENABLE\_MPI}.
\end{sphinxadmonition}

\item[{\index{MPI\_Fortran\_COMPILER (CMake option)}MPI\_Fortran\_COMPILER}] \leavevmode
\sphinxcode{mpif77} or \sphinxcode{mpif90} program

Default:

\begin{sphinxadmonition}{note}{Note:}
This option is triggered only if MPI is enabled
(\sphinxcode{ENABLE\_MPI} is \sphinxcode{ON}) and Fortran-C support is
enabled (\sphinxcode{EXAMPLES\_ENABLE\_F77} or \sphinxcode{EXAMPLES\_ENABLE\_F90} are \sphinxcode{ON}).
\end{sphinxadmonition}

\item[{\index{MPIEXEC\_EXECUTABLE (CMake option)}MPIEXEC\_EXECUTABLE}] \leavevmode
Specify the executable for running MPI programs

Default: \sphinxcode{mpirun}

\begin{sphinxadmonition}{note}{Note:}
This option is triggered only if MPI is enabled (\sphinxcode{ENABLE\_MPI} is \sphinxcode{ON}).
\end{sphinxadmonition}

\item[{\index{ENABLE\_OPENMP (CMake option)}ENABLE\_OPENMP}] \leavevmode
Enable OpenMP support (build the OpenMP NVector)

Default: \sphinxcode{OFF}

\item[{\index{ENABLE\_PETSC (CMake option)}ENABLE\_PETSC}] \leavevmode
Enable PETSc support

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
See additional information on building with
PETSc enabled in {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{PETSC\_DIR (CMake option)}PETSC\_DIR}] \leavevmode
Path to PETSc installation

Default: none

\item[{\index{PETSC\_LIBRARIES (CMake option)}PETSC\_LIBRARIES (advanced option)}] \leavevmode
Semi-colon separated list of PETSc link libraries. Unless provided by the
user, this is autopopulated based on the PETSc installation found in
\sphinxcode{PETSC\_DIR}.

Default: none

\item[{\index{PETSC\_INCLUDES (CMake option)}PETSC\_INCLUDES (advanced option)}] \leavevmode
Semi-colon separated list of PETSc include directroies. Unless provided by
the user, this is autopopulated based on the PETSc installation found in
\sphinxcode{PETSC\_DIR}.

Default: none

\item[{\index{ENABLE\_PTHREAD (CMake option)}ENABLE\_PTHREAD}] \leavevmode
Enable Pthreads support (build the Pthreads NVector)

Default: \sphinxcode{OFF}

\item[{\index{RAJA\_ENABLE (CMake option)}ENABLE\_RAJA}] \leavevmode
Enable RAJA support.

Default: OFF

\begin{sphinxadmonition}{note}{Note:}
You need to enable CUDA or HIP in order to build the
RAJA vector module.
\end{sphinxadmonition}

\item[{\index{SUNDIALS\_RAJA\_BACKENDS (CMake option)}SUNDIALS\_RAJA\_BACKENDS}] \leavevmode
If building SUNDIALS with RAJA support, this sets the RAJA
backend to target. Values supported are CUDA and HIP.

Default: CUDA

\item[{\index{ENABLE\_SUPERLUDIST (CMake option)}ENABLE\_SUPERLUDIST}] \leavevmode
Enable SuperLU\_DIST support

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
See additional information on building wtih
SuperLU\_DIST enabled in {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{SUPERLUDIST\_INCLUDE\_DIR (CMake option)}SUPERLUDIST\_INCLUDE\_DIR}] \leavevmode
Path to SuperLU\_DIST header files (under a typical SuperLU\_DIST
install, this is typically the SuperLU\_DIST \sphinxcode{SRC} directory)

Default: none

\item[{\index{SUPERLUDIST\_LIBRARY\_DIR (CMake option)}SUPERLUDIST\_LIBRARY\_DIR}] \leavevmode
Path to SuperLU\_DIST installed library files

Default: none

\item[{\index{SUPERLUDIST\_LIBRARIES (CMake option)}SUPERLUDIST\_LIBRARIES}] \leavevmode
Semi-colon separated list of libraries needed for SuperLU\_DIST

Default: none

\item[{\index{SUPERLUDIST\_OpenMP (CMake option)}SUPERLUDIST\_OpenMP}] \leavevmode
Enable SUNDIALS support for SuperLU\_DIST built with OpenMP

Default: none

Note: SuperLU\_DIST must be built with OpenMP support for this option to function.
Additionally the environment variable \sphinxcode{OMP\_NUM\_THREADS} must be set to the desired
number of threads.

\item[{\index{ENABLE\_SUPERLUMT (CMake option)}ENABLE\_SUPERLUMT}] \leavevmode
Enable SuperLU\_MT support

Default: \sphinxcode{OFF}

\begin{sphinxadmonition}{note}{Note:}
See additional information on building with
SuperLU\_MT enabled in {\hyperref[\detokenize{Install:installation-cmake-externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with external Libraries}}}}.
\end{sphinxadmonition}

\item[{\index{SUPERLUMT\_INCLUDE\_DIR (CMake option)}SUPERLUMT\_INCLUDE\_DIR}] \leavevmode
Path to SuperLU\_MT header files (under a typical SuperLU\_MT
install, this is typically the SuperLU\_MT \sphinxcode{SRC} directory)

Default: none

\item[{\index{SUPERLUMT\_LIBRARY\_DIR (CMake option)}SUPERLUMT\_LIBRARY\_DIR}] \leavevmode
Path to SuperLU\_MT installed library files

Default: none

\item[{\index{SUPERLUMT\_THREAD\_TYPE (CMake option)}SUPERLUMT\_THREAD\_TYPE}] \leavevmode
Must be set to Pthread or OpenMP, depending on how SuperLU\_MT was compiled.

Default: Pthread

\item[{\index{SUNDIALS\_BUILD\_WITH\_MONITORING (CMake option)}SUNDIALS\_BUILD\_WITH\_MONITORING}] \leavevmode
Build SUNDIALS with capabilties for fine-grained monitoring of solver progress
and statistics. This is primarily useful for debugging.

Default: OFF

Note: Building with monitoring may result in minor performance degradation
even if monitoring is not utilized.

\item[{\index{CMAKE\_CXX\_STANDARD (CMake option)}CMAKE\_CXX\_STANDARD}] \leavevmode
The C++ standard to build C++ parts of SUNDIALS with.

Default: 11

Note: Options are 99, 11, 14, 17. This option only used when a
C++ compiler is required.

\item[{\index{SUNDIALS\_F77\_FUNC\_CASE (CMake option)}SUNDIALS\_F77\_FUNC\_CASE}] \leavevmode
Specify the case to use in the Fortran name-mangling scheme,
options are: \sphinxcode{lower} or \sphinxcode{upper}

Default:

Note: The build system will attempt to infer the Fortran
name-mangling scheme using the Fortran compiler. This option should
only be used if a Fortran compiler is not available or to override
the inferred or default (\sphinxcode{lower}) scheme if one can not be
determined. If used, \sphinxcode{SUNDIALS\_F77\_FUNC\_UNDERSCORES} must also
be set.

\item[{\index{SUNDIALS\_F77\_FUNC\_UNDERSCORES (CMake option)}SUNDIALS\_F77\_FUNC\_UNDERSCORES}] \leavevmode
Specify the number of underscores to append in the Fortran
name-mangling scheme, options are: \sphinxcode{none}, \sphinxcode{one}, or \sphinxcode{two}

Default:

Note: The build system will attempt to infer the Fortran
name-mangling scheme using the Fortran compiler. This option should
only be used if a Fortran compiler is not available or to override
the inferred or default (\sphinxcode{one}) scheme if one can not be
determined. If used, \sphinxcode{SUNDIALS\_F77\_FUNC\_CASE} must also be set.

\item[{\index{SUNDIALS\_INDEX\_TYPE (CMake option)}SUNDIALS\_INDEX\_TYPE (advanced)}] \leavevmode
Integer type used for SUNDIALS indices.  The size must match the size provided for
the \sphinxcode{SUNDIALS\_INDEX\_SIZE} option.

Default:

Note: In past SUNDIALS versions, a user could set this option to
\sphinxcode{INT64\_T} to use 64-bit integers, or \sphinxcode{INT32\_T} to use 32-bit
integers. Starting in SUNDIALS 3.2.0, these special values are
deprecated. For SUNDIALS 3.2.0 and up, a user will only need to use
the \sphinxcode{SUNDIALS\_INDEX\_SIZE} option in most cases.

\item[{\index{SUNDIALS\_INDEX\_SIZE (CMake option)}SUNDIALS\_INDEX\_SIZE}] \leavevmode
Integer size (in bits) used for indices in SUNDIALS, options are: \sphinxcode{32} or \sphinxcode{64}

Default: \sphinxcode{64}

Note: The build system tries to find an integer type of appropriate
size. Candidate 64-bit integer types are (in order of preference):
\sphinxcode{int64\_t}, \sphinxcode{\_\_int64}, \sphinxcode{long long}, and \sphinxcode{long}.  Candidate
32-bit integers are (in order of preference): \sphinxcode{int32\_t},
\sphinxcode{int}, and \sphinxcode{long}.  The advanced option,
\sphinxcode{SUNDIALS\_INDEX\_TYPE} can be used to provide a type not listed
here.

\item[{\index{SUNDIALS\_PRECISION (CMake option)}SUNDIALS\_PRECISION}] \leavevmode
Precision used in SUNDIALS, options are: \sphinxcode{double}, \sphinxcode{single} or
\sphinxcode{extended}

Default: \sphinxcode{double}

\item[{\index{SUNDIALS\_INSTALL\_CMAKEDIR (CMake option)}SUNDIALS\_INSTALL\_CMAKEDIR}] \leavevmode
Installation directory for the SUNDIALS cmake files (relative to \sphinxcode{CMAKE\_INSTALL\_PREFIX}).

Default: \sphinxcode{CMAKE\_INSTALL\_PREFIX/cmake/sundials}

\item[{\index{USE\_GENERIC\_MATH (CMake option)}USE\_GENERIC\_MATH}] \leavevmode
Use generic (\sphinxcode{stdc}) math libraries

Default: \sphinxcode{ON}

\item[{\index{XBRAID\_DIR (CMake option)}XBRAID\_DIR}] \leavevmode
The root directory of the XBraid installation.

Default: \sphinxcode{OFF}

\item[{\index{XBRAID\_INCLUDES (CMake option)}XBRAID\_INCLUDES}] \leavevmode
Semi-colon separated list of XBraid include directories. Unless provided by
the user, this is autopopulated based on the XBraid installation found in
\sphinxcode{XBRAID\_DIR}.

Default: none

\item[{\index{XBRAID\_LIBRARIES (CMake option)}XBRAID\_LIBRARIES}] \leavevmode
Semi-colon separated list of XBraid link libraries. Unless provided by
the user, this is autopopulated based on the XBraid installation found in
\sphinxcode{XBRAID\_DIR}.

Default: none

\item[{\index{USE\_XSDK\_DEFAULTS (xSDK CMake option)}USE\_XSDK\_DEFAULTS}] \leavevmode
Enable xSDK (see \sphinxurl{https://xsdk.info} for more
information) default configuration settings. This sets \sphinxcode{CMAKE\_BUILD\_TYPE}
to \sphinxcode{Debug}, \sphinxcode{SUNDIALS\_INDEX\_SIZE} to 32 and \sphinxcode{SUNDIALS\_PRECISION} to
double.

Default: \sphinxcode{OFF}

\end{description}


\subsection{Configuration examples}
\label{\detokenize{Install:installation-cmake-examples}}\label{\detokenize{Install:configuration-examples}}
The following examples will help demonstrate usage of the CMake
configure options.

To configure SUNDIALS using the default C and Fortran compilers,
and default \sphinxcode{mpicc} and \sphinxcode{mpif77} parallel compilers,
enable compilation of examples, and install libraries, headers, and
example sources under subdirectories of \sphinxcode{/home/myname/sundials/}, use:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DENABLE\PYGZus{}MPI\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DFCMIX\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{sphinxVerbatim}

To disable installation of the examples, use:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DENABLE\PYGZus{}MPI\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DFCMIX\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYG{o}{=}OFF \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{sphinxVerbatim}


\subsection{Working with external Libraries}
\label{\detokenize{Install:working-with-external-libraries}}\label{\detokenize{Install:installation-cmake-externallibraries}}
The SUNDIALS suite contains many options to enable implementation
flexibility when developing solutions. The following are some notes
addressing specific configurations when using the supported third
party libraries.


\subsubsection{Building with LAPACK}
\label{\detokenize{Install:building-with-lapack}}\label{\detokenize{Install:installation-cmake-externallibraries-lapack}}
To enable LAPACK, set the \sphinxcode{ENABLE\_LAPACK} option to \sphinxcode{ON}.
If the directory containing the LAPACK library is in the
\sphinxcode{LD\_LIBRARY\_PATH} environment variable, CMake will set the
\sphinxcode{LAPACK\_LIBRARIES} variable accordingly, otherwise CMake will
attempt to find the LAPACK library in standard system locations. To
explicitly tell CMake what library to use, the \sphinxcode{LAPACK\_LIBRARIES}
variable can be set to the desired libraries required for LAPACK.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DENABLE\PYGZus{}LAPACK\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DLAPACK\PYGZus{}LIBRARIES\PYG{o}{=}/mylapackpath/lib/libblas.so\PYG{p}{;}/mylapackpath/lib/liblapack.so \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If a working Fortran compiler is not available to infer the
Fortran name-mangling scheme, the options
\sphinxcode{SUNDIALS\_F77\_FUNC\_CASE} and
\sphinxcode{SUNDIALS\_F77\_FUNC\_UNDERSCORES} \sphinxstyleemphasis{must} be set in order to
bypass the check for a Fortran compiler and define the
name-mangling scheme. The defaults for these options in
earlier versions of SUNDIALS were \sphinxcode{lower} and \sphinxcode{one},
respectively.
\end{sphinxadmonition}


\subsubsection{Building with KLU}
\label{\detokenize{Install:building-with-klu}}\label{\detokenize{Install:installation-cmake-externallibraries-klu}}
The KLU libraries are part of SuiteSparse, a suite of sparse matrix
software, available from the Texas A\&M University website:
\sphinxurl{http://faculty.cse.tamu.edu/davis/suitesparse.html} .

SUNDIALS has been tested with SuiteSparse version 5.7.2.  To enable
KLU, set \sphinxcode{ENABLE\_KLU} to \sphinxcode{ON}, set \sphinxcode{KLU\_INCLUDE\_DIR} to the
\sphinxcode{include} path of the KLU installation and set \sphinxcode{KLU\_LIBRARY\_DIR}
to the \sphinxcode{lib} path of the KLU installation.  The CMake configure will
result in populating the following variables: \sphinxcode{AMD\_LIBRARY},
\sphinxcode{AMD\_LIBRARY\_DIR},  \sphinxcode{BTF\_LIBRARY}, \sphinxcode{BTF\_LIBRARY\_DIR},
\sphinxcode{COLAMD\_LIBRARY}, \sphinxcode{COLAMD\_LIBRARY\_DIR}, and \sphinxcode{KLU\_LIBRARY}.


\subsubsection{Building with SuperLU\_DIST}
\label{\detokenize{Install:installation-cmake-externallibraries-superlu-mt}}\label{\detokenize{Install:building-with-superlu-dist}}
The SuperLU\_DIST libraries are available for download from the Lawrence
Berkeley National Laboratory website:
\sphinxurl{http://crd-legacy.lbl.gov/\$sim\$xiaoye/SuperLU/}\#superlu\_dist.

SUNDIALS has been tested with SuperLU\_DIST 6.1.1. To enable
SuperLU\_DIST, set  \sphinxcode{ENABLE\_SUPERLUDIST} to \sphinxcode{ON}, set
\sphinxcode{SUPERLUDIST\_INCLUDE\_DIR} to the \sphinxcode{SRC} path of the SuperLU\_DIST
installation, and set the variable \sphinxcode{SUPERLUMT\_LIBRARY\_DIR} to the
\sphinxcode{lib} path of the SuperLU\_DIST installation.  At the same time, the
variable \sphinxcode{SUPERLUDIST\_LIBRARIES} must be set to a semi-colon separated list
of other libraries SuperLU\_DIST depends on. For example, if SuperLU\_DIST
was built with LAPACK, then include the LAPACK library in this list.
If SuperLU\_DIST was built with OpenMP support, then you may set
\sphinxcode{SUPERLUDIST\_OpenMP} to \sphinxcode{ON} utilize the OpenMP functionality of
SuperLU\_DIST.


\subsubsection{Building with SuperLU\_MT}
\label{\detokenize{Install:building-with-superlu-mt}}
The SuperLU\_MT libraries are available for download from the Lawrence
Berkeley National Laboratory website:
\sphinxurl{http://crd-legacy.lbl.gov/\$sim\$xiaoye/SuperLU/}\#superlu\_mt .

SUNDIALS has been tested with SuperLU\_MT version 3.1.  To enable
SuperLU\_MT, set  \sphinxcode{ENABLE\_SUPERLUMT} to \sphinxcode{ON}, set
\sphinxcode{SUPERLUMT\_INCLUDE\_DIR} to the \sphinxcode{SRC} path of the SuperLU\_MT
installation, and set the variable \sphinxcode{SUPERLUMT\_LIBRARY\_DIR} to the
\sphinxcode{lib} path of the SuperLU\_MT installation. At the same time, the
variable \sphinxcode{SUPERLUMT\_LIBRARIES} must be set to a semi-colon separated
list of other libraries SuperLU\_MT depends on. For example, if
SuperLU\_MT was build with an external blas library, then include the
full path to the blas library in this list. Additionally, the
variable \sphinxcode{SUPERLUMT\_THREAD\_TYPE} must be set to either \sphinxcode{Pthread}
or \sphinxcode{OpenMP}.

Do not mix thread types when building SUNDIALS solvers.
If threading is enabled for SUNDIALS by having either
\sphinxcode{ENABLE\_OPENMP} or \sphinxcode{ENABLE\_PTHREAD} set to \sphinxcode{ON} then SuperLU\_MT
should be set to use the same threading type.


\subsubsection{Building with PETSc}
\label{\detokenize{Install:building-with-petsc}}\label{\detokenize{Install:installation-cmake-externallibraries-petsc}}
The PETSc libraries are available for download from the Argonne
National Laboratory website:
\sphinxurl{http://www.mcs.anl.gov/petsc} .

SUNDIALS has been tested with PETSc version 3.10.0 - 3.14.0. To enable PETSc,
set \sphinxcode{ENABLE\_PETSC} to \sphinxcode{ON}, and set \sphinxcode{PETSC\_DIR} to the path of the PETSc
installation. Alternatively, a user can provide a list of inlcude paths in
\sphinxcode{PETSC\_INCLUDES} and a list of complete paths to the PETSc libraries in
\sphinxcode{PETSC\_LIBRARIES}.


\subsubsection{Building with \sphinxstyleemphasis{hypre}}
\label{\detokenize{Install:installation-cmake-externallibraries-hypre}}\label{\detokenize{Install:building-with-hypre}}
The \sphinxstyleemphasis{hypre} libraries are available for download from the Lawrence
Livermore National Laboratory website:
\sphinxurl{http://computing.llnl.gov/projects/hypre}.
SUNDIALS has been tested with \sphinxstyleemphasis{hypre} version 2.19.0.
To enable \sphinxstyleemphasis{hypre}, set  \sphinxcode{ENABLE\_HYPRE} to \sphinxcode{ON}, set \sphinxcode{HYPRE\_INCLUDE\_DIR}
to the \sphinxcode{include} path of the \sphinxstyleemphasis{hypre} installation, and set the variable
\sphinxcode{HYPRE\_LIBRARY\_DIR} to the \sphinxcode{lib} path of the \sphinxstyleemphasis{hypre} installation.

Note: SUNDIALS must be configured so that \sphinxcode{SUNDIALS\_INDEX\_SIZE} (or
equivalently, \sphinxcode{XSDK\_INDEX\_SIZE}) equals the precision of
\sphinxcode{HYPRE\_BigInt} in the corresponding \sphinxstyleemphasis{hypre} installation.


\subsubsection{Building with CUDA}
\label{\detokenize{Install:building-with-cuda}}\label{\detokenize{Install:installation-cmake-externallibraries-cuda}}
SUNDIALS CUDA modules and examples have been tested with version 10 and 11
of the CUDA toolkit. To build them, you need to install the Toolkit and compatible
NVIDIA drivers. Both are available for download from the NVIDIA website:
\sphinxurl{https://developer.nvidia.com/cuda-downloads}. To enable CUDA,
set \sphinxcode{ENABLE\_CUDA} to \sphinxcode{ON}. If CUDA is installed in a nonstandard
location, you may be prompted to set the variable
\sphinxcode{CUDA\_TOOLKIT\_ROOT\_DIR} with your CUDA Toolkit installation
path. To enable CUDA examples, set \sphinxcode{EXAMPLES\_ENABLE\_CUDA} to \sphinxcode{ON}.


\subsubsection{Building with RAJA}
\label{\detokenize{Install:building-with-raja}}\label{\detokenize{Install:installation-cmake-externallibraries-raja}}
RAJA is a performance portability layer developed by Lawrence
Livermore National Laboratory and can be obtained from
\sphinxurl{https://github.com/LLNL/RAJA}.
SUNDIALS RAJA modules and examples have been tested with RAJA
version 0.12.1. Building SUNDIALS RAJA modules requires a CUDA-enabled
RAJA installation. To enable RAJA, set \sphinxcode{ENABLE\_CUDA} and
\sphinxcode{ENABLE\_RAJA} to \sphinxcode{ON}. If RAJA is installed in a nonstandard
location you will be prompted to set the variable \sphinxcode{RAJA\_DIR} with
the path to the RAJA CMake configuration file. To enable building the
RAJA examples set \sphinxcode{EXAMPLES\_ENABLE\_CUDA} to \sphinxcode{ON}.


\subsubsection{Building with XBraid}
\label{\detokenize{Install:installation-cmake-externallibraries-xbraid}}\label{\detokenize{Install:building-with-xbraid}}
The XBraid library is available for download from the XBraid GitHub:
\sphinxurl{https://github.com/XBraid/xbraid}.
SUNDIALS has been tested with XBraid version 3.0.0.
To enable XBraid, set  \sphinxcode{ENABLE\_XBRAID} to \sphinxcode{ON}, set \sphinxcode{XBRAID\_DIR}
to the root install location of XBraid or the location of the clone of the
XBraid repository.

Note: At this time the XBraid types \sphinxcode{braid\_Int} and \sphinxcode{braid\_Real} are
hard-coded to \sphinxcode{int} and \sphinxcode{double} respectively. As such SUNDIALS must be
configured with \sphinxcode{SUNDIALS\_INDEX\_SIZE} set to \sphinxcode{32} and \sphinxcode{SUNDIALS\_PRECISION}
set to \sphinxcode{double}. Additionally, SUNDIALS must be configured with \sphinxcode{ENABLE\_MPI}
set to \sphinxcode{ON}.


\subsection{Testing the build and installation}
\label{\detokenize{Install:installation-cmake-testing}}\label{\detokenize{Install:testing-the-build-and-installation}}
If SUNDIALS was configured with \sphinxcode{EXAMPLES\_ENABLE\_\textless{}language\textgreater{}} options
to \sphinxcode{ON}, then a set of regression tests can be run after building
with the \sphinxcode{make} command by running:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{} make \PYG{n+nb}{test}
\end{sphinxVerbatim}

Additionally, if \sphinxcode{EXAMPLES\_INSTALL} was also set to \sphinxcode{ON}, then a
set of smoke tests can be run after installing with the \sphinxcode{make install}
command by running:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZpc{} make test\PYGZus{}install
\end{sphinxVerbatim}


\subsection{Building and Running Examples}
\label{\detokenize{Install:installation-cmake-buildrunexamples}}\label{\detokenize{Install:building-and-running-examples}}
Each of the SUNDIALS solvers is distributed with a set of examples
demonstrating basic usage. To build and install the examples, set at
least of the \sphinxcode{EXAMPLES\_ENABLE\_\textless{}language\textgreater{}} options to \sphinxcode{ON}, and
set \sphinxcode{EXAMPLES\_INSTALL} to \sphinxcode{ON}. Specify
the installation path for the examples with the variable
\sphinxcode{EXAMPLES\_INSTALL\_PATH}. CMake will generate \sphinxcode{CMakeLists.txt}
configuration files (and \sphinxcode{Makefile} files if on Linux/Unix) that
reference the \sphinxstyleemphasis{installed} SUNDIALS headers and libraries.

Either the \sphinxcode{CMakeLists.txt} file or the traditional \sphinxcode{Makefile} may
be used to build the examples as well as serve as a template for
creating user developed solutions.  To use the supplied \sphinxcode{Makefile}
simply run \sphinxcode{make} to compile and generate the executables.  To use
CMake from within the installed example directory, run \sphinxcode{cmake} (or
\sphinxcode{ccmake} or \sphinxcode{cmake-gui} to use the GUI) followed by \sphinxcode{make} to
compile the example code.  Note that if CMake is used, it will
overwrite the traditional \sphinxcode{Makefile} with a new CMake-generated
\sphinxcode{Makefile}.

The resulting output from running the examples can be compared with
example output bundled in the SUNDIALS distribution.

NOTE: There will potentially be differences in the output due to
machine architecture, compiler versions, use of third party libraries etc.


\subsection{Configuring, building, and installing on Windows}
\label{\detokenize{Install:configuring-building-and-installing-on-windows}}\label{\detokenize{Install:installation-cmake-windows}}
CMake can also be used to build SUNDIALS on Windows. To build SUNDIALS
for use with Visual Studio the following steps should be performed:
\begin{enumerate}
\item {} 
Unzip the downloaded tar file(s) into a directory. This will be the
\sphinxcode{SOLVERDIR}

\item {} 
Create a separate \sphinxcode{BUILDDIR}

\item {} 
Open a Visual Studio Command Prompt and cd to \sphinxcode{BUILDDIR}

\item {} 
Run \sphinxcode{cmake-gui ../SOLVERDIR}
\begin{enumerate}
\item {} 
Hit Configure

\item {} 
Check/Uncheck solvers to be built

\item {} 
Change \sphinxcode{CMAKE\_INSTALL\_PREFIX} to \sphinxcode{INSTDIR}

\item {} 
Set other options as desired

\item {} 
Hit Generate

\end{enumerate}

\item {} 
Back in the VS Command Window:
\begin{enumerate}
\item {} 
Run \sphinxcode{msbuild ALL\_BUILD.vcxproj}

\item {} 
Run \sphinxcode{msbuild INSTALL.vcxproj}

\end{enumerate}

\end{enumerate}

The resulting libraries will be in the \sphinxcode{INSTDIR}.

The SUNDIALS project can also now be opened in Visual Studio.
Double click on the \sphinxcode{ALL\_BUILD.vcxproj} file to open the project.
Build the whole \sphinxstyleemphasis{solution} to create the SUNDIALS libraries.
To use the SUNDIALS libraries in your own projects, you must
set the include directories for your project,
add the SUNDIALS libraries to your project solution,
and set the SUNDIALS libraries as dependencies for your project.


\section{Installed libraries and exported header files}
\label{\detokenize{Install:installation-results}}\label{\detokenize{Install:installed-libraries-and-exported-header-files}}
Using the CMake SUNDIALS build system, the command

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} make install
\end{sphinxVerbatim}

will install the libraries under \sphinxcode{LIBDIR} and the public header
files under \sphinxcode{INCLUDEDIR}. The values for these directories
are \sphinxcode{INSTDIR/lib} and \sphinxcode{INSTDIR/include}, respectively.  The
location can be changed by setting the CMake variable
\sphinxcode{CMAKE\_INSTALL\_PREFIX}.  Although all installed libraries reside
under \sphinxcode{LIBDIR/lib}, the public header files are further organized
into subdirectories under \sphinxcode{INCLUDEDIR/include}.

The installed libraries and exported header files are listed for
reference in the {\hyperref[\detokenize{Install:installation-table}]{\sphinxcrossref{\DUrole{std,std-ref}{Table: SUNDIALS libraries and header files}}}}. The file extension \sphinxcode{.LIB} is typically \sphinxcode{.so}
for shared libraries and \sphinxcode{.a} for static libraries. Note that, in
this table names are relative to \sphinxcode{LIBDIR} for libraries and to
\sphinxcode{INCLUDEDIR} for header files.

A typical user program need not explicitly include any of the shared
SUNDIALS header files from under the \sphinxcode{INCLUDEDIR/include/sundials}
directory since they are explicitly included by the appropriate solver
header files (e.g., \sphinxcode{cvode\_dense.h} includes
\sphinxcode{sundials\_dense.h}). However, it is both legal and safe to do so,
and would be useful, for example, if the functions declared in
\sphinxcode{sundials\_dense.h} are to be used in building a preconditioner.


\subsection{Using SUNDIALS as a Third Party Library in other CMake Projects}
\label{\detokenize{Install:using-sundials-as-a-third-party-library-in-other-cmake-projects}}
The \sphinxcode{make install} command will also install a \sphinxhref{https://cmake.org/cmake/help/v3.12/manual/cmake-packages.7.html\#package-configuration-file}{CMake package configuration file}
that other CMake projects can load to get all the information needed to build
against SUNDIALS. In the consuming project’s CMake code, the \sphinxcode{find\_package}
command may be used to search for the configuration file, which will be
installed to \sphinxcode{instdir/SUNDIALS\_INSTALL\_CMAKEDIR/SUNDIALSConfig.cmake}
alongside a package version file
\sphinxcode{instdir/SUNDIALS\_INSTALL\_CMAKEDIR/SUNDIALSConfigVersion.cmake}. Together
these files contain all the information the consuming project needs to use
SUNDIALS, including exported CMake targets. The SUNDIALS exported CMake targets
follow the same naming convention as the generated library binaries, e.g. the
exported target for CVODE is \sphinxcode{SUNDIALS::cvode}. The CMake code snipped
below shows how a consuming project might leverage the SUNDIALS package
configuration file to build against SUNDIALS in their own CMake project.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
project(MyProject)

\PYGZsh{} Set the variable SUNDIALS\PYGZus{}DIR to the SUNDIALS instdir.
\PYGZsh{} When using the cmake CLI command, this can be done like so:
\PYGZsh{}   cmake \PYGZhy{}D SUNDIALS\PYGZus{}DIR=/path/to/sundials/installation

find\PYGZus{}project(SUNDIALS REQUIRED)

add\PYGZus{}executable(myexec main.c)

\PYGZsh{} Link to SUNDIALS libraries through the exported targets.
\PYGZsh{} This is just an example, users should link to the targets appropriate
\PYGZsh{} for their use case.
target\PYGZus{}link\PYGZus{}libraries(myexec PUBLIC SUNDIALS::cvode SUNDIALS::nvecpetsc)
\end{sphinxVerbatim}
\phantomsection\label{\detokenize{Install:installation-table}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|\Y{0.3}|\Y{0.1}|\Y{0.6}|}
\caption{SUNDIALS shared libraries and header files\strut}\label{\detokenize{Install:id3}}\\*[\sphinxlongtablecapskipadjust]
\hline

\endfirsthead

\multicolumn{3}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{3}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot
\sphinxmultirow{16}{1}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Shared
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{16}{2}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{sundials/sundials\_band.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_config.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_cuda\_policies.hpp}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_dense.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_direct.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_fconfig.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_fnvector.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_iterative.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_linearsolver.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_nonlinearsolver.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_matrix.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_math.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_nvector.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_types.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_version.h}
\\
\cline{3-3}\sphinxtablestrut{1}&\sphinxtablestrut{2}&
\sphinxcode{sundials/sundials\_xbraid.h}
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
NVECTOR Modules
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxmultirow{3}{20}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SERIAL
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{21}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_nvecserial.LIB}
\\
\cline{3-3}\sphinxtablestrut{20}&\sphinxtablestrut{21}&
\sphinxcode{libsundials\_fnvecserial.a}
\\
\cline{2-3}\sphinxtablestrut{20}&
Headers
&
\sphinxcode{nvector/nvector\_serial.h}
\\
\hline\sphinxmultirow{3}{26}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
PARALLEL
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{27}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_nvecparallel.LIB}
\\
\cline{3-3}\sphinxtablestrut{26}&\sphinxtablestrut{27}&
\sphinxcode{libsundials\_fnvecparallel.a}
\\
\cline{2-3}\sphinxtablestrut{26}&
Headers
&
\sphinxcode{nvector/nvector\_parallel.h}
\\
\hline\sphinxmultirow{3}{32}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
OPENMP
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{33}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_nvecopenmp.LIB}
\\
\cline{3-3}\sphinxtablestrut{32}&\sphinxtablestrut{33}&
\sphinxcode{libsundials\_fnvecopenmp.a}
\\
\cline{2-3}\sphinxtablestrut{32}&
Headers
&
\sphinxcode{nvector/nvector\_openmp.h}
\\
\hline\sphinxmultirow{3}{38}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
PTHREADS
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{39}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_nvecpthreads.LIB}
\\
\cline{3-3}\sphinxtablestrut{38}&\sphinxtablestrut{39}&
\sphinxcode{libsundials\_fnvecpthreads.a}
\\
\cline{2-3}\sphinxtablestrut{38}&
Headers
&
\sphinxcode{nvector/nvector\_pthreads.h}
\\
\hline\sphinxmultirow{2}{44}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
PARHYP
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nvecparhyp.LIB}
\\
\cline{2-3}\sphinxtablestrut{44}&
Headers
&
\sphinxcode{nvector/nvector\_parhyp.h}
\\
\hline\sphinxmultirow{2}{49}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
PETSC
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nvecpetsc.LIB}
\\
\cline{2-3}\sphinxtablestrut{49}&
Headers
&
\sphinxcode{nvector/nvector\_petsc.h}
\\
\hline\sphinxmultirow{2}{54}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
CUDA
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nveccuda.LIB}
\\
\cline{2-3}\sphinxtablestrut{54}&
Headers
&
\sphinxcode{nvector/nvector\_cuda.h}
\\
\hline\sphinxmultirow{2}{59}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
RAJA
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nveccudaraja.LIB}
\sphinxcode{libsundials\_nvechipraja.LIB}
\\
\cline{2-3}\sphinxtablestrut{59}&
Headers
&
\sphinxcode{nvector/nvector\_raja.h}
\\
\hline\sphinxmultirow{2}{64}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
MANYVECTOR
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nvecmanyvector.LIB}
\\
\cline{2-3}\sphinxtablestrut{64}&
Headers
&
\sphinxcode{nvector/nvector\_manyvector.h}
\\
\hline\sphinxmultirow{2}{69}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
MPIMANYVECTOR
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nvecmpimanyvector.LIB}
\\
\cline{2-3}\sphinxtablestrut{69}&
Headers
&
\sphinxcode{nvector/nvector\_mpimanyvector.h}
\\
\hline\sphinxmultirow{2}{74}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
MPIPLUSX
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_nvecmpiplusx.LIB}
\\
\cline{2-3}\sphinxtablestrut{74}&
Headers
&
\sphinxcode{nvector/nvector\_mpiplusx.h}
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
SUNMATRIX Modules
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxmultirow{3}{80}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
BAND
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{81}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunmatrixband.LIB}
\\
\cline{3-3}\sphinxtablestrut{80}&\sphinxtablestrut{81}&
\sphinxcode{libsundials\_fsunmatrixband.a}
\\
\cline{2-3}\sphinxtablestrut{80}&
Headers
&
\sphinxcode{sunmatrix/sunmatrix\_band.h}
\\
\hline\sphinxmultirow{3}{86}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
DENSE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{87}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunmatrixdense.LIB}
\\
\cline{3-3}\sphinxtablestrut{86}&\sphinxtablestrut{87}&
\sphinxcode{libsundials\_fsunmatrixdense.a}
\\
\cline{2-3}\sphinxtablestrut{86}&
Headers
&
\sphinxcode{sunmatrix/sunmatrix\_dense.h}
\\
\hline\sphinxmultirow{3}{92}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SPARSE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{93}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunmatrixsparse.LIB}
\\
\cline{3-3}\sphinxtablestrut{92}&\sphinxtablestrut{93}&
\sphinxcode{libsundials\_fsunmatrixsparse.a}
\\
\cline{2-3}\sphinxtablestrut{92}&
Headers
&
\sphinxcode{sunmatrix/sunmatrix\_sparse.h}
\\
\hline\sphinxmultirow{2}{98}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SLUNRLOC
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_sunmatrixslunrloc.LIB}
\\
\cline{2-3}\sphinxtablestrut{98}&
Headers
&
\sphinxcode{sunmatrix/sunmatrix\_slunrloc.h}
\\
\hline\sphinxmultirow{2}{103}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
CUSPARSE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_sunmatrixcusparse.LIB}
\\
\cline{2-3}\sphinxtablestrut{103}&
Headers
&
\sphinxcode{sunmatrix/sunmatrix\_cusparse.h}
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
SUNLINSOL Modules
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxmultirow{3}{109}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
BAND
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{110}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolband.LIB}
\\
\cline{3-3}\sphinxtablestrut{109}&\sphinxtablestrut{110}&
\sphinxcode{libsundials\_fsunlinsolband.a}
\\
\cline{2-3}\sphinxtablestrut{109}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_band.h}
\\
\hline\sphinxmultirow{3}{115}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
DENSE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{116}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsoldense.LIB}
\\
\cline{3-3}\sphinxtablestrut{115}&\sphinxtablestrut{116}&
\sphinxcode{libsundials\_fsunlinsoldense.a}
\\
\cline{2-3}\sphinxtablestrut{115}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_dense.h}
\\
\hline\sphinxmultirow{3}{121}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
KLU
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{122}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolklu.LIB}
\\
\cline{3-3}\sphinxtablestrut{121}&\sphinxtablestrut{122}&
\sphinxcode{libsundials\_fsunlinsolklu.a}
\\
\cline{2-3}\sphinxtablestrut{121}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_klu.h}
\\
\hline\sphinxmultirow{3}{127}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
LAPACKBAND
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{128}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsollapackband.LIB}
\\
\cline{3-3}\sphinxtablestrut{127}&\sphinxtablestrut{128}&
\sphinxcode{libsundials\_fsunlinsollapackband.a}
\\
\cline{2-3}\sphinxtablestrut{127}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_lapackband.h}
\\
\hline\sphinxmultirow{3}{133}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
LAPACKDENSE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{134}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsollapackdense.LIB}
\\
\cline{3-3}\sphinxtablestrut{133}&\sphinxtablestrut{134}&
\sphinxcode{libsundials\_fsunlinsollapackdense.a}
\\
\cline{2-3}\sphinxtablestrut{133}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_lapackdense.h}
\\
\hline\sphinxmultirow{3}{139}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
PCG
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{140}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolpcg.LIB}
\\
\cline{3-3}\sphinxtablestrut{139}&\sphinxtablestrut{140}&
\sphinxcode{libsundials\_fsunlinsolpcg.a}
\\
\cline{2-3}\sphinxtablestrut{139}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_pcg.h}
\\
\hline\sphinxmultirow{3}{145}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SPBCGS
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{146}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolspbcgs.LIB}
\\
\cline{3-3}\sphinxtablestrut{145}&\sphinxtablestrut{146}&
\sphinxcode{libsundials\_fsunlinsolspbcgs.a}
\\
\cline{2-3}\sphinxtablestrut{145}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_spbcgs.h}
\\
\hline\sphinxmultirow{3}{151}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SPFGMR
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{152}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolspfgmr.LIB}
\\
\cline{3-3}\sphinxtablestrut{151}&\sphinxtablestrut{152}&
\sphinxcode{libsundials\_fsunlinsolspfgmr.a}
\\
\cline{2-3}\sphinxtablestrut{151}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_spfgmr.h}
\\
\hline\sphinxmultirow{3}{157}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SPGMR
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{158}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolspgmr.LIB}
\\
\cline{3-3}\sphinxtablestrut{157}&\sphinxtablestrut{158}&
\sphinxcode{libsundials\_fsunlinsolspgmr.a}
\\
\cline{2-3}\sphinxtablestrut{157}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_spgmr.h}
\\
\hline\sphinxmultirow{3}{163}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SPTFQMR
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{164}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolsptfqmr.LIB}
\\
\cline{3-3}\sphinxtablestrut{163}&\sphinxtablestrut{164}&
\sphinxcode{libsundials\_fsunlinsolsptfqmr.a}
\\
\cline{2-3}\sphinxtablestrut{163}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_sptfqmr.h}
\\
\hline\sphinxmultirow{3}{169}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SUPERLUMT
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{170}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunlinsolsuperlumt.LIB}
\\
\cline{3-3}\sphinxtablestrut{169}&\sphinxtablestrut{170}&
\sphinxcode{libsundials\_fsunlinsolsuperlumt.a}
\\
\cline{2-3}\sphinxtablestrut{169}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_superlumt.h}
\\
\hline\sphinxmultirow{2}{175}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
SUPERLUDIST
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_sunlinsolsuperludist.LIB}
\\
\cline{2-3}\sphinxtablestrut{175}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_superludist.h}
\\
\hline\sphinxmultirow{2}{180}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
CUSOLVERSP\_BATCHQR
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_sunlinsolcusolversp.LIB}
\\
\cline{2-3}\sphinxtablestrut{180}&
Headers
&
\sphinxcode{sunlinsol/sunlinsol\_cusolversp\_batchqr.h}
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
SUNNONLINSOL Modules
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxmultirow{3}{186}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
NEWTON
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{187}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunnonlinsolnewton.LIB}
\\
\cline{3-3}\sphinxtablestrut{186}&\sphinxtablestrut{187}&
\sphinxcode{libsundials\_fsunnonlinsolnewton.a}
\\
\cline{2-3}\sphinxtablestrut{186}&
Headers
&
\sphinxcode{sunnonlinsol/sunnonlinsol\_newton.h}
\\
\hline\sphinxmultirow{3}{192}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
FIXEDPOINT
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{193}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_sunnonlinsolfixedpoint.LIB}
\\
\cline{3-3}\sphinxtablestrut{192}&\sphinxtablestrut{193}&
\sphinxcode{libsundials\_fsunnonlinsolfixedpoint.a}
\\
\cline{2-3}\sphinxtablestrut{192}&
Headers
&
\sphinxcode{sunnonlinsol/sunnonlinsol\_fixedpoint.h}
\\
\hline\sphinxmultirow{2}{198}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
PETSCSNES
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_sunnonlinsolpetscsnes.LIB}
\\
\cline{2-3}\sphinxtablestrut{198}&
Headers
&
\sphinxcode{sunnonlinsol/sunnonlinsol\_petscsnes.h}
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
SUNDIALS Packages
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxmultirow{10}{204}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
CVODE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{205}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_cvode.LIB}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{205}&
\sphinxcode{libsundials\_fcvode.a}
\\
\cline{2-3}\sphinxtablestrut{204}&\sphinxmultirow{8}{208}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{cvode/cvode.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_bandpre.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_bbdpre.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_diag.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_direct.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_impl.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_ls.h}
\\
\cline{3-3}\sphinxtablestrut{204}&\sphinxtablestrut{208}&
\sphinxcode{cvode/cvode\_spils.h}
\\
\hline\sphinxmultirow{8}{217}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
CVODES
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_cvodes.LIB}
\\
\cline{2-3}\sphinxtablestrut{217}&\sphinxmultirow{7}{220}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{cvodes/cvodes.h}
\\
\cline{3-3}\sphinxtablestrut{217}&\sphinxtablestrut{220}&
\sphinxcode{cvodes/cvodes\_bandpre.h}
\\
\cline{3-3}\sphinxtablestrut{217}&\sphinxtablestrut{220}&
\sphinxcode{cvodes/cvodes\_bbdpre.h}
\\
\cline{3-3}\sphinxtablestrut{217}&\sphinxtablestrut{220}&
\sphinxcode{cvodes/cvodes\_diag.h}
\\
\cline{3-3}\sphinxtablestrut{217}&\sphinxtablestrut{220}&
\sphinxcode{cvodes/cvodes\_direct.h}
\\
\cline{3-3}\sphinxtablestrut{217}&\sphinxtablestrut{220}&
\sphinxcode{cvodes/cvodes\_impl.h}
\\
\cline{3-3}\sphinxtablestrut{217}&\sphinxtablestrut{220}&
\sphinxcode{cvodes/cvodes\_spils.h}
\\
\hline\sphinxmultirow{14}{228}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
ARKODE
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{3}{229}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_arkode.LIB}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{229}&
\sphinxcode{libsundials\_farkode.a}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{229}&
\sphinxcode{libsundials\_xbraid.LIB}
\\
\cline{2-3}\sphinxtablestrut{228}&\sphinxmultirow{11}{233}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{arkode/arkode.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_arkstep.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_bandpre.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_bbdpre.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_butcher.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_butcher\_dirk.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_butcher\_erk.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_erkstep.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_impl.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_ls.h}
\\
\cline{3-3}\sphinxtablestrut{228}&\sphinxtablestrut{233}&
\sphinxcode{arkode/arkode\_xbraid.h}
\\
\hline\sphinxmultirow{8}{245}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
IDA
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{246}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_ida.LIB}
\\
\cline{3-3}\sphinxtablestrut{245}&\sphinxtablestrut{246}&
\sphinxcode{libsundials\_fida.a}
\\
\cline{2-3}\sphinxtablestrut{245}&\sphinxmultirow{6}{249}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{ida/ida.h}
\\
\cline{3-3}\sphinxtablestrut{245}&\sphinxtablestrut{249}&
\sphinxcode{ida/ida\_bbdpre.h}
\\
\cline{3-3}\sphinxtablestrut{245}&\sphinxtablestrut{249}&
\sphinxcode{ida/ida\_direct.h}
\\
\cline{3-3}\sphinxtablestrut{245}&\sphinxtablestrut{249}&
\sphinxcode{ida/ida\_impl.h}
\\
\cline{3-3}\sphinxtablestrut{245}&\sphinxtablestrut{249}&
\sphinxcode{ida/ida\_ls.h}
\\
\cline{3-3}\sphinxtablestrut{245}&\sphinxtablestrut{249}&
\sphinxcode{ida/ida\_spils.h}
\\
\hline\sphinxmultirow{6}{256}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
IDAS
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
Libraries
&
\sphinxcode{libsundials\_idas.LIB}
\\
\cline{2-3}\sphinxtablestrut{256}&\sphinxmultirow{5}{259}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{idas/idas.h}
\\
\cline{3-3}\sphinxtablestrut{256}&\sphinxtablestrut{259}&
\sphinxcode{idas/idas\_bbdpre.h}
\\
\cline{3-3}\sphinxtablestrut{256}&\sphinxtablestrut{259}&
\sphinxcode{idas/idas\_direct.h}
\\
\cline{3-3}\sphinxtablestrut{256}&\sphinxtablestrut{259}&
\sphinxcode{idas/idas\_impl.h}
\\
\cline{3-3}\sphinxtablestrut{256}&\sphinxtablestrut{259}&
\sphinxcode{idas/idas\_spils.h}
\\
\hline\sphinxmultirow{8}{265}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
KINSOL
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&\sphinxmultirow{2}{266}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Libraries
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{libsundials\_kinsol.LIB}
\\
\cline{3-3}\sphinxtablestrut{265}&\sphinxtablestrut{266}&
\sphinxcode{libsundials\_fkinsol.a}
\\
\cline{2-3}\sphinxtablestrut{265}&\sphinxmultirow{6}{269}{%
\begin{varwidth}[t]{\sphinxcolwidth{1}{3}}
Headers
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
}%
&
\sphinxcode{kinsol/kinsol.h}
\\
\cline{3-3}\sphinxtablestrut{265}&\sphinxtablestrut{269}&
\sphinxcode{kinsol/kinsol\_bbdpre.h}
\\
\cline{3-3}\sphinxtablestrut{265}&\sphinxtablestrut{269}&
\sphinxcode{kinsol/kinsol\_direct.h}
\\
\cline{3-3}\sphinxtablestrut{265}&\sphinxtablestrut{269}&
\sphinxcode{kinsol/kinsol\_impl.h}
\\
\cline{3-3}\sphinxtablestrut{265}&\sphinxtablestrut{269}&
\sphinxcode{kinsol/kinsol\_ls.h}
\\
\cline{3-3}\sphinxtablestrut{265}&\sphinxtablestrut{269}&
\sphinxcode{kinsol/kinsol\_spils.h}
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\chapter{Appendix: ARKode Constants}
\label{\detokenize{Constants:appendix-arkode-constants}}\label{\detokenize{Constants:constants}}\label{\detokenize{Constants::doc}}
Below we list all input and output constants used by the main solver,
timestepper, and linear solver modules, together with their numerical
values and a short description of their meaning.


\section{ARKode input constants}
\label{\detokenize{Constants:arkode-input-constants}}

\subsection{Shared ARKode input constants}
\label{\detokenize{Constants:shared-arkode-input-constants}}\begin{description}
\item[{\index{ARK\_NORMAL}ARK\_NORMAL (1):}] \leavevmode
Solver returns at a specified output time.

\item[{\index{ARK\_ONE\_STEP}ARK\_ONE\_STEP  (2):}] \leavevmode
Solver returns after each successful step.

\end{description}


\subsection{Interpolation module input constants}
\label{\detokenize{Constants:interpolation-module-input-constants}}\begin{description}
\item[{\index{ARK\_INTERP\_MAX\_DEGREE}ARK\_INTERP\_MAX\_DEGREE (5):}] \leavevmode
Maximum possible interpolating polynomial degree.

\item[{\index{ARK\_INTERP\_HERMITE}ARK\_INTERP\_HERMITE  (0):}] \leavevmode
Specifies use of the Hermite polynomial interpolation module (for non-stiff problems)

\item[{\index{ARK\_INTERP\_LAGRANGE}ARK\_INTERP\_LAGRANGE  (1):}] \leavevmode
Specifies use of the Lagrange polynomial interpolation module (for stiff problems)

\end{description}


\subsection{Explicit Butcher table specification}
\label{\detokenize{Constants:explicit-butcher-table-specification}}\begin{description}
\item[{\index{Heun-Euler-2-1-2 ERK method}HEUN\_EULER\_2\_1\_2  (0):}] \leavevmode
Use the Heun-Euler-2-1-2 ERK method

\item[{\index{Bogacki-Shampine-4-2-3 ERK method}BOGACKI\_SHAMPINE\_4\_2\_3  (1):}] \leavevmode
Use the Bogacki-Shampine-4-2-3 ERK method

\item[{\index{ARK-4-2-3 ERK method}ARK324L2SA\_ERK\_4\_2\_3  (2):}] \leavevmode
Use the ARK-4-2-3 ERK method

\item[{\index{Zonneveld-5-3-4 ERK method}ZONNEVELD\_5\_3\_4  (3):}] \leavevmode
Use the Zonneveld-5-3-4 ERK method

\item[{\index{ARK-6-3-4 ERK method}ARK436L2SA\_ERK\_6\_3\_4  (4):}] \leavevmode
Use the ARK-6-3-4 ERK method

\item[{\index{Sayfy-Aburub-6-3-4 ERK method}SAYFY\_ABURUB\_6\_3\_4  (5):}] \leavevmode
Use the Sayfy-Aburub-6-3-4 ERK method

\item[{\index{Cash-Karp-6-4-5 ERK method}CASH\_KARP\_6\_4\_5  (6):}] \leavevmode
Use the Cash-Karp-6-4-5 ERK method

\item[{\index{Fehlberg-6-4-5 ERK method}FEHLBERG\_6\_4\_5  (7):}] \leavevmode
Use the Fehlberg-6-4-5 ERK method

\item[{\index{Dormand-Prince-7-4-5 ERK method}DORMAND\_PRINCE\_7\_4\_5  (8):}] \leavevmode
Use the Dormand-Prince-7-4-5 ERK method

\item[{\index{ARK-8-4-5 ERK method}ARK548L2SA\_ERK\_8\_4\_5  (9):}] \leavevmode
Use the ARK-8-4-5 ERK method

\item[{\index{Verner-8-5-6 ERK method}VERNER\_8\_5\_6  (10):}] \leavevmode
Use the Verner-8-5-6 ERK method

\item[{\index{Fehlberg-13-7-8 ERK method}FEHLBERG\_13\_7\_8  (11):}] \leavevmode
Use the Fehlberg-13-7-8 ERK method

\item[{\index{Knoth-Wolke-3-3 ERK method}KNOTH\_WOLKE\_3\_3  (12):}] \leavevmode
Use the Knoth-Wolke-3-3 ERK method

\item[{\index{DEFAULT\_ERK\_2}DEFAULT\_ERK\_2  (HEUN\_EULER\_2\_1\_2):}] \leavevmode
Use the default second-order ERK method

\item[{\index{DEFAULT\_ERK\_3}DEFAULT\_ERK\_3  (BOGACKI\_SHAMPINE\_4\_2\_3):}] \leavevmode
Use the default third-order ERK method

\item[{\index{DEFAULT\_ERK\_4}DEFAULT\_ERK\_4  (ZONNEVELD\_5\_3\_4):}] \leavevmode
Use the default fourth-order ERK method

\item[{\index{DEFAULT\_ERK\_5}DEFAULT\_ERK\_5  (CASH\_KARP\_6\_4\_5):}] \leavevmode
Use the default fifth-order ERK method

\item[{\index{DEFAULT\_ERK\_6}DEFAULT\_ERK\_6  (VERNER\_8\_5\_6):}] \leavevmode
Use the default sixth-order ERK method

\item[{\index{DEFAULT\_ERK\_8}DEFAULT\_ERK\_8  (FEHLBERG\_13\_7\_8):}] \leavevmode
Use the default eighth-order ERK method

\end{description}


\subsection{Implicit Butcher table specification}
\label{\detokenize{Constants:implicit-butcher-table-specification}}\begin{description}
\item[{\index{SDIRK-2-1-2 method}SDIRK\_2\_1\_2  (100):}] \leavevmode
Use the SDIRK-2-1-2 SDIRK method

\item[{\index{Billington-3-3-2 SDIRK method}BILLINGTON\_3\_3\_2  (101):}] \leavevmode
Use the Billington-3-3-2 SDIRK method

\item[{\index{TRBDF2-3-3-2 ESDIRK method}TRBDF2\_3\_3\_2  (102):}] \leavevmode
Use the TRBDF2-3-3-2 ESDIRK method

\item[{\index{Kvaerno-4-2-3 ESDIRK method}KVAERNO\_4\_2\_3  (103):}] \leavevmode
Use the Kvaerno-4-2-3 ESDIRK method

\item[{\index{ARK-4-2-3 ESDIRK method}ARK324L2SA\_DIRK\_4\_2\_3  (104):}] \leavevmode
Use the ARK-4-2-3 ESDIRK method

\item[{\index{Cash-5-2-4 SDIRK method}CASH\_5\_2\_4  (105):}] \leavevmode
Use the Cash-5-2-4 SDIRK method

\item[{\index{Cash-5-3-4 SDIRK method}CASH\_5\_3\_4  (106):}] \leavevmode
Use the Cash-5-3-4 SDIRK method

\item[{\index{SDIRK-5-3-4 method}SDIRK\_5\_3\_4  (107):}] \leavevmode
Use the SDIRK-5-3-4 SDIRK method

\item[{\index{Kvaerno-5-3-4 ESDIRK method}KVAERNO\_5\_3\_4  (108):}] \leavevmode
Use the Kvaerno-5-3-4 ESDIRK method

\item[{\index{ARK-6-3-4 ESDIRK method}ARK436L2SA\_DIRK\_6\_3\_4  (109):}] \leavevmode
Use the ARK-6-3-4 ESDIRK method

\item[{\index{Kvaerno-7-4-5 ESDIRK method}KVAERNO\_7\_4\_5  (110):}] \leavevmode
Use the Kvaerno-7-4-5 ESDIRK method

\item[{\index{ARK-8-4-5 ESDIRK method}ARK548L2SA\_DIRK\_8\_4\_5  (111):}] \leavevmode
Use the ARK-8-4-5 ESDIRK method

\item[{\index{ARK-7-3-4 ESDIRK method}ARK437L2SA\_DIRK\_7\_3\_4  (112):}] \leavevmode
Use the ARK-7-3-4 ESDIRK method

\item[{\index{ARK-8-4-5 ESDIRK method}ARK548L2SAb\_DIRK\_8\_4\_5  (113):}] \leavevmode
Use the ARK-8-4-5b ESDIRK method

\item[{\index{DEFAULT\_DIRK\_2}DEFAULT\_DIRK\_2  (SDIRK\_2\_1\_2):}] \leavevmode
Use the default second-order DIRK method

\item[{\index{DEFAULT\_DIRK\_3}DEFAULT\_DIRK\_3  (ARK324L2SA\_DIRK\_4\_2\_3):}] \leavevmode
Use the default third-order DIRK method

\item[{\index{DEFAULT\_DIRK\_4}DEFAULT\_DIRK\_4  (SDIRK\_5\_3\_4):}] \leavevmode
Use the default fourth-order DIRK method

\item[{\index{DEFAULT\_DIRK\_5}DEFAULT\_DIRK\_5  (ARK548L2SA\_DIRK\_8\_4\_5):}] \leavevmode
Use the default fifth-order DIRK method

\end{description}


\subsection{ImEx Butcher table specification}
\label{\detokenize{Constants:imex-butcher-table-specification}}\begin{description}
\item[{\index{ARK-4-2-3 ARK method}ARK324L2SA\_ERK\_4\_2\_3 and ARK324L2SA\_DIRK\_4\_2\_3 (2 and 16):}] \leavevmode
Use the ARK-4-2-3 ARK method

\item[{\index{ARK-6-3-4 ARK method}ARK436L2SA\_ERK\_6\_3\_4 and ARK436L2SA\_DIRK\_6\_3\_4 (4 and 21):}] \leavevmode
Use the ARK-6-3-4 ARK method

\item[{\index{ARK-8-4-5 ARK method}ARK548L2SA\_ERK\_8\_4\_5 and ARK548L2SA\_DIRK\_8\_4\_5 (9 and 23):}] \leavevmode
Use the ARK-8-4-5 ARK method

\item[{\index{DEFAULT\_ARK\_ETABLE\_3}DEFAULT\_ARK\_ETABLE\_3 and \index{DEFAULT\_ARK\_ITABLE\_3}DEFAULT\_ARK\_ITABLE\_3 (ARK324L2SA\_{[}ERK,DIRK{]}\_4\_2\_3):}] \leavevmode
Use the default third-order ARK method

\item[{\index{DEFAULT\_ARK\_ETABLE\_4}DEFAULT\_ARK\_ETABLE\_4 and \index{DEFAULT\_ARK\_ITABLE\_4}DEFAULT\_ARK\_ITABLE\_4 (ARK436L2SA\_{[}ERK,DIRK{]}\_6\_3\_4):}] \leavevmode
Use the default fourth-order ARK method

\item[{\index{DEFAULT\_ARK\_ETABLE\_5}DEFAULT\_ARK\_ETABLE\_5 and \index{DEFAULT\_ARK\_ITABLE\_5}DEFAULT\_ARK\_ITABLE\_5 (ARK548L2SA\_{[}ERK,DIRK{]}\_8\_4\_5):}] \leavevmode
Use the default fifth-order ARK method

\end{description}


\section{ARKode output constants}
\label{\detokenize{Constants:arkode-output-constants}}

\subsection{Shared ARKode output constants}
\label{\detokenize{Constants:shared-arkode-output-constants}}\begin{description}
\item[{\index{ARK\_SUCCESS}ARK\_SUCCESS  (0):}] \leavevmode
Successful function return.

\item[{\index{ARK\_TSTOP\_RETURN}ARK\_TSTOP\_RETURN  (1):}] \leavevmode
ARKode succeeded by reaching the specified
stopping point.

\item[{\index{ARK\_ROOT\_RETURN}ARK\_ROOT\_RETURN  (2):}] \leavevmode
ARKode succeeded and found one more more roots.

\item[{\index{ARK\_WARNING}ARK\_WARNING  (99):}] \leavevmode
ARKode succeeded but an unusual situation occurred.

\item[{\index{ARK\_TOO\_MUCH\_WORK}ARK\_TOO\_MUCH\_WORK  (-1):}] \leavevmode
The solver took \sphinxcode{mxstep} internal steps
but could not reach \sphinxcode{tout}.

\item[{\index{ARK\_TOO\_MUCH\_ACC}ARK\_TOO\_MUCH\_ACC  (-2):}] \leavevmode
The solver could not satisfy the accuracy
demanded by the user for some internal step.

\item[{\index{ARK\_ERR\_FAILURE}ARK\_ERR\_FAILURE  (-3):}] \leavevmode
Error test failures occurred too many times
during one internal time step, or the minimum step size was
reached.

\item[{\index{ARK\_CONV\_FAILURE}ARK\_CONV\_FAILURE  (-4):}] \leavevmode
Convergence test failures occurred too many
times during one internal time step, or the minimum step size was
reached.

\item[{\index{ARK\_LINIT\_FAIL}ARK\_LINIT\_FAIL  (-5):}] \leavevmode
The linear solver’s initialization function failed.

\item[{\index{ARK\_LSETUP\_FAIL}ARK\_LSETUP\_FAIL  (-6):}] \leavevmode
The linear solver’s setup function failed in
an unrecoverable manner.

\item[{\index{ARK\_LSOLVE\_FAIL}ARK\_LSOLVE\_FAIL  (-7):}] \leavevmode
The linear solver’s solve function failed in
an unrecoverable manner.

\item[{\index{ARK\_RHSFUNC\_FAIL}ARK\_RHSFUNC\_FAIL  (-8):}] \leavevmode
The right-hand side function failed in an
unrecoverable manner.

\item[{\index{ARK\_FIRST\_RHSFUNC\_ERR}ARK\_FIRST\_RHSFUNC\_ERR  (-9):}] \leavevmode
The right-hand side function failed
at the first call.

\item[{\index{ARK\_REPTD\_RHSFUNC\_ERR}ARK\_REPTD\_RHSFUNC\_ERR  (-10):}] \leavevmode
The right-hand side function had
repeated recoverable errors.

\item[{\index{ARK\_UNREC\_RHSFUNC\_ERR}ARK\_UNREC\_RHSFUNC\_ERR  (-11):}] \leavevmode
The right-hand side function had a
recoverable error, but no recovery is possible.

\item[{\index{ARK\_RTFUNC\_FAIL}ARK\_RTFUNC\_FAIL  (-12):}] \leavevmode
The rootfinding function failed in an
unrecoverable manner.

\item[{\index{ARK\_LFREE\_FAIL}ARK\_LFREE\_FAIL  (-13):}] \leavevmode
The linear solver’s memory deallocation function failed.

\item[{\index{ARK\_MASSINIT\_FAIL}ARK\_MASSINIT\_FAIL  (-14):}] \leavevmode
The mass matrix linear solver’s initialization function failed.

\item[{\index{ARK\_MASSSETUP\_FAIL}ARK\_MASSSETUP\_FAIL  (-15):}] \leavevmode
The mass matrix linear solver’s setup function failed in
an unrecoverable manner.

\item[{\index{ARK\_MASSSOLVE\_FAIL}ARK\_MASSSOLVE\_FAIL  (-16):}] \leavevmode
The mass matrix linear solver’s solve function failed in
an unrecoverable manner.

\item[{\index{ARK\_MASSFREE\_FAIL}ARK\_MASSFREE\_FAIL  (-17):}] \leavevmode
The mass matrix linear solver’s memory deallocation function failed.

\item[{\index{ARK\_MASSMULT\_FAIL}ARK\_MASSMULT\_FAIL  (-18):}] \leavevmode
The mass matrix-vector product function failed.

\item[{\index{ARK\_CONSTR\_FAIL}ARK\_CONSTR\_FAIL  (-19):}] \leavevmode
The inequality constraint test failed repeatedly or failed with the minimum
step size.

\item[{\index{ARK\_MEM\_FAIL}ARK\_MEM\_FAIL  (-20):}] \leavevmode
A memory allocation failed.

\item[{\index{ARK\_MEM\_NULL}ARK\_MEM\_NULL  (-21):}] \leavevmode
The \sphinxcode{arkode\_mem} argument was \sphinxcode{NULL}.

\item[{\index{ARK\_ILL\_INPUT}ARK\_ILL\_INPUT  (-22):}] \leavevmode
One of the function inputs is illegal.

\item[{\index{ARK\_NO\_MALLOC}ARK\_NO\_MALLOC  (-23):}] \leavevmode
The ARKode memory block was not allocated by
a call to \sphinxcode{ARKodeMalloc()}.

\item[{\index{ARK\_BAD\_K}ARK\_BAD\_K  (-24):}] \leavevmode
The derivative order \(k\) is larger than allowed.

\item[{\index{ARK\_BAD\_T}ARK\_BAD\_T  (-25):}] \leavevmode
The time \(t\) is outside the last step taken.

\item[{\index{ARK\_BAD\_DKY}ARK\_BAD\_DKY  (-26):}] \leavevmode
The output derivative vector is \sphinxcode{NULL}.

\item[{\index{ARK\_TOO\_CLOSE}ARK\_TOO\_CLOSE  (-27):}] \leavevmode
The output and initial times are too close to
each other.

\item[{\index{ARK\_VECTOROP\_ERR}ARK\_VECTOROP\_ERR  (-28):}] \leavevmode
An error occurred when calling an NVECTOR routine.

\item[{\index{ARK\_NLS\_INIT\_FAIL}ARK\_NLS\_INIT\_FAIL  (-29):}] \leavevmode
An error occurred when initializing a SUNNonlinearSolver module.

\item[{\index{ARK\_NLS\_SETUP\_FAIL}ARK\_NLS\_SETUP\_FAIL  (-30):}] \leavevmode
A non-recoverable error occurred when setting up a
SUNNonlinearSolver module.

\item[{\index{ARK\_NLS\_SETUP\_RECVR}ARK\_NLS\_SETUP\_RECVR  (-31):}] \leavevmode
A recoverable error occurred when setting up a SUNNonlinearSolver module.

\item[{\index{ARK\_NLS\_OP\_ERR}ARK\_NLS\_OP\_ERR  (-32):}] \leavevmode
An error occurred when calling a set/get routine in a SUNNonlinearSolver
module.

\item[{\index{ARK\_INNERSTEP\_ATTACH\_ERR}ARK\_INNERSTEP\_ATTACH\_ERR  (-33):}] \leavevmode
An error occurred when attaching the inner stepper module.

\item[{\index{ARK\_INNERSTEP\_FAIL}ARK\_INNERSTEP\_FAIL  (-34):}] \leavevmode
An error occurred in the inner stepper module.

\item[{\index{ARK\_PREINNERFN\_FAIL}ARK\_PREINNERFN\_FAIL  (-35):}] \leavevmode
An error occurred in the MRIStep pre inner integrator function.

\item[{\index{ARK\_POSTINNERFN\_FAIL}ARK\_POSTINNERFN\_FAIL  (-36):}] \leavevmode
An error occurred in the MRIStep post inner integrator function.

\item[{\index{ARK\_INTERP\_FAIL}ARK\_INTERP\_FAIL  (-40):}] \leavevmode
An error occurred in the ARKode polynomial interpolation module.

\item[{\index{ARK\_INVALID\_TABLE}ARK\_INVALID\_TABLE  (-41):}] \leavevmode
An invalid Butcher or MRI table was encountered.

\item[{\index{ARK\_UNRECOGNIZED\_ERROR}ARK\_UNRECOGNIZED\_ERROR (-99):}] \leavevmode
An unknown error was encountered.

\end{description}


\subsection{ARKLS linear solver modules}
\label{\detokenize{Constants:arkls-linear-solver-modules}}\begin{description}
\item[{\index{ARKLS\_SUCCESS}ARKLS\_SUCCESS  (0):}] \leavevmode
Successful function return.

\item[{\index{ARKLS\_MEM\_NULL}ARKLS\_MEM\_NULL  (-1):}] \leavevmode
The \sphinxcode{arkode\_mem} argument was \sphinxcode{NULL}.

\item[{\index{ARKLS\_LMEM\_NULL}ARKLS\_LMEM\_NULL  (-2):}] \leavevmode
The ARKLS linear solver interface has not been initialized.

\item[{\index{ARKLS\_ILL\_INPUT}ARKLS\_ILL\_INPUT  (-3):}] \leavevmode
The ARKLS solver interface is not compatible with
the current NVECTOR module, or an input value was illegal.

\item[{\index{ARKLS\_MEM\_FAIL}ARKLS\_MEM\_FAIL  (-4):}] \leavevmode
A memory allocation request failed.

\item[{\index{ARKLS\_PMEM\_NULL}ARKLS\_PMEM\_NULL  (-5):}] \leavevmode
The preconditioner module has not been initialized.

\item[{\index{ARKLS\_MASSMEM\_NULL}ARKLS\_MASSMEM\_NULL  (-6):}] \leavevmode
The ARKLS mass-matrix linear solver interface has not been initialized.

\item[{\index{ARKLS\_JACFUNC\_UNRECVR}ARKLS\_JACFUNC\_UNRECVR  (-7):}] \leavevmode
The Jacobian function failed in an unrecoverable manner.

\item[{\index{ARKLS\_JACFUNC\_RECVR}ARKLS\_JACFUNC\_RECVR  (-8):}] \leavevmode
The Jacobian function had a recoverable error.

\item[{\index{ARKLS\_MASSFUNC\_UNRECVR}ARKLS\_MASSFUNC\_UNRECVR  (-9):}] \leavevmode
The mass matrix function failed in an unrecoverable manner.

\item[{\index{ARKLS\_MASSFUNC\_RECVR}ARKLS\_MASSFUNC\_RECVR  (-10):}] \leavevmode
The mass matrix function had a recoverable error.

\item[{\index{ARKLS\_SUNMAT\_FAIL}ARKLS\_SUNMAT\_FAIL  (-11):}] \leavevmode
An error occurred with the current SUNMATRIX module.

\item[{\index{ARKLS\_SUNLS\_FAIL}ARKLS\_SUNLS\_FAIL  (-12):}] \leavevmode
An error occurred with the current SUNLINSOL module.

\end{description}


\chapter{Appendix: Butcher tables}
\label{\detokenize{Butcher:butcher}}\label{\detokenize{Butcher::doc}}\label{\detokenize{Butcher:appendix-butcher-tables}}
Here we catalog the full set of Butcher tables included in ARKode.
We group these into three categories: \sphinxstyleemphasis{explicit}, \sphinxstyleemphasis{implicit} and
\sphinxstyleemphasis{additive}.  However, since the methods that comprise an additive
Runge Kutta method are themselves explicit and implicit, their
component Butcher tables are listed within their separate
sections, but are referenced together in the additive section.

In each of the following tables, we use the following notation (shown
for a 3-stage method):
\begin{equation*}
\begin{split}\begin{array}{r|ccc}
  c_1 & a_{1,1} & a_{1,2} & a_{1,3} \\
  c_2 & a_{2,1} & a_{2,2} & a_{2,3} \\
  c_3 & a_{3,1} & a_{3,2} & a_{3,3} \\
  \hline
  q & b_1 & b_2 & b_3 \\
  p & \tilde{b}_1 & \tilde{b}_2 & \tilde{b}_3
\end{array}\end{split}
\end{equation*}
where here the method and embedding share stage \(A\) and
\(c\) values, but use their stages \(z_i\) differently through
the coefficients \(b\) and \(\tilde{b}\) to generate methods
of orders \(q\) (the main method) and \(p\) (the embedding,
typically \(q = p+1\), though sometimes this is reversed).

Method authors often use different naming conventions to categorize
their methods.  For each of the methods below with an embedding, we follow the
uniform naming convention:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
NAME\PYGZhy{}S\PYGZhy{}P\PYGZhy{}Q
\end{sphinxVerbatim}

where here
\begin{itemize}
\item {} 
\sphinxcode{NAME} is the author or the name provided by the author (if applicable),

\item {} 
\sphinxcode{S} is the number of stages in the method,

\item {} 
\sphinxcode{P} is the global order of accuracy for the embedding,

\item {} 
\sphinxcode{Q} is the global order of accuracy for the method.

\end{itemize}

For methods without an embedding (e.g., fixed-step methods) \sphinxcode{P} is omitted so
that methods follow the naming convention \sphinxcode{NAME-S-Q}.

In the code, unique integer IDs are defined inside \sphinxcode{arkode\_butcher\_erk.h} and
\sphinxcode{arkode\_butcher\_dirk.h} for each method, which may be used by calling routines
to specify the desired method.  These names are specified in \sphinxcode{fixed width
font} at the start of each method’s section below.

Additionally, for each method we provide a plot of the linear
stability region in the complex plane.  These have been computed via
the following approach.  For any Runge Kutta method as defined above,
we may define the stability function
\begin{equation*}
\begin{split}R(\eta) = 1 + \eta b [I - \eta A]^{-1} e,\end{split}
\end{equation*}
where \(e\in\mathbb{R}^s\) is a column vector of all ones, \(\eta =
h\lambda\) and \(h\) is the time step size.  If the stability
function satisfies \(|R(\eta)| \le 1\) for all eigenvalues,
\(\lambda\), of \(\frac{\partial }{\partial y}f(t,y)\) for a
given IVP, then the method will be linearly stable for that problem
and step size.  The stability region
\begin{equation*}
\begin{split}S = \{ \eta\in\mathbb{C}\; :\; \left| R(\eta) \right| \le 1\}\end{split}
\end{equation*}
is typically given by an enclosed region of the complex plane, so it
is standard to search for the border of that region in order to
understand the method.  Since all complex numbers with unit magnitude
may be written as \(e^{i\theta}\) for some value of \(\theta\),
we perform the following algorithm to trace out this boundary.
\begin{enumerate}
\item {} 
Define an array of values \sphinxcode{Theta}.  Since we wish for a
smooth curve, and since we wish to trace out the entire boundary,
we choose 10,000 linearly-spaced points from 0 to \(16\pi\).
Since some angles will correspond to multiple locations on the
stability boundary, by going beyond \(2\pi\) we ensure that all
boundary locations are plotted, and by using such a fine
discretization the Newton method (next step) is more likely to
converge to the root closest to the previous boundary point,
ensuring a smooth plot.

\item {} 
For each value \(\theta \in\) \sphinxcode{Theta}, we solve the nonlinear
equation
\begin{equation*}
\begin{split}0 = f(\eta) = R(\eta) - e^{i\theta}\end{split}
\end{equation*}
using a finite-difference Newton iteration, using tolerance
\(10^{-7}\), and differencing parameter
\(\sqrt{\varepsilon}\) (\(\approx 10^{-8}\)).

In this iteration, we use as initial guess the solution from the
previous value of \(\theta\), starting with an initial-initial
guess of \(\eta=0\) for \(\theta=0\).

\item {} 
We then plot the resulting \(\eta\) values that trace the
stability region boundary.

\end{enumerate}

We note that for any stable IVP method, the value \(\eta_0 =
-\varepsilon + 0i\) is always within the stability region.  So in each
of the following pictures, the interior of the stability region is the
connected region that includes \(\eta_0\).  Resultingly, methods
whose linear stability boundary is located entirely in the right
half-plane indicate an \sphinxtitleref{A-stable} method.


\section{Explicit Butcher tables}
\label{\detokenize{Butcher:butcher-explicit}}\label{\detokenize{Butcher:explicit-butcher-tables}}
In the category of explicit Runge-Kutta methods, ARKode includes
methods that have orders 2 through 6, with embeddings that are of
orders 1 through 5.


\subsection{Heun-Euler-2-1-2}
\label{\detokenize{Butcher:heun-euler-2-1-2}}\label{\detokenize{Butcher:butcher-heun-euler}}
\index{Heun-Euler-2-1-2 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{HEUN\_EULER\_2\_1\_2} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the default 2nd order
explicit method.
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cc}
  0 & 0 & 0 \\
  1 & 1 & 0 \\
  \hline
  2 & \frac{1}{2} & \frac{1}{2} \\
  1 & 1 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_0}.png}
\caption{Linear stability region for the Heun-Euler method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id28}}\end{figure}


\subsection{Bogacki-Shampine-4-2-3}
\label{\detokenize{Butcher:butcher-bogacki-shampine}}\label{\detokenize{Butcher:bogacki-shampine-4-2-3}}
\index{Bogacki-Shampine-4-2-3 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{BOGACKI\_SHAMPINE\_4\_2\_3} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the default 3rd order
explicit method (from \phantomsection\label{\detokenize{Butcher:id1}}{\hyperref[\detokenize{References:bs1989}]{\sphinxcrossref{{[}BS1989{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccc}
  0 &   0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{2} & 0 & 0 & 0 \\
  \frac{3}{4} & 0 & \frac{3}{4} & 0 & 0 \\
  1   & \frac{2}{9} & \frac{1}{3} & \frac{4}{9} & 0 \\
  \hline
  3 & \frac{2}{9} & \frac{1}{3} & \frac{4}{9} \\
  2 & \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_1}.png}
\caption{Linear stability region for the Bogacki-Shampine method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id29}}\end{figure}


\subsection{ARK-4-2-3 (explicit)}
\label{\detokenize{Butcher:ark-4-2-3-explicit}}\label{\detokenize{Butcher:butcher-ark-4-2-3-e}}
\index{ARK-4-2-3 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK324L2SA\_ERK\_4\_2\_3} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}. This is the explicit portion of
the default 3rd order additive method (from \phantomsection\label{\detokenize{Butcher:id2}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccc}
  0 & 0 & 0 & 0 & 0 \\
  \frac{1767732205903}{2027836641118} & \frac{1767732205903}{2027836641118} & 0 & 0 & 0 \\
  \frac{3}{5} & \frac{5535828885825}{10492691773637} & \frac{788022342437}{10882634858940} & 0 & 0 \\
  1 & \frac{6485989280629}{16251701735622} & -\frac{4246266847089}{9704473918619} & \frac{10755448449292}{10357097424841} & 0 \\
  \hline
  3 & \frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236} \\
  2 & \frac{2756255671327}{12835298489170} & -\frac{10771552573575}{22201958757719} & \frac{9247589265047}{10645013368117} & \frac{2193209047091}{5459859503100}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_2}.png}
\caption{Linear stability region for the explicit ARK-4-2-3 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id30}}\end{figure}


\subsection{Knoth-Wolke-3-3}
\label{\detokenize{Butcher:knoth-wolke-3-3}}\label{\detokenize{Butcher:butcher-knoth-wolke}}
\index{Knoth-Wolke-3-3 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{KNOTH\_WOLKE\_3\_3} to
\sphinxcode{MRIStepSetMRITableNum()} and {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.
This is the default 3th order slow and fast MRIStep method (from
\phantomsection\label{\detokenize{Butcher:id3}}{\hyperref[\detokenize{References:kw1998}]{\sphinxcrossref{{[}KW1998{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccc}
            0 & 0             & 0             & 0 \\
  \frac{1}{3} & \frac{1}{3}   & 0             & 0 \\
  \frac{3}{4} & -\frac{3}{16} & \frac{15}{16} & 0 \\
  \hline
            3 & \frac{1}{6} & \frac{3}{10} & \frac{8}{15}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_24}.png}
\caption{Linear stability region for the Knoth-Wolke method}\label{\detokenize{Butcher:id31}}\end{figure}


\subsection{Zonneveld-5-3-4}
\label{\detokenize{Butcher:butcher-zonneveld}}\label{\detokenize{Butcher:zonneveld-5-3-4}}
\index{Zonneveld-5-3-4 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{ZONNEVELD\_5\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is
the default 4th order explicit method (from \phantomsection\label{\detokenize{Butcher:id4}}{\hyperref[\detokenize{References:z1963}]{\sphinxcrossref{{[}Z1963{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccc}
    0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{2} & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & 0 & \frac{1}{2} & 0 & 0 & 0 \\
    1 & 0 & 0 & 1 & 0 & 0 \\
  \frac{3}{4} & \frac{5}{32} & \frac{7}{32} & \frac{13}{32} & -\frac{1}{32} & 0 \\
  \hline
  4 & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6} & 0 \\
  3 & -\frac{1}{2} & \frac{7}{3} & \frac{7}{3} & \frac{13}{6} & -\frac{16}{3}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_3}.png}
\caption{Linear stability region for the Zonneveld method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id32}}\end{figure}


\subsection{ARK-6-3-4 (explicit)}
\label{\detokenize{Butcher:ark-6-3-4-explicit}}\label{\detokenize{Butcher:butcher-ark-6-3-4-e}}
\index{ARK-6-3-4 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK436L2SA\_ERK\_6\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the explicit portion
of the default 4th order additive method (from \phantomsection\label{\detokenize{Butcher:id5}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac12 & \frac12 & 0 & 0 & 0 & 0 & 0 \\
  \frac{83}{250} & \frac{13861}{62500} & \frac{6889}{62500} & 0 & 0 & 0 & 0 \\
  \frac{31}{50} & -\frac{116923316275}{2393684061468} & -\frac{2731218467317}{15368042101831} & \frac{9408046702089}{11113171139209} & 0 & 0 & 0 \\
  \frac{17}{20} & -\frac{451086348788}{2902428689909} & -\frac{2682348792572}{7519795681897} & \frac{12662868775082}{11960479115383} & \frac{3355817975965}{11060851509271} & 0 & 0 \\
  1 & \frac{647845179188}{3216320057751} & \frac{73281519250}{8382639484533} & \frac{552539513391}{3454668386233} & \frac{3354512671639}{8306763924573} & \frac{4040}{17871} & 0 \\
  \hline
  4 & \frac{82889}{524892} & 0 & \frac{15625}{83664} & \frac{69875}{102672} & -\frac{2260}{8211} & \frac14 \\
  3 & \frac{4586570599}{29645900160} & 0 & \frac{178811875}{945068544} & \frac{814220225}{1159782912} & -\frac{3700637}{11593932} & \frac{61727}{225920}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_4}.png}
\caption{Linear stability region for the explicit ARK-6-3-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id33}}\end{figure}


\subsection{ARK-7-3-4 (explicit)}
\label{\detokenize{Butcher:ark-7-3-4-explicit}}\label{\detokenize{Butcher:butcher-ark-7-3-4-e}}
\index{ARK-7-3-4 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK437L2SA\_ERK\_7\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the explicit portion
of the 4th order additive method (from \phantomsection\label{\detokenize{Butcher:id6}}{\hyperref[\detokenize{References:kc2019}]{\sphinxcrossref{{[}KC2019{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{247}{1000} & \frac{247}{1000} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{4276536705230}{10142255878289} & \frac{247}{4000} & \frac{2694949928731}{7487940209513} & 0 & 0 & 0 & 0 & 0 \\
  \frac{67}{200} & \frac{464650059369}{8764239774964} & \frac{878889893998}{2444806327765} & -\frac{952945855348}{12294611323341} & 0 & 0 & 0 & 0 \\
  \frac{3}{40} & \frac{476636172619}{8159180917465} & -\frac{1271469283451}{7793814740893} & -\frac{859560642026}{4356155882851} & \frac{1723805262919}{4571918432560} & 0 & 0 & 0 \\
  \frac{7}{10} & \frac{6338158500785}{11769362343261} & -\frac{4970555480458}{10924838743837} & \frac{3326578051521}{2647936831840} & -\frac{880713585975}{1841400956686} & -\frac{1428733748635}{8843423958496} & 0 & 0 \\
  1 & \frac{760814592956}{3276306540349} & \frac{760814592956}{3276306540349} & -\frac{47223648122716}{6934462133451} & \frac{71187472546993}{9669769126921} & -\frac{13330509492149}{9695768672337} & \frac{11565764226357}{8513123442827} & 0 \\
  \hline
  4 & 0 & 0 & \frac{9164257142617}{17756377923965} & -\frac{10812980402763}{74029279521829} & \frac{1335994250573}{5691609445217} & \frac{2273837961795}{8368240463276} & \frac{247}{2000} \\
  3 & 0 & 0 & \frac{4469248916618}{8635866897933} & -\frac{621260224600}{4094290005349} & \frac{696572312987}{2942599194819} & \frac{1532940081127}{5565293938103} & \frac{2441}{20000}
\end{array}\end{split}
\end{equation*}

\subsection{Sayfy-Aburub-6-3-4}
\label{\detokenize{Butcher:butcher-sayfy-aburub}}\label{\detokenize{Butcher:sayfy-aburub-6-3-4}}
\index{Sayfy-Aburub-6-3-4 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{SAYFY\_ABURUB\_6\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}} (from \phantomsection\label{\detokenize{Butcher:id7}}{\hyperref[\detokenize{References:sa2002}]{\sphinxcrossref{{[}SA2002{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{2} & 0 & 0 & 0 & 0 & 0 \\
  1 & -1 & 2 & 0 & 0 & 0 & 0 \\
  1 & \frac{1}{6} & \frac{2}{3} & \frac{1}{6} & 0 & 0 & 0 \\
  \frac{1}{2} & 0.137 & 0.226 & 0.137 & 0 & 0 & 0 \\
  1 & 0.452 & -0.904 & -0.548 & 0 & 2 & 0 \\
  \hline
  4 & \frac{1}{6} & \frac{1}{3} & \frac{1}{12} & 0 & \frac{1}{3} & \frac{1}{12} \\
  3 & \frac{1}{6} & \frac{2}{3} & \frac{1}{6} & 0 & 0 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_5}.png}
\caption{Linear stability region for the Sayfy-Aburub-6-3-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id34}}\end{figure}


\subsection{Cash-Karp-6-4-5}
\label{\detokenize{Butcher:cash-karp-6-4-5}}\label{\detokenize{Butcher:butcher-cash-karp}}
\index{Cash-Karp-6-4-5 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{CASH\_KARP\_6\_4\_5} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the default 5th order
explicit method (from \phantomsection\label{\detokenize{Butcher:id8}}{\hyperref[\detokenize{References:ck1990}]{\sphinxcrossref{{[}CK1990{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{5} & \frac{1}{5} & 0 & 0 & 0 & 0 & 0 \\
  \frac{3}{10} & \frac{3}{40} & \frac{9}{40} & 0 & 0 & 0 & 0 \\
  \frac{3}{5} & \frac{3}{10} & -\frac{9}{10} & \frac{6}{5} & 0 & 0 & 0 \\
  1 & -\frac{11}{54} & \frac{5}{2} & -\frac{70}{27} & \frac{35}{27} & 0 & 0 \\
  \frac{7}{8} & \frac{1631}{55296} & \frac{175}{512} & \frac{575}{13824} & \frac{44275}{110592} & \frac{253}{4096} & 0 \\
  \hline
  5 & \frac{37}{378} & 0 & \frac{250}{621} & \frac{125}{594} & 0 & \frac{512}{1771} \\
  4 & \frac{2825}{27648} & 0 & \frac{18575}{48384} & \frac{13525}{55296} & \frac{277}{14336} & \frac{1}{4}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_6}.png}
\caption{Linear stability region for the Cash-Karp method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id35}}\end{figure}


\subsection{Fehlberg-6-4-5}
\label{\detokenize{Butcher:butcher-fehlberg}}\label{\detokenize{Butcher:fehlberg-6-4-5}}
\index{Fehlberg-6-4-5 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{FEHLBERG\_6\_4\_5} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}} (from \phantomsection\label{\detokenize{Butcher:id9}}{\hyperref[\detokenize{References:f1969}]{\sphinxcrossref{{[}F1969{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{4} & \frac{1}{4} & 0 & 0 & 0 & 0 & 0 \\
  \frac{3}{8} & \frac{3}{32} & \frac{9}{32} & 0 & 0 & 0 & 0 \\
  \frac{12}{13} & \frac{1932}{2197} & -\frac{7200}{2197} & \frac{7296}{2197} & 0 & 0 & 0 \\
  1 & \frac{439}{216} & -8 & \frac{3680}{513} & -\frac{845}{4104} & 0 & 0 \\
  \frac{1}{2} & -\frac{8}{27} & 2 & -\frac{3544}{2565} & \frac{1859}{4104} & -\frac{11}{40} & 0 \\
  \hline
  5 & \frac{16}{135} & 0 & \frac{6656}{12825} & \frac{28561}{56430} & -\frac{9}{50} & \frac{2}{55} \\
  4 & \frac{25}{216} & 0 & \frac{1408}{2565} & \frac{2197}{4104} & -\frac{1}{5} & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_7}.png}
\caption{Linear stability region for the Fehlberg method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id36}}\end{figure}


\subsection{Dormand-Prince-7-4-5}
\label{\detokenize{Butcher:dormand-prince-7-4-5}}\label{\detokenize{Butcher:butcher-dormand-prince}}
\index{Dormand-Prince-7-4-5 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{DORMAND\_PRINCE\_7\_4\_5} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}} (from \phantomsection\label{\detokenize{Butcher:id10}}{\hyperref[\detokenize{References:dp1980}]{\sphinxcrossref{{[}DP1980{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{5} & \frac{1}{5} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{3}{10} & \frac{3}{40} & \frac{9}{40} & 0 & 0 & 0 & 0 & 0 \\
  \frac{4}{5} & \frac{44}{45} & -\frac{56}{15} & \frac{32}{9} & 0 & 0 & 0 & 0 \\
  \frac{8}{9} & \frac{19372}{6561} & -\frac{25360}{2187} & \frac{64448}{6561} & -\frac{212}{729} & 0 & 0 & 0 \\
  1 & \frac{9017}{3168} & -\frac{355}{33} & \frac{46732}{5247} & \frac{49}{176} & -\frac{5103}{18656} & 0 & 0 \\
  1 & \frac{35}{384} & 0 & \frac{500}{1113} & \frac{125}{192} & -\frac{2187}{6784} & \frac{11}{84} & 0 \\
  \hline
  5 & \frac{35}{384} & 0 & \frac{500}{1113} & \frac{125}{192} & -\frac{2187}{6784} & \frac{11}{84} & 0 \\
  4 & \frac{5179}{57600} & 0 & \frac{7571}{16695} & \frac{393}{640} & -\frac{92097}{339200} & \frac{187}{2100} & \frac{1}{40}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_8}.png}
\caption{Linear stability region for the Dormand-Prince method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id37}}\end{figure}


\subsection{ARK-8-4-5 (explicit)}
\label{\detokenize{Butcher:ark-8-4-5-explicit}}\label{\detokenize{Butcher:butcher-ark-8-4-5-e}}
\index{ARK-8-4-5 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK548L2SA\_ERK\_8\_4\_5} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the explicit portion
of the default 5th order additive method (from \phantomsection\label{\detokenize{Butcher:id11}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{41}{100} & \frac{41}{100} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{2935347310677}{11292855782101} & \frac{367902744464}{2072280473677} & \frac{677623207551}{8224143866563} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1426016391358}{7196633302097} & \frac{1268023523408}{10340822734521} & 0 & \frac{1029933939417}{13636558850479} & 0 & 0 & 0 & 0 & 0 \\
  \frac{92}{100} & \frac{14463281900351}{6315353703477} & 0 & \frac{66114435211212}{5879490589093} & -\frac{54053170152839}{4284798021562} & 0 & 0 & 0 & 0 \\
  \frac{24}{100} & \frac{14090043504691}{34967701212078} & 0 & \frac{15191511035443}{11219624916014} & -\frac{18461159152457}{12425892160975} & -\frac{281667163811}{9011619295870} & 0 & 0 & 0 \\
  \frac{3}{5} & \frac{19230459214898}{13134317526959} & 0 & \frac{21275331358303}{2942455364971} & -\frac{38145345988419}{4862620318723} & -\frac{1}{8} & -\frac{1}{8} & 0 & 0 \\
  1 & -\frac{19977161125411}{11928030595625} & 0 & -\frac{40795976796054}{6384907823539} & \frac{177454434618887}{12078138498510} & \frac{782672205425}{8267701900261} & -\frac{69563011059811}{9646580694205} & \frac{7356628210526}{4942186776405} & 0 \\
  \hline
  5 & -\frac{872700587467}{9133579230613} & 0 & 0 & \frac{22348218063261}{9555858737531} & -\frac{1143369518992}{8141816002931} & -\frac{39379526789629}{19018526304540} & \frac{32727382324388}{42900044865799} & \frac{41}{200} \\
  4 & -\frac{975461918565}{9796059967033} & 0 & 0 & \frac{78070527104295}{32432590147079} & -\frac{548382580838}{3424219808633} & -\frac{33438840321285}{15594753105479} & \frac{3629800801594}{4656183773603} & \frac{4035322873751}{18575991585200}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_9}.png}
\caption{Linear stability region for the explicit ARK-8-4-5 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id38}}\end{figure}


\subsection{ARK-8-4-5b (explicit)}
\label{\detokenize{Butcher:ark-8-4-5b-explicit}}\label{\detokenize{Butcher:butcher-ark-8-4-5b-e}}
\index{ARK-8-4-5b ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK548L2SAb\_ERK\_8\_4\_5} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the explicit portion
of the 5th order additive method from \phantomsection\label{\detokenize{Butcher:id12}}{\hyperref[\detokenize{References:kc2019}]{\sphinxcrossref{{[}KC2019{]}}}}.
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{4}{9} & \frac{4}{9} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{6456083330201}{8509243623797} & \frac{1}{9} & \frac{1183333538310}{1827251437969} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1632083962415}{14158861528103} & \frac{895379019517}{9750411845327} & \frac{477606656805}{13473228687314} & \frac{-112564739183}{9373365219272} & 0 & 0 & 0 & 0 & 0 \\
  \frac{6365430648612}{17842476412687} & \frac{-4458043123994}{13015289567637} & \frac{-2500665203865}{9342069639922} & \frac{983347055801}{8893519644487} & \frac{2185051477207}{2551468980502} & 0 & 0 & 0 & 0 \\
  \frac{18}{25} & \frac{-167316361917}{17121522574472} & \frac{1605541814917}{7619724128744} & \frac{991021770328}{13052792161721} & \frac{2342280609577}{11279663441611} & \frac{3012424348531}{12792462456678} & 0 & 0 & 0 \\
  \frac{191}{200} & \frac{6680998715867}{14310383562358} & \frac{5029118570809}{3897454228471} & \frac{2415062538259}{6382199904604} & \frac{-3924368632305}{6964820224454} & \frac{-4331110370267}{15021686902756} & \frac{-3944303808049}{11994238218192} & 0 & 0 \\
  1 & \frac{2193717860234}{3570523412979} & \frac{2193717860234}{3570523412979} & \frac{5952760925747}{18750164281544} & \frac{-4412967128996}{6196664114337} & \frac{4151782504231}{36106512998704} & \frac{572599549169}{6265429158920} & \frac{-457874356192}{11306498036315} & 0 \\
  \hline
  5 & 0 & 0 & \frac{3517720773327}{20256071687669} & \frac{4569610470461}{17934693873752} & \frac{2819471173109}{11655438449929} & \frac{3296210113763}{10722700128969} & \frac{-1142099968913}{5710983926999} & \frac{2}{9} \\
  4 & 0 & 0 & \frac{520639020421}{8300446712847} & \frac{4550235134915}{17827758688493} & \frac{1482366381361}{6201654941325} & \frac{5551607622171}{13911031047899} & \frac{-5266607656330}{36788968843917} & \frac{1074053359553}{5740751784926}
\end{array}\end{split}
\end{equation*}

\subsection{Verner-8-5-6}
\label{\detokenize{Butcher:butcher-verner-6-5}}\label{\detokenize{Butcher:verner-8-5-6}}
\index{Verner-8-5-6 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{VERNER\_8\_5\_6} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the default 6th order
explicit method (from \phantomsection\label{\detokenize{Butcher:id13}}{\hyperref[\detokenize{References:v1978}]{\sphinxcrossref{{[}V1978{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{6} & \frac{1}{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{4}{15} & \frac{4}{75} & \frac{16}{75} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{2}{3} & \frac{5}{6} & -\frac{8}{3} & \frac{5}{2} & 0 & 0 & 0 & 0 & 0 \\
  \frac{5}{6} & -\frac{165}{64} & \frac{55}{6} & -\frac{425}{64} & \frac{85}{96} & 0 & 0 & 0 & 0 \\
  1 & \frac{12}{5} & -8 & \frac{4015}{612} & -\frac{11}{36} & \frac{88}{255} & 0 & 0 & 0 \\
  \frac{1}{15} & -\frac{8263}{15000} & \frac{124}{75} & -\frac{643}{680} & -\frac{81}{250} & \frac{2484}{10625} & 0 & 0 & 0 \\
  1 & \frac{3501}{1720} & -\frac{300}{43} & \frac{297275}{52632} & -\frac{319}{2322} & \frac{24068}{84065} & 0 & \frac{3850}{26703} & 0 \\
  \hline
  6 & \frac{3}{40} & 0 & \frac{875}{2244} & \frac{23}{72} & \frac{264}{1955} & 0 & \frac{125}{11592} & \frac{43}{616} \\
  5 & \frac{13}{160} & 0 & \frac{2375}{5984} & \frac{5}{16} & \frac{12}{85} & \frac{3}{44} & 0 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_10}.png}
\caption{Linear stability region for the Verner-8-5-6 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id39}}\end{figure}


\subsection{Fehlberg-13-7-8}
\label{\detokenize{Butcher:fehlberg-13-7-8}}\label{\detokenize{Butcher:butcher-fehlberg-8-7}}
\index{Fehlberg-13-7-8 ERK method}\ignorespaces 
Accessible via the constant \sphinxcode{FEHLBERG\_13\_7\_8} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}, {\hyperref[\detokenize{ERKStep_c_interface/User_callable:c.ERKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ERKStepSetTableNum()}}}}
or {\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadERK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadERK()}}}}.  This is the default 8th order
explicit method (from \phantomsection\label{\detokenize{Butcher:id14}}{\hyperref[\detokenize{References:b2008}]{\sphinxcrossref{{[}B2008{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccccccccccc}
  0&   0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{2}{27}&   \frac{2}{27}& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{9}&   \frac{1}{36}& \frac{1}{12}& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{6}&   \frac{1}{24}& 0& \frac{1}{8}& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{5}{12}&   \frac{5}{12}& 0& -\frac{25}{16}& \frac{25}{16}& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{2}&   \frac{1}{20}& 0& 0& \frac{1}{4}& \frac{1}{5}& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{5}{6}&   -\frac{25}{108}& 0& 0& \frac{125}{108}& -\frac{65}{27}& \frac{125}{54}& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{6}&   \frac{31}{300}& 0& 0& 0& \frac{61}{225}& -\frac{2}{9}& \frac{13}{900}& 0& 0& 0& 0& 0& 0\\
  \frac{2}{3}&   2& 0& 0& -\frac{53}{6}& \frac{704}{45}& -\frac{107}{9}& \frac{67}{90}& 3& 0& 0& 0& 0& 0\\
  \frac{1}{3}&   -\frac{91}{108}& 0& 0& \frac{23}{108}& -\frac{976}{135}& \frac{311}{54}& -\frac{19}{60}& \frac{17}{6}& -\frac{1}{12}& 0& 0& 0& 0\\
  1&   \frac{2383}{4100}& 0& 0& -\frac{341}{164}& \frac{4496}{1025}& -\frac{301}{82}& \frac{2133}{4100}& \frac{45}{82}& \frac{45}{164}& \frac{18}{41}& 0& 0& 0\\
  0&   \frac{3}{205}& 0& 0& 0& 0& -\frac{6}{41}& -\frac{3}{205}& -\frac{3}{41}& \frac{3}{41}& \frac{6}{41}& 0& 0& 0\\
  1&   -\frac{1777}{4100}& 0& 0& -\frac{341}{164}& \frac{4496}{1025}& -\frac{289}{82}& \frac{2193}{4100}& \frac{51}{82}& \frac{33}{164}& \frac{12}{41}& 0& 1& 0\\
  \hline
  8& 0& 0& 0& 0& 0& \frac{34}{105}& \frac{9}{35}& \frac{9}{35}& \frac{9}{280}& \frac{9}{280}& 0& \frac{41}{840}& \frac{41}{840} \\
  7& \frac{41}{840}& 0& 0& 0& 0& \frac{34}{105}& \frac{9}{35}& \frac{9}{35}& \frac{9}{280}& \frac{9}{280}& \frac{41}{840}& 0& 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_23}.png}
\caption{Linear stability region for the Fehlberg-13-7-8 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id40}}\end{figure}


\section{Implicit Butcher tables}
\label{\detokenize{Butcher:implicit-butcher-tables}}\label{\detokenize{Butcher:butcher-implicit}}
In the category of diagonally implicit Runge-Kutta methods, ARKode
includes methods that have orders 2 through 5, with embeddings that are of
orders 1 through 4.


\subsection{SDIRK-2-1-2}
\label{\detokenize{Butcher:sdirk-2-1-2}}\label{\detokenize{Butcher:butcher-sdirk-2-1}}
\index{SDIRK-2-1-2 method}\ignorespaces 
Accessible via the constant \sphinxcode{SDIRK\_2\_1\_2} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the default 2nd order
implicit method.  Both the method and embedding are A- and B-stable.
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cc}
  1 & 1 & 0 \\
  0 & -1 & 1 \\
  \hline
  2 & \frac{1}{2} & \frac{1}{2} \\
  1 & 1 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_11}.png}
\caption{Linear stability region for the SDIRK-2-1-2 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id41}}\end{figure}


\subsection{Billington-3-3-2}
\label{\detokenize{Butcher:billington-3-3-2}}\label{\detokenize{Butcher:butcher-billington}}
\index{Billington-3-3-2 SDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{BILLINGTON\_3\_3\_2} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  Here, the higher-order
embedding is less stable than the lower-order method (from \phantomsection\label{\detokenize{Butcher:id15}}{\hyperref[\detokenize{References:b1983}]{\sphinxcrossref{{[}B1983{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccc}
  0.292893218813 & 0.292893218813 & 0 & 0 \\
  1.091883092037 & 0.798989873223 & 0.292893218813 & 0 \\
  1.292893218813 & 0.740789228841 & 0.259210771159 & 0.292893218813 \\
  \hline
  2 & 0.740789228840 & 0.259210771159 & 0 \\
  3 & 0.691665115992 & 0.503597029883 & -0.195262145876
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_12}.png}
\caption{Linear stability region for the Billington method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id42}}\end{figure}


\subsection{TRBDF2-3-3-2}
\label{\detokenize{Butcher:trbdf2-3-3-2}}\label{\detokenize{Butcher:butcher-trbdf2}}
\index{TRBDF2-3-3-2 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{TRBDF2\_3\_3\_2} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  As with Billington, here the
higher-order embedding is less stable than the lower-order method
(from \phantomsection\label{\detokenize{Butcher:id16}}{\hyperref[\detokenize{References:b1985}]{\sphinxcrossref{{[}B1985{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccc}
  0 & 0 & 0 & 0 \\
  2-\sqrt{2} & \frac{2-\sqrt{2}}{2} & \frac{2-\sqrt{2}}{2} & 0 \\
  1 & \frac{\sqrt{2}}{4} & \frac{\sqrt{2}}{4} & \frac{2-\sqrt{2}}{2} \\
  \hline
  2 & \frac{\sqrt{2}}{4} & \frac{\sqrt{2}}{4} & \frac{2-\sqrt{2}}{2} \\
  3 & \frac{1-\frac{\sqrt{2}}{4}}{3} & \frac{\frac{3\sqrt{2}}{4}+1}{3} & \frac{2-\sqrt{2}}{6}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_13}.png}
\caption{Linear stability region for the TRBDF2 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id43}}\end{figure}


\subsection{Kvaerno-4-2-3}
\label{\detokenize{Butcher:butcher-kvaerno-4-2-3}}\label{\detokenize{Butcher:kvaerno-4-2-3}}
\index{Kvaerno-4-2-3 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{KVAERNO\_4\_2\_3} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  Both the method and embedding are
A-stable; additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id17}}{\hyperref[\detokenize{References:k2004}]{\sphinxcrossref{{[}K2004{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccc}
  0 & 0 & 0 & 0 & 0 \\
  0.871733043 & 0.4358665215 & 0.4358665215 & 0 & 0 \\
  1 & 0.490563388419108 & 0.073570090080892 & 0.4358665215 & 0 \\
  1 & 0.308809969973036 & 1.490563388254106 & -1.235239879727145 & 0.4358665215 \\
  \hline
  3 & 0.308809969973036 & 1.490563388254106 & -1.235239879727145 & 0.4358665215 \\
  2 & 0.490563388419108 & 0.073570090080892 & 0.4358665215 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_14}.png}
\caption{Linear stability region for the Kvaerno-4-2-3 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id44}}\end{figure}


\subsection{ARK-4-2-3 (implicit)}
\label{\detokenize{Butcher:ark-4-2-3-implicit}}\label{\detokenize{Butcher:butcher-ark-4-2-3-i}}
\index{ARK-4-2-3 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK324L2SA\_DIRK\_4\_2\_3} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the default 3rd order
implicit method, and the implicit portion of the default 3rd order
additive method.  Both the method and embedding are A-stable;
additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id18}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccc}
  0 & 0 & 0 & 0 & 0 \\
  \frac{1767732205903}{2027836641118} & \frac{1767732205903}{4055673282236} & \frac{1767732205903}{4055673282236} & 0 & 0 \\
  \frac{3}{5} & \frac{2746238789719}{10658868560708} & -\frac{640167445237}{6845629431997} & \frac{1767732205903}{4055673282236} & 0 \\
  1 & \frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236} \\
  \hline
  3 & \frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236} \\
  2 & \frac{2756255671327}{12835298489170} & -\frac{10771552573575}{22201958757719} & \frac{9247589265047}{10645013368117} & \frac{2193209047091}{5459859503100}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_15}.png}
\caption{Linear stability region for the implicit ARK-4-2-3 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id45}}\end{figure}


\subsection{Cash-5-2-4}
\label{\detokenize{Butcher:cash-5-2-4}}\label{\detokenize{Butcher:butcher-cash-5-2-4}}
\index{Cash-5-2-4 SDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{CASH\_5\_2\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  Both the method and embedding are
A-stable; additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id19}}{\hyperref[\detokenize{References:c1979}]{\sphinxcrossref{{[}C1979{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccc}
  0.435866521508 & 0.435866521508 & 0 & 0 & 0 & 0 \\
  -0.7 & -1.13586652150 & 0.435866521508 & 0 & 0 & 0 \\
  0.8 & 1.08543330679 & -0.721299828287 & 0.435866521508 & 0 & 0 \\
  0.924556761814 & 0.416349501547 & 0.190984004184 & -0.118643265417 & 0.435866521508 & 0 \\
  1 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  \hline
  4 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  2 & 1.05646216107052 & -0.0564621610705236 & 0 & 0 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_16}.png}
\caption{Linear stability region for the Cash-5-2-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id46}}\end{figure}


\subsection{Cash-5-3-4}
\label{\detokenize{Butcher:butcher-cash-5-3-4}}\label{\detokenize{Butcher:cash-5-3-4}}
\index{Cash-5-3-4 SDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{CASH\_5\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  Both the method and embedding are
A-stable; additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id20}}{\hyperref[\detokenize{References:c1979}]{\sphinxcrossref{{[}C1979{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccc}
  0.435866521508 & 0.435866521508 & 0 & 0 & 0 & 0 \\
  -0.7 & -1.13586652150 & 0.435866521508 & 0 & 0 & 0 \\
  0.8 & 1.08543330679 & -0.721299828287 & 0.435866521508 & 0 & 0 \\
  0.924556761814 & 0.416349501547 & 0.190984004184 & -0.118643265417 & 0.435866521508 & 0 \\
  1 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  \hline
  4 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  3 & 0.776691932910 & 0.0297472791484 & -0.0267440239074 & 0.220304811849 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_17}.png}
\caption{Linear stability region for the Cash-5-3-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id47}}\end{figure}


\subsection{SDIRK-5-3-4}
\label{\detokenize{Butcher:butcher-sdirk-5-4}}\label{\detokenize{Butcher:sdirk-5-3-4}}
\index{SDIRK-5-3-4 method}\ignorespaces 
Accessible via the constant \sphinxcode{SDIRK\_5\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the default 4th order
implicit method.  Here, the method is both A- and L-stable, although
the embedding has reduced stability (from \phantomsection\label{\detokenize{Butcher:id21}}{\hyperref[\detokenize{References:hw1996}]{\sphinxcrossref{{[}HW1996{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccc}
  \frac{1}{4} & \frac{1}{4} & 0 & 0 & 0 & 0 \\
  \frac{3}{4} & \frac{1}{2} & \frac{1}{4} & 0 & 0 & 0 \\
  \frac{11}{20} & \frac{17}{50} & -\frac{1}{25} & \frac{1}{4} & 0 & 0 \\
  \frac{1}{2} & \frac{371}{1360} & -\frac{137}{2720} & \frac{15}{544} & \frac{1}{4} & 0 \\
  1 & \frac{25}{24} & -\frac{49}{48} & \frac{125}{16} & -\frac{85}{12} & \frac{1}{4} \\
  \hline
  4 & \frac{25}{24} & -\frac{49}{48} & \frac{125}{16} & -\frac{85}{12} & \frac{1}{4} \\
  3 & \frac{59}{48} & -\frac{17}{96} & \frac{225}{32} & -\frac{85}{12} & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_18}.png}
\caption{Linear stability region for the SDIRK-5-3-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id48}}\end{figure}


\subsection{Kvaerno-5-3-4}
\label{\detokenize{Butcher:kvaerno-5-3-4}}\label{\detokenize{Butcher:butcher-kvaerno-5-3-4}}
\index{Kvaerno-5-3-4 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{KVAERNO\_5\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  Both the method and embedding are
A-stable (from \phantomsection\label{\detokenize{Butcher:id22}}{\hyperref[\detokenize{References:k2004}]{\sphinxcrossref{{[}K2004{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccc}
  0 & 0 & 0 & 0 & 0 & 0 \\
  0.871733043 & 0.4358665215  & 0.4358665215  & 0 & 0 & 0 \\
  0.468238744853136 & 0.140737774731968 & -0.108365551378832 & 0.4358665215 & 0 & 0 \\
  1 & 0.102399400616089 & -0.376878452267324 & 0.838612530151233 & 0.4358665215 & 0 \\
  1 & 0.157024897860995 & 0.117330441357768 & 0.61667803039168 & -0.326899891110444 & 0.4358665215 \\
  \hline
  4 & 0.157024897860995 & 0.117330441357768 & 0.61667803039168 & -0.326899891110444 & 0.4358665215 \\
  3 & 0.102399400616089 & -0.376878452267324 & 0.838612530151233 & 0.4358665215 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_19}.png}
\caption{Linear stability region for the Kvaerno-5-3-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id49}}\end{figure}


\subsection{ARK-6-3-4 (implicit)}
\label{\detokenize{Butcher:butcher-ark-6-3-4-i}}\label{\detokenize{Butcher:ark-6-3-4-implicit}}
\index{ARK-6-3-4 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK436L2SA\_DIRK\_6\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the implicit portion
of the default 4th order additive method. Both the method and
embedding are A-stable; additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id23}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{4} & \frac{1}{4} & 0 & 0 & 0 & 0 \\
  \frac{83}{250} & \frac{8611}{62500} & -\frac{1743}{31250} & \frac{1}{4} & 0 & 0 & 0 \\
  \frac{31}{50} & \frac{5012029}{34652500} & -\frac{654441}{2922500} & \frac{174375}{388108} & \frac{1}{4} & 0 & 0 \\
  \frac{17}{20} & \frac{15267082809}{155376265600} & -\frac{71443401}{120774400} & \frac{730878875}{902184768} & \frac{2285395}{8070912} & \frac{1}{4} & 0 \\
  1 & \frac{82889}{524892} & 0 & \frac{15625}{83664} & \frac{69875}{102672} & -\frac{2260}{8211} & \frac{1}{4} \\
  \hline
  4 & \frac{82889}{524892} & 0 & \frac{15625}{83664} & \frac{69875}{102672} & -\frac{2260}{8211} & \frac{1}{4} \\
  3 & \frac{4586570599}{29645900160} & 0 & \frac{178811875}{945068544} & \frac{814220225}{1159782912} & -\frac{3700637}{11593932} & \frac{61727}{225920}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_20}.png}
\caption{Linear stability region for the implicit ARK-6-3-4 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id50}}\end{figure}


\subsection{ARK-7-3-4 (implicit)}
\label{\detokenize{Butcher:butcher-ark-7-3-4-i}}\label{\detokenize{Butcher:ark-7-3-4-implicit}}
\index{ARK-7-3-4 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK437L2SA\_DIRK\_7\_3\_4} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the implicit portion
of the 4th order additive method from \phantomsection\label{\detokenize{Butcher:id24}}{\hyperref[\detokenize{References:kc2019}]{\sphinxcrossref{{[}KC2019{]}}}}.
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{247}{1000} & \frac{1235}{10000} & \frac{1235}{10000} & 0 & 0 & 0 & 0 & 0 \\
  \frac{4276536705230}{10142255878289} & \frac{624185399699}{4186980696204} & \frac{624185399699}{4186980696204} & \frac{1235}{10000} & 0 & 0 & 0 & 0 \\
  \frac{67}{200} & \frac{1258591069120}{10082082980243} & \frac{1258591069120}{10082082980243} & -\frac{322722984531}{8455138723562} & \frac{1235}{10000} & 0 & 0 & 0 \\
  \frac{3}{40} & -\frac{436103496990}{5971407786587} & -\frac{436103496990}{5971407786587} & -\frac{2689175662187}{11046760208243} & \frac{4431412449334}{12995360898505} & \frac{1235}{10000} & 0 & 0 \\
  \frac{7}{10} & -\frac{2207373168298}{14430576638973} & -\frac{2207373168298}{14430576638973} & \frac{242511121179}{3358618340039} & \frac{3145666661981}{7780404714551} & \frac{5882073923981}{14490790706663} & \frac{1235}{10000} & 0 \\
  1 & 0 & 0 & \frac{9164257142617}{17756377923965} & -\frac{10812980402763}{74029279521829} & \frac{1335994250573}{5691609445217} & \frac{2273837961795}{8368240463276} & \frac{1235}{10000} \\
  \hline
  4 & 0 & 0 & \frac{9164257142617}{17756377923965} & -\frac{10812980402763}{74029279521829} & \frac{1335994250573}{5691609445217} & \frac{2273837961795}{8368240463276} & \frac{1235}{10000} \\
  3 & 0 & 0 & \frac{4469248916618}{8635866897933} & -\frac{621260224600}{4094290005349} & \frac{696572312987}{2942599194819} & \frac{1532940081127}{5565293938103} & \frac{2441}{20000}
\end{array}\end{split}
\end{equation*}

\subsection{Kvaerno-7-4-5}
\label{\detokenize{Butcher:kvaerno-7-4-5}}\label{\detokenize{Butcher:butcher-kvaerno-7-4-5}}
\index{Kvaerno-7-4-5 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{KVAERNO\_7\_4\_5} to
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  Both the method and embedding are
A-stable; additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id25}}{\hyperref[\detokenize{References:k2004}]{\sphinxcrossref{{[}K2004{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|ccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  0.52 & 0.26 & 0.26 & 0 & 0 & 0 & 0 & 0 \\
  1.230333209967908 & 0.13 & 0.84033320996790809 & 0.26 & 0 & 0 & 0 & 0 \\
  0.895765984350076 & 0.22371961478320505 & 0.47675532319799699 & -0.06470895363112615 & 0.26 & 0 & 0 & 0 \\
  0.436393609858648 & 0.16648564323248321 & 0.10450018841591720 & 0.03631482272098715 & -0.13090704451073998 & 0.26 & 0 & 0 \\
  1 & 0.13855640231268224 & 0 & -0.04245337201752043 & 0.02446657898003141 & 0.61943039072480676 & 0.26 & 0 \\
  1 & 0.13659751177640291 & 0 & -0.05496908796538376 & -0.04118626728321046 & 0.62993304899016403 & 0.06962479448202728 & 0.26 \\
  \hline
  5 & 0.13659751177640291 & 0 & -0.05496908796538376 & -0.04118626728321046 & 0.62993304899016403 & 0.06962479448202728 & 0.26 \\
  4 & 0.13855640231268224 & 0 & -0.04245337201752043 & 0.02446657898003141 & 0.61943039072480676 & 0.26 & 0
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_21}.png}
\caption{Linear stability region for the Kvaerno-7-4-5 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id51}}\end{figure}


\subsection{ARK-8-4-5 (implicit)}
\label{\detokenize{Butcher:ark-8-4-5-implicit}}\label{\detokenize{Butcher:butcher-ark-8-4-5-i}}
\index{ARK-8-4-5 ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK548L2SA\_DIRK\_8\_4\_5} for
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the default 5th order
implicit method, and the implicit portion of the default 5th order
additive method.  Both the method and embedding are A-stable;
additionally the method is L-stable (from \phantomsection\label{\detokenize{Butcher:id26}}{\hyperref[\detokenize{References:kc2003}]{\sphinxcrossref{{[}KC2003{]}}}}).
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{41}{100} & \frac{41}{200} & \frac{41}{200} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{2935347310677}{11292855782101} & \frac{41}{400} & -\frac{567603406766}{11931857230679} & \frac{41}{200} & 0 & 0 & 0 & 0 & 0 \\
  \frac{1426016391358}{7196633302097} & \frac{683785636431}{9252920307686} & 0 & -\frac{110385047103}{1367015193373} & \frac{41}{200} & 0 & 0 & 0 & 0 \\
  \frac{92}{100} & \frac{3016520224154}{10081342136671} & 0 & \frac{30586259806659}{12414158314087} & -\frac{22760509404356}{11113319521817} & \frac{41}{200} & 0 & 0 & 0 \\
  \frac{24}{100} & \frac{218866479029}{1489978393911} & 0 & \frac{638256894668}{5436446318841} & -\frac{1179710474555}{5321154724896} & -\frac{60928119172}{8023461067671} & \frac{41}{200} & 0 & 0 \\
  \frac{3}{5} & \frac{1020004230633}{5715676835656} & 0 & \frac{25762820946817}{25263940353407} & -\frac{2161375909145}{9755907335909} & -\frac{211217309593}{5846859502534} & -\frac{4269925059573}{7827059040749} & \frac{41}{200} & 0 \\
  1 & -\frac{872700587467}{9133579230613} & 0 & 0 & \frac{22348218063261}{9555858737531} & -\frac{1143369518992}{8141816002931} & -\frac{39379526789629}{19018526304540} & \frac{32727382324388}{42900044865799} & \frac{41}{200} \\
  \hline
  5 & -\frac{872700587467}{9133579230613} & 0 & 0 & \frac{22348218063261}{9555858737531} & -\frac{1143369518992}{8141816002931} & -\frac{39379526789629}{19018526304540} & \frac{32727382324388}{42900044865799} & \frac{41}{200} \\
  4 & -\frac{975461918565}{9796059967033} & 0 & 0 & \frac{78070527104295}{32432590147079} & -\frac{548382580838}{3424219808633} & -\frac{33438840321285}{15594753105479} & \frac{3629800801594}{4656183773603} & \frac{4035322873751}{18575991585200}
\end{array}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{stab_region_22}.png}
\caption{Linear stability region for the implicit ARK-8-4-5 method.  The method’s
region is outlined in blue; the embedding’s region is in red.}\label{\detokenize{Butcher:id52}}\end{figure}


\subsection{ARK-8-4-5b (implicit)}
\label{\detokenize{Butcher:butcher-ark-8-4-5b-i}}\label{\detokenize{Butcher:ark-8-4-5b-implicit}}
\index{ARK-8-4-5b ESDIRK method}\ignorespaces 
Accessible via the constant \sphinxcode{ARK548L2SAb\_DIRK\_8\_4\_5} for
{\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}} or
{\hyperref[\detokenize{ARKodeButcherTable:c.ARKodeButcherTable_LoadDIRK}]{\sphinxcrossref{\sphinxcode{ARKodeButcherTable\_LoadDIRK()}}}}.  This is the 5th order
implicit method from \phantomsection\label{\detokenize{Butcher:id27}}{\hyperref[\detokenize{References:kc2019}]{\sphinxcrossref{{[}KC2019{]}}}}.
\begin{equation*}
\begin{split}\renewcommand{\arraystretch}{1.5}
\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{4}{9} & \frac{2}{9} & \frac{2}{9} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{6456083330201}{8509243623797} & \frac{2366667076620}{8822750406821} & \frac{2366667076620}{8822750406821} & \frac{2}{9} & 0 & 0 & 0 & 0 & 0 \\
  \frac{1632083962415}{14158861528103} & -\frac{257962897183}{4451812247028} & -\frac{257962897183}{4451812247028} & \frac{128530224461}{14379561246022} & \frac{2}{9} & 0 & 0 & 0 & 0 \\
  \frac{6365430648612}{17842476412687} & -\frac{486229321650}{11227943450093} & -\frac{486229321650}{11227943450093} & -\frac{225633144460}{6633558740617} & \frac{1741320951451}{6824444397158} & \frac{2}{9} & 0 & 0 & 0 \\
  \frac{18}{25} & \frac{621307788657}{4714163060173} & \frac{621307788657}{4714163060173} & -\frac{125196015625}{3866852212004} & \frac{940440206406}{7593089888465} & \frac{961109811699}{6734810228204} & \frac{2}{9} & 0 & 0 \\
  \frac{191}{200} & \frac{2036305566805}{6583108094622} & \frac{2036305566805}{6583108094622} & -\frac{3039402635899}{4450598839912} & -\frac{1829510709469}{31102090912115} & -\frac{286320471013}{6931253422520} & \frac{8651533662697}{9642993110008} & \frac{2}{9} & 0 \\
  1 & 0 & 0 & \frac{3517720773327}{20256071687669} & \frac{4569610470461}{17934693873752} & \frac{2819471173109}{11655438449929} & \frac{3296210113763}{10722700128969} & -\frac{1142099968913}{5710983926999} & \frac{2}{9} \\
  \hline
  5 & 0 & 0 & \frac{3517720773327}{20256071687669} & \frac{4569610470461}{17934693873752} & \frac{2819471173109}{11655438449929} & \frac{3296210113763}{10722700128969} & -\frac{1142099968913}{5710983926999} & \frac{2}{9} \\
  4 & 0 & 0 & \frac{520639020421}{8300446712847} & \frac{4550235134915}{17827758688493} & \frac{1482366381361}{6201654941325} & \frac{5551607622171}{13911031047899} & -\frac{5266607656330}{36788968843917} & \frac{1074053359553}{5740751784926}
\end{array}\end{split}
\end{equation*}

\section{Additive Butcher tables}
\label{\detokenize{Butcher:additive-butcher-tables}}\label{\detokenize{Butcher:butcher-additive}}
In the category of additive Runge-Kutta methods for split implicit and
explicit calculations, ARKode includes methods that have orders 3
through 5, with embeddings that are of orders 2 through 4.  These
Butcher table pairs are as follows:
\begin{itemize}
\item {} 
\index{ARK-4-2-3 ARK method}3rd-order pair:
{\hyperref[\detokenize{Butcher:butcher-ark-4-2-3-e}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-4-2-3 (explicit)}}}} with {\hyperref[\detokenize{Butcher:butcher-ark-4-2-3-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-4-2-3 (implicit)}}}},
corresponding to Butcher tables \sphinxcode{ARK324L2SA\_ERK\_4\_2\_3} and
\sphinxcode{ARK324L2SA\_DIRK\_4\_2\_3} for {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}.

\item {} 
\index{ARK-6-3-4 ARK method}4th-order pair:
{\hyperref[\detokenize{Butcher:butcher-ark-6-3-4-e}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-6-3-4 (explicit)}}}} with {\hyperref[\detokenize{Butcher:butcher-ark-6-3-4-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-6-3-4 (implicit)}}}},
corresponding to Butcher tables \sphinxcode{ARK436L2SA\_ERK\_6\_3\_4} and
\sphinxcode{ARK436L2SA\_DIRK\_6\_3\_4} for {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}.

\item {} 
\index{ARK-7-3-4 ARK method}4th-order pair:
{\hyperref[\detokenize{Butcher:butcher-ark-7-3-4-e}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-7-3-4 (explicit)}}}} with {\hyperref[\detokenize{Butcher:butcher-ark-7-3-4-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-7-3-4 (implicit)}}}},
corresponding to Butcher tables \sphinxcode{ARK437L2SA\_ERK\_7\_3\_4} and
\sphinxcode{ARK437L2SA\_DIRK\_7\_3\_4} for {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}.

\item {} 
\index{ARK-8-4-5 ARK method}5th-order pair:
{\hyperref[\detokenize{Butcher:butcher-ark-8-4-5-e}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-8-4-5 (explicit)}}}} with {\hyperref[\detokenize{Butcher:butcher-ark-8-4-5-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-8-4-5 (implicit)}}}},
corresponding to Butcher tables \sphinxcode{ARK548L2SA\_ERK\_8\_4\_5} and
\sphinxcode{ARK548L2SA\_ERK\_8\_4\_5} for {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}.

\item {} 
\index{ARK-8-4-5b ARK method}5th-order pair:
{\hyperref[\detokenize{Butcher:butcher-ark-8-4-5b-e}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-8-4-5b (explicit)}}}} with {\hyperref[\detokenize{Butcher:butcher-ark-8-4-5b-i}]{\sphinxcrossref{\DUrole{std,std-ref}{ARK-8-4-5b (implicit)}}}},
corresponding to Butcher tables \sphinxcode{ARK548L2SAb\_ERK\_8\_4\_5} and
\sphinxcode{ARK548L2SAb\_ERK\_8\_4\_5} for {\hyperref[\detokenize{ARKStep_c_interface/User_callable:c.ARKStepSetTableNum}]{\sphinxcrossref{\sphinxcode{ARKStepSetTableNum()}}}}.

\end{itemize}


\chapter{Appendix: SUNDIALS Release History}
\label{\detokenize{History:history}}\label{\detokenize{History:appendix-sundials-release-history}}\label{\detokenize{History::doc}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|l|l|l|l|l|l|}
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Date
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
SUNDIALS
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKode
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CVODE
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CVODES
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
IDA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
IDAS
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
KINSOL
\unskip}\relax \\
\hline
\endfirsthead

\multicolumn{8}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstylethead{\sphinxstyletheadfamily 
Date
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
SUNDIALS
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
ARKode
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CVODE
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
CVODES
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
IDA
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
IDAS
\unskip}\relax &\sphinxstylethead{\sphinxstyletheadfamily 
KINSOL
\unskip}\relax \\
\hline
\endhead

\hline
\multicolumn{8}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

Dec 2020
&
5.6.0
&
4.6.0
&
5.6.0
&
5.6.0
&
5.6.0
&
4.6.0
&
5.6.0
\\
\hline
Oct 2020
&
5.5.0
&
4.5.0
&
5.5.0
&
5.5.0
&
5.5.0
&
4.5.0
&
5.5.0
\\
\hline
Sep 2020
&
5.4.0
&
4.4.0
&
5.4.0
&
5.4.0
&
5.4.0
&
4.4.0
&
5.4.0
\\
\hline
May 2020
&
5.3.0
&
4.3.0
&
5.3.0
&
5.3.0
&
5.3.0
&
4.3.0
&
5.3.0
\\
\hline
Mar 2020
&
5.2.0
&
4.2.0
&
5.2.0
&
5.2.0
&
5.2.0
&
4.2.0
&
5.2.0
\\
\hline
Jan 2020
&
5.1.0
&
4.1.0
&
5.1.0
&
5.1.0
&
5.1.0
&
4.1.0
&
5.1.0
\\
\hline
Oct 2019
&
5.0.0
&
4.0.0
&
5.0.0
&
5.0.0
&
5.0.0
&
4.0.0
&
5.0.0
\\
\hline
Feb 2019
&
4.1.0
&
3.1.0
&
4.1.0
&
4.1.0
&
4.1.0
&
3.1.0
&
4.1.0
\\
\hline
Jan 2019
&
4.0.2
&
3.0.2
&
4.0.2
&
4.0.2
&
4.0.2
&
3.0.2
&
4.0.2
\\
\hline
Dec 2018
&
4.0.1
&
3.0.1
&
4.0.1
&
4.0.1
&
4.0.1
&
3.0.1
&
4.0.1
\\
\hline
Dec 2018
&
4.0.0
&
3.0.0
&
4.0.0
&
4.0.0
&
4.0.0
&
3.0.0
&
4.0.0
\\
\hline
Oct 2018
&
3.2.1
&
2.2.1
&
3.2.1
&
3.2.1
&
3.2.1
&
2.2.1
&
3.2.1
\\
\hline
Sep 2018
&
3.2.0
&
2.2.0
&
3.2.0
&
3.2.0
&
3.2.0
&
2.2.0
&
3.2.0
\\
\hline
Jul 2018
&
3.1.2
&
2.1.2
&
3.1.2
&
3.1.2
&
3.1.2
&
2.1.2
&
3.1.2
\\
\hline
May 2018
&
3.1.1
&
2.1.1
&
3.1.1
&
3.1.1
&
3.1.1
&
2.1.1
&
3.1.1
\\
\hline
Nov 2017
&
3.1.0
&
2.1.0
&
3.1.0
&
3.1.0
&
3.1.0
&
2.1.0
&
3.1.0
\\
\hline
Sep 2017
&
3.0.0
&
2.0.0
&
3.0.0
&
3.0.0
&
3.0.0
&
2.0.0
&
3.0.0
\\
\hline
Sep 2016
&
2.7.0
&
1.1.0
&
2.9.0
&
2.9.0
&
2.9.0
&
1.3.0
&
2.9.0
\\
\hline
Aug 2015
&
2.6.2
&
1.0.2
&
2.8.2
&
2.8.2
&
2.8.2
&
1.2.2
&
2.8.2
\\
\hline
Mar 2015
&
2.6.1
&
1.0.1
&
2.8.1
&
2.8.1
&
2.8.1
&
1.2.1
&
2.8.1
\\
\hline
Mar 2015
&
2.6.0
&
1.0.0
&
2.8.0
&
2.8.0
&
2.8.0
&
1.2.0
&
2.8.0
\\
\hline
Mar 2012
&
2.5.0
&
\textendash{}
&
2.7.0
&
2.7.0
&
2.7.0
&
1.1.0
&
2.7.0
\\
\hline
May 2009
&
2.4.0
&
\textendash{}
&
2.6.0
&
2.6.0
&
2.6.0
&
1.0.0
&
2.6.0
\\
\hline
Nov 2006
&
2.3.0
&
\textendash{}
&
2.5.0
&
2.5.0
&
2.5.0
&
\textendash{}
&
2.5.0
\\
\hline
Mar 2006
&
2.2.0
&
\textendash{}
&
2.4.0
&
2.4.0
&
2.4.0
&
\textendash{}
&
2.4.0
\\
\hline
May 2005
&
2.1.1
&
\textendash{}
&
2.3.0
&
2.3.0
&
2.3.0
&
\textendash{}
&
2.3.0
\\
\hline
Apr 2005
&
2.1.0
&
\textendash{}
&
2.3.0
&
2.2.0
&
2.3.0
&
\textendash{}
&
2.3.0
\\
\hline
Mar 2005
&
2.0.2
&
\textendash{}
&
2.2.2
&
2.1.2
&
2.2.2
&
\textendash{}
&
2.2.2
\\
\hline
Jan 2005
&
2.0.1
&
\textendash{}
&
2.2.1
&
2.1.1
&
2.2.1
&
\textendash{}
&
2.2.1
\\
\hline
Dec 2004
&
2.0.0
&
\textendash{}
&
2.2.0
&
2.1.0
&
2.2.0
&
\textendash{}
&
2.2.0
\\
\hline
Jul 2002
&
1.0.0
&
\textendash{}
&
2.0.0
&
1.0.0
&
2.0.0
&
\textendash{}
&
2.0.0
\\
\hline
Mar 2002
&
\textendash{}
&
\textendash{}
&
1.0.0 %
\begin{footnote}[3]\sphinxAtStartFootnote
CVODE and PVODE combined
%
\end{footnote}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
\\
\hline
Feb 1999
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
1.0.0 %
\begin{footnote}[4]\sphinxAtStartFootnote
IDA written
%
\end{footnote}
&
\textendash{}
&
\textendash{}
\\
\hline
Aug 1998
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
1.0.0 %
\begin{footnote}[5]\sphinxAtStartFootnote
KINSOL written
%
\end{footnote}
\\
\hline
Jul 1997
&
\textendash{}
&
\textendash{}
&
1.0.0 %
\begin{footnote}[2]\sphinxAtStartFootnote
PVODE written
%
\end{footnote}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
\\
\hline
Sep 1994
&
\textendash{}
&
\textendash{}
&
1.0.0 %
\begin{footnote}[1]\sphinxAtStartFootnote
CVODE written
%
\end{footnote}
&
\textendash{}
&
\textendash{}
&
\textendash{}
&
\textendash{}
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\phantomsection\label{\detokenize{References:references}}
\begin{sphinxthebibliography}{SuperLUDIST}
\bibitem[A1965]{\detokenize{A1965}}{\phantomsection\label{\detokenize{References:a1965}} 
D.G. Anderson, Iterative Procedures for Nonlinear Integral
Equations, \sphinxstyleemphasis{J. Assoc. Comput. Machinery},
12:547-560, 1965.
}
\bibitem[AP1998]{\detokenize{AP1998}}{\phantomsection\label{\detokenize{References:ap1998}} 
U.M Ascher and L.R. Petzold, Computer Methods for Ordinary
Differential Equations and Differential-Algebraic Equations,
SIAM, Philadelphia, 1998.
}
\bibitem[B1985]{\detokenize{B1985}}{\phantomsection\label{\detokenize{References:b1985}} 
Bank et al., Transient Simulation of Silicon Devices and
Circuits, \sphinxstyleemphasis{IEEE Trans. CAD}, 4:436-451, 1985.
}
\bibitem[B1983]{\detokenize{B1983}}{\phantomsection\label{\detokenize{References:b1983}} 
S.R. Billington, Type-Insensitive Codes for the Solution of
Stiff and Nonstiff Systems of Ordinary Differential
Equations, \sphinxstyleemphasis{in: Master Thesis, University of Manchester,
United Kingdom}, 1983.
}
\bibitem[BS1989]{\detokenize{BS1989}}{\phantomsection\label{\detokenize{References:bs1989}} 
P. Bogacki and L.F. Shampine. A 3(2) pair of Runge\textendash{}Kutta
formulas, \sphinxstyleemphasis{Appl. Math. Lett.}, 2:321\textendash{}325, 1989.
}
\bibitem[B1987]{\detokenize{B1987}}{\phantomsection\label{\detokenize{References:b1987}} 
P.N. Brown. A local convergence theory for combined
inexact-Newton/finite difference projection
methods. \sphinxstyleemphasis{SIAM J. Numer. Anal.}, 24:407-434, 1987.
}
\bibitem[BBH1989]{\detokenize{BBH1989}}{\phantomsection\label{\detokenize{References:bbh1989}} 
P.N. Brown, G.D. Byrne and A.C. Hindmarsh.  VODE, a
Variable-Coefficient ODE
Solver. \sphinxstyleemphasis{SIAM J. Sci. Stat. Comput.}, 10:1038-1051, 1989.
}
\bibitem[BH1989]{\detokenize{BH1989}}{\phantomsection\label{\detokenize{References:bh1989}} 
P.N. Brown and A.C. Hindmarsh. Reduced Storage
Matrix Methods in Stiff ODE Systems. \sphinxstyleemphasis{J. Appl. Math. \&
Comp.}, 31:49-91, 1989.
}
\bibitem[BS1990]{\detokenize{BS1990}}{\phantomsection\label{\detokenize{References:bs1990}} 
P.N. Brown and Y. Saad. Hybrid Krylov Methods for
Nonlinear Systems of Equations. \sphinxstyleemphasis{SIAM J. Sci. Stat. Comput.}, 11:450-481, 1990.
}
\bibitem[B2008]{\detokenize{B2008}}{\phantomsection\label{\detokenize{References:b2008}} 
J.C. Butcher, Numerical Methods for Ordinary Differential
Equations. Wiley, 2nd edition, Chicester, England, 2008.
}
\bibitem[B1992]{\detokenize{B1992}}{\phantomsection\label{\detokenize{References:b1992}} 
G.D. Byrne. Pragmatic Experiments with Krylov Methods
in the Stiff ODE Setting.  In J.R. Cash and I. Gladwell,
editors, \sphinxstyleemphasis{Computational Ordinary Differential Equations},
pp. 323-356, Oxford University Press, 1992.
}
\bibitem[C1979]{\detokenize{C1979}}{\phantomsection\label{\detokenize{References:c1979}} 
J.R. Cash. Diagonally Implicit Runge-Kutta Formulae with
Error Estimates. \sphinxstyleemphasis{IMA J Appl Math}, 24:293-301, 1979.
}
\bibitem[CK1990]{\detokenize{CK1990}}{\phantomsection\label{\detokenize{References:ck1990}} 
J.R. Cash and A.H. Karp. A variable order Runge-Kutta
method for initial value problems with rapidly varying
right-hand sides, \sphinxstyleemphasis{ACM Trans. Math. Soft.},
16:201-222, 1990.
}
\bibitem[CGM2014]{\detokenize{CGM2014}}{\phantomsection\label{\detokenize{References:cgm2014}} 
J. Cheng, M. Grossman and T. McKercher. Professional Cuda
C Programming.  John Wiley \& Sons, 2014.
}
\bibitem[CUDA]{\detokenize{CUDA}}{\phantomsection\label{\detokenize{References:cuda}} 
\sphinxhref{https://docs.nvidia.com/cuda/index.html}{NVIDIA CUDA Programming Guide}.
}
\bibitem[cuSOLVER]{\detokenize{cuSOLVER}}{\phantomsection\label{\detokenize{References:cusolver}} 
\sphinxhref{https://docs.nvidia.com/cuda/cusolver/index.html}{NVIDIA cuSOLVER Documentation}.
}
\bibitem[cuSPARSE]{\detokenize{cuSPARSE}}{\phantomsection\label{\detokenize{References:cusparse}} 
\sphinxhref{https://docs.nvidia.com/cuda/cusparse/index.html}{NVIDIA cuSPARSE Documentation}.
}
\bibitem[DFWBT2010]{\detokenize{DFWBT2010}}{\phantomsection\label{\detokenize{References:dfwbt2010}} 
M.R. Dorr, J.-L. Fattebert, M.E. Wickett, J.F. Belak and
P.E.A Turchi. A numerical algorithm for the solution of a
phase-field model of polycrystalline materials.
\sphinxstyleemphasis{J. Comput. Phys.}, 229(3):626-641, 2010.
}
\bibitem[DP1980]{\detokenize{DP1980}}{\phantomsection\label{\detokenize{References:dp1980}} 
J.R. Dormand and P.J. Prince. A family of embedded
Runge-Kutta formulae, \sphinxstyleemphasis{J. Comput. Appl. Math.} 6:19\textendash{}26, 1980.
}
\bibitem[DP2010]{\detokenize{DP2010}}{\phantomsection\label{\detokenize{References:dp2010}} 
T. Davis and E. Palamadai Natarajan.  Algortithm 907: KLU,
a direct sparse solver for circuit simulation
problems. \sphinxstyleemphasis{ACM Trans. Math. Soft.}, 37, 2010.
}
\bibitem[DES1982]{\detokenize{DES1982}}{\phantomsection\label{\detokenize{References:des1982}} 
R.S. Dembo, S.C. Eisenstat and T. Steihaug.  Inexact
Newton Methods. \sphinxstyleemphasis{SIAM J. Numer. Anal.}, 19:400-408, 1982.
}
\bibitem[DGL1999]{\detokenize{DGL1999}}{\phantomsection\label{\detokenize{References:dgl1999}} 
J.W. Demmel, J.R. Gilbert and X.S. Li. An Asynchronous
Parallel Supernodal Algorithm for Sparse Gaussian
Elimination. \sphinxstyleemphasis{SIAM J. Matrix Analysis and Applications},
20:915-952, 1999.
}
\bibitem[DS1996]{\detokenize{DS1996}}{\phantomsection\label{\detokenize{References:ds1996}} 
J.E. Dennis and R.B. Schnabel.  Numerical Methods for
Unconstrained Optimization and Nonlinear Equations. SIAM,
Philadelphia, 1996.
}
\bibitem[F2014]{\detokenize{F2014}}{\phantomsection\label{\detokenize{References:f2014}} 
R.D. Falgout, S. Friedhoff, TZ.V. Kolev, S.P. MacLachlan, and
J.B. Schroder, Parallel Time Integration with Multigrid,
\sphinxstyleemphasis{SIAM J. Sci. Comput.}, 36:C635-C661, 2014.
}
\bibitem[F2015]{\detokenize{F2015}}{\phantomsection\label{\detokenize{References:f2015}} 
R. Falgout and U.M. Yang. Hypre user’s manual. \sphinxstyleemphasis{LLNL
Technical Report}, 2015.
}
\bibitem[FS2009]{\detokenize{FS2009}}{\phantomsection\label{\detokenize{References:fs2009}} 
H. Fang and Y. Saad. Two classes of secant methods for
nonlinear acceleration. \sphinxstyleemphasis{Numer. Linear Algebra Appl.},
16:197-21, 2009.
}
\bibitem[F1969]{\detokenize{F1969}}{\phantomsection\label{\detokenize{References:f1969}} 
E. Fehlberg. Low-order classical Runge-Kutta formulas with
step size control and their application to some heat
transfer problems. \sphinxstyleemphasis{NASA Technical Report 315}, 1969.
}
\bibitem[F1993]{\detokenize{F1993}}{\phantomsection\label{\detokenize{References:f1993}} 
R.W. Freund. A Transpose-Free Quasi-Minimal Residual Algorithm
for Non-Hermitian Linear Systems. \sphinxstyleemphasis{SIAM J. Sci. Comp.},
14:470-482, 1993.
}
\bibitem[G1991]{\detokenize{G1991}}{\phantomsection\label{\detokenize{References:g1991}} 
K. Gustafsson.  Control theoretic techniques for stepsize
selection in explicit Runge-Kutta methods. \sphinxstyleemphasis{ACM
Trans. Math. Soft.}, 17:533-554, 1991.
}
\bibitem[G1994]{\detokenize{G1994}}{\phantomsection\label{\detokenize{References:g1994}} 
K. Gustafsson.  Control-theoretic techniques for stepsize
selection in implicit Runge-Kutta methods. \sphinxstyleemphasis{ACM
Trans. Math. Soft.} 20:496-512, 1994.
}
\bibitem[GDL2007]{\detokenize{GDL2007}}{\phantomsection\label{\detokenize{References:gdl2007}} 
L. Grigori, J.W. Demmel, and X.S. Li. Parallel Symbolic
Factorization for Sparse LU with Static Pivoting. \sphinxstyleemphasis{SIAM J.
Scientific Comptuing}, 29:1289-1314, 2007.
}
\bibitem[HW1993]{\detokenize{HW1993}}{\phantomsection\label{\detokenize{References:hw1993}} 
E. Hairer, S. Norsett and G. Wanner.  Solving Ordinary
Differential Equations I. \sphinxstyleemphasis{Springer Series in
Computational Mathematics}, vol. 8, 1993.
}
\bibitem[HW1996]{\detokenize{HW1996}}{\phantomsection\label{\detokenize{References:hw1996}} 
E. Hairer and G. Wanner. Solving Ordinary Differential
Equations II. \sphinxstyleemphasis{Springer Series in Computational
Mathematics}, vol. 14, 1996.
}
\bibitem[HS1952]{\detokenize{HS1952}}{\phantomsection\label{\detokenize{References:hs1952}} 
M.R. Hestenes and E. Stiefel. Methods of Conjugate
Gradients for Solving Linear Systems. \sphinxstyleemphasis{J. Research of the
National Bureau of Standards}, 49:409-436, 1952.
}
\bibitem[HS1980]{\detokenize{HS1980}}{\phantomsection\label{\detokenize{References:hs1980}} 
K.L. Hiebert and L.F. Shampine.  Implicitly Defined Output
Points for Solutions of ODEs.  Technical Report
SAND80-0180, Sandia National Laboratories, February 1980.
}
\bibitem[H2000]{\detokenize{H2000}}{\phantomsection\label{\detokenize{References:h2000}} 
A.C. Hindmarsh. The PVODE and IDA Algorithms. Technical
Report UCRL-ID-141558, LLNL, 2000.
}
\bibitem[HS2017]{\detokenize{HS2017}}{\phantomsection\label{\detokenize{References:hs2017}} 
A.C. Hindmarsh and R. Serban. User Documentation for CVODE
v5.6.0. Technical Report UCRL-SM-208108, LLNL, 2020.
}
\bibitem[HSR2017]{\detokenize{HSR2017}}{\phantomsection\label{\detokenize{References:hsr2017}} 
A.C. Hindmarsh, R. Serban and D.R. Reynolds. Example
Programs for CVODE v5.6.0. Technical Report
UCRL-SM-208110, LLNL, 2020.
}
\bibitem[HT1998]{\detokenize{HT1998}}{\phantomsection\label{\detokenize{References:ht1998}} 
A.C. Hindmarsh and A.G. Taylor.  PVODE and KINSOL:
Parallel Software for Differential and Nonlinear
Systems. Technical Report UCRL-IL-129739, LLNL,
February 1998.
}
\bibitem[HK2014]{\detokenize{HK2014}}{\phantomsection\label{\detokenize{References:hk2014}} 
R.D. Hornung and J.A. Keasler.  The RAJA Portability
Layer: Overview and Status. Technical Report
LLNL-TR-661403, LLNL, September 2014.
}
\bibitem[JPE2019]{\detokenize{JPE2019}}{\phantomsection\label{\detokenize{References:jpe2019}} 
S.R. Johnson, A. Prokopenko, and K. J. Evans. Automated
Fortran-C++ bindings for Large-Scale Scientific Applications.
arXiv:1904.02546 {[}cs{]}, Apr. 2019.
}
\bibitem[K1995]{\detokenize{K1995}}{\phantomsection\label{\detokenize{References:k1995}} 
C.T. Kelley.  Iterative Methods for Solving Linear and
Nonlinear Equations. SIAM, Philadelphia, 1995.
}
\bibitem[KC2003]{\detokenize{KC2003}}{\phantomsection\label{\detokenize{References:kc2003}} 
C.A. Kennedy and M.H. Carpenter. Additive Runge-Kutta
schemes for convection-diffusion-reaction
equations. \sphinxstyleemphasis{Appl. Numer. Math.}, 44:139-181, 2003.
}
\bibitem[KC2019]{\detokenize{KC2019}}{\phantomsection\label{\detokenize{References:kc2019}} 
C.A. Kennedy and M.H. Carpenter. Higher-order additive
Runge\textendash{}Kutta schemes for ordinary differential
equations. \sphinxstyleemphasis{Appl. Numer. Math.}, 136:183-205, 2019.
}
\bibitem[K2004]{\detokenize{K2004}}{\phantomsection\label{\detokenize{References:k2004}} 
A. Kv\{ae\}rno. Singly Diagonally Implicit Runge-Kutta
Methods with an Explicit First Stage. \sphinxstyleemphasis{BIT Numer. Math.},
44:489-502, 2004.
}
\bibitem[KLU]{\detokenize{KLU}}{\phantomsection\label{\detokenize{References:klu}} 
\sphinxhref{http://faculty.cse.tamu.edu/davis/suitesparse.html}{KLU Sparse Matrix Factorization Library}.
}
\bibitem[L2005]{\detokenize{L2005}}{\phantomsection\label{\detokenize{References:l2005}} 
X.S. Li. An Overview of SuperLU: Algorithms,
Implementation, and User Interface.
\sphinxstyleemphasis{ACM Trans. Math. Soft.}, 31:302-325, 2005.
}
\bibitem[LD2003]{\detokenize{LD2003}}{\phantomsection\label{\detokenize{References:ld2003}} 
X.S. Li. and J.W. Demmel. A Scalable Distributed-Memory Sparse
Direct Solver for Unsymmetric Linear Systems.
\sphinxstyleemphasis{ACM Trans. Math. Soft.}, 29:110-140, 2003.
}
\bibitem[LWWY2012]{\detokenize{LWWY2012}}{\phantomsection\label{\detokenize{References:lwwy2012}} 
P.A. Lott, H.F. Walker, C.S. Woodward and U.M. Yang. An
Accelerated Picard Method for Nonlinear Systems Related to
Variably Saturated Flow, \sphinxstyleemphasis{Adv. Wat. Resour.}, 38:92-101, 2012.
}
\bibitem[oneAPI]{\detokenize{oneAPI}}{\phantomsection\label{\detokenize{References:oneapi}} 
\sphinxhref{https://software.intel.com/content/www/us/en/develop/documentation/oneapi-programming-guide/top.html}{Intel oneAPI Programming Guide}.
}
\bibitem[R2018]{\detokenize{R2018}}{\phantomsection\label{\detokenize{References:r2018}} 
D.R. Reynolds. ARKode Example Documentation. Technical
Report, Southern Methodist University Center for Scientific
Computation, 2020.
}
\bibitem[ROCm]{\detokenize{ROCm}}{\phantomsection\label{\detokenize{References:rocm}} 
\sphinxhref{https://rocmdocs.amd.com/en/latest/index.html}{AMD ROCm Documentation}.
}
\bibitem[SS1986]{\detokenize{SS1986}}{\phantomsection\label{\detokenize{References:ss1986}} 
Y. Saad and M.H. Schultz. GMRES: A Generalized Minimal Residual
Algorithm for Solving Nonsymmetric Linear Systems.
\sphinxstyleemphasis{SIAM J. Sci. Stat. Comp.}, 7:856-869, 1986.
}
\bibitem[S1993]{\detokenize{S1993}}{\phantomsection\label{\detokenize{References:s1993}} 
Y. Saad. A flexible inner-outer preconditioned GMRES
algorithm.  \sphinxstyleemphasis{SIAM J. Sci. Comput.}, 14:461-469, 1993.
}
\bibitem[S2019]{\detokenize{S2019}}{\phantomsection\label{\detokenize{References:s2019}} 
A. Sandu, A Class of Multirate Infinitesimal GARK Methods.
\sphinxstyleemphasis{SIAM J. Numer. Anal.}, 57:2300-2327, 2019.
}
\bibitem[SA2002]{\detokenize{SA2002}}{\phantomsection\label{\detokenize{References:sa2002}} 
A. Sayfy and A. Aburub. Embedded Additive Runge-Kutta
Methods. \sphinxstyleemphasis{Intern. J. Computer Math.}, 79:945-953, 2002.
}
\bibitem[SKAW2009]{\detokenize{SKAW2009}}{\phantomsection\label{\detokenize{References:skaw2009}} 
M. Schlegel, O. Knoth, M. Arnold, and R. Wolke. Multirate
Runge\textendash{}Kutta schemes for advection
equations. \sphinxstyleemphasis{J. Comput. Appl. Math.}, 226:345-357, 2009.
}
\bibitem[SKAW2012a]{\detokenize{SKAW2012a}}{\phantomsection\label{\detokenize{References:skaw2012a}} 
M. Schlegel, O. Knoth, M. Arnold, and R. Wolke. Implementation of
multirate time integration methods for air pollution modelling.
\sphinxstyleemphasis{GMD}, 5:1395-1405, 2012.
}
\bibitem[SKAW2012b]{\detokenize{SKAW2012b}}{\phantomsection\label{\detokenize{References:skaw2012b}} 
M. Schlegel, O. Knoth, M. Arnold, and R. Wolke. Numerical
solution of multiscale problems in atmospheric modeling.
\sphinxstyleemphasis{Appl. Numer. Math.}, 62:1531-1542, 2012.
}
\bibitem[S1998]{\detokenize{S1998}}{\phantomsection\label{\detokenize{References:s1998}} 
G. Soderlind. The automatic control of numerical
integration.  \sphinxstyleemphasis{CWI Quarterly}, 11:55-74, 1998.
}
\bibitem[S2003]{\detokenize{S2003}}{\phantomsection\label{\detokenize{References:s2003}} 
G. Soderlind. Digital filters in adaptive time-stepping.
\sphinxstyleemphasis{ACM Trans. Math. Soft.}, 29:1-26, 2003.
}
\bibitem[S2006]{\detokenize{S2006}}{\phantomsection\label{\detokenize{References:s2006}} 
G. Soderlind. Time-step selection algorithms: Adaptivity,
control and signal processing. \sphinxstyleemphasis{Appl. Numer. Math.},
56:488-502, 2006.
}
\bibitem[SLUUG1999]{\detokenize{SLUUG1999}}{\phantomsection\label{\detokenize{References:sluug1999}} 
X.S. Li, J.W. Demmel, J.R. Gilbert, L. Grigori,  M. Shao and
I. Yamazaki. SuperLU Users’ Guide. 1999.
}
\bibitem[SuperLUDIST]{\detokenize{SuperLUDIST}}{\phantomsection\label{\detokenize{References:superludist}} 
\sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU\_DIST Parallel Sparse Matrix Factorization Library}.
}
\bibitem[SuperLUMT]{\detokenize{SuperLUMT}}{\phantomsection\label{\detokenize{References:superlumt}} 
\sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU\_MT Threaded Sparse Matrix Factorization Library}.
}
\bibitem[V1992]{\detokenize{V1992}}{\phantomsection\label{\detokenize{References:v1992}} 
H.A. Van Der Vorst. Bi-CGSTAB: A Fast and Smoothly Converging Variant
of Bi-CG for the Solution of Nonsymmetric Linear Systems. \sphinxstyleemphasis{SIAM J. Sci. Stat. Comp.},
13:631-644, 1992.
}
\bibitem[V1978]{\detokenize{V1978}}{\phantomsection\label{\detokenize{References:v1978}} 
J.H. Verner. Explicit Runge-Kutta methods with estimates of
the local truncation error. \sphinxstyleemphasis{SIAM J. Numer. Anal.},
15:772-790, 1978.
}
\bibitem[WN2011]{\detokenize{WN2011}}{\phantomsection\label{\detokenize{References:wn2011}} 
H.F. Walker and P. Ni. Anderson acceleration for
fixed-point iterations. \sphinxstyleemphasis{SIAM J. Numer. Anal.},
49:1715-1735, 2011.
}
\bibitem[KW1998]{\detokenize{KW1998}}{\phantomsection\label{\detokenize{References:kw1998}} 
O. Knoth and R. Wolke. Implicit-explicit Runge-Kutta methods for
computing atmospheric reactive flows. \sphinxstyleemphasis{Appl. Numer. Math.},
28(2):327-341, 1998.
}
\bibitem[XBraid]{\detokenize{XBraid}}{\phantomsection\label{\detokenize{References:xbraid}} 
\sphinxhref{http://llnl.gov/casc/xbraid}{XBraid: Parallel multigrid in time.}.
}
\bibitem[Z1963]{\detokenize{Z1963}}{\phantomsection\label{\detokenize{References:z1963}} 
J.A. Zonneveld. Automatic integration of ordinary
differential equations. \sphinxstyleemphasis{Report R743, Mathematisch Centrum},
Postbus 4079, 1009AB Amsterdam, 1963.
}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
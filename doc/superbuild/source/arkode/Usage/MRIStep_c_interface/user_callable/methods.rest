.. ----------------------------------------------------------------
   SUNDIALS Copyright Start
   Copyright (c) 2002-2021, Lawrence Livermore National Security
   and Southern Methodist University.
   All rights reserved.

   See the top-level LICENSE and NOTICE files for details.

   SPDX-License-Identifier: BSD-3-Clause
   SUNDIALS Copyright End
   ----------------------------------------------------------------

.. _ARKODE.Usage.MRIStep.MRIStepMethodInput:

Optional inputs for IVP method selection
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. _ARKODE.Usage.MRIStep.MRIStepMethodInputTable:
.. table:: Optional inputs for IVP method selection

   +--------------------------------+-------------------------------------+----------+
   | Optional input                 | Function name                       | Default  |
   +--------------------------------+-------------------------------------+----------+
   | Set MRI coupling coefficients  | :c:func:`MRIStepSetCoupling()`      | internal |
   +--------------------------------+-------------------------------------+----------+
   | Set MRI outer RK table         | :c:func:`MRIStepSetTable()`         | internal |
   +--------------------------------+-------------------------------------+----------+
   | Specify MRI outer table number | :c:func:`MRIStepSetTableNum()`      | internal |
   +--------------------------------+-------------------------------------+----------+


..
   .. c:function:: int MRIStepSetOrder(void* arkode_mem, int ord)

      Specifies the order of accuracy for the ERK integration method.

      **Arguments:**

      * *arkode_mem* -- pointer to the MRIStep memory block.

      * *ord* -- requested order of accuracy.

      **Return value:**

      * *ARK_SUCCESS* if successful

      * *ARK_MEM_NULL* if the MRIStep memory is ``NULL``

      * *ARK_ILL_INPUT* if an argument has an illegal value

      **Notes:** The allowed values are :math:`2 \le` *ord* :math:`\le
      8`.  Any illegal input will result in the default value of 4.

      Since *ord* affects the memory requirements for the internal
      MRIStep memory block, it cannot be changed after the first call to
      :c:func:`MRIStepEvolve()`, unless :c:func:`MRIStepReInit()` is called.



.. c:function:: int MRIStepSetCoupling(void* arkode_mem, MRIStepCoupling C)

   Specifies a customized set of slow-to-fast coupling coefficients for the MRI method.

   **Arguments:**

   * *arkode_mem* -- pointer to the MRIStep memory block.

   * *C* -- the table of coupling coefficients for the MRI method.

   **Return value:**

   * *ARK_SUCCESS* if successful

   * *ARK_MEM_NULL* if the MRIStep memory is ``NULL``

   * *ARK_ILL_INPUT* if an argument has an illegal value

   **Notes:**

   For a description of the :c:type:`MRIStepCoupling` type and related
   functions for creating Butcher tables see :numref:`ARKODE.Usage.MRIStep.MRIStepCoupling`.


.. c:function:: int MRIStepSetTable(void* arkode_mem, int q, ARKodeButcherTable B)

   Specifies a customized slow Butcher table for a traditional MIS method.

   **Arguments:**

   * *arkode_mem* -- pointer to the MRIStep memory block.

   * *q* -- global order of accuracy for the MRI method.

   * *B* -- the Butcher table for the outer (slow) RK method.

   **Return value:**

   * *ARK_SUCCESS* if successful

   * *ARK_MEM_NULL* if the MRIStep memory is ``NULL``

   * *ARK_ILL_INPUT* if an argument has an illegal value

   **Notes:**

   For a description of the :c:type:`ARKodeButcherTable` type and related
   functions for creating Butcher tables see :numref:`ARKodeButcherTable`.

   Internally, this function directly calls the utility routine
   :c:func:`MRIStepCoupling_MIStoMRI()` to convert from the input table *B* to
   an MRI coupling table.  As such, all constraints on *B* stated for that function
   apply here as well: it must have explicit first stage (i.e., :math:`c_1=0` and
   :math:`A_{1,j}=0` for :math:`1\le j\le s`) and sorted abscissae (i.e.,
   :math:`c_{i} \ge  c_{i-1}` for :math:`2\le i\le s`).

   The input value of *q* is used rather than the order encoded in the Butcher
   table since the overall order of the MRI method may differ from the order of
   the outer table (see equation :eq:`ARKODE_MIS_order3` and surrounding discussion).
   No error checking is performed to ensure that *q* correctly describes the
   order of the overall MRI method.


.. c:function:: int MRIStepSetTableNum(void* arkode_mem, int itable)

   Indicates to use a specific built-in Butcher table or MRI coupling table
   for the MRI outer (slow) method.

   **Arguments:**

   * *arkode_mem* -- pointer to the MRIStep memory block.

   * *itable* -- index of the outer (slow) Butcher or MRI table.

   **Return value:**

   * *ARK_SUCCESS* if successful

   * *ARK_MEM_NULL* if the MRIStep memory is ``NULL``

   * *ARK_ILL_INPUT* if an argument has an illegal value

   **Notes:** Depending on the value of *itable*, this routine will do one of two
   things.

   If *itable* specifies a built-in ERK or DIRK Butcher table, then this will
   internally retrieve the :c:type:`ARKodeButcherTable` corresponding to the
   *itable* argument, and then immediately call the utility routine
   :c:func:`MRIStepSetTable()` to convert this to an MRI coupling table and store
   the result within MRIStep.  In this case, *itable* should match one of the
   methods from :numref:`Butcher.explicit` or :numref:`Butcher.implicit`.
   Error-checking is performed to ensure that this
   table exists and satisfies the restrictions listed above for
   :c:func:`MRIStepSetTable()`.  This approach assumes that the overall
   MRI method order equals :math:`min(q,2)`, where :math:`q` is the order of
   accuracy for the Butcher table indicated by *itable*; if in fact the overall
   method differs from this assumed value, it is recommended that the user instead
   call either :c:func:`MRIStepSetCoupling()` or :c:func:`MRIStepSetTable()`
   directly.

   If *itable* instead specifies a built-in MRI coupling table, then this will
   internally retrieve the :c:type:`MRIStepCoupling` table via the routine
   :c:func:`MRIStepCoupling_LoadTable()`, and store the result in MRIStep.  In
   this case, *itable* should match one of the methods from
   :numref:`ARKODE.Usage.MRIStep.MRIStepCoupling.Tables`.

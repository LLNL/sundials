..
   Author(s): Cody J. Balos @ LLNL
   -----------------------------------------------------------------------------
   SUNDIALS Copyright Start
   Copyright (c) 2002-2025, Lawrence Livermore National Security
   and Southern Methodist University.
   All rights reserved.

   See the top-level LICENSE and NOTICE files for details.

   SPDX-License-Identifier: BSD-3-Clause
   SUNDIALS Copyright End
   -----------------------------------------------------------------------------

.. _Python:

Python Interfaces
=================

This chapter covers details developers need to know about the SUNDIALS Python interfaces.


nanobind
--------

We use `nanobind <https://github.com/wjakob/nanobind>__` for the Python bindings. nanobind is a sleeker, faster ``pybind11``.
It is a C++ library, i.e. you write your binding code in C++. Nanobind does have some restrictions:

- Cannot bind to functions which take double, or more pointer arguments. I.e., it cannot bind to `**` or `***` and so on.
- Cannot implicitly convert between a "View" container class and the underlying C type. I.e., it cannot implicitly convert ``NVectorView`` to ``N_Vector``.
   This means user must explicitly convert from the "View" class by calling the ``get`` member function. 


Litgen
------

We use `litgen <https://github.com/pthom/litgen>__` to generate a large portion of the nanobind code.

- We have ``generate.yaml`` files designate headers to generate bindings from and functions to exclude.
- A ``generate.py`` script uses litgen to generate the bindings as a C++ header according to the ``generate.yaml``.
- For each generated file, there is a hand-coded file that includes the generated header.  

.. note::

    Litgen itself is licensed under GPLv3. This means the ``generate.py`` script is effectively governed by ``GPLv3``,  
    **but the binding code generated by the script/litgen falls only under our SUNDIALS license**. 
    Because of this, the ``generate.py`` script is in a separate git repository.


Developing
----------

The recommended method for development is to use a typical Python development workflow with ``pip`` rather than invoking CMake directly.

```
$ cd sundials_root_directory
$ python -m venv .venv  # create python virtual environment
$ . .venv/bin/activate  # activate the python virtual environment
$ pip install scikit-build-core[pyproject]  # this is a prerequisite for the next step
$ pip install --no-build-isolation -Ceditable.rebuild=true -ve .[dev] # install pysundials into the virtual environment
```

The last ``pip install`` command will allow automatic incremental builds. It will invoke the SUNDIALS `CMake` build system with the
``-DSUNDIALS_ENABLE_PYTHON=ON`` option through `scikit-build-core <https://scikit-build-core.readthedocs.io/en/latest/index.html>`__.
After the initial build, if you make any changes within SUNDIALS a rebuild will be triggered when you import the ``pysundials``
module wihtin a Python script. 

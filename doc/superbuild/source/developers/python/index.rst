..
   Author(s): Cody J. Balos @ LLNL
   -----------------------------------------------------------------------------
   SUNDIALS Copyright Start
   Copyright (c) 2002-2025, Lawrence Livermore National Security
   and Southern Methodist University.
   All rights reserved.

   See the top-level LICENSE and NOTICE files for details.

   SPDX-License-Identifier: BSD-3-Clause
   SUNDIALS Copyright End
   -----------------------------------------------------------------------------

.. _Python:

Python Interfaces
=================

This chapter covers details developers need to know about the SUNDIALS Python interfaces.


nanobind
--------

We use `nanobind <https://github.com/wjakob/nanobind>__` for the Python bindings. nanobind is a sleeker, faster ``pybind11``.
It is a C++ library, i.e. you write your binding code in C++. Nanobind does have some restrictions:

- Cannot bind to functions which take double, or more pointer arguments. I.e., it cannot bind to `**` or `***` and so on.
- Cannot implicitly convert between a "View" container class and the underlying C type. I.e., it cannot implicitly convert ``NVectorView`` to ``N_Vector``.
   This means user must explicitly convert from the "View" class by calling the ``get`` member function. 


Litgen
------

We use `litgen <https://github.com/pthom/litgen>__` to generate a large portion of the nanobind code.

- We have ``generate.yaml`` files designate headers to generate bindings from and functions to exclude.
- A ``generate.py`` script uses litgen to generate the bindings as a C++ header according to the ``generate.yaml``.
- For each generated file, there is a hand-coded file that includes the generated header.  

.. note::

    Litgen itself is licensed under GPLv3. This means the ``generate.py`` script is effectively governed by ``GPLv3``,  
    **but the binding code generated by the script/litgen falls only under our SUNDIALS license**. 
    Because of this, the ``generate.py`` script is in a separate git repository.


Developing
----------

The recommended method for development is to use a typical Python development workflow with ``pip`` rather than invoking CMake directly.

.. code-block:: shell

   cd sundials_root_directory
   python -m venv .venv  # create python virtual environment
   . .venv/bin/activate  # activate the python virtual environment
   pip install scikit-build-core[pyproject] hatchling # this is a prerequisite for the next step
   MAKEFLAGS="-j$(nproc)" pip install --no-build-isolation -Ceditable.rebuild=true -ve .[dev] # install pysundials into the virtual environment

The last ``pip install`` command will allow automatic incremental builds. It will invoke the SUNDIALS `CMake` build system with the
``-DSUNDIALS_ENABLE_PYTHON=ON`` option through `scikit-build-core <https://scikit-build-core.readthedocs.io/en/latest/index.html>`__.
After the initial build, if you make any changes within SUNDIALS a rebuild will be triggered when you import the ``pysundials``
module wihtin a Python script. 

Different CMake options can be controlled by passing them through the ``--config-settings`` (or ``-C`` for short) option of ``pip install``.
E.g.,

.. code-block:: shell

   MAKEFLAGS="-j$(nproc)" pip install --no-build-isolation -Ceditable.rebuild=true -ve .[dev] \
      -C cmake.define.SUNDIALS_INDEX_SIZE=32  


Things to Know
--------------

All user-supplied Python functions have to be wrapped with a functions which converts between a ``std::function`` and a raw C function pointer.
This is done by smuggling in a "function table" -- a struct of ``std::function`` members -- in the ``user_data``.
The upshot is that everytime we add a user-supplied function, we need to add a new member to the function table struct, and add a wrapper for it.
We also have to add a wrapper for the "Set" function that takes the user-supplied function. Here is an example for ARKODE:

In ``bindings/pysundials/arkode/pysundials_arkode_usersupplied.hpp``, the function table struct is defined:

.. code-block:: cpp

   struct arkode_user_supplied_fn_table
   {
      // common user-supplied function pointers
      nb::object rootfn;
      nb::object ewtn;
      nb::object rwtn;
      nb::object adaptfn;
      nb::object expstabfn;
      nb::object vecresizefn;
      nb::object postprocessfn;
      nb::object stagepredictfn;
      nb::object relaxfn;
      nb::object relaxjacfn;
      nb::object nlsfi;

      // akrode_ls user-supplied function pointers
      nb::object lsjacfn;
      nb::object lsmassfn;
      nb::object lsprecsetupfn;
      nb::object lsprecsolvefn;
      nb::object lsjactimessetupfn;
      nb::object lsjactimesvecfn;
      nb::object lslinsysfn;
      nb::object lsmass_timessetupfn;
      nb::object lsmass_timesvecfn;
      nb::object lsmassprecsetupfn;
      nb::object lsmassprecsolvefn;
      nb::object lsjacrhsfn;

      // erkstep-specific user-supplied function pointers
      nb::object erkstep_f;

      // arkstep-specific user-supplied function pointers
      nb::object arkstep_fe;
      nb::object arkstep_fi;
   };


Then each one of the functions in the table has a wrapper function defined below this struct definition, e.g.,

.. code-block:: cpp

   inline int arkode_postprocessfn_wrapper(sunrealtype t, N_Vector y, void* user_data)
   {
      return pysundials::user_supplied_fn_caller<
         std::remove_pointer_t<ARKPostProcessFn>,
         arkode_user_supplied_fn_table>(&arkode_user_supplied_fn_table::postprocessfn,
                                       t, y, user_data);
   }

Finally, in ``bindings/pysundials/arkode/pysundials_arkode.cpp``, the Set function is registered with nanobind:

.. code-block:: cpp

     m.def("ARKodeSetPostprocessStepFn",
        [](void* ark_mem, std::function<std::remove_pointer_t<ARKPostProcessFn>> fn)
        {
            void* user_data = nullptr;

            ARKodeGetUserData(ark_mem, &user_data);
            if (!user_data)
            {
               throw std::runtime_error(
               "Failed to get Python function table from ARKODE memory");
            }

            auto fntable = static_cast<arkode_user_supplied_fn_table*>(user_data);

            // Set the user-supplied function
            fntable->postprocessfn = nb::cast(fn);
            return ARKodeSetPostprocessStepFn(ark_mem,
                                             &arkode_postprocessfn_wrapper);
        });
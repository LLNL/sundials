%%==============================================================================
\chapter{FIDA, an Interface Module for FORTRAN Applications}\label{s:fcmix}
%%==============================================================================

The {\fida} interface module is a package of {\CC} functions which support
the use of the {\ida} solver, for the solution of DAE systems, in a mixed
{\F}/{\CC} setting.  While {\ida} is written in {\CC}, it is assumed here
that the user's calling program and user-supplied problem-defining routines
are written in {\F}. This package provides the necessary interface to {\ida}
for all supplied serial and parallel {\nvector} implementations.

%%==============================================================================
% Pull in sections on portability and data types.
%%==============================================================================
\input{fortran}

%%==============================================================================
\section{FIDA routines}\label{sss:fidaroutines}
%%==============================================================================

\index{FIDA@{\fida} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\ida} functions,
are as follows:
\begin{itemize}
\item
  Interface to the {\nvector} modules
  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs})
    interfaces to \id{N\_VNewEmpty\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp})
    interfaces to \id{N\_VNewEmpty\_Parallel}.
  \item \id{FNVINITOMP} (defined by {\nvecopenmp})
    interfaces to \id{N\_VNewEmpty\_OpenMP}.
  \item \id{FNVINITPTS} (defined by {\nvecpthreads})
    interfaces to \id{N\_VNewEmpty\_Pthreads}.
  \end{itemize}
\item
  Interface to the {\sunmatrix} modules
  \begin{itemize}
  \item \id{FSUNBANDMATINIT} (defined by {\sunmatband})
    interfaces to \id{SUNBandMatrix}.
  \item \id{FSUNDENSEMATINIT} (defined by {\sunmatdense})
    interfaces to \id{SUNDenseMatrix}.
  \item \id{FSUNSPARSEMATINIT} (defined by {\sunmatsparse})
    interfaces to \id{SUNSparseMatrix}.
  \end{itemize}
\item
  Interface to the {\sunlinsol} modules
  \begin{itemize}
  \item \id{FSUNBANDLINSOLINIT} (defined by {\sunlinsolband}) 
    interfaces to \id{SUNLinSol\_Band}.
  \item \id{FSUNDENSELINSOLINIT} (defined by {\sunlinsoldense}) 
    interfaces to \id{SUNLinSol\_Dense}.
  \item \id{FSUNKLUINIT} (defined by {\sunlinsolklu}) 
    interfaces to \id{SUNLinSol\_KLU}.
  \item \id{FSUNKLUREINIT} (defined by {\sunlinsolklu}) 
    interfaces to \id{SUNLinSol\_KLUReinit}.
  \item \id{FSUNLAPACKBANDINIT} (defined by {\sunlinsollapband}) 
    interfaces to \\ \noindent \id{SUNLinSol\_LapackBand}.
  \item \id{FSUNLAPACKDENSEINIT} (defined by {\sunlinsollapdense}) 
    interfaces to \\ \noindent \id{SUNLinSol\_LapackDense}.
  \item \id{FSUNPCGINIT} (defined by {\sunlinsolpcg}) 
    interfaces to \id{SUNLinSol\_PCG}.
  \item \id{FSUNSPBCGSINIT} (defined by {\sunlinsolspbcgs}) 
    interfaces to \id{SUNLinSol\_SPBCGS}.
  \item \id{FSUNSPFGMRINIT} (defined by {\sunlinsolspfgmr}) 
    interfaces to \id{SUNLinSol\_SPFGMR}.
  \item \id{FSUNSPGMRINIT} (defined by {\sunlinsolspgmr}) 
    interfaces to \id{SUNLinSol\_SPGMR}.
  \item \id{FSUNSPTFQMRINIT} (defined by {\sunlinsolsptfqmr}) 
    interfaces to \id{SUNLinSol\_SPTFQMR}.
  \item \id{FSUNSUPERLUMTINIT} (defined by {\sunlinsolslumt}) 
    interfaces to \\ \noindent \id{SUNLinSol\_SuperLUMT}.
  \end{itemize}
\item
  %% Interface to the {\sunnonlinsol} modules
  %% \begin{itemize}
  %% \item \id{FSUNNEWTONINIT} (defined by {\sunnonlinsolnewton})
  %%   interfaces to \id{SUNNonlinSol\_Newton}.
  %% \end{itemize}
\item Interface to the main {\ida} module
  \begin{itemize}
  \item \id{FIDAMALLOC}
    interfaces to \id{IDACreate}, \id{IDASetUserData}, \id{IDAInit},
    \id{IDASStolerances}, and \id{IDASVtolerances}.
  \item \id{FIDAREINIT}
    interfaces to \id{IDAReInit} and \id{IDASStolerances}/\id{IDASVtolerances}.
  \item \id{FIDASETIIN}, \id{FIDASETVIN}, and \id{FIDASETRIN}
    interface to \id{IDASet*} functions.
  \item \id{FIDATOLREINIT}
    interfaces to \id{IDASStolerances}/\id{IDASVtolerances}.
  \item \id{FIDACALCIC}
    interfaces to \id{IDACalcIC}.
  \item \id{FIDAEWTSET}
    interfaces to \id{IDAWFtolerances}.
  \item \id{FIDASOLVE}
    interfaces to \id{IDASolve}, \id{IDAGet*} functions, and to the optional
    output functions for the selected linear solver module.
  \item \id{FIDAGETDKY}
    interfaces to \id{IDAGetDky}.
  \item \id{FIDAGETERRWEIGHTS}
    interfaces to \id{IDAGetErrWeights}.
  \item \id{FIDAGETESTLOCALERR}
    interfaces to \id{IDAGetEstLocalErrors}.
  \item \id{FIDAFREE}
    interfaces to \id{IDAFree}.
  \end{itemize}
\item Interface to the {\idals} module
  \begin{itemize}
  \item \id{FIDALSINIT}
    interfaces to \id{IDASetLinearSolver}.
  \item \id{FIDALSSETEPSLIN}
    interfaces to \id{IDASetEpsLin}
  \item \id{FIDALSSETJAC}
   interfaces to \id{IDASetJacTimes}.
 \item \id{FIDALSSETPREC}
   interfaces to \id{IDASetPreconditioner}.
  \item \id{FIDADENSESETJAC}
    interfaces to \id{IDASetJacFn}.
  \item \id{FIDABANDSETJAC}
    interfaces to \id{IDASetJacFn}.
  \item \id{FIDASPARSESETJAC}
    interfaces to \id{IDASetJacFn}.
 \end{itemize}
%% \item Interface to the nonlinear solver interfaces
%%   \begin{itemize}
%%   \item \id{FIDANLSINIT}
%%     interfaces to \id{IDASetNonlinearSolver}.
%%  \end{itemize}

\end{itemize}
\index{FIDA@{\fida} interface module!user-callable functions|)}

\index{FIDA@{\fida} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding internal interface
function which calls it (and its type within {\ida}), are as follows:
\begin{center}
\begin{tabular}{l||l|l}
{\fida} routine      &  {\ida} function & {\ida} type of \\
({\F}, user-supplied)  &  ({\CC}, interface) & interface function \\ \hline\hline
\id{FIDARESFUN} & \id{FIDAresfn}    & \id{IDAResFn} \\
\id{FIDAEWT}    & \id{FIDAEwtSet}   & \id{IDAEwtFn} \\
\id{FIDADJAC}   & \id{FIDADenseJac} & \id{IDALsJacFn} \\
\id{FIDABJAC}   & \id{FIDABandJac}  & \id{IDALsJacFn} \\
\id{FIDASPJAC}  & \id{FIDASparseJac}& \id{IDALsJacFn} \\
\id{FIDAPSOL}   & \id{FIDAPSol}     & \id{IDALsPrecSolveFn} \\
\id{FIDAPSET}   & \id{FIDAPSet}     & \id{IDALsPrecSetupFn} \\
\id{FIDAJTIMES} & \id{FIDAJtimes}   & \id{IDALsJacTimesVecFn} \\
\id{FIDAJTSETUP}& \id{FIDAJTSetup}  & \id{IDALsJacTimesSetupFn} \\
\end{tabular}
\end{center}
In contrast to the case of direct use of {\ida}, and of most {\F} DAE
solvers, the names of all user-supplied routines here are fixed, in
order to maximize portability for the resulting mixed-language program.

%%==============================================================================
\section{Usage of the FIDA interface module}\label{ss:fida_usage}
%%==============================================================================
\index{FIDA@{\fida} interface module!usage|(}

The usage of {\fida} requires calls to a variety of interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\ida} functions for information on the arguments
of any given user-callable interface routine, or of a given user-supplied
function called by an interface function.
The usage of {\fida} for rootfinding, and usage of {\fida} with
preconditioner modules, are each described in later sections.

%
\index{User main program!FIDA@{\fida} usage}
\begin{Steps}

%%====================
\item {\bf Residual function specification}
%%====================

  The user must, in all cases, supply the following {\F} routine
  \index{FIDARESFUN@\texttt{FIDARESFUN}}
\begin{verbatim}
      SUBROUTINE FIDARESFUN (T, Y, YP, R, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), R(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the \id{R} array to $F(t,y,\dot{y})$, the residual function of the DAE
  system, as a function of \id{T} $ = t$ and the arrays \id{Y} $ = y$ and
  \id{YP} $ = \dot{y}$.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  It should return \id{IER} = 0 if it was successful,
  \id{IER} = 1 if it had a recoverable failure, or
  \id{IER} = -1 if it had a non-recoverable failure.

%%====================
\item  {\bf {\nvector} module initialization}
%%====================

  If using one of the {\nvector} modules supplied with {\sundials},
  the user must make a call of the form
\begin{verbatim}
      CALL FNVINIT***(...)
\end{verbatim}
in which the name and call sequence are as described in the appropriate
section of Chapter \ref{s:nvector}.


%%====================
\item\label{i:fida_matrix_init} {\bf {\sunmatrix} module initialization}
%%====================

  In the case of a stiff system, the implicit \id{BDF} method involves the solution
  of linear systems related to the Jacobian
  of the DAE system.  If using a Newton iteration with the direct {\sunlinsol} linear solver
  module and one of the {\sunmatrix} modules supplied with {\sundials},
  the user must make a call of the form
\begin{verbatim}
      CALL FSUN***MATINIT(...)
\end{verbatim}
in which the name and call sequence are as described in the appropriate
section of Chapter \ref{s:sunmatrix}.  Note that the dense, band, or
sparse matrix options are usable only in a serial or multi-threaded
environment.


%%====================
\item\label{i:fida_linsol_init} {\bf {\sunlinsol} module initialization}
%%====================

  If using a Newton iteration with one of the {\sunlinsol} linear
  solver modules supplied with {\sundials}, the user must make a call
  of the form
\begin{verbatim}
      CALL FSUNBANDLINSOLINIT(...)
      CALL FSUNDENSELINSOLINIT(...)
      CALL FSUNKLUINIT(...)
      CALL FSUNLAPACKBANDINIT(...)
      CALL FSUNLAPACKDENSEINIT(...)
      CALL FSUNPCGINIT(...)
      CALL FSUNSPBCGSINIT(...)
      CALL FSUNSPFGMRINIT(...)
      CALL FSUNSPGMRINIT(...)
      CALL FSUNSPTFQMRINIT(...)
      CALL FSUNSUPERLUMTINIT(...)
\end{verbatim}
in which the call sequence is as described in the appropriate
section of Chapter \ref{s:sunlinsol}.  Note that the dense, band, or
sparse solvers are usable only in a serial or multi-threaded
environment.

Once one of these solvers has been initialized, its solver parameters may be
modified using a call to the functions
\begin{verbatim}
      CALL FSUNKLUSETORDERING(...)
      CALL FSUNSUPERLUMTSETORDERING(...)
      CALL FSUNPCGSETPRECTYPE(...)
      CALL FSUNPCGSETMAXL(...)
      CALL FSUNSPBCGSSETPRECTYPE(...)
      CALL FSUNSPBCGSSETMAXL(...)
      CALL FSUNSPFGMRSETGSTYPE(...)
      CALL FSUNSPFGMRSETPRECTYPE(...)
      CALL FSUNSPGMRSETGSTYPE(...)
      CALL FSUNSPGMRSETPRECTYPE(...)
      CALL FSUNSPTFQMRSETPRECTYPE(...)
      CALL FSUNSPTFQMRSETMAXL(...)
\end{verbatim}
where again the call sequences are described in the appropriate
sections of Chapter \ref{s:sunlinsol}.

%% %%====================
%% \item\label{i:fida_nonlinsol_init} {\bf {\sunnonlinsol} module initialization}
%% %%====================

%%   By default {\ida} uses the {\sunnonlinsol} implementation of Newton's method
%%   defined by the {\sunnonlinsolnewton} module (see \S\ref{s:sunnonlinsol_newton}).
%%   To specify a non-default nonlinear solver in {\ida}, the user's program must
%%   create a {\sunnonlinsol} object by calling the appropriate Fortran interface
%%   function to the constructor routine (see Chapter \ref{c:sunnonlinsol}). For
%%   example, to create the {\sunnonlinsolfixedpoint} solver call the function
%% \begin{verbatim}
%%       CALL FSUNFIXEDPOINTINIT(...)
%% \end{verbatim}
%%   in which the call sequence is described in \S\ref{s:sunnonlinsol_fixedpoint}.

%%====================
\item {\bf Problem specification}
%%====================

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FIDAMALLOC@\texttt{FIDAMALLOC}}
  \ucfunction{FIDAMALLOC}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l}
        &CALL FIDAMALLOC(&T0, Y0, YP0, IATOL, RTOL, ATOL,  \\
    {\&}&                &IOUT, ROUT, IPAR, RPAR, IER)
  \end{tabular}
  }
  {
    This function provides required problem and solution specifications,
    specifies optional inputs,
    allocates internal memory, and initializes {\ida}.
  }
  {
    \begin{args}[IATOL]
    \item[T0] is the initial value of $t$.
    \item[Y0] is an array of initial conditions for $y$.
    \item[YP0] is an array of initial conditions for $\dot{y}$.
    \item[IATOL] specifies the type for absolute tolerance \id{ATOL}:
      $1$ for scalar or $2$ for array. If \id{IATOL}$=3$, the arguments
      \id{RTOL} and \id{ATOL} are ignored and the user is expected to
      subsequently call \id{FIDAEWTSET} and provide the function \id{FIDAEWT}.
    \item[RTOL] is the relative tolerance (scalar).
    \item[ATOL] is the absolute tolerance (scalar or array).
    \item[IOUT] is an integer array of length at least 21 for integer optional
                outputs.
    \item[ROUT] is a real array of length at least 6 for real optional outputs.
    \item[IPAR] is an integer array of user data which will be passed
      unmodified to all user-provided routines.
    \item[RPAR] is a real array of user data which will be passed
      unmodified to all user-provided routines.
    \end{args}
  }
  {
    \id{IER} is a return completion flag.  Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
    The user integer data arrays \id{IOUT} and \id{IPAR} must be declared as
    \id{INTEGER*4} or \id{INTEGER*8} according to the {\CC} type \id{long int}.

    Modifications to the user data arrays \id{IPAR} and \id{RPAR} inside a
    user-provided routine will be propagated to all subsequent calls to
    such routines.

    The optional outputs associated with the main {\ida} integrator
    are listed in Table~\ref{t:fida_out}.
  }

  As an alternative to providing tolerances in the call to \ID{FIDAMALLOC}, the
  user may provide a routine to compute the error weights used in the WRMS norm
  evaluations. If supplied, it must have the following form:
  \index{FIDAEWT@\texttt{FIDAEWT}}
\begin{verbatim}
      SUBROUTINE FIDAEWT (Y, EWT, IPAR, RPAR, IER)
      DIMENSION Y(*), EWT(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the positive components of the error weight vector \id{EWT} for
  the calculation of the WRMS norm of \id{Y}. On return, set
  \id{IER} = 0 if \id{FIDAEWT} was successful, and nonzero otherwise.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the \id{FIDAEWT} routine is provided, then,
  following the call to \id{FIDAMALLOC}, the user must make the call:
  \index{FIDAEWTSET@\texttt{FIDAEWTSET}}
\begin{verbatim}
      CALL FIDAEWTSET (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied error weight routine.
  The argument \id{IER} is an error return flag, which is $0$
  for success or non-zero if an error occurred.

%%====================
\item\label{i:fida_opt_input}{\bf Set optional inputs}
%%====================

  Call \id{FIDASETIIN}, \id{FIDASETRIN}, and/or \id{FIDASETVIN} to set desired
  optional inputs, if any.  See \S\ref{fida_opt_inout} for details.

%%====================
\item\label{i:fida_lin_solv_spec} {\bf Linear solver interface specification}
%%====================

  The variable-order, variable-coefficient \id{BDF} method used by {\ida} involves
  the solution of linear systems related to the system Jacobian
  $J = \partial F / \partial y + \alpha \partial F / \partial \dot{y}$.
  See Eq. (\ref{e:DAE_Newtoncorr}).
  To attach the linear solver (and optionally the matrix) objects
  initialized in steps \ref{i:fida_matrix_init} and
  \ref{i:fida_linsol_init} above, the user of {\fida} must initialize
  the {\idals} linear solver interface.  To attach any {\sunlinsol}
  object (and optional {\sunmatrix} object) to {\ida}, then following
  calls to initialize the {\sunlinsol} (and {\sunmatrix}) object(s) in
  steps \ref{i:fida_matrix_init} and \ref{i:fida_linsol_init} above,
  the user must make the call:
  \index{FIDALSINIT@\texttt{FIDALSINIT}}
\begin{verbatim}
      CALL FIDALSINIT(IER)
\end{verbatim}
  \id{IER} is an error return flag set on $0$ on success or $-1$ if a memory
  failure occurred.

  The previous routines \Id{FIDADLSINIT} and \Id{FIDASPILSINIT} are now
  wrappers for this routine, and may still be used for
  backward-compatibility.  However, these will be deprecated in future
  releases, so we recommend that users transition to the new routine
  name soon.

  {\bf {\idals} with dense Jacobian matrix}
  \index{Jacobian approximation function!dense!use in {\fida}}

  As an option when using the {\idals} interface with the
  {\sunlinsoldense} or \\ \noindent {\sunlinsollapdense} linear solvers, the user
  may supply a routine that computes a dense approximation of the
  system Jacobian  $J$. If supplied, it must
  have the following form:
  \index{FIDADJAC@\texttt{FIDADJAC}}
\begin{verbatim}
      SUBROUTINE FIDADJAC (NEQ, T, Y, YP, R, DJAC, CJ, EWT, H,
     &                     IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), DJAC(NEQ,*),
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*)
\end{verbatim}
  This routine must compute the Jacobian and store it columnwise in \id{DJAC}.
  The vectors \id{WK1}, \id{WK2}, and \id{WK3} of length \id{NEQ} are provided
  as work space for use in \id{FIDADJAC}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  NOTE: The argument \id{NEQ} has a type consistent with {\CC} type \id{long int}
  even in the case when the LAPACK dense solver is to be used.

  If the user's \id{FIDADJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the \id{FIDADJAC} routine is provided, then, following the call to \id{FIDALSINIT}
  the user must make the call:
  \index{FIDADENSESETJAC@\texttt{FIDADENSESETJAC}}
\begin{verbatim}
      CALL FIDADENSESETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag, which is $0$
  for success or non-zero if an error occurred.

  %%-------------------------------------------------

  {\bf {\idals} with band Jacobian matrix}
  \index{Jacobian approximation function!band!use in {\fida}}
  
  As an option when using the {\idals} interface with the
  {\sunlinsolband} or {\sunlinsollapband} linear solvers, the user may
  supply a routine that computes a band approximation of the system
  Jacobian  $J$. If supplied, it must have the following form:
  \index{FIDABJAC@\texttt{FIDABJAC}}
\begin{verbatim}
      SUBROUTINE FIDABJAC(NEQ, MU, ML, MDIM, T, Y, YP, R, CJ, BJAC,
     &                    EWT, H, IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), BJAC(MDIM,*),
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*)
\end{verbatim}
  This routine must load the \id{MDIM} by \id{NEQ} array \id{BJAC} with the
  Jacobian matrix at the current $(t, y, \dot{y})$ in band form.  Store in
  \id{BJAC}$(k,j)$ the Jacobian element $J_{i,j}$ with $k = i - j + $\id{MU}$ + 1$
  ($k = 1 \cdots $\id{ML} + \id{MU} + 1) and $j = 1 \cdots N$. The vectors
  \id{WK1}, \id{WK2}, and \id{WK3} of length \id{NEQ} are provided as work space
  for use in \id{FIDABJAC}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  NOTE: The arguments \id{NEQ}, \id{MU}, \id{ML}, and \id{MDIM} have a type
  consistent with {\CC} type \id{long int} even in the case when the LAPACK band
  solver is to be used.

  If the user's \id{FIDABJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the \id{FIDABJAC} routine is provided, then, following the call to
  \id{FIDALSINIT}, the user must make the call:
  \index{FIDABANDSETJAC@\texttt{FIDABANDSETJAC}}
\begin{verbatim}
      CALL FIDABANDSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag, which is $0$
  for success or non-zero if an error occurred.

  %%-------------------------------------------------

  {\bf {\idals} with sparse Jacobian matrix}
  \index{Jacobian approximation function!sparse!use in {\fida}}
  
  When using the {\idals} interface with the {\sunlinsolklu} or
  {\sunlinsolslumt} linear solvers, the user must
  supply the \id{FIDASPJAC} routine that computes a
  compressed-sparse-column (CSC) or compressed-sparse-row (CSR)
  approximation of the system Jacobian
  $J = \partial F / \partial y + c_j \partial F / \partial \dot{y}$.
  If supplied, it must have the following form:
\begin{verbatim}
       SUBROUTINE FIDASPJAC(T, CJ, Y, YP, R, N, NNZ, JDATA, JINDEXVALS,
      &                    JINDEXPTRS, H, IPAR, RPAR, WK1, WK2, WK3, IER)
\end{verbatim}
  It must load the \id{N} by \id{N}
  compressed sparse column  [or compressed sparse row] matrix
  with storage for \id{NNZ} nonzeros, stored in the arrays \id{JDATA} (nonzero
  values), \id{JINDEXVALS} (row [or column] indices for each nonzero), \id{JINDEXPTRS} (indices
  for start of each column [or row]), with the Jacobian matrix at the current
  $(t, y)$ in CSC [or CSR] form (see \id{sunmatrix\_sparse.h} for more information).
  The arguments are \id{T}, the current time; \id{CJ}, scalar in the system
  proportional to the inverse step size; \id{Y}, an array containing
  state variables; \id{YP}, an array containing state derivatives;
  \id{R}, an array containing the system nonlinear residual;
  \id{N}, the number of matrix rows/columns
  in the Jacobian; \id{NNZ}, allocated length of nonzero storage; \id{JDATA},
  nonzero values in the Jacobian (of length \id{NNZ});
  \id{JINDEXVALS}, row [or column] indices for each nonzero in Jacobian (of length \id{NNZ});
  \id{JINDEXPTRS}, pointers to each Jacobian column [or row] in the two preceding arrays
  (of length \id{N}+1); \id{H}, the current step size;
  \id{IPAR}, an array containing integer user data that was
  passed to \id{FIDAMALLOC}; \id{RPAR}, an array containing real user
  data that was passed to \id{FIDAMALLOC};
  \id{WK*}, work arrays containing temporary workspace
  of same size as \id{Y}; and \id{IER}, error return code (0 if successful,
  $>0$ if a recoverable error occurred, or $<0$ if an unrecoverable error occurred.)

  To indicate that the \id{FIDASPJAC} routine has been provided, then
  following the call to \id{FIDALSINIT}, the
  following call must be made
  \index{FIDASPARSESETJAC@\texttt{FIDASPARSESETJAC}}
\begin{verbatim}
      CALL FIDASPARSESETJAC (IER)
\end{verbatim}
  The int return flag \id{IER} is an error return flag which is $0$
  for success or nonzero for an error.

%%-------------------------------------------------

  {\bf {\idals} with Jacobian-vector product}
  \index{Jacobian approximation function!Jacobian times vector!use in {\fida}}

  As an option when using the {\idals} linear solver interface, the user may
  supply a routine that computes the product of the system Jacobian
  $J = \partial F / \partial y + \alpha \partial F / \partial \dot{y}$
  and a given vector $v$.  If supplied, it must have the following form:
  \index{FIDAJTIMES@\texttt{FIDAJTIMES}}
\begin{verbatim}
      SUBROUTINE FIDAJTIMES(T, Y, YP, R, V, FJV, CJ, EWT, H,
     &                      IPAR, RPAR, WK1, WK2, IER)
      DIMENSION Y(*), YP(*), R(*), V(*), FJV(*), EWT(*),
     &          IPAR(*), RPAR(*), WK1(*), WK2(*)
\end{verbatim}
  This routine must compute the product vector $Jv$, where the vector $v$ is
  stored in \id{V}, and store the product in \id{FJV}.  On return, set
  \id{IER = 0} if \id{FIDAJTIMES} was successful, and nonzero otherwise.
  The vectors \id{W1K} and \id{WK2}, of length \id{NEQ}, are
  provided as work space for use in \id{FIDAJTIMES}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDAJTIMES} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the user's Jacobian-times-vector product routine requires that
  any Jacobian related data be evaluated or preprocessed, then the
  following routine can be used for the evaluation and preprocessing
  of this data:
  \index{FIDAJTSETUP@\texttt{FIDAJTSETUP}}
\begin{verbatim}
      SUBROUTINE FIDAJTSETUP (T, Y, YP, R, CJ, EWT, H, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), IPAR(*), RPAR(*)
\end{verbatim}
  Typically this routine will use only \id{T}, \id{Y}, and \ida{YP}.  It should
  compute any necessary data for subsequent calls to \id{FIDAJTIMES}.  On return, set
  \id{IER = 0} if \id{FIDAJTSETUP} was successful, and nonzero otherwise.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  To indicate that the \id{FIDAJTIMES} and \id{FIDAJTSETUP} routines
  have been provided, then following the call to \id{FIDALSINIT}, the
  following call must be made
  \index{FIDALSSETJAC@\texttt{FIDALSSETJAC}}
\begin{verbatim}
      CALL FIDALSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if successful,
  or negative if a memory error occurred.

  The previous routine \Id{FIDASPILSETJAC} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
  
  {\warn}If the user calls \id{FIDALSSETJAC}, the routine \id{FIDAJTSETUP} must
  be provided, even if it is not needed, and it must return \id{IER=0}.


%%-------------------------------------------------

  {\bf {\idals} with preconditioning}
  \index{Preconditioner setup routine!use in {\fida}}
  \index{Preconditioner solve routine!use in {\fida}}

  If user-supplied preconditioning is to be performed, the following
  routine must be supplied for solution of the preconditioner linear system:
  \index{FIDAPSOL@\texttt{FIDAPSOL}}
\begin{verbatim}
      SUBROUTINE FIDAPSOL(T, Y, YP, R, RV, ZV, CJ, DELTA, EWT,
     &                    IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), R(*), RV(*), ZV(*), EWT(*),
     &          IPAR(*), RPAR(*)
\end{verbatim}
  It must solve the preconditioner linear system $Pz = r$, where $r =$ \id{RV}
  is input, and store the solution $z$ in \id{ZV}. Here $P$ is the left
  preconditioner.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  On return, set \id{IER = 0} if \id{FIDAPSOL} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a
  non-recoverable error occurred.

  The arguments \id{EWT} and \id{DELTA} are input and provide the error weight
  array and a scalar tolerance, respectively, for use by \id{FIDAPSOL} if it uses
  an iterative method in its solution.  In that case, the residual vector
  $\rho = r - Pz$ of the system should be made less than \id{DELTA} in weighted
  $\ell_2$ norm, i.e. $\sqrt{\sum(\rho_i * \id{EWT}[i])^2} < $ \id{DELTA}.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's preconditioner requires that any Jacobian-related data be evaluated
  or preprocessed, then the following routine is to be used for the evaluation and
  preprocessing of the preconditioner:
  \index{FIDAPSET@\texttt{FIDAPSET}}
\begin{verbatim}
      SUBROUTINE FIDAPSET(T, Y, YP, R, CJ, EWT, H,
     &                    IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*),
     &          IPAR(*), RPAR(*)
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and preprocessing needed
  for the solution of the preconditioner linear systems by \id{FIDAPSOL}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $\dot{y}$, $F(t,y,\dot{y})$, and $\alpha$, respectively.
  On return, set \id{IER = 0} if \id{FIDAPSET} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a
  non-recoverable error occurred.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDAPSET} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  To indicate that the \id{FIDAPSET} and \id{FIDAPSOL} routines are
  supplied, then following the call to \id{FIDALSINIT}, the user must call 
  \index{FIDALSSETPREC@\texttt{FIDALSSETPREC}}
\begin{verbatim}
      CALL FIDALSSETPREC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if successful,
  or negative if a memory error occurred.  In addition, the user must
  supply preconditioner routines \id{FIDAPSET} and \id{FIDAPSOL}.

  The previous routine \Id{FIDASPILSETPREC} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
  
  {\warn} If the user calls \id{FIDALSSETPREC}, the subroutine \id{FIDAPSET}
  must be provided, even if it is not needed, and it must return \id{IER = 0}.
  
%% %%====================
%% \item\label{i:fida_nonlin_solv_spec} {\bf Nonlinear solver interface specification}
%% %%====================

%%   If a non-default {\sunnonlinsol} object was created in step
%%   \ref{i:fida_nonlinsol_init}, the user must attach it to {\ida} with
%%   the call:
%% \begin{verbatim}
%%       CALL FIDANLSINIT(IER)
%% \end{verbatim}
%%   \id{IER} is an error return flag set on $0$ on success or $-1$ if an
%%   error occurred.

%%   Once attached, the user may specify non-default inputs for the
%%   {\sunnonlinsol} object (e.g.~the maximum number of nonlinear
%%   iterations) by calling appropriate Fortran interface routines (see Chapter
%%   \ref{c:sunnonlinsol}).

%%====================
\item {\bf Correct initial values}
%%====================

  Optionally, to correct the initial values $y$ and/or $\dot{y}$, make the call
\begin{verbatim}
      CALL FIDACALCIC (ICOPT, TOUT1, IER)
\end{verbatim}
  (See \S\ref{ss:ivp_sol} for details.)  The arguments are as follows:
  \id{ICOPT} is 1 for initializing the algebraic components of $y$ and
  differential components of $\dot{y}$, or 2 for initializing all of $y$.
  \id{IER} is an error return flag, which is 0 for success, or negative
  for a failure (see \id{IDACalcIC} return values).

%%====================
\item {\bf Problem solution}
%%====================

  Carrying out the integration is accomplished by making calls as follows:
  \index{FIDASOLVE@\texttt{FIDASOLVE}}
\begin{verbatim}
      CALL FIDASOLVE (TOUT, T, Y, YP, ITASK, IER)
\end{verbatim}
  The arguments are as follows.
  \id{TOUT} specifies the next value of $t$ at which a solution is desired (input).
  \id{T} is the value of $t$ reached by the solver on output.
  \id{Y} is an array containing the computed solution vector $y$ on output.
  \id{YP} is an array containing the computed solution vector $\dot{y}$ on output.
  \id{ITASK} is a task indicator and should be set to $1$ for normal mode
  (overshoot \id{TOUT} and interpolate), or to $2$ for one-step mode
  (return after each internal step taken).
  \id{IER} is a completion flag and will be set to a positive value upon
  successful return or to a negative value if an error occurred. These values
  correspond to the \id{IDASolve} returns (see \S\ref{sss:idasolve} and \S\ref{s:ida_out_constants}).
  The current values of the optional outputs are available in \id{IOUT} and
  \id{ROUT} (see Table~\ref{t:fida_out}).

%%====================
\item {\bf Additional solution output}
%%====================

  After a successful return from \id{FIDASOLVE}, the routine \id{FIDAGETDKY} may
  be called to get interpolated values of $y$ or any derivative $d^k y/dt^k$
  for $k$ not exceeding the current method order, and for any value of $t$ in
  the last internal step taken by {\ida}.  The call is as follows:
  \index{FIDAGETDKY@\texttt{FIDAGETDKY}}
\begin{verbatim}
      CALL FIDAGETDKY (T, K, DKY, IER)
\end{verbatim}
  where
  \id{T} is the input value of $t$ at which solution derivative is desired,
  \id{K} is the derivative order, and
  \id{DKY} is an array containing the computed vector $y^{(K)}(t)$ on return.
  The value of \id{T} must lie between \id{TCUR - HLAST} and \id{TCUR}.
  The value of \id{K} must satisfy $0 \leq K \leq $\id{QLAST}. (See the
  optional outputs for \id{TCUR}, \id{HLAST}, and \id{QLAST}.)
  The return flag \id{IER} is set to $0$ upon successful return, or to a
  negative value to indicate an illegal input.

%%====================
\item {\bf Problem reinitialization}
%%====================

  To re-initialize the {\ida} solver for the solution of a new problem
  of the same size as one already solved, make the following call:
  \index{FIDAREINIT@\texttt{FIDAREINIT}}
\begin{verbatim}
      CALL FIDAREINIT (T0, Y0, YP0, IATOL, RTOL, ATOL, IER)
\end{verbatim}
  The arguments have the same names and meanings as those of \id{FIDAMALLOC}.
  \id{FIDAREINIT} performs the same initializations as \id{FIDAMALLOC}, but
  does no memory allocation, using instead the existing internal memory
  created by the previous \id{FIDAMALLOC} call.

  Following this call, if the choice of linear solver is being changed
  then a user must make a call to create the alternate {\sunlinsol}
  module and then attach it to the {\idals} interface, as shown above.
  If only linear solver parameters are being modified, then these
  calls may be made without re-attaching to the {\idals} interface.


%%====================
\item {\bf Memory deallocation}
%%====================

  To free the internal memory created by the call to \id{FIDAMALLOC},
  \id{FIDALSINIT}, \id{FNVINIT*} and \id{FSUN***MATINIT},
  make the call
  \index{FIDAFREE@\texttt{FIDAFREE}}
\begin{verbatim}
      CALL FIDAFREE
\end{verbatim}

\end{Steps}
\index{FIDA@{\fida} interface module!usage|)}

%%==============================================================================
\section{FIDA optional input and output}\label{fida_opt_inout}
%%==============================================================================
\index{FIDA@{\fida} interface module!optional input and output}

In order to keep the number of user-callable {\fida} interface routines to
a minimum, optional inputs to the {\ida} solver are passed through only
three routines: \Id{FIDASETIIN} for integer optional inputs, \Id{FIDASETRIN}
for real optional inputs, and \Id{FIDASETVIN} for real vector (array) optional
inputs.  These functions should be called as follows:
\begin{verbatim}
      CALL FIDASETIIN(KEY, IVAL, IER)
      CALL FIDASETRIN(KEY, RVAL, IER)
      CALL FIDASETVIN(KEY, VVAL, IER)
\end{verbatim}
where \id{KEY} is a quoted string indicating which optional input is set
(see Table \ref{t:fida_in}), \id{IVAL} is the input integer value,
\id{RVAL} is the input real value (scalar),
\id{VVAL} is the input real array, and
\id{IER} is an integer return flag which is set to $0$ on success and
a negative value if a failure occurred.
\id{IVAL} should be declared so as to match {\CC} type \id{long int}.

When using \id{FIDASETVIN} to specify the variable types (\id{KEY = 'ID\_VEC'})
the components in the array \id{VVAL} must be $1.0$ to indicate a differential
variable, or $0.0$ to indicate an algebraic variable.
Note that this array is required only if \id{FIDACALCIC} is to be called
with \id{ICOPT = 1}, or if algebraic variables are suppressed from the error
test (indicated using \id{FIDASETIIN} with \id{KEY = 'SUPPRESS\_ALG'}).
%
When using \id{FIDASETVIN} to specify optional constraints on the
solution vector (\id{KEY = 'CONSTR\_VEC'}) the components in the
array \id{VVAL} should be one of $-2.0$, $-1.0$, $0.0$, $1.0$, or $2.0$.
See the description of \id{IDASetConstraints} (\S\ref{sss:optin_main})
for details.

The optional outputs from the {\ida} solver are accessed not through
individual functions, but rather through a pair of arrays, \Id{IOUT}
(integer type) of dimension at least $21$, and \Id{ROUT} (real type) of
dimension at least $6$.  These arrays are owned (and allocated) by
the user and are passed as arguments to \id{FIDAMALLOC}.  Table
\ref{t:fida_out} lists the entries in these two arrays and specifies
the optional variable as well as the {\ida} function which is actually
called to extract the optional output.

For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Keys for setting {\fida} optional inputs}
\label{t:fida_in}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer optional inputs (\id{FIDASETIIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{MAX\_ORD}      & Maximum LMM method order & $5$  \\
\Id{MAX\_NSTEPS}   & Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$
                   & $500$  \\
\Id{MAX\_ERRFAIL}  & Maximum no. of error test failures & $10$  \\
\Id{MAX\_NITERS}   & Maximum no. of nonlinear iterations & $4$  \\
\Id{MAX\_CONVFAIL} & Maximum no. of convergence failures & $10$  \\
\Id{SUPPRESS\_ALG}   & Suppress alg. vars. from error test (1 = SUNTRUE)
                     & 0 (= SUNFALSE)  \\
\Id{MAX\_NSTEPS\_IC}   & Maximum no. of steps for IC calc. & $5$  \\
\Id{MAX\_NITERS\_IC}   & Maximum no. of Newton iterations for IC calc.& $10$  \\
\Id{MAX\_NJE\_IC}  & Maximum no. of Jac. evals fo IC calc. & $4$  \\
\Id{LS\_OFF\_IC}  & Turn off line search (1 = SUNTRUE) & 0 (= SUNFALSE)  \\


\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real optional inputs (\id{FIDASETRIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{INIT\_STEP}   & Initial step size & estimated \\
\Id{MAX\_STEP}    & Maximum absolute step size & $\infty$ \\
\Id{STOP\_TIME}   & Value of $t_{stop}$ & undefined \\
\Id{NLCONV\_COEF} & Coeff. in the nonlinear conv. test & $0.33$ \\
\Id{NLCONV\_COEF\_IC} & Coeff. in the nonlinear conv. test for IC calc.& $0.0033$ \\
\Id{STEP\_TOL\_IC} & Lower bound on Newton step for IC calc. & uround$^{2/3}$ \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real vector optional inputs (\id{FIDASETVIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{ID\_VEC}   & Differential/algebraic component types & undefined\\
\Id{CONSTR\_VEC}   & Inequality constraints on solution & undefined \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Description of the {\fida} optional output arrays \Id{IOUT} and \Id{ROUT}}
\label{t:fida_out}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer output array \id{IOUT}}\\\hline
{\bf Index} & {\bf Optional output} & {\ida} {\bf function} \\
\hline
\multicolumn{3}{|c|}{{\ida} main solver}\\
\hline
 1 & \id{LENRW}     & \id{IDAGetWorkSpace} \\
 2 & \id{LENIW}     & \id{IDAGetWorkSpace} \\
 3 & \id{NST}       & \id{IDAGetNumSteps} \\
 4 & \id{NRE}       & \id{IDAGetNumResEvals} \\
 5 & \id{NETF}      & \id{IDAGetNumErrTestFails} \\
 6 & \id{NNCFAILS}  & \id{IDAGetNonlinSolvConvFails} \\
 7 & \id{NNI}       & \id{IDAGetNumNonlinSolvIters} \\
 8 & \id{NSETUPS}   & \id{IDAGetNumLinSolvSetups} \\
 9 & \id{QLAST}     & \id{IDAGetLastOrder} \\
10 & \id{QCUR}      & \id{IDAGetCurrentOrder} \\
11 & \id{NBCKTRKOPS}& \id{IDAGetNumBacktrackOps} \\
12 & \id{NGE}       & \id{IDAGetNumGEvals} \\
\hline
\multicolumn{3}{|c|}{{\idals} linear solver interface}\\
\hline
13 &  \id{LENRWLS}  & \id{IDAGetLinWorkSpace} \\
14 &  \id{LENIWLS}  & \id{IDAGetLinWorkSpace} \\
15 &  \id{LS\_FLAG} & \id{IDAGetLastLinFlag} \\
16 &  \id{NRELS}    & \id{IDAGetNumLinResEvals} \\
17 &  \id{NJE}      & \id{IDAGetNumJacEvals} \\
18 &  \id{NJTS}     & \id{IDAGetNumJTSetupEvals} \\
19 &  \id{NJT}      & \id{IDAGetNumJtimesEvals} \\
20 &  \id{NPE}      & \id{IDAGetNumPrecEvals} \\
21 &  \id{NPS}      & \id{IDAGetNumPrecSolves} \\
22 &  \id{NLI}      & \id{IDAGetNumLinIters} \\
23 &  \id{NCFL}     & \id{IDAGetNumLinConvFails} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real output array \id{ROUT}}\\\hline
{\bf Index} & {\bf Optional output} & {\ida} {\bf function} \\
\hline
 1 & \id{H0\_USED} & \id{IDAGetActualInitStep} \\
 2 & \id{HLAST}    & \id{IDAGetLastStep} \\
 3 & \id{HCUR}     & \id{IDAGetCurrentStep} \\
 4 & \id{TCUR}     & \id{IDAGetCurrentTime} \\
 5 & \id{TOLFACT}  & \id{IDAGetTolScaleFactor} \\
 6 & \id{UROUND}   & unit roundoff \\
\hline
\end{tabular}
\end{table}

In addition to the optional inputs communicated through \id{FIDASET*}
calls and the optional outputs extracted from \id{IOUT}
and \id{ROUT}, the following user-callable routines are available:

To reset the tolerances at any time, make the following call:
\index{FIDATOLREINIT@\texttt{FIDATOLREINIT}}
\begin{verbatim}
      CALL FIDATOLREINIT (IATOL, RTOL, ATOL, IER)
\end{verbatim}
The tolerance arguments have the same names and meanings as those of
\id{FIDAMALLOC}.  The error return flag \id{IER} is 0 if successful,
and negative if there was a memory failure or illegal input.

To obtain the error weight array \id{EWT}, containing the multiplicative
error weights used the WRMS norms, make the following call:
\index{FIDAGETERRWEIGHTS@\texttt{FIDAGETERRWEIGHTS}}
\begin{verbatim}
      CALL FIDAGETERRWEIGHTS (EWT, IER)
\end{verbatim}
This computes the \id{EWT} array, normally defined by Eq. (\ref{e:errwt}).
The array \id{EWT}, of length \id{NEQ} or \id{NLOCAL}, must already have been
declared by the user.  The error return flag \id{IER} is zero if successful,
and negative if there was a memory error.

To obtain the estimated local errors, following a successful call to
\id{FIDASOLVE}, make the following call:
\index{FIDAGETESTLOCALERR@\texttt{FIDAGETESTLOCALERR}}
\begin{verbatim}
      CALL FIDAGETESTLOCALERR (ELE, IER)
\end{verbatim}
This computes the \id{ELE} array of estimated local errors as of the last
step taken.  The array \id{ELE} must already have been declared by the user.
The error return flag \id{IER} is zero if successful, and negative if there
was a memory error.

%%==============================================================================
\section{Usage of the FIDAROOT interface to rootfinding}
%%==============================================================================
\index{FIDA@{\fida} interface module!rootfinding|(}
\index{Rootfinding}

The {\fidaroot} interface package allows programs written in {\F} to
use the rootfinding feature of the {\ida} solver module.
%%
The user-callable functions in {\fidaroot}, with the corresponding
{\ida} functions, are as follows:
\begin{itemize}
  \item \id{FIDAROOTINIT} interfaces to \id{IDARootInit}.
  \item \id{FIDAROOTINFO} interfaces to \id{IDAGetRootInfo}.
  \item \id{FIDAROOTFREE} interfaces to \id{IDARootFree}.
\end{itemize}
%%
Note that, at this time {\fidaroot} does not provide support to
specify the direction of zero-crossing that is to be monitored.
Instead, all roots are considered. However, the actual direction
of zero-crossing is reported (through the sign of the non-zero
elements in the array \id{INFO} returned by \id{FIDAROTINFO}).

In order to use the rootfinding feature of {\ida}, the following call must
be made, after calling \id{FIDAMALLOC} but prior to calling \id{FIDASOLVE},
to allocate and initialize memory for the \id{FIDAROOT} module:
\begin{verbatim}
      CALL FIDAROOTINIT (NRTFN, IER)
\end{verbatim}
The arguments are as follows:
\id{NRTFN} is the number of root functions.
\id{IER} is a return completion flag; its values are $0$ for success, $-1$
if the \id{IDA} memory was \id{NULL}, and $-14$ if a memory allocation failed.

To specifiy the functions whose roots are to be found, the user must
define the following routine:
\begin{verbatim}
      SUBROUTINE FIDAROOTFN (T, Y, YP, G, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), G(*), IPAR(*), RPAR(*)
\end{verbatim}
It must set the \id{G} array, of length \id{NRTFN}, with components
$g_i(t,y,\dot{y})$, as a function of \id{T} $= t$ and the arrays \id{Y} $= y$
and \id{YP} $= \dot{y}$.
The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
and are the same as those passed to \id{FIDAMALLOC}.
Set \id{IER} on 0 if successful, or on a non-zero value if an error occurred.

When making calls to \id{FIDASOLVE} to solve the DAE system, the occurrence
of a root is flagged by the return value \id{IER} = 2.  In that case, if
\id{NRTFN} $> 1$, the functions $g_i$ which were found to have a root can
be identified by making the following call:
\begin{verbatim}
      CALL FIDAROOTINFO (NRTFN, INFO, IER)
\end{verbatim}
The arguments are as follows: \id{NRTFN} is the number of root functions.
\id{INFO} is an integer array of length \id{NRTFN} with root information.
\id{IER} is a return completion flag; its values are $0$ for success,
negative if there was a memory failure.  The returned values of \id{INFO(i)}
(\id{i}$ = 1,\ldots,$ \id{NRTFN}) are $0$ or $\pm 1$, such that
\id{INFO(i)} $ = +1$ if $g_{\id{i}}$ was found to have a root and $g_{\id{i}}$ is increasing,
\id{INFO(i)} $ = -1$ if $g_{\id{i}}$ was found to have a root and $g_{\id{i}}$ is dereasing,
and \id{INFO(i)} $ = 0$ otherwise.

The total number of calls made to the root function \id{FIDAROOTFN},
denoted \id{NGE}, can be obtained from \id{IOUT(12)}.
%%
If the {\fida}/{\ida} memory block is reinitialized to solve a
different problem via a call to \id{FIDAREINIT}, then the counter
\id{NGE} is reset to zero.

To free the memory resources allocated by a prior call to \id{FIDAROOTINIT}, make
the following call:
\begin{verbatim}
      CALL FIDAROOTFREE
\end{verbatim}
See \S\ref{ss:idarootinit} for additional information on the
rootfinding feature.
\index{FIDA@{\fida} interface module!rootfinding|)}



%%==============================================================================
\section{Usage of the FIDABBD interface to IDABBDPRE}
%%==============================================================================
\index{FIDA@{\fida} interface module!interface to the {\idabbdpre} module|(}

The {\fidabbd} interface sub-module is a package of {\CC} functions
which, as part of the {\fida} interface module, support the use of the
{\ida} solver with the parallel {\nvecp} module, in a combination of
any of the Krylov iterative solver modules with the {\idabbdpre} preconditioner
module (see \S\ref{sss:idabbdpre}).

The user-callable functions in this package, with the corresponding
{\ida} and {\idabbdpre} functions, are as follows:
\begin{itemize}
\item \id{FIDABBDINIT}
  interfaces to \id{IDABBDPrecAlloc}.
\item \id{FIDABBDREINIT}
  interfaces to \id{IDABBDPrecReInit}.
\item \id{FIDABBDOPT}
  interfaces to {\idabbdpre} optional output functions.
\item \id{FIDABBDFREE}
  interfaces to \id{IDABBDPrecFree}.
\end{itemize}

In addition to the {\F} residual function \id{FIDARESFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\idabbdpre} or {\ida}):
\begin{center}
\begin{tabular}{l|l|l}
{\fidabbd} routine ({\F})  &  {\ida} function ({\CC}) & {\ida} function type \\\hline
\id{FIDAGLOCFN}  & \id{FIDAgloc}     & \id{IDABBDLocalFn} \\
\id{FIDACOMMFN}  & \id{FIDAcfn}      & \id{IDABBDCommFn} \\
\id{FIDAJTIMES}  & \id{FIDAJtimes}   & \id{IDALsJacTimesVecFn} \\
\id{FIDAJTSETUP} & \id{FIDAJTSetup}  & \id{IDALsJacTimesSetupFn} \\
\end{tabular}
\end{center}
As with the rest of the {\fida} routines, the names of all user-supplied routines
here are fixed, in order to maximize portability for the resulting mixed-language
program.  Additionally, based on flags discussed above in \S\ref{sss:fidaroutines},
the names of the user-supplied routines are mapped to actual values
through a series of definitions in the header file \id{fidabbd.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fida_usage} are grayed-out.

\index{User main program!FIDABBD@{\fidabbd} usage}
\begin{Steps}

\item \textcolor{gray}{\bf Residual function specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item {\bf {\sunlinsol} module initialization}

  Initialize one of the iterative {\sunlinsol} modules, by calling one
  of \id{FSUNPCGINIT}, \id{FSUNSPBCGSINIT}, \id{FSUNSPFGMRINIT},
  \id{FSUNSPGMRINIT} or \id{FSUNSPTFQMRINIT}.

\item \textcolor{gray}{\bf Problem specification}

\item \textcolor{gray}{\bf Set optional inputs}

\item \textcolor{gray}{\bf Linear solver interface specification}

  Initialize the {\idals} iterative linear solver interface
  by calling \id{FIDALSINIT}.

\item {\bf BBD preconditioner initialization}

  To initialize the {\idabbdpre} preconditioner, make the following call:
  \index{FIDABBDINIT@\texttt{FIDABBDINIT}}
\begin{verbatim}
       CALL FIDABBDINIT (NLOCAL, MUDQ, MLDQ, MU, ML, DQRELY, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors on this processor.
  \id{MUDQ} and \id{MLDQ} are the upper and lower half-bandwidths to be used in
  the computation of the local Jacobian blocks by difference quotients.
  These may be smaller than the true half-bandwidths of the
  Jacobian of the local block of $G$, when smaller values may
  provide greater efficiency.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band matrix
  that  is retained as an approximation of the local Jacobian block.
  These may be smaller than \id{MUDQ} and \id{MLDQ}.
  \id{DQRELY} is the relative increment factor in $y$ for difference quotients
  (optional). A value of $0.0$ indicates the default, $\sqrt{\text{unit roundoff}}$.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.

\item \textcolor{gray}{\bf Correct initial values}

\item \textcolor{gray}{\bf Problem solution}

\item \textcolor{gray}{\bf Additional solution output}

\item {\bf {\idabbdpre} Optional outputs}

  Optional outputs specific to the {\spgmr}, {\spbcg}, or {\sptfqmr} solver are
  listed in Table \ref{t:fida_out}.
  To obtain the optional outputs associated with the {\idabbdpre}
  module, make the following call:
  \index{FIDABBDOPT@\texttt{FIDABBDOPT}}
\begin{verbatim}
       CALL FIDABBDOPT (LENRWBBD, LENIWBBD, NGEBBD)
\end{verbatim}
  The arguments should be consistent with {\CC} type \id{long int}.  Their
  returned values are as follows:
  \id{LENRWBBD} is the length of real preconditioner work space, in \id{realtype}
  words.  \id{LENIWBBD} is the length of integer preconditioner work space, in
  integer words.  Both of these sizes are local to the current processor.
  \id{NGEBBD} is the number of $G(t,y,\dot{y})$ evaluations (calls to \id{FIDALOCFN})
  so far.

\item {\bf Problem reinitialization}

  If a sequence of problems of the same size is being solved using the same
  linear solver in combination with the {\idabbdpre}
  preconditioner, then the {\ida} package can be re-initialized for the second
  and subsequent problems by calling \id{FIDAREINIT}, following which a call
  to \id{FIDABBDINIT} may or  may not be needed.
  If the input arguments are the same, no \id{FIDABBDINIT} call is needed.
  If there is a change in input arguments other than \id{MU} or \id{ML},
  then the user program should make the call
  \index{FIDABBDREINIT@\texttt{FIDABBDREINIT}}
\begin{verbatim}
       CALL FIDABBDREINIT (NLOCAL, MUDQ, MLDQ, DQRELY, IER)
\end{verbatim}
  This reinitializes the {\idabbdpre} preconditioner, but without
  reallocating its memory.  The arguments of the \id{FIDABBDREINIT}
  routine have the same names and meanings as those of \id{FIDABBDINIT}.
  If the value of \id{MU} or \id{ML} is being changed, then a call to
  \id{FIDABBDINIT} must be made.  Finally, if there is a change in any of the
  linear solver inputs, then a call to one of \id{FSUN****INIT},
  followed by a call to \id{FIDALSINIT} must
  also be made; in this case the linear solver memory is reallocated.

\item \textcolor{gray}{\bf Memory deallocation}

  (The memory allocated for the {\fidabbd} module is deallocated automatically
  by \id{FIDAFREE}.)

\index{FIDA@{\fida} interface module!interface to the {\idabbdpre} module|)}

\item {\bf User-supplied routines}

  The following two routines must be supplied for use with the {\idabbdpre}
  module:
  \index{FIDAGLOCFN@\texttt{FIDAGLOCFN}}
\begin{verbatim}
      SUBROUTINE FIDAGLOCFN (NLOC, T, YLOC, YPLOC, GLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), YPLOC(*), GLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to evaluate the function $G(t,y,\dot{y})$ approximating $F$
  (possibly identical to $F$), in terms of \id{T} $ = t$, and the arrays
  \id{YLOC} and \id{YPLOC} (of length \id{NLOC}), which are the sub-vectors
  of $y$ and $\dot{y}$ local to this processor.  The resulting (local) sub-vector
  is to be stored in the array \id{GLOC}.  \id{IER} is a return flag that
  should be set to 0 if successful, to 1 (for a recoverable error), or to
  -1 (for a non-recoverable error).
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  \index{FIDACOMMFN@\texttt{FIDACOMMFN}}
\begin{verbatim}
      SUBROUTINE FIDACOMMFN (NLOC, T, YLOC, YPLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), YPLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to perform the inter-processor communication necessary
  for the \id{FIDAGLOCFN} routine.
  Each call to \id{FIDACOMMFN} is preceded by a call to the residual routine
  \id{FIDARESFUN} with the same arguments \id{T}, \id{YLOC}, and \id{YPLOC}.
  Thus \id{FIDACOMMFN} can omit any communications done by \id{FIDARESFUN} if
  relevant to the evaluation of \id{GLOC}.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  \id{IER} is a return flag that should be set to 0 if successful, to 1
  (for a recoverable error), or to -1 (for a non-recoverable error).

  {\warn}The subroutine \id{FIDACOMMFN} must be supplied even if it is empty,
  and it must return \id{IER = 0}.

  \index{FIDAJTIMES@\texttt{FIDAJTIMES}}
  \index{FIDAJTSETUP@\texttt{FIDAJTSETUP}}
  Optionally, the user can supply routines \id{FIDAJTIMES} and
  \id{FIDAJTSETUP} for the evaluation of Jacobian-vector products, as
  described above in step \ref{i:fida_lin_solv_spec}
  in \S\ref{ss:fida_usage}.

\end{Steps}

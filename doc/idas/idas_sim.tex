%%===================================================================================
\chapter{Using IDAS for IVP Solution}\label{s:simulation}
%%===================================================================================

This chapter is concerned with the use of {\idas} for the integration
of DAEs.  The following sections treat the header files,
the layout of the user's main program, description of the {\idas} user-callable
functions, and description of user-supplied functions.
This usage is essentially equivalent to using {\ida}~\cite{ida_ug}.

The sample programs described in the companion document \cite{idas_ex} 
may also be helpful. Those codes may be used as templates (with the removal of
some lines involved in testing), and are included in the {\idas} package.

The user should be aware that not all linear solver modules are compatible 
with all {\nvector} implementations. 
\index{IDAS@{\idas} linear solvers!NVECTOR@{\nvector} compatibility}
For example, {\nvecp} is not compatible with the direct dense, direct
band or direct sparse linear solvers, since these linear solver
modules need to form the complete system Jacobian.  The {\idadense}
and {\idaband} modules (using either the internal implementation or
Lapack), as well as the {\idaklu} and {\idasuperlumt} modules can only
be used with {\nvecs}, {\nvecopenmp} and {\nvecpthreads}. 
It is not recommended to use a threaded vector module with SuperLU\_MT
unless it is the {\nvecopenmp} module and SuperLU\_MT is also compiled
with openMP.
The preconditioner module {\idabbdpre} can only be used with {\nvecp}. 

{\idas} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

%%==============================================================================
\section{Access to library and header files}\label{ss:file_access}
%%==============================================================================

At this point, it is assumed that the installation of {\idas},
following the procedure described in Appendix \ref{c:install}, has
been completed successfully.

Regardless of where the user's application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
{\idas}.  The relevant library files are
\begin{itemize}
\item {\em libdir}\id{/libsundials\_idas.}{\em lib},
\item {\em libdir}\id{/libsundials\_nvec*.}{\em lib} (one to four files),
\end{itemize}
where the file extension .{\em lib} is typically \id{.so} for shared libraries
and \id{.a} for static libraries. The relevant header files are located in
the subdirectories
\begin{itemize}
\item {\em incdir}\id{/include/idas}
\item {\em incdir}\id{/include/sundials}
\item {\em incdir}\id{/include/nvector}
\end{itemize}
The directories {\em libdir} and {\em incdir} are the install library
and include directories, respectively. For a default installation,
these are {\em instdir}\id{/lib} and {\em instdir}\id{/include},
respectively, where {\em instdir} is the directory where {\sundials}
was installed (see Appendix \ref{c:install}).

Note that an application cannot link to both the {\ida} and {\idas} libraries
because both contain user-callable functions with the same names (to ensure that {\idas}
is backward compatible with {\ida}). Therefore, applications that contain both
DAE problems and DAEs with sensitivity analysis, should use {\idas}.

%%===================================================================================
\section{Data types}\label{s:types}
%%===================================================================================
\input{types}

%%===================================================================================
\section{Header files}\label{ss:header_sim}
%%===================================================================================
\index{header files}
The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%%
\begin{itemize}
\item  \Id{idas.h}, 
  the header file for {\idas}, which defines the several
  types and various constants, and includes function prototypes.
\end{itemize}
%%
Note that \id{idas.h} includes \Id{sundials\_types.h}, 
which defines the types \id{realtype} and \id{booleantype}
and the constants \id{FALSE} and \id{TRUE}.

The calling program must also include an {\nvector} implementation header file
(see Chapter \ref{s:nvector} for details).
For the {\nvector} implementations that are included in the {\idas} package,
the corresponding header files are:
%%
\begin{itemize}
\item \Id{nvector\_serial.h}, 
  which defines the serial implementation {\nvecs};
\item \Id{nvector\_parallel.h}, 
  which defines the parallel MPI implementation, {\nvecp}.
\item \Id{nvector\_openmp.h},
  which defines the shared memory parallel openMP implementation,
\item \Id{nvector\_pthreads.h},
  which defines the shared memory parallel Pthreads implementation.
\end{itemize}
%%
Note that both these files include in turn the header file \Id{sundials\_nvector.h} which 
defines the abstract \Id{N\_Vector} type. 

Finally, a linear solver module header file is required. 
\index{IDAS@{\idas} linear solvers!header files}
The header files corresponding to the various linear solver options in {\idas} are
as follows:
%%
\begin{itemize}
\item \Id{idas\_dense.h}, 
  which is used with the dense direct linear solver;

\item \Id{idas\_band.h}, 
  which is used with the band direct linear solver;

\item \Id{idas\_lapack.h},
  which is used with Lapack implementations of dense or band direct linear solvers;
  
\item \Id{idas\_klu.h}, 
  which is used with the KLU sparse direct linear solver;

\item \Id{idas\_superlumt.h}, 
  which is used with the SuperLU\_MT threaded sparse direct linear solver;

\item \Id{idas\_spgmr.h}, 
  which is used with the scaled, preconditioned GMRES Krylov linear solver {\spgmr};

\item \Id{idas\_spbcgs.h}, 
  which is used with the scaled, preconditioned Bi-CGStab Krylov linear solver {\spbcg};

\item \Id{idas\_sptfqmr.h}, 
  which is used with the scaled, preconditioned TFQMR Krylov solver {\sptfqmr}.
\end{itemize}

The header files for the dense and banded linear solvers (both
internal and Lapack) include the file \id{idas\_direct.h}, which
defines common functions.  This in turn includes a file
(\id{sundials\_direct.h}) which defines the matrix type for these
direct linear solvers (\id{DlsMat}), as well as various functions and
macros acting on such matrices.

The header files for the KLU and SuperLU\_MT sparse linear solvers
include the file \id{idas\_sparse.h}, which defines common
functions. This in turn includes a file (\id{sundials\_sparse.h})
which defines the matrix type for these sparse direct linear solvers
(\id{SlsMat}), as well as various functions and macros acting on such
matrices. 

The header files for the Krylov iterative solvers include \id{idas\_spils.h}
which defines common functions and which in turn includes a header file (\id{sundials\_iterative.h})
which enumerates the kind of preconditioning and (for the {\spgmr} solver only) the choices for the Gram-Schmidt process.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, in the \id{idasFoodWeb\_kry\_p}
example (see \cite{idas_ex}), preconditioning is done with a
block-diagonal matrix. For this, even though the {\idaspgmr} linear
solver is used, the header \id{sundials\_dense.h} is included for
access to the underlying generic dense linear solver.

%%===================================================================================
\section{A skeleton of the user's main program}\label{ss:skeleton_sim}
%%===================================================================================
The following is a skeleton of the user's main program (or calling
program) for the integration of a DAE IVP. Some steps are independent of the
{\nvector} implementation used; where this is not the case, usage specifications
are given for the implementations provided with {\idas}:
steps marked {\s} correspond to {\nvecs},
steps marked {\omp} correspond to {\nvecopenmp},
steps marked {\pt} correspond to {\nvecpthreads},
steps marked {\p} correspond to {\nvecp}, while
steps marked {\h} correspond to {\nvecph}.
%%
\index{User main program!IDAS@{\idas} usage}
\begin{Steps}
  
\item 
  {\bf {\p} {\h} Initialize MPI}

  Call \id{MPI\_Init(\&argc, \&argv)} to initialize MPI if used by
  the user's program, aside from the internal use in {\nvecp}.  
  Here \id{argc} and \id{argv} are the command line argument 
  counter and array received by \id{main}.
  
\item
  {\bf Set problem dimensions}

  {\s, \omp, \pt} Set \id{N}, the problem size $N$.

  {\omp, \pt} Set \id{num\_threads}, the number of threads to use within
  the threaded vector functions.

  {\p} {\h} Set \id{Nlocal}, the local vector length (the sub-vector
  length for this processor); \id{N}, the global vector length (the
  problem size $N$, and the sum of all the values of \id{Nlocal});
  and the active set of processors.
    
  Note: The variables \id{N} and \id{Nlocal} should be of type
  \id{long int}.  The variable \id{num\_threads} should be of type \id{int}.

\item
  {\bf Set vectors of initial values}
 
  To set the vectors \id{y0} and \id{yp0} to initial values for $y$ and $\dot{y}$, 
  use functions defined by the particular {\nvector} implementation. 
  For the two {\nvector} implementations provided, if a \id{realtype} array  \id{ydata}
  already exists, containing the initial values of $y$, make the calls:

  {\s} \id{y0  = N\_VMake\_Serial(N, ydata);}

  {\omp} \id{y0 = N\_VMake\_OpenMP(N, num\_threads, ydata);}

  {\pt} \id{y0 = N\_VMake\_Pthreads(N, num\_threads, ydata);}

  {\p} \id{y0 = N\_VMake\_Parallel(comm, Nlocal, N, ydata);}

  {\h} \id{y0 = N\_VMake\_ParHyp(comm, Nlocal, N, ydata);}

  Otherwise, make the calls:

  {\s} \id{y0 = N\_VNew\_Serial(N);}

  {\omp} \id{y0 = N\_VNew\_OpenMP(N, num\_threads);}

  {\pt} \id{y0 = N\_VNew\_Pthreads(N, num\_threads);}

  {\p} \id{y0 = N\_VNew\_Parallel(comm, Nlocal, N);}

  {\h} \id{y0 = N\_VNew\_ParHyp(comm, Nlocal, N);}

  and load initial values into the structure defined by:

  {\s} \id{NV\_DATA\_S(y0)}

  {\omp} \id{NV\_DATA\_OMP(y0)}

  {\pt} \id{NV\_DATA\_PT(y0)}

  {\p} \id{NV\_DATA\_P(y0)}

  {\h} \id{NV\_DATA\_PH(y0)}

  Here \id{comm} is the MPI communicator, set in one of two ways: 
  If a proper subset of active processors is to be used, \id{comm} 
  must be set by suitable MPI calls. Otherwise, to specify that all 
  processors are to be used, \id{comm} must be \id{MPI\_COMM\_WORLD}.
  
  The initial conditions for $\dot{y}$ are set similarly.

\item\label{i:ida_create} 
  {\bf Create {\idas} object}

  Call \id{ida\_mem = }\id{IDACreate}\id{()} 
  to create the {\idas} memory block.
  \id{IDACreate} returns a pointer to the {\idas} memory structure.
  See \S\ref{sss:idainit} for details.
  This \id{void *} pointer must then be passed as the first argument
  to all subsequent {\idas} function calls.

\item\label{i:ida_init} 
  {\bf Initialize {\idas} solver}

  Call \id{IDAInit}\id{(...)} to provide required problem
  specifications (residual function, initial time, and initial conditions),
  allocate internal memory for {\idas}, and initialize {\idas}.
  \id{IDAInit} returns an error flag to indicate success or an illegal argument
  value.  See \S\ref{sss:idainit} for details.
  
\item
  {\bf Specify integration tolerances}

  Call \id{IDASStolerances}\id{(...)} or \id{IDASVtolerances}\id{(...)}
  to specify, respectively, a scalar relative tolerance and scalar
  absolute tolerance, or a scalar relative tolerance and a vector of
  absolute tolerances.  Alternatively, call \id{IDAWFtolerances} to
  specify a function which sets directly the weights used in
  evaluating WRMS vector norms.  See \S\ref{sss:idatolerances} for
  details.

\item
  {\bf Set optional inputs}

  Optionally, call \id{IDASet*} functions to change from their default values any
  optional inputs that control the behavior of {\idas}.
  See \S\ref{sss:optin_main} for details.

\item\label{i:lin_solver} 
  {\bf Attach linear solver module}

  Initialize the linear solver module
  with one of the following calls (for details see \S\ref{sss:lin_solv_init}):

  {\s, \omp, \pt} \id{flag = }\Id{IDADense}\id{(...);}

  {\s, \omp, \pt} \id{flag = }\Id{IDABand}\id{(...);}

  {\s, \omp, \pt} \id{flag = }\Id{IDALapackDense}\id{(...);}

  {\s, \omp, \pt} \id{flag = }\Id{IDALapackBand}\id{(...);}

  {\s, \omp, \pt} \id{flag = }\Id{IDAKLU}\id{(...);}

  {\s, \omp, \pt} \id{flag = }\Id{IDASuperLUMT}\id{(...);}

  \id{flag = }\Id{IDASpgmr}\id{(...);}

  \id{flag = }\Id{IDASpbcg}\id{(...);}

  \id{flag = }\Id{IDASptfqmr}\id{(...);}

\item
  {\bf Set linear solver optional inputs}

  Optionally, call \id{IDA*Set*} functions from the selected linear solver module to
  change optional inputs specific to that linear solver.
  See \S\ref{sss:optin_dls} and \S\ref{sss:optin_spils} for details.

\item 
  {\bf Correct initial values}

  Optionally, call \id{IDACalcIC} to correct the initial values
  \id{y0} and \id{yp0} passed to \id{IDAInit}.  See \S\ref{ss:idacalcic}.
  Also see \S\ref{sss:optin_iccalc} for relevant optional input calls.

\item
  {\bf Specify rootfinding problem}
  \index{Rootfinding}

  Optionally, call \id{IDARootInit} to initialize a rootfinding problem
  to be solved during the integration of the DAE system.
  See \S\ref{ss:idarootinit} for details, and see \S\ref{sss:optin_root}
  for relevant optional input calls.

\item
  {\bf Advance solution in time}

  For each point at which output is desired, call
  \id{flag = }\Id{IDASolve}\id{(ida\_mem, tout, \&tret, yret, ypret, itask)}.
  Here \id{itask} specifies the return mode.  The vector \id{yret}
  (which can be the same as the vector \id{y0} above) will contain $y(t)$,
  while the vector \id{ypret} will contain $\dot{y}(t)$.
  See \S\ref{sss:idasolve} for details.
  
\item
  {\bf Get optional outputs}

  Call \id{IDA*Get*} functions to obtain optional output.
  See \S\ref{ss:optional_output} for details.

\item
  {\bf Deallocate memory for solution vectors}

  Upon completion of the integration, deallocate memory for the vectors \id{yret}
  and \id{ypret} by calling the destructor function defined by the {\nvector} 
  implementation:

  {\s} \id{N\_VDestroy\_Serial(yret);}

  {\omp} \id{N\_VDestroy\_OpenMP(y);}

  {\pt} \id{N\_VDestroy\_Pthreads(y);}
  
  {\p} \id{N\_VDestroy\_Parallel(yret);}

  {\h} \id{N\_VDestroy\_ParHyp(y);}

  and similarly for \id{ypret}.
  
\item
  {\bf Free solver memory}

  \Id{IDAFree}\id{(\&ida\_mem)} to free the memory allocated for {\idas}.
  
\item 
  {\bf {\p} {\h} Finalize MPI}
  
  Call \id{MPI\_Finalize()} to terminate MPI.

\end{Steps}

%%===================================================================================
\section{User-callable functions}\label{ss:callable_fct_sim}
%%===================================================================================

This section describes the {\idas} functions that are called by the
user to set up and solve a DAE. Some of these are required. However,
starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs can be
skipped for a casual use of {\idas}. In any case, refer to
\S\ref{ss:skeleton_sim} for the correct order of these calls.

On an error, each user-callable function returns a negative value and
sends an error message to the error handler routine, which prints the
message on \id{stderr} by default. However, the user can set a file
as error output or can provide his own error handler function (see
\S\ref{sss:optin_main}).

\subsection{IDAS initialization and deallocation functions}
\label{sss:idainit}
%%
The following three functions must be called in the order listed. The last one
is to be called only after the DAE solution is complete, as it frees the {\idas}
memory block created and allocated by the first two calls.
%%
\ucfunction{IDACreate}
{
  ida\_mem = IDACreate();
}
{
  The function \ID{IDACreate} instantiates an {\idas} solver object.
}
{
  \id{IDACreate} has no arguments.
}
{
  If successful, \id{IDACreate} returns a pointer to the newly created 
  {\idas} memory block (of type \id{void *}).  Otherwise it returns \id{NULL}.
}
{}
%%
%%
\ucfunction{IDAInit}
{
  flag = IDAInit(ida\_mem, res, t0, y0, yp0);
}
{
  The function \ID{IDAInit} provides required problem and solution
  specifications, allocates internal memory, and initializes {\idas}.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[res] (\Id{IDAResFn})
    is the {\CC} function which computes the residual function $F$ in the DAE.
     This function has the form \id{res(t, yy, yp, resval, user\_data)}.
     For full details see \S\ref{ss:resFn}.
  \item[t0] (\id{realtype})
    is the initial value of $t$.
  \item[y0] (\id{N\_Vector})
    is the initial value of $y$. 
  \item[yp0] (\id{N\_Vector})
    is the initial value of $\dot{y}$. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAInit} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_ILL\_INPUT}] 
    An input argument to \id{IDAInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{IDAInit} also sends an error message to the
  error handler function.
}
%%
%%
\ucfunction{IDAFree}
{
  IDAFree(\&ida\_mem);
}
{
  The function \ID{IDAFree} frees the pointer allocated by
  a previous call to \id{IDACreate}.
}
{
  The argument is the pointer to the {\idas} memory block (of type \id{void *}).
}
{
  The function \id{IDAFree} has no return value.
}
{}


%%==============================================================================
\subsection{IDAS tolerance specification functions}\label{sss:idatolerances}
%%==============================================================================
%%
One of the following three functions must be called to specify the
integration tolerances (or directly specify the weights used in
evaluating WRMS vector norms).  Note that this call must be made after
the call to \id{IDAInit}.
%%
\ucfunction{IDASStolerances}
{
  flag = IDASStolerances(ida\_mem, reltol, abstol);
}
{
  The function \ID{IDASStolerances} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDASStolerances} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \item[\Id{IDA\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASVtolerances}
{
  flag = IDASVtolerances(ida\_mem, reltol, abstol);
}
{
  The function \ID{IDASVtolerances} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDASVtolerances} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \item[\Id{IDA\_ILL\_INPUT}] 
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the state vector $y$. 
}
%%
%%
\ucfunction{IDAWFtolerances}
{
  flag = IDAWFtolerances(ida\_mem, efun);
}
{
  The function \ID{IDAWFtolerances} specifies a user-supplied function \id{efun}
  that sets the multiplicative error weights $W_i$ for use in the weighted
  RMS norm, which are normally defined by Eq. (\ref{e:errwt}).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[efun] (\id{IDAEwtFn}) 
    is the {\CC} function which defines the \id{ewt} vector (see
    \S\ref{ss:ewtsetFn}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAWFtolerances} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \end{args}
}
{}

\index{tolerances}
{\bf General advice on choice of tolerances.}
For many users, the appropriate choices for tolerance values in
\id{reltol} and \id{abstol} are a concern.  The following pieces of
advice are relevant.

(1) The scalar relative tolerance \id{reltol} is to be set to control relative
errors.  So \id{reltol}=$10^{-4}$ means that errors are controlled to .01\%.  We
do not recommend using \id{reltol} larger than $10^{-3}$.  On the other hand,
\id{reltol} should not be so small that it is comparable to the unit roundoff
of the machine arithmetic (generally around $10^{-15}$).

(2) The absolute tolerances \id{abstol} (whether scalar or vector) need to
be set to control absolute errors when any components of the solution
vector \id{y} may be so small that pure relative error control is
meaningless.  For example, if \id{y[i]} starts at some nonzero value, but in time
decays to zero, then pure relative error control on \id{y[i]} makes no sense
(and is overly costly) after \id{y[i]} is below some noise level.  Then
\id{abstol} (if scalar) or \id{abstol[i]} (if a vector) needs to be set to that
noise level.  If the different components have different noise levels,
then \id{abstol} should be a vector.  See the example \id{idasRoberts\_dns} in the
{\idas} package, and the discussion of it in the {\idas} Examples document
\cite{idas_ex}.
In that problem, the three components vary between 0 and 1, and have
different noise levels; hence the \id{abstol} vector.  It is impossible to
give any general advice on \id{abstol} values, because the appropriate noise
levels are completely problem-dependent.  The user or modeler hopefully has
some idea as to what those noise levels are.

(3) Finally, it is important to pick all the tolerance values conservatively,
because they control the error committed on each individual time step.
The final (global) errors are a sort of accumulation of those
per-step errors.  A good rule of thumb is to reduce the tolerances by a
factor of .01 from the actual desired limits on errors.  So if you
want .01\% accuracy (globally), a good choice is \id{reltol}$=10^{-6}$.
But in any case, it is a good idea to do a few experiments with
the tolerances to see how the computed solution values vary as
tolerances are reduced.

\vspace{0.1in}
\index{tolerances}
{\bf Advice on controlling unphysical negative values.}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the numerical
solution, however, small negative (hence unphysical) values can then
occur.  In most cases, these values are harmless, and simply need to
be controlled, not eliminated. The following pieces of advice are relevant.

(1) The way to control the size of unwanted negative computed values
is with tighter absolute tolerances.  Again this requires some
knowledge of the noise level of these components, which may or may not
be different for different components.  Some experimentation may be
needed.

(2) If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of avoiding
a long explanation of them, if nothing else), then eliminate them, but
only in the context of the output medium.  Then the internal values carried
by the solver are unaffected.  Remember that a small negative value in \id{yret}
returned by {\idas}, with magnitude comparable to \id{abstol} or less,
is equivalent to zero as far as the computation is concerned.

(3) The user's residual routine \id{res} should never change a
negative value in the solution vector \id{yy} to a non-negative value,
as a "solution" to this problem.  This can cause instability.  If the
\id{res} routine cannot tolerate a zero or negative value (e.g. because
there is a square root or log of it), then the offending value should
be changed to zero or a tiny positive number in a temporary variable
(not in the input \id{yy} vector) for the purposes of computing $F(t,y,\dot{y})$.

(4) {\idas} provides the option of enforcing positivity or non-negativity
on components.  Also, such constraints can be enforced by use of the
recoverable error return feature in the user-supplied residual function.
However, because these options involve some extra overhead cost, they
should only be exercised if the use of absolute tolerances to control
the computed values is unsuccessful.
%%
%%==================================================================================
%%
\subsection{Linear solver specification functions}\label{sss:lin_solv_init}

As previously explained, Newton iteration requires the solution of
linear systems of the form (\ref{e:DAE_Newtoncorr}).  There are seven
{\idas} linear solvers currently available for this task: {\idadense},
{\idaband}, {\idaklu}, {\idasuperlumt}, {\idaspgmr}, {\idaspbcg}, and
{\idasptfqmr}.

The first two linear solvers are direct and derive their
names from the type of approximation used for the Jacobian 
$J = \partial{F}/\partial{y} + \alpha \partial{F}/\partial{\dot{y}}$.
{\idadense} and {\idaband} work with dense and banded approximations to $J$,
respectively. The {\sundials} suite includes both internal implementations of
these two linear solvers and interfaces to Lapack implementations.
Together, these linear solvers are referred to as {\idadls} (from Direct
Linear Solvers).

The second two linear solvers are sparse direct solvers based on
Gaussian elimination, and require user-supplied routines to construct
the Jacobian $J = \partial{F}/\partial{y} + \alpha
\partial{F}/\partial{\dot{y}}$ in compressed-sparse-column format. The
{\sundials} suite does not include internal implementations of these
solver libraries, instead requiring compilation of {\sundials} to link
with existing installations of these libraries (if either is missing,
{\sundials} will install without the corresponding interface
routines).  Together, these linear solvers are referred to as {\cvsls}
(from Sparse Linear Solvers). 

The remaining three {\idas} linear solvers, {\idaspgmr}, {\idaspbcg},
and {\idasptfqmr}, are Krylov iterative solvers. The {\spgmr}, {\spbcg}, and
{\sptfqmr} in the names indicate the scaled preconditioned GMRES, scaled
preconditioned Bi-CGStab, and scaled preconditioned TFQMR methods, respectively.
Together, they are referred to as {\idaspils} (from Scaled Preconditioned 
Iterative Linear Solvers).

When using any of the Krylov linear solvers, preconditioning (on the left)
is permitted, and in fact encouraged, for the sake of efficiency.
A preconditioner matrix $P$ must approximate the Jacobian $J$, at least
crudely.  For the specification of a preconditioner, see \S\ref{sss:optin_spils}
and \S\ref{ss:user_fct_sim}.

\index{IDAS@{\idas} linear solvers!selecting one|(} 
To specify an {\idas} linear solver, after the call to \id{IDACreate} but
before any calls to \id{IDASolve}, the user's program must call one of the
functions \Id{IDADense}/\Id{IDALapackDense}, \Id{IDABand}/\Id{IDALapackBand},
\Id{IDAKLU}, \Id{IDASuperLUMT}, \Id{IDASpgmr}, \Id{IDASpbcg}, or
\Id{IDASptfqmr}, as documented below. 
The first argument passed to these functions
is the {\idas} memory pointer returned by \id{IDACreate}.  A call to one of these
functions links the main {\idas} integrator to a linear solver and
allows the user to specify parameters which are specific to a
particular solver, such as the bandwidths in the {\idaband} case.
%%
The use of each of the linear solvers involves certain constants and possibly 
some macros, that are likely to be needed in the user code.  These are
available in the corresponding header file associated with the linear
solver, as specified below.
\index{IDAS@{\idas} linear solvers!selecting one|)}

\index{IDAS@{\idas} linear solvers!built on generic solvers|(} 
In each case the linear solver module used by {\idas} is actually
built on top of a generic linear system solver, which may be of
interest in itself.  These generic solvers, denoted {\dense}, {\band},
{\klu}, {\superlumt}, {\spgmr}, {\spbcg}, and {\sptfqmr}, are
described separately in Chapter \ref{s:gen_linsolv}.
\index{IDAS@{\idas} linear solvers!built on generic solvers|)}
%%
%%
%%
\index{IDAS@{\idas} linear solvers!IDADENSE@{\idadense}}
\index{IDADENSE@{\idadense} linear solver!selection of}
\index{IDADENSE@{\idadense} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{IDADense}
{
  flag = IDADense(ida\_mem, N);
}
{
  The function \ID{IDADense} selects the {\idadense} linear solver and indicates
  the use of the internal direct dense linear algebra functions. 

  The user's main program must include the \id{idas\_dense.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_ILL\_INPUT]
  \item[\Id{IDADLS\_SUCCESS}] 
    The {\idadense} initialization was successful.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_ILL\_INPUT}]
    The {\idadense} solver is not compatible with the current {\nvector} module.
  \item[\Id{IDADLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\idadense} linear solver is not compatible with all
  implementations of the {\nvector} module. 
  Of the {\nvector} modules provided with {\sundials}, only {\nvecs},
  {\nvecopenmp}, and {\nvecpthreads} are compatible, while {\nvecp} and
  {\nvecph} are not.
}
%%
%%
\ucfunction{IDALapackDense}
{
  flag = IDALapackDense(ida\_mem, N);
}
{
  The function \ID{IDALapackDense} selects the {\idadense} linear solver and 
  indicates the use of Lapack functions. 

  The user's main program must include the \id{idas\_lapack.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[N] (\id{int})
    problem dimension.
  \end{args}
}
{
  The values of the returned \id{flag} (of type \id{int}) are identical
  to those of \id{IDADense}.
}
{
  Note that \id{N} is restricted to be of type \id{int} here, because
  of the corresponding type restriction in the Lapack solvers.
}
%%
%%
\index{IDAS@{\idas} linear solvers!IDABAND@{\idaband}}
\index{IDABAND@{\idaband} linear solver!selection of}
\index{IDABAND@{\idaband} linear solver!NVECTOR@{\nvector} compatibility}
\index{half-bandwidths}
\ucfunction{IDABand}
{
  flag = IDABand(ida\_mem, N, mupper, mlower);
}
{
  The function \ID{IDABand} selects the {\idaband} linear solver and indicates
  the use of the internal direct band linear algebra functions.

  The user's main program must include the \id{idas\_band.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \item[mupper] (\id{long int})
    upper half-bandwidth of the problem Jacobian (or of the approximation of it).
  \item[mlower] (\id{long int})
    lower half-bandwidth of the problem Jacobian (or of the approximation of it).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDABAND\_ILL\_INPUT]
  \item[\Id{IDABAND\_SUCCESS}] 
    The {\idaband} initialization was successful.
  \item[\Id{IDABAND\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDABAND\_ILL\_INPUT}]
    The {\idaband} solver is not compatible with the current {\nvector} module, or
    one of the Jacobian half-bandwidths is outside its valid range ($0 \ldots$
    \id{N}$-1$).
  \item[\Id{IDABAND\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\idaband} linear solver is not compatible with all
  implementations of the {\nvector} module.  Of the {\nvector} modules
  provided with {\sundials}, only {\nvecs}, {\nvecopenmp} and
  {\nvecpthreads} are compatible, while {\nvecp} and {\nvecph} are not. 
  The half-bandwidths are to be set so that the nonzero locations $(i,j)$ in the
  banded (approximate) Jacobian satisfy $-$\id{mlower} $\leq j-i \leq$ \id{mupper}.
}
%%
%%
\ucfunction{IDALapackBand}
{
  flag = IDALapackBand(ida\_mem, N, mupper, mlower);
}
{
  The function \ID{IDALapackBand} selects the {\idaband} linear solver and
  indicates the use of Lapack functions. 

  The user's main program must include the \id{idas\_lapack.h} header file.
}
{
  The input arguments are identical to those of \id{IDABand}, except
  that \id{N}, \id{mupper}, and \id{mlower} are of type \id{int} here.
}
{
  The values of the returned \id{flag} (of type \id{int}) are identical
  to those of \id{IDABand}.
}
{
  Note that \id{N}, \id{mupper}, and \id{mlower} are restricted to be of type \id{int}
  here, because of the corresponding type restriction in the Lapack solvers.
}
%%
%%
\index{IDAS@{\idas} linear solvers!IDAKLU@{\idaklu}}
\index{IDAKLU@{\idaklu} linear solver!selection of}
\index{IDAKLU@{\idaklu} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{IDAKLU}
{
  flag = IDAKLU(ida\_mem, NP, NNZ, sparsetype);
}
{
  The function \ID{IDAKLU} selects the {\idaklu} linear solver and indicates
  the use of sparse direct linear algebra functions. 

  The user's main program must include the \id{idas\_sparse.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[NP] (\id{int})
    problem dimension.
  \item[NNZ] (\id{int})
    maximum number of nonzero entries in the system Jacobian.
  \item[sparsetype] (\id{int})
    sparse storage type of the system Jacobian. If \Id{sparsetype} is  
    set to \Id{CSC\_MAT} the solver will expect the Jacobian to be stored as 
    a compressed sparse column matrix, and if \Id{sparsetype=CSR\_MAT} 
    the solver will expect a compressed sparse row matrix. 
    If neither option is chosen, the solver will exit with error.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_ILL\_INPUT]
  \item[\Id{IDASLS\_SUCCESS}] 
    The {\idaklu} initialization was successful.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The {\idaklu} solver is not compatible with the current {\nvector} module.
  \item[\Id{IDASLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{IDASLS\_PACKAGE\_FAIL}]
    A call to the KLU library returned a failure flag.
  \end{args}
}
{
  The {\idaklu} linear solver is not compatible with all
  implementations of the {\nvector} module. 
  Of the {\nvector} modules provided with {\sundials}, only {\nvecs},
  {\nvecopenmp} and {\nvecpthreads} are compatible, while {\nvecp} and
  {\nvecph} are not.
}
%%
%%
\index{IDAS@{\idas} linear solvers!IDASUPERLUMT@{\idasuperlumt}}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!selection of}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{IDASuperLUMT}
{
  flag = IDASuperLUMT(ida\_mem, num\_threads, N, NNZ);
}
{
  The function \ID{IDASuperLUMT} selects the {\idasuperlumt} linear
  solver and indicates the use of sparse direct linear
  algebra functions.  

  The user's main program must include the \id{idas\_superlumt.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[num\_threads] (\id{int})
    the number of threads to use when factoring/solving the linear systems.
    Note that SuperLU\_MT is thread-parallel only in the factorization routine.
  \item[N] (\id{int})
    problem dimension.
  \item[NNZ] (\id{int})
    maximum number of nonzero entries in the system Jacobian.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_ILL\_INPUT]
  \item[\Id{IDASLS\_SUCCESS}] 
    The {\idasuperlumt} initialization was successful.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The {\idasuperlumt} solver is not compatible with the current {\nvector} module.
  \item[\Id{IDASLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{IDASLS\_PACKAGE\_FAIL}]
    A call to the SuperLU\_MT library returned a failure flag.
  \end{args}
}
{
  The {\idasuperlumt} linear solver is not compatible with all
  implementations of the {\nvector} module. 
  Of the {\nvector} modules provided with {\sundials}, only {\nvecs},
  {\nvecopenmp} and {\nvecpthreads} are compatible, while {\nvecp} and
  {\nvecph} are not.

  {\warn}Performance will significantly degrade if the user applies the SuperLU\_MT
  package compiled with PThreads while using the {\nvecopenmp} module.
  If a user wants to use a threaded vector kernel with this thread-parallel
  solver, then SuperLU\_MT should be compiled with openMP and the {\nvecopenmp}
  module should be used.  Also, note that the expected benefit of using the threaded
  vector kernel is minimal compared to the potential benefit of the threaded solver,
  unless very long (greater than 100,000 entries) vectors are used.
}
%%
\index{IDAS@{\idas} linear solvers!IDASPGMR@{\idaspgmr}}
\index{IDASPGMR@{\idaspgmr} linear solver!selection of} 
\ucfunction{IDASpgmr}
{
  flag = IDASpgmr(ida\_mem, maxl);
}
{
  The function \ID{IDASpgmr} selects the {\idaspgmr} linear solver. 

  The user's main program must include the \id{idas\_spgmr.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{IDA\_SPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_MEM\_NULL]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The {\idaspgmr} initialization was successful.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}
%%
%%
%%
\index{IDAS@{\idas} linear solvers!IDASPBCG@{\idaspbcg}}
\index{IDASPBCG@{\idaspbcg} linear solver!selection of} 
\ucfunction{IDASpbcg}
{
  flag = IDASpbcg(ida\_mem, maxl);
}
{
  The function \ID{IDASpbcg} selects the {\idaspbcg} linear solver. 

  The user's main program must include the \id{idas\_spbcgs.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{IDA\_SPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_MEM\_NULL]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The {\idaspbcg} initialization was successful.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}
%%
%%
%%
\index{IDAS@{\idas} linear solvers!IDASPTFQMR@{\idasptfqmr}}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!selection of} 
\ucfunction{IDASptfqmr}
{
  flag = IDASptfqmr(ida\_mem, maxl);
}
{
  The function \ID{IDASptfqmr} selects the {\idasptfqmr} linear solver. 

  The user's main program must include the \id{idas\_sptfqmr.h} header file.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxl] (\id{int})
    \index{maxl@\texttt{maxl}}
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{IDA\_SPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_MEM\_NULL]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The {\idasptfqmr} initialization was successful.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}

%%===================================================================================

\subsection{Initial condition calculation function}\label{ss:idacalcic}

\id{IDACalcIC} calculates corrected initial conditions for the DAE system
for certain index-one problems including a class of systems of semi-implicit
form.  (See \S{\ref{ss:ivp_sol} and Ref. \cite{BHP:98}.)
It uses Newton iteration combined with a linesearch algorithm.
Calling \id{IDACalcIC} is optional. It is only necessary when the  
initial conditions do not satisfy the given system.  Thus if   
\id{y0} and \id{yp0} are known to satisfy $F(t_0, y_0, \dot{y}_0) = 0$, 
then a call to \id{IDACalcIC} is generally {\em not} necessary.

A call to the function \id{IDACalcIC} must be preceded by successful calls to  
\id{IDACreate} and \id{IDAInit} (or \id{IDAReInit}), and by a 
successful call to the linear system solver specification function.  
The call to \id{IDACalcIC} should precede the call(s) to \id{IDASolve}  
for the given problem.
%
\ucfunction{IDACalcIC}
{
  flag = IDACalcIC(ida\_mem, icopt, tout1);
}
{
  The function \ID{IDACalcIC} corrects the initial values \id{y0} and \id{yp0} at
  time \id{t0}.
}
{
  \begin{args}[ida\_mem]

  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.

  \item[icopt] (\id{int})
    is one of the following two options for the initial condition calculation.
    
    \id{icopt}$ = $\ID{IDA\_YA\_YDP\_INIT} directs \id{IDACalcIC} to compute 
    the algebraic components of $y$ and differential components of $\dot{y}$, 
    given the differential components of $y$.  
    This option requires that the \id{N\_Vector} \id{id} was set through 
    \id{IDASetId}, specifying the differential and algebraic components.  
    
    \id{icopt}$ = $\ID{IDA\_Y\_INIT} directs \id{IDACalcIC} to compute all  
    components of $y$, given $\dot{y}$.  In this case, \id{id} is not required.

  \item[tout1] (\id{realtype})
    is the first value of $t$ at which a solution will be requested (from
    \id{IDASolve}).  This value is needed here only to determine the direction of
    integration and rough scale in the independent variable $t$.   

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:

  \begin{args}[IDA\_LINESEARCH\_FAIL]

  \item[\Id{IDA\_SUCCESS}]
    \id{IDASolve} succeeded.

  \item[\Id{IDA\_MEM\_NULL}]
    The argument \id{ida\_mem} was \id{NULL}.             
               
  \item[\Id{IDA\_NO\_MALLOC}]
    The allocation function \id{IDAInit} has not been called.
                                                  
  \item[\Id{IDA\_ILL\_INPUT}]
    One of the input arguments was illegal.    
                                                                 
  \item[\Id{IDA\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.

  \item[\Id{IDA\_LINIT\_FAIL}]
    The linear solver's initialization function failed.   
                                                                 
  \item[\Id{IDA\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.

  \item[\Id{IDA\_BAD\_EWT}]
    Some component of the error weight vector is zero (illegal), either for 
    the input value of \id{y0} or a corrected value.          
                                                                 
  \item[\Id{IDA\_FIRST\_RES\_FAIL}]
    The user's residual function returned a recoverable error flag on the first
    call, but \id{IDACalcIC} was unable to recover.       
                                                                 
  \item[\Id{IDA\_RES\_FAIL}]
    The user's residual function returned a nonrecoverable error flag.

  \item[\Id{IDA\_NO\_RECOVERY}]
    The user's residual function, or the linear solver's setup or solve function
    had a recoverable error, but \id{IDACalcIC} was unable to recover.
                                                                 
  \item[\Id{IDA\_CONSTR\_FAIL}]
    \id{IDACalcIC} was unable to find a solution    
    satisfying the inequality constraints.     
                                                                 
  \item[\Id{IDA\_LINESEARCH\_FAIL}]
    The linesearch algorithm failed to find a solution with a step larger than 
    \id{steptol} in weighted RMS norm, and within the allowed number of backtracks.
 
  \item[\Id{IDA\_CONV\_FAIL}]
    \id{IDACalcIC} failed to get convergence of the Newton iterations.

  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{IDACalcIC} failures.

  Note that \id{IDACalcIC} will correct the values of $y(t_0)$ and $\dot{y}(t_0)$
  which were specified in the previous call to \id{IDAInit} or \id{IDAReInit}.
  To obtain the corrected values, call \id{IDAGetconsistentIC} (see \S\ref{sss:optout_iccalc}).
}


%%===================================================================================
\subsection{Rootfinding initialization function}\label{ss:idarootinit}
\index{Rootfinding}

While integrating the IVP, {\idas} has the capability of finding the
roots of a set of user-defined functions. To activate the rootfinding 
algorithm, call the following function.  This is normally called only
once, prior to the first call to \id{IDASolve}, but if the rootfinding
problem is to be changed during the solution, \id{IDARootInit} can also
be called prior to a continuation call to \id{IDASolve}. 
%%
%%
\ucfunction{IDARootInit}
{
  flag = IDARootInit(ida\_mem, nrtfn, g);
}
{
  The function \ID{IDARootInit} specifies that the roots of a set of
  functions $g_i(t,y,\dot{y})$ are to be found while the IVP is being solved.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[nrtfn] (\id{int})
    is the number of root functions $g_i$.
  \item[g] (\id{IDARootFn})
    is the {\CC} function which defines the \id{nrtfn} functions $g_i(t,y,\dot{y})$
    whose roots are sought. See \S\ref{ss:rootFn} for details.
 \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[IDA\_SUCCESS]
    The call to \id{IDARootInit} was successful.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} argument was \id{NULL}.
  \item[IDA\_MEM\_FAIL]
    A memory allocation failed.
  \item[IDA\_ILL\_INPUT]
    The function \id{g} is \id{NULL}, but \id{nrtfn}$>0$.
  \end{args}
}
{
  If a new IVP is to be solved with a call to \id{IDAReInit}, where the new
  IVP has no rootfinding problem but the prior one did, then call
  \id{IDARootInit} with \id{nrtfn}$=0$.
}


%%===================================================================================

\subsection{IDAS solver function}\label{sss:idasolve}
%
This is the central step in the solution process, the call to perform the
integration of the DAE.  One of the input arguments (\id{itask})
specifies one of two modes as to where {\idas} is to return a solution.
But these modes are modified if the user has set a stop time (with
\id{IDASetStopTime}) or requested rootfinding.
%
\ucfunction{IDASolve}
{
  flag = IDASolve(ida\_mem, tout, \&tret, yret, ypret, itask);
}
{
  The function \ID{IDASolve} integrates the DAE over an interval in $t$.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yret] (\id{N\_Vector})
    the computed solution vector $y$.
  \item[ypret] (\id{N\_Vector})
    the computed solution vector $\dot{y}$.
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}}
    a flag indicating the job of the solver for the next user step. 
    The \Id{IDA\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user specified \id{tout}
    parameter. The solver then interpolates in order to   
    return approximate values of $y($\id{tout}$)$ and $\dot{y}($\id{tout}$)$. 
    The \Id{IDA\_ONE\_STEP} option tells the solver to just take one internal step  
    and return the solution at the point reached by that step. 
  \end{args}
}
{
  \id{IDASolve} returns vectors \id{yret} and \id{ypret} and a
  corresponding independent variable value $t =$ \id{tret}, such that (\id{yret},
  \id{ypret}) are the computed values of ($y(t)$, $\dot{y}(t)$).

  In \id{IDA\_NORMAL} mode with no errors, \id{tret} will be equal to \id{tout} 
  and \id{yret} = $y($\id{tout}$)$, \id{ypret} = $\dot{y}($\id{tout}$)$.

  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_TOO\_MUCH\_WORK]
  \item[\Id{IDA\_SUCCESS}]
    \id{IDASolve} succeeded.
  \item[\Id{IDA\_TSTOP\_RETURN}]
    \id{IDASolve} succeeded by reaching the stop point specified through
    the optional input function \id{IDASetStopTime}.
  \item[\Id{IDA\_ROOT\_RETURN}]
    \id{IDASolve} succeeded and found one or more roots.  In this case,
    \id{tret} is the location of the root.  If \id{nrtfn} $>1$,
     call \id{IDAGetRootInfo} to see which $g_i$ were found to
     have a root.  See \S\ref{sss:optout_root} for more information.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} argument was \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    One of the inputs to \id{IDASolve} was illegal, or some other input to the
    solver was either illegal or missing.
    The latter category includes the following situations:
    (a) The tolerances have not been set.
    (b) A component of the error weight vector became zero during internal 
    time-stepping.
    (c) The linear solver initialization function (called by the user after calling
    \id{IDACreate}) failed to set the linear solver-specific \id{lsolve} field in
    \id{ida\_mem}.
    (d) A root of one of the root functions was found both at a point $t$ and also
    very near $t$.
    In any case, the user should see the printed error message for details.
  \item[\Id{IDA\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tout}. 
    The default value for \id{mxstep} is \id{MXSTEP\_DEFAULT = 500}.
  \item[\Id{IDA\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{IDA\_ERR\_FAIL}]
    Error test failures occurred too many times (\id{MXNEF = 10}) during one 
    internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{IDA\_CONV\_FAIL}] 
    Convergence test failures occurred too many times (\id{MXNCF = 10}) during 
    one internal time step or occurred with $|h| = h_{min}$.             
  \item[\Id{IDA\_LINIT\_FAIL}]
    The linear solver's initialization function failed.   
  \item[\Id{IDA\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{IDA\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{IDA\_CONSTR\_FAIL}]
    The inequality constraints were violated and the solver was unable
    to recover.
  \item[\Id{IDA\_REP\_RES\_ERR}]
    The user's residual function repeatedly returned a recoverable error
    flag, but the solver was unable to recover.
  \item[\Id{IDA\_RES\_FAIL}]
    The user's residual function returned a nonrecoverable error flag.
  \item[\Id{IDA\_RTFUNC\_FAIL}] 
    The rootfinding function failed.
  \end{args} 
}
{
  The vector \id{yret} can occupy the same space as the vector \id{y0} of 
  initial conditions that was passed to \id{IDAInit}, and the
  vector \id{ypret} can occupy the same space as \id{yp0}.

  In the \id{IDA\_ONE\_STEP} mode, \id{tout} is used on the first call only,
  and only to get the direction and rough scale of the independent variable.

  All failure return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{IDASolve} failures.

  On any error return in which one or more internal steps were taken by
  \id{IDASolve}, the returned values of \id{tret}, \id{yret}, and \id{ypret}
  correspond to the farthest point reached in the integration.
  On all other error returns, these values are left unchanged from the
  previous \id{IDASolve} return.
}

%%===================================================================================

\subsection{Optional input functions}\label{ss:optional_input}

There are numerous optional input parameters that control the behavior
of the {\idas} solver.  {\idas} provides functions that can be used to change
these optional input parameters from their default values. 
Table \ref{t:optional_input} lists all optional input functions in {\idas} which 
are then described in detail in the remainder of this section.
For the most casual use of {\idas}, the reader can skip to \S\ref{ss:user_fct_sim}.

We note that, on an error return, all these functions also send an error message to
the error handler function.
\index{error messages}
We also note that all error return values are negative, 
so a test \id{flag} $<0$ will catch any error.

\begin{table}
\centering
\caption{Optional inputs for {\idas}, {\idadls}, {\idasls}, and {\idaspils}}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf IDAS main solver} \\
\hline
Pointer to an error file & \id{IDASetErrFile} & \id{stderr}  \\
Error handler function & \id{IDASetErrHandlerFn} & internal fn. \\
User data & \id{IDASetUserData} & \id{NULL} \\
Maximum order for BDF method & \id{IDASetMaxOrd} & 5 \\
Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$ & \id{IDASetMaxNumSteps} & 500 \\
Initial step size & \id{IDASetInitStep} & estimated \\
Maximum absolute step size & \id{IDASetMaxStep} & $\infty$ \\
Value of $t_{stop}$ & \id{IDASetStopTime} & $\infty$ \\
Maximum no. of error test failures & \id{IDASetMaxErrTestFails} & 10 \\
Maximum no. of nonlinear iterations & \id{IDASetMaxNonlinIters} & 4 \\
Maximum no. of convergence failures & \id{IDASetMaxConvFails} & 10 \\
Maximum no. of error test failures & \id{IDASetMaxErrTestFails} & 7 \\
Coeff. in the nonlinear convergence test & \id{IDASetNonlinConvCoef} & 0.33 \\
Suppress alg. vars. from error test & \id{IDASetSuppressAlg} & \id{FALSE} \\
Variable types (differential/algebraic) & \id{IDASetId} & \id{NULL} \\
Inequality constraints on solution & \id{IDASetConstraints} & \id{NULL} \\
Direction of zero-crossing & \id{IDASetRootDirection} & both \\
Disable rootfinding warnings & \id{IDASetNoInactiveRootWarn} & none \\
\hline
\multicolumn{3}{|c|}{\bf IDAS initial conditions calculation} \\
\hline
Coeff. in the nonlinear convergence test & \id{IDASetNonlinConvCoefIC} & 0.0033 \\
Maximum no. of steps & \id{IDASetMaxNumStepsIC} & 5 \\
Maximum no. of Jacobian/precond. evals. & \id{IDASetMaxNumJacsIC} & 4 \\
Maximum no. of Newton iterations & \id{IDASetMaxNumItersIC} & 10 \\
Max. linesearch backtracks per Newton iter. & \id{IDASetMaxBacksIC} & 100 \\
Turn off linesearch & \id{IDASetLineSearchOffIC} & \id{FALSE} \\
Lower bound on Newton step & \id{IDASetStepToleranceIC} &  uround$^{2/3}$ \\ 
\hline
\multicolumn{3}{|c|}{\bf IDADLS linear solvers} \\
\hline
Dense Jacobian function & \id{IDADlsSetDenseJacFn} & DQ\\
Band Jacobian function & \id{IDADlsSetBandJacFn} & DQ\\
\hline
\multicolumn{3}{|c|}{\bf IDASLS linear solvers} \\
\hline
Sparse Jacobian function & \id{IDASlsSetSparseJacFn} & none\\
Sparse matrix ordering algorithm & \id{IDAKLUSetOrdering} & 1 for \id{COLAMD} \\
Sparse matrix ordering algorithm & \id{IDASuperLUMTSetOrdering} & 3 for \id{COLAMD} \\
\hline
\multicolumn{3}{|c|}{\bf IDASPILS linear solvers} \\
\hline
Preconditioner functions & \id{IDASpilsSetPreconditioner} &NULL, NULL \\
Jacobian-times-vector function & \id{IDASpilsSetJacTimesVecFn} & DQ\\
Factor in linear convergence test & \id{IDASpilsSetEpsLin} & 0.05 \\
Factor in DQ increment calculation & \id{IDASpilsSetIncrementFactor} & 1.0 \\
Maximum no. of restarts ({\idaspgmr}) & \id{IDASpilsSetMaxRestarts} & 5 \\
Type of Gram-Schmidt orthogonalization ${}^{(a)}$& \id{IDASpilsSetGSType} & classical GS \\
Maximum Krylov subspace size${}^{(b)}$ & \id{IDASpilsSetMaxl} & 5 \\
\hline
\multicolumn{3}{l}{}\\
\multicolumn{3}{l}{${}^{(a)}$ Only for {\idaspgmr}}\\
\multicolumn{3}{l}{${}^{(b)}$ Only for {\idaspbcg} and {\idasptfqmr}}
\end{tabular}
\end{table}

\subsubsection{Main solver optional input functions}\label{sss:optin_main}
\index{optional input!solver|(}
The calls listed here can be executed in any order.
However, if the user's program calls either \id{IDASetErrFile} or
\id{IDASetErrHandlerFn}, then that call should appear first, in order to
take effect for any later error message.
%%
%%
\index{error messages!redirecting}
\ucfunction{IDASetErrFile}
{
flag = IDASetErrFile(ida\_mem, errfp);
}
{
  The function \ID{IDASetErrFile} specifies the pointer to the file
  where all {\idas} messages should be directed when the default
  {\idas} error handler function is used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}.

  Passing a value \id{NULL} disables all future error message output
  (except for the case in which the {\idas} memory pointer is \id{NULL}).
  This use of \id{IDASetErrFile} is strongly discouraged.

  {\warn}If \id{IDASetErrFile} is to be called, it should be called before any
  other optional input functions, in order to take effect for any later error
  message.
}
%%
%%
\index{error messages!user-defined handler}
\ucfunction{IDASetErrHandlerFn}
{
flag = IDASetErrHandlerFn(ida\_mem, ehfun, eh\_data);
}
{
  The function \ID{IDASetErrHandlerFn} specifies the optional user-defined function
  to be used in handling error messages.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ehfun] (\id{IDAErrHandlerFn}) 
    is the user's {\CC} error handler function (see \S\ref{ss:ehFn}).
  \item[eh\_data] (\id{void *})
    pointer to user data passed to \id{ehfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The function \id{ehfun} and data pointer \id{eh\_data} have been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Error messages indicating that the {\idas} solver memory is \id{NULL} will 
  always be directed to \id{stderr}.
}
%%
%%
\ucfunction{IDASetUserData}
{
  flag = IDASetUserData(ida\_mem, user\_data);
}
{
  The function \ID{IDASetUserData} specifies the user data block \Id{user\_data}
  and attaches it to the main {\idas} memory block.
}
{
  \begin{args}[user\_data]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[user\_data] (\id{void *})
    pointer to the user data.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If specified, the pointer to \id{user\_data} is passed to all user-supplied 
  functions that have it as an argument. Otherwise, a \id{NULL} pointer is passed.

  {\warn}If \id{user\_data} is needed in user preconditioner functions, the call to
  \id{IDASetUserData} must be made {\it before} the call to specify the
  linear solver.
}
%%
%%
\ucfunction{IDASetMaxOrd}
{
flag = IDASetMaxOrd(ida\_mem, maxord);
}
{
  The function \ID{IDASetMaxOrd} specifies the maximum order of the 
  linear multistep method.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxord] (\id{int})
    value of the maximum method order.  This must be positive.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The input value \id{maxord} is $\leq 0$, or larger than 
    its previous value.
  \end{args}
}
{ 
  The default value is $5$.  If the input value exceeds $5$,
  the value $5$ will be used.   Since \id{maxord} affects the memory
  requirements for the internal {\idas} memory block, its value cannot
  be increased past its previous value.
}
%%
%%
\ucfunction{IDASetMaxNumSteps}
{
flag = IDASetMaxNumSteps(ida\_mem, mxsteps);
}
{
  The function \ID{IDASetMaxNumSteps} specifies the maximum number
  of steps to be taken by the solver in its attempt to reach 
  the next output time.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[mxsteps] (\id{long int})
    maximum allowed number of steps.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Passing \id{mxsteps} $= 0$ results in {\idas} using the default value ($500$).

  Passing \id{mxsteps} $< 0$ disables the test (\it{not recommended}).
}
%%
%%
\ucfunction{IDASetInitStep}
{
flag = IDASetInitStep(ida\_mem, hin);
}
{
  The function \ID{IDASetInitStep} specifies the initial step size.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[hin] (\id{realtype})
    value of the initial step size to be attempted.
    Pass $0.0$ to have {\idas} use the default value.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  By default, {\idas} estimates the initial step as the solution of 
  $\|h \dot{y} \|_{\mbox{\scriptsize WRMS}} = 1/2$, with an added restriction
  that $|h| \leq .001|$\id{tout - t0}$|$.
}
%%
%%
\index{step size bounds|(}
%%
\ucfunction{IDASetMaxStep}
{
flag = IDASetMaxStep(ida\_mem, hmax);
}
{
  The function \ID{IDASetMaxStep} specifies the maximum absolute
  value of the step size.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[hmax] (\id{realtype})
    maximum absolute value of the step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    Either \id{hmax} is not positive or it is smaller than the minimum allowable
    step.
  \end{args}
}
{
  Pass \id{hmax}$=0$ to obtain the default value $\infty$.
}
\index{step size bounds|)}
%%
%%
\ucfunction{IDASetStopTime}
{
flag = IDASetStopTime(ida\_mem, tstop);
}
{
  The function \ID{IDASetStopTime} specifies the value of the
  independent variable $t$ past which the solution is not to proceed.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[tstop] (\id{realtype})
    value of the independent variable past which the solution should
    not proceed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}] 
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}] 
    The value of \id{tstop} is not beyond the current $t$ value, $t_n$.
  \end{args}
}
{
  The default, if this routine is not called, is that no stop time is imposed.
}
%%
%%
\ucfunction{IDASetMaxErrTestFails}
{
flag = IDASetMaxErrTestFails(ida\_mem, maxnef);
}
{
  The function \ID{IDASetMaxErrTestFails} specifies the
  maximum number of error test failures in attempting one step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxnef] (\id{int})
    maximum number of error test failures allowed on one step ($>0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $7$.
}
%%
%%
\ucfunction{IDASetMaxNonlinIters}
{
flag = IDASetMaxNonlinIters(ida\_mem, maxcor);
}
{
  The function \ID{IDASetMaxNonlinIters} specifies the maximum
  number of nonlinear solver iterations at one step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxcor] (\id{int})
    maximum number of nonlinear solver iterations allowed on one step ($>0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $3$.
}
%%
%%
\ucfunction{IDASetMaxConvFails}
{
flag = IDASetMaxConvFails(ida\_mem, maxncf);
}
{
  The function \ID{IDASetMaxConvFails} specifies the
  maximum number of nonlinear solver convergence failures at one step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxncf] (\id{int})
    maximum number of allowable nonlinear solver convergence failures
    on one step ($>0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $10$.
}
%%
%%
\ucfunction{IDASetNonlinConvCoef}
{
flag = IDASetNonlinConvCoef(ida\_mem, nlscoef);
}
{
  The function \ID{IDASetNonlinConvCoef} specifies the safety factor
  in the nonlinear convergence test;
  see Chapter \ref{s:math}, Eq. (\ref{e:DAE_nls_test}).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nlscoef] (\id{realtype})
    coefficient in nonlinear convergence test ($>0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The value of \id{nlscoef} is $<= 0.0$.
  \end{args}
}
{
  The default value is $0.33$.
}
%%
%%
\ucfunction{IDASetSuppressAlg}
{
flag = IDASetSuppressAlg(ida\_mem, suppressalg);
}
{
  The function \ID{IDASetSuppressAlg} indicates whether or not to
  suppress algebraic variables in the local error test.
}
{
  \begin{args}[suppressalg]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[suppressalg] (\id{booleantype})
    indicates whether to suppress (\id{TRUE}) or not
    (\id{FALSE}) the algebraic variables in the local error test.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is \id{FALSE}.

  If \id{suppressalg}$=$\id{TRUE} is selected, then the \id{id} vector
  must be set (through \id{IDASetId}) to specify the algebraic components.

  In general, the use of this option (with \id{suppressalg = TRUE}) is
  {\em discouraged} when solving DAE systems of index 1, whereas it is
  generally {\em encouraged} for systems of index 2 or more.
  See pp.~146-147 of Ref.~\cite{BCP:96} for more on this issue.
}
%%
%%
\ucfunction{IDASetId}
{
flag = IDASetId(ida\_mem, id);
}
{
  The function \ID{IDASetId} specifies algebraic/differential
  components in the $y$ vector.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[id] (\id{N\_Vector})
    state vector. A value of $1.0$ indicates a differential variable, while
    $0.0$ indicates an algebraic variable.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The vector \id{id} is required if the algebraic variables are to be 
  suppressed from the local error test (see \id{IDASetSuppressAlg}) or
  if \id{IDACalcIC} is to be called with \id{icopt} $=$ \id{IDA\_YA\_YDP\_INIT}
  (see \S\ref{ss:idacalcic}).
}
%%
%%
\ucfunction{IDASetConstraints}
{
flag = IDASetConstraints(ida\_mem, constraints);
}
{
  The function \ID{IDASetConstraints} specifies a vector defining
  inequality constraints for each component of the solution vector $y$.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[constraints] (\id{N\_Vector})
    vector of constraint flags. If \id{constraints[i]} is
    \begin{itemize}    
    \item[$0.0$] then no constraint is imposed on $y_i$. 
    \item[$1.0$] then $y_i$ will be constrained to be $y_i \ge 0.0$.
    \item[$-1.0$] then $y_i$ will be constrained to be $y_i \le 0.0$.
    \item[$2.0$] then $y_i$ will be constrained to be $y_i > 0.0$.
    \item[$-2.0$] then $y_i$ will be constrained to be $y_i < 0.0$.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The constraints vector contains illegal values.
  \end{args}
}
{
  The presence of a non-\id{NULL} constraints vector that is not $0.0$ in
  all components will cause constraint checking to be performed.
  However, a call with $0.0$ in all components of \id{constraints} will 
  result in an illegal input return.
}
\index{optional input!solver|)}

%%
%%
%%==================================================================================
%%
\subsubsection{Dense/band direct linear solvers optional input functions}
\label{sss:optin_dls}
\index{optional input!dense linear solver|(}
\index{optional input!band linear solver|(}
\index{IDADENSE@{\idadense} linear solver!optional input|(}
\index{IDABAND@{\idaband} linear solver!optional input|(}
The \index{IDADENSE@{\idadense} linear solver!Jacobian approximation used by}
{\idadense} solver needs a function to compute a dense approximation to
the Jacobian matrix $J(t,y,\dot{y})$.  
This function must be of type \id{IDADlsDenseJacFn}. 
The user can supply his/her own dense Jacobian function, or use the default 
internal difference quotient approximation
\index{Jacobian approximation function!dense!difference quotient}
that comes with the {\idadense} solver.
To specify a user-supplied Jacobian function \id{djac}, {\idadense} provides 
the function \id{IDADlsSetDenseJacFn}.
The {\idadense} solver passes the pointer \id{user\_data} 
to the dense Jacobian function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without
using global data in the program. 
The pointer \id{user\_data} may be specified through \id{IDASetUserData}.
%%
\index{Jacobian approximation function!dense!user-supplied}
\ucfunction{IDADlsSetDenseJacFn}
{
  flag = IDADlsSetDenseJacFn(ida\_mem, djac);
}
{
  The function \ID{IDADlsSetDenseJacFn} specifies the dense Jacobian
  approximation function to be used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[djac] (\id{IDADlsDenseJacFn})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_LMEM\_NULL]
  \item[\Id{IDADLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The {\idadense} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\idadense} uses an internal difference quotient function.
  If \id{NULL} is passed to \id{djac}, this default function is used.

  The function type \id{IDADlsDenseJacFn} is described in \S\ref{ss:djacFn}.
}
%%
%%
%%
The \index{IDABAND@{\idaband} linear solver!Jacobian approximation used by}
{\idaband} solver needs a function to compute a banded approximation to the
Jacobian matrix $J(t,y,\dot{y})$. This function must be of type \id{IDADlsBandJacFn}. 
The user can supply his/her own banded Jacobian approximation function, 
or use the default difference quotient function
\index{Jacobian approximation function!band!difference quotient}
that comes with the {\idaband} solver.
To specify a user-supplied Jacobian function \id{bjac}, {\idaband} provides
the function \id{IDADlsSetBandJacFn}.
The {\idaband} solver passes the pointer \id{user\_data}
to the banded Jacobian approximation function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without using
global data in the program.  The pointer \id{user\_data} may be 
specified through \id{IDASetUserData}.
%%
\index{Jacobian approximation function!band!user-supplied}
\ucfunction{IDADlsSetBandJacFn}
{
  flag = IDADlsSetBandJacFn(ida\_mem, bjac);
}
{
  The function \ID{IDADlsSetBandJacFn} specifies the banded Jacobian
  approximation function to be used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[bjac] (\id{IDADlsBandJacFn})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_LMEM\_NULL]
  \item[\Id{IDADLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The {\idaband} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\idaband} uses an internal difference quotient function.
  If \id{NULL} is passed to \id{bjac}, this default function is used.

  The function type \id{IDADlsBandJacFn} is described in \S\ref{ss:bjacFn}.
}
\index{IDABAND@{\idaband} linear solver!optional input|)}
\index{IDADENSE@{\idadense} linear solver!optional input|)}
\index{optional input!band linear solver|)}
\index{optional input!dense linear solver|)}

%%
%%
%%==================================================================================
%%
\subsubsection{Sparse direct linear solvers optional input functions}\label{sss:optin_sls}
\index{optional input!sparse linear solver|(}
\index{IDAKLU@{\idaklu} linear solver!optional input|(}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!optional input|(}
The \index{IDAKLU@{\idaklu} linear solver!Jacobian approximation used by}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!Jacobian approximation used by}
{\idaklu} and {\idasuperlumt} solvers require a function to compute a
compressed-sparse-column approximation ot the Jacobian matrix $J(t,y,\dot{y})$.  
This function must be of type \id{IDASlsSparseJacFn}. 
The user must supply a custom sparse Jacobian function since a
difference quotient approximation would not leverage the underlying
sparse matrix structure of the problem.  To specify a user-supplied
Jacobian function \id{sjac}, {\idaklu} and {\idasuperlumt} provide
the function \id{IDASlsSetSparseJacFn}.  The {\idaklu} and
{\idasuperlumt} solvers pass the pointer \id{user\_data} to the sparse
Jacobian function. This mechanism allows the user to create an arbitrary
structure with relevant problem data and access it during the
execution of the user-supplied Jacobian function, without using global
data in the program.  The pointer \id{user\_data} may be specified
through \id{IDASetUserData}.
%%
\index{Jacobian approximation function!sparse!user-supplied}
\ucfunction{IDASlsSetSparseJacFn}
{
  flag = IDASlsSetSparseJacFn(ida\_mem, sjac);
}
{
  The function \ID{IDASlsSetSparseJacFn} specifies the sparse Jacobian
  approximation function to be used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[sjac] (\id{IDASlsSparseJacFn})
    user-defined sparse Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_LMEM\_NULL]
  \item[\Id{IDASLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_LMEM\_NULL}]
    The {\idaklu} or {\idasuperlumt} linear solver has not been initialized.
  \end{args}
}
{
  The function type \id{IDASlsSparseJacFn} is described in \S\ref{ss:sjacFn}.
}
%%
%%
\index{IDAKLU@{\idaklu} linear solver!reinitialization}
When using a sparse direct solver, there 
may be instances when the number of state variables does not 
change, but the number of nonzeroes in the Jacobian does change.  
In this case, for the {\idaklu} solver, we provide the following reinitialization
function.  This function reinitializes the Jacobian matrix
memory for the new number of nonzeroes and sets flags for a new factorization 
(symbolic and numeric) to be conducted at the next solver setup
call.  This routine is useful in the cases where the number of nonzeroes 
has changed, or where the structure of the linear system has changed,
requiring a new symbolic (and numeric) factorization.
%%
\ucfunction{IDAKLUReInit}
{
  flag = IDAKLUReInit(ida\_mem, n, nnz, reinit\_type);
}
{
  The function \ID{IDAKLUReInit} reinitializes Jacobian matrix memory and flags for
  new symbolic and numeric KLU factorizations.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[n] (\id{int})
    number of state variables in the system.
  \item[nnz] (\id{int})
    number of nonzeroes in the Jacobian matrix.
  \item[reinit\_type] (\id{int})
    type of reinitialization:
    \begin{itemize}
    \item[1]  The Jacobian matrix will be destroyed and a new one will 
      be allocated based on the \id{nnz} value passed to this call. New symbolic and
      numeric factorizations will be completed at the next
      solver setup.
    \item[2]  Only symbolic and numeric factorizations will be completed.  
      It is assumed that the Jacobian size has not exceeded the size of 
      \id{nnz} given in the prior call to {\idaklu}.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_MEM\_FAIL]
  \item[\Id{IDASLS\_SUCCESS}] 
    The reinitialization succeeded.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_LMEM\_NULL}]
    The {\idaklu} linear solver has not been initialized.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The given \id{reinit\_type} has an illegal value.
  \item[\Id{IDASLS\_MEM\_FAIL}]
    A memory allocation failed.
  \end{args}
}
{
  The default value for \id{reinit\_type} is $2$.
}
%%
%%
\index{IDAKLU@{\idaklu} linear solver!matrix reordering algorithm specification}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!matrix reordering algorithm specification}
Both the {\idaklu} and {\idasuperlumt} solvers can apply reordering
algorithms to minimize fill-in for the resulting sparse $LU$
decomposition internal to the solver.  The approximate minimal degree
ordering for nonsymmetric matrices given by the \id{COLAMD} algorithm
is the default algorithm used within both solvers, but alternate
orderings may be chosen through one of the following two functions.
The input values to these functinos are the numeric values used in the respective
packages, and the user-supplied value will be passed directly to the package.
%%
\ucfunction{IDAKLUSetOrdering}
{
  flag = IDAKLUSetOrdering(ida\_mem, ordering\_choice);
}
{
  The function \ID{IDAKLUSetOrdering} specifies the ordering algorithm
  used by {\idaklu} for reducing fill.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ordering\_choice] (\id{int})
    flag denoting algorithm choice:
    \begin{itemize}
    \item[0] \id{AMD}
    \item[1] \id{COLAMD}
    \item[2] natural ordering
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_LMEM\_NULL]
  \item[\Id{IDASLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The supplied value of \id{ordering\_choice} is illegal.
  \end{args}
}
{
  The default ordering choice is 1 for \id{COLAMD}.
}
%%
%%
\ucfunction{IDASuperLUMTSetOrdering}
{
  flag = IDASuperLUMTSetOrdering(ida\_mem, ordering\_choice);
}
{
  The function \ID{IDASuperLUMTSetOrdering} specifies the ordering algorithm
  used by {\idasuperlumt} for reducing fill.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ordering\_choice] (\id{int})
    flag denoting algorithm choice:
    \begin{itemize}
    \item[0] natural ordering
    \item[1] minimal degree ordering on $J^TJ$
    \item[2] minimal degree ordering on $J^T + J$
    \item[3] \id{COLAMD}
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_LMEM\_NULL]
  \item[\Id{IDASLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_ILL\_INPUT}]
    The supplied value of \id{ordering\_choice} is illegal.
  \end{args}
}
{
  The default ordering choice is 3 for \id{COLAMD}.
}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!optional input|)}
\index{IDAKLU@{\idaklu} linear solver!optional input|)}
\index{optional input!sparse linear solver|)}
%%
%%==================================================================================
%%
\subsubsection{Iterative linear solvers optional input functions}\label{sss:optin_spils}
\index{optional input!iterative linear solver|(}
\index{IDASPGMR@{\idaspgmr} linear solver!optional input|(}
\index{IDASPBCG@{\idaspbcg} linear solver!optional input|(}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!optional input|(}
\index{preconditioning!user-supplied|(}
If preconditioning is to be done with one of the {\idaspils} linear solvers, 
then the user must supply a preconditioner solve function \id{psolve} and specify
its name through a call to \id{IDASpilsSetPreconditioner}.
\index{IDASPGMR@{\idaspgmr} linear solver!preconditioner solve function}
\index{IDASPBCG@{\idaspbcg} linear solver!preconditioner solve function}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!preconditioner solve function}
%%
The evaluation and preprocessing of any Jacobian-related data needed
by the user's preconditioner solve function is done in the optional
user-supplied function \id{psetup}. Both of these functions are
fully specified in \S\ref{ss:user_fct_sim}.
If used, the name of the \id{psetup} function should be specified in the call to
\id{IDASpilsSetPreconditioner}.
\index{IDASPGMR@{\idaspgmr} linear solver!preconditioner setup function}
\index{IDASPBCG@{\idaspbcg} linear solver!preconditioner setup function}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!preconditioner setup function}

The pointer \id{user\_data} received through \id{IDASetUserData} (or a pointer to \id{NULL}
if \id{user\_data} was not specified) 
is passed to the preconditioner \id{psetup} and \id{psolve} functions.  
This allows the user to create an arbitrary structure with relevant problem data 
and access it during the execution of the user-supplied preconditioner functions
without using global data in the program.  

\index{IDASPGMR@{\idaspgmr} linear solver!Jacobian approximation used by}
\index{IDASPBCG@{\idaspbcg} linear solver!Jacobian approximation used by}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!Jacobian approximation used by}
The {\idaspils} solvers require a function to compute an approximation to the
product between the Jacobian matrix $J(t,y)$ and a vector $v$.
The user can supply his/her own Jacobian-times-vector approximation function, 
or use the default internal difference quotient function
\index{Jacobian approximation function!Jacobian times vector!difference quotient}
that comes with the {\idaspils} solvers.
A user-defined Jacobian-vector function must be of type \id{IDASpilsJacTimesVecFn}
and can be specified through a call to \id{IDASpilsSetJacTimesVecFn}
(see \S\ref{ss:jtimesFn} for specification details).
%%
As with the preconditioner user-supplied functions,
a pointer to the user-defined data structure, \id{user\_data}, specified through
\id{IDASetUserData} (or a \id{NULL} pointer otherwise) is passed to the 
Jacobian-times-vector function \id{jtimes} each time it is called.  
%%
%%
\ucfunction{IDASpilsSetPreconditioner}
{
  flag = IDASpilsSetPreconditioner(ida\_mem, psetup, psolve);
}
{
  The function \ID{IDASpilsSetPreconditioner} specifies the preconditioner
  setup and solve functions.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[psetup] (\id{IDASpilsPrecSetupFn})
    user-defined preconditioner setup function.  Pass \id{NULL} if no
    setup is to be done.
  \item[psolve] (\id{IDASpilsPrecSolveFn})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional values have been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{
   The function type \id{IDASpilsPrecSolveFn} is described in \S\ref{ss:psolveFn}.
   The function type \id{IDASpilsPrecSetupFn} is described in \S\ref{ss:precondFn}.
}
%%
%%
\index{preconditioning!user-supplied|)}
%%
\index{Jacobian approximation function!Jacobian times vector!user-supplied}
\ucfunction{IDASpilsSetJacTimesVecFn}
{
  flag = IDASpilsSetJacTimesVecFn(ida\_mem, jtimes);
}
{
  The function \ID{IDASpilsSetJacTimesFn} specifies the Jacobian-vector 
  function to be used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[jtimes] (\id{IDASpilsJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{
  By default, the {\idaspils} solvers use the difference quotient function. 
  If \id{NULL} is passed to \id{jtimes}, this default function is used.

  The function type \id{IDASpilsJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.
}
%%
%%
%%
\ucfunction{IDASpilsSetGSType}
{
  flag = IDASpilsSetGSType(ida\_mem, gstype);
}
{
  The function \ID{IDASpilsSetGSType} specifies the 
  Gram-Schmidt orthogonalization to be used. 
  This must be one of the enumeration constants \ID{MODIFIED\_GS}
  or \ID{CLASSICAL\_GS}. These correspond to using modified Gram-Schmidt 
  and classical Gram-Schmidt, respectively. 
  \index{Gram-Schmidt procedure}
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[gstype] (\id{int})
    type of Gram-Schmidt orthogonalization.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The value of \id{gstype} is not valid.
  \end{args}
}
{
  The default value is \id{MODIFIED\_GS}.

  {\warn}This option is available only for the {\idaspgmr} linear solver.
}
%%
%%
\ucfunction{IDASpilsSetMaxRestarts}
{
  flag = IDASpilsSetMaxRestarts(ida\_mem, maxrs);
}
{
  The function \ID{IDASpilsSetMaxRestarts} specifies the maximum number of 
  restarts to be used in the GMRES algorithm.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxrs] (\id{int})
    maximum number of restarts.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The \id{maxrs} argument is negative.
  \end{args}
}
{
  The default value is $5$. Pass \id{maxrs} $=0$ to specify no restarts.

  {\warn}This option is available only for the {\idaspgmr} linear solver.
}
%%
%%
\ucfunction{IDASpilsSetEpsLin}
{
  flag = IDASpilsSetEpsLin(ida\_mem, eplifac);
}
{
  The function \ID{IDASpilsSetEpsLin} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the Newton iteration test constant. (See \S\ref{ss:ivp_sol}).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[eplifac] (\id{realtype})
    linear convergence safety factor ($>= 0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The value of \id{eplifac} is negative.
  \end{args}
}
{
  The default value is $0.05$.

  Passing a value \id{eplifac}$ = 0.0$ also indicates using the default value.
}
%%
%%
\ucfunction{IDASpilsSetIncrementFactor}
{
  flag = IDASpilsSetIncrementFactor(ida\_mem, dqincfac);
}
{
  The function \ID{IDASpilsSetIncrementFactor} specifies a factor in the 
  increments to $y$ used in the difference quotient approximations 
  to the Jacobian-vector products.  (See \S\ref{ss:ivp_sol}).  The increment
  used to approximate $Jv$ will be $\sigma = $ \id{dqincfac}$/\|v\|$.
}
{
  \begin{args}[dqincfac]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[dqincfac] (\id{realtype})
    difference quotient increment factor.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The increment factor was non-positive.
  \end{args}
}
{
  The default value is \id{dqincfac} $=1.0$.
}
%%
\ucfunction{IDASpilsSetMaxl}
{
  flag = IDASpilsSetMaxl(ida\_mem, maxl);
}
{
  The function \ID{IDASpilsSetMaxl} resets the maximum Krylov subspace
  dimension for the Bi-CGStab\index{Bi-CGStab method} or TFQMR\index{TFQMR method} 
  methods.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{
  The maximum subspace dimension is initially specified in the call
  to the linear solver specification function (see \S\ref{sss:lin_solv_init}). 
  This function call is needed only if \id{maxl} is being changed from its 
  previous value.

  An input value \id{maxl} $\leq 0$ will result in the default value, 5.

  {\warn}This option is available only for the {\idaspbcg} and {\idasptfqmr} linear solvers.
}
%%
\index{IDASPTFQMR@{\idasptfqmr} linear solver!optional input|)}
\index{IDASPBCG@{\idaspbcg} linear solver!optional input|)}
\index{IDASPGMR@{\idaspgmr} linear solver!optional input|)}
\index{optional input!iterative linear solver|)}

%%
%%
%%==================================================================================
%%
\subsubsection{Initial condition calculation optional input functions}\label{sss:optin_iccalc}
\index{optional input!initial condition calculation|(}
%%
The following functions can be called just prior to calling \id{IDACalcIC}
to set optional inputs controlling the initial condition calculation.
%%
\ucfunction{IDASetNonlinConvCoefIC}
{
flag = IDASetNonlinConvCoefIC(ida\_mem, epiccon);
}
{
  The function \ID{IDASetNonlinConvCoefIC} specifies the positive constant in
  the Newton iteration convergence test within the initial condition calculation.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[epiccon] (\id{realtype})
    coefficient in the Newton convergence test ($>0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The \id{epiccon} factor is $<= 0.0$.
  \end{args}
}
{
  The default value is $0.01 \cdot 0.33$.

  This test uses a weighted RMS norm (with weights defined by the tolerances).
  For new initial value vectors $y$ and $\dot{y}$ to be accepted, the norm
  of $J^{-1}F(t_0, y, \dot{y})$ must be $\le$ \id{epiccon}, where $J$ is the
  system Jacobian.
}
%%
\ucfunction{IDASetMaxNumStepsIC}
{
flag = IDASetMaxNumStepsIC(ida\_mem, maxnh);
}
{
  The function \ID{IDASetMaxNumStepsIC} specifies the maximum number
  of steps allowed when \id{icopt}$=$\id{IDA\_YA\_YDP\_INIT}
  in \id{IDACalcIC}, where $h$ appears in the system Jacobian,
  $J = \partial F / \partial y + (1/h) \partial F / \partial \dot{y}$.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxnh] (\id{int})
    maximum allowed number of values for $h$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    \id{maxnh} is non-positive.
  \end{args}
}
{
  The default value is $5$.
}
%%
%%
\ucfunction{IDASetMaxNumJacsIC}
{
flag = IDASetMaxNumJacsIC(ida\_mem, maxnj);
}
{
  The function \ID{IDASetMaxNumJacsIC} specifies the maximum number
  of the approximate Jacobian or preconditioner evaluations allowed 
  when the Newton iteration appears to be slowly converging.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxnj] (\id{int})
    maximum allowed number of Jacobian or preconditioner evaluations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    \id{maxnj} is non-positive.
  \end{args}
}
{
  The default value is $4$.
}
%%
%%
\ucfunction{IDASetMaxNumItersIC}
{
flag = IDASetMaxNumItersIC(ida\_mem, maxnit);
}
{
  The function \ID{IDASetMaxNumItersIC} specifies the maximum
  number of Newton iterations allowed in any one attempt to solve
  the initial conditions calculation problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[maxnit] (\id{int})
    maximum number of Newton iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    \id{maxnit} is non-positive.
  \end{args}
}
{
  The default value is $10$.
}
%%
%%
\ucfunction{IDASetMaxBacksIC}
{
flag = IDASetMaxBacksIC(ida\_mem, maxbacks);
}
{
  The function \ID{IDASetMaxBacksIC} specifies the maximum number
  of linesearch backtracks allowed in any Newton iteration, when solving
  the initial conditions calculation problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[maxbacks] (\id{int})
    maximum number of linesearch backtracks per Newton step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    \id{maxbacks} is non-positive.
  \end{args}
}
{
  The default value is $100$.

  If \id{IDASetMaxBacksIC} is called in a Forward Sensitivity Analysis, the 
  the limit \id{maxbacks} applies in the calculation of both the initial state
  values and the initial sensititivies.
}
%%
%%
\ucfunction{IDASetLineSearchOffIC}
{
flag = IDASetLineSearchOffIC(ida\_mem, lsoff);
}
{
  The function \ID{IDASetLineSearchOffIC} specifies whether to turn
  on or off the linesearch algorithm.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lsoff] (\id{booleantype})
    a flag to turn off (\id{TRUE}) or keep (\id{FALSE}) the linesearch
    algorithm.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is \id{FALSE}.
}
%%
%%
\ucfunction{IDASetStepToleranceIC}
{
flag = IDASetStepToleranceIC(ida\_mem, steptol);
}
{
  The function \ID{IDASetStepToleranceIC} specifies a positive lower bound
  on the Newton step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[steptol] (\id{int})
    Minimum allowed WRMS-norm of the Newton step ($> 0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The \id{steptol} tolerance is  $<= 0.0$.
  \end{args}
}
{
  The default value is (unit roundoff)$^{2/3}$.
}
%%
\index{optional input!initial condition calculation|)}


%%==============================================================================

\subsubsection{Rootfinding optional input functions}\label{sss:optin_root}
\index{optional input!rootfinding|(}
%%
The following functions can be called to set optional inputs to control the 
rootfinding algorithm.
%%
\ucfunction{IDASetRootDirection}
{
flag = IDASetRootDirection(ida\_mem, rootdir);
}
{
  The function \ID{IDASetRootDirection} specifies the direction of
  zero-crossings to be located and returned to the user.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[rootdir] (\id{int *})
    state array of length \id{nrtfn}, the number of root functions $g_i$, as
    specified in the call to the function \id{IDARootInit}. A value of $0$ for
    \id{rootdir[i]} indicates that crossing in either direction should be reported
    for $g_i$.  A value of $+1$ or $-1$ indicates that the solver should report
    only zero-crossings where $g_i$ is increasing or decreasing, respectively. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    rootfinding has not been activated through a call to \id{IDARootInit}.
  \end{args}
}
{
  The default behavior is to locate both zero-crossing directions.
}
%%
%%
\ucfunction{IDASetNoInactiveRootWarn}
{
flag = IDASetNoInactiveRootWarn(ida\_mem);
}
{
  The function \ID{IDASetNoInactiveRootWarn} disables issuing a warning 
  if some root function appears to be identically zero at the beginning of the integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\idas} will not report the initial conditions as a possible zero-crossing
  (assuming that one or more components $g_i$ are zero at the initial time).
  However, if it appears that some $g_i$ is identically zero at the initial
  time (i.e., $g_i$ is zero at the initial time and after the first step),
  {\idas} will issue a warning which can be disabled with this optional input 
  function.
}
%%
\index{optional input!rootfinding|)}

%%
%%===================================================================================
%%

\subsection{Interpolated output function}\label{ss:optional_dky}
\index{optional output!interpolated solution}

An optional function \ID{IDAGetDky} is available to obtain additional output
values.  This function must be called after a successful return from \id{IDASolve}
and provides interpolated values of $y$ or its derivatives of order up to the last internal order used
for any value of $t$ in the last internal step taken by {\idas}.

The call to the \id{IDAGetDky} function has the following form:
%%
\ucfunction{IDAGetDky}
{
  flag = IDAGetDky(ida\_mem, t, k, dky);
}
{
  The function \ID{IDAGetDky} computes the interpolated values of the $k^{th}$
  derivative of $y$ for any value of $t$ in the last internal step taken by {\idas}.
  The value of $k$ must be non-negative and smaller than the last internal order used. A 
  value of $0$ for $k$ means that the $y$ is interpolated.
  The value of $t$ must satisfy $t_n - h_u \le t \le t_n$, where $t_n$ denotes
  the current internal time reached, and $h_u$ is the last internal step size
  used successfully.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[t] (\id{realtype})
    time at which to interpolate.
  \item[k] (\id{int})
    integer specifying the order of the derivative of $y$ wanted.
  \item[dky] (\id{N\_Vector})
    vector containing the interpolated $k^{th}$ derivative of $y(t)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL] 
  \item[\Id{IDA\_SUCCESS}]
    \id{IDAGetDky} succeeded.
  \item[\Id{IDA\_MEM\_NULL}] 
    The \id{ida\_mem} argument was \id{NULL}.
  \item[\Id{IDA\_BAD\_T}] 
    \id{t} is not in the interval $[t_n - h_u , t_n]$.
  \item[\Id{IDA\_BAD\_K}]
    \id{k} is not one of $\{0, 1, \ldots, klast\}$.
  \item[\Id{IDA\_BAD\_DKY}]
    \id{dky} is \id{NULL}.
  \end{args}

}
{
  It is only legal to call the function \id{IDAGetDky} after a 
  successful return from \id{IDASolve}. Functions \id{IDAGetCurrentTime},
  \id{IDAGetLastStep} and \id{IDAGetLastOrder} (see \S\ref{sss:optout_main})
  can be used to access $t_n$, $h_u$ and $klast$.
}

%%
%%===================================================================================
%%

\subsection{Optional output functions}\label{ss:optional_output}

{\idas} provides an extensive list of functions that can be used to obtain
solver performance information.  Table \ref{t:optional_output} lists all optional
output functions in {\idas}, which are then described in detail in the remainder
of this section.

Some of the optional outputs, especially the various counters, can be
very useful in determining how successful the {\idas} solver is in
doing its job.  For example, the counters \id{nsteps} and \id{nrevals}
provide a rough measure of the overall cost of a given run, and can be
compared among runs with differing input options to suggest which set
of options is most efficient.  The ratio \id{nniters/nsteps} measures
the performance of the Newton iteration in solving the nonlinear
systems at each time step; typical values for this range from 1.1 to
1.8.  The ratio \id{njevals/nniters} (in the case of a direct linear
solver), and the ratio \id{npevals/nniters} (in the case of an
iterative linear solver) measure the overall degree of nonlinearity
in these systems, and also the quality of the approximate Jacobian or
preconditioner being used.  Thus, for example, \id{njevals/nniters}
can indicate if a user-supplied Jacobian is inaccurate, if this ratio
is larger than for the case of the corresponding internal Jacobian.
The ratio \id{nliters/nniters} measures the performance of the Krylov
iterative linear solver, and thus (indirectly) the quality of the
preconditioner.

\vspace*{.2in}

\newlength{\colAA}
\settowidth{\colAA}{No. of residual calls for finite diff. Jacobian-vector evals.}
\newlength{\colBB}
\settowidth{\colBB}{\id{IDAGetNumNonlinSolvConvFails}}

\begin{table}
\centering
\caption{Optional outputs from {\idas}, {\idadls}, {\idasls}, and {\idaspils}}
\label{t:optional_output}
\medskip
\begin{tabular}{|p{\colAA}|p{\colBB}|}
\hline 
{\bf Optional output} & {\bf Function name} \\
\hline
\multicolumn{2}{|c|}{\bf IDAS main solver} \\
\hline
Size of {\idas} real and integer workspace & \id{IDAGetWorkSpace} \\
Cumulative number of internal steps & \id{IDAGetNumSteps} \\
No. of calls to residual function & \id{IDAGetNumResEvals} \\
No. of calls to linear solver setup function & \id{IDAGetNumLinSolvSetups} \\
No. of local error test failures that have occurred & \id{IDAGetNumErrTestFails} \\
Order used during the last step & \id{IDAGetLastOrder} \\
Order to be attempted on the next step & \id{IDAGetCurrentOrder} \\
Order reductions due to stability limit detection & \id{IDAGetNumStabLimOrderReds} \\
Actual initial step size used & \id{IDAGetActualInitStep} \\
Step size used for the last step & \id{IDAGetLastStep} \\
Step size to be attempted on the next step & \id{IDAGetCurrentStep} \\
Current internal time reached by the solver & \id{IDAGetCurrentTime} \\
Suggested factor for tolerance scaling  & \id{IDAGetTolScaleFactor} \\
Error weight vector for state variables & \id{IDAGetErrWeights} \\
Estimated local errors & \id{IDAGetEstLocalErrors} \\
No. of nonlinear solver iterations & \id{IDAGetNumNonlinSolvIters} \\
No. of nonlinear convergence failures & \id{IDAGetNumNonlinSolvConvFails} \\ 
Array showing roots found & \id{IDAGetRootInfo} \\
No. of calls to user root function & \id{IDAGetNumGEvals} \\
Name of constant associated with a return flag & \id{IDAGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf IDAS initial conditions calculation} \\
\hline
Number of backtrack operations & \id{IDAGetNumBacktrackops} \\
Corrected initial conditions & \id{IDAGetConsistentIC} \\ 
\hline
\multicolumn{2}{|c|}{\bf IDADLS linear solver} \\
\hline
Size of real and integer workspace & \id{IDADlsGetWorkSpace} \\
No. of Jacobian evaluations & \id{IDADlsGetNumJacEvals} \\
No. of residual calls for finite diff. Jacobian evals. & \id{IDADlsGetNumResEvals} \\ 
Last return from a linear solver function & \id{IDADlsGetLastFlag} \\ 
Name of constant associated with a return flag & \id{IDADlsGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf IDASLS linear solver} \\
\hline
No. of Jacobian evaluations & \id{IDASlsGetNumJacEvals} \\
Last return from a linear solver function & \id{IDASlsGetLastFlag} \\
Name of constant associated with a return flag & \id{IDASlsGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf IDASPILS linear solvers} \\
\hline
Size of real and integer workspace & \id{IDASpilsGetWorkSpace} \\
No. of linear iterations & \id{IDASpilsGetNumLinIters} \\
No. of linear convergence failures & \id{IDASpilsGetNumConvFails} \\
No. of preconditioner evaluations & \id{IDASpilsGetNumPrecEvals} \\
No. of preconditioner solves & \id{IDASpilsGetNumPrecSolves} \\
No. of Jacobian-vector product evaluations & \id{IDASpilsGetNumJtimesEvals} \\
No. of residual calls for finite diff. Jacobian-vector evals. & \id{IDASpilsGetNumResEvals} \\
Last return from a linear solver function & \id{IDASpilsGetLastFlag} \\
Name of constant associated with a return flag & \id{IDASpilsGetReturnFlagName} \\
\hline
\end{tabular}
\end{table}

\subsubsection{Main solver optional output functions}\label{sss:optout_main}
\index{optional output!solver|(}
%%
{\idas} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements, solver performance statistics, as well as additional data from
the {\idas} memory block (a suggested tolerance scaling factor, the error weight
vector, and the vector of estimated local errors). Also provided are functions to
extract statistics related to the performance of the {\idas} nonlinear solver
being used. As a convenience, additional extraction functions provide the optional 
outputs in groups.
%%
These optional output functions are described next.
%%
%%
\ucfunction{IDAGetWorkSpace}
{
  flag = IDAGetWorkSpace(ida\_mem, \&lenrw, \&leniw);
}
{
  The function \ID{IDAGetWorkSpace} returns the
  {\idas} real and integer workspace sizes.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lenrw] (\id{long int})
    number of real values in the {\idas} workspace.
  \item[leniw] (\id{long int})
    number of integer values in the {\idas} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  \index{memory requirements!IDAS@{\idas} solver}
  In terms of the problem size $N$, the maximum method order \id{maxord}, and
  the number \id{nrtfn} of root functions (see \S\ref{ss:idarootinit}),
  the actual size of the real workspace, in \id{realtype} words, is
  given by the following:
  \begin{itemize}
  \item base value: \id{lenrw} $= 55 + (m + 6)*N_r + 3*$\id{nrtfn};
  \item with \id{IDASVtolerances}: \id{lenrw} $=$ \id{lenrw} $+ N_r$;
  \item with constraint checking (see \id{IDASetConstraints}): 
    \id{lenrw} $=$ \id{lenrw} $+ N_r$;
  \item with \id{id} specified (see \id{IDASetId}): 
    \id{lenrw} $=$ \id{lenrw} $+ N_r$;
  \end{itemize}
  where $m = \max($\id{maxord}$,3)$, and
  $N_r$ is the number of real words in one \id{N\_Vector} ($\approx N$).

  The size of the integer workspace (without distinction between \id{int} 
  and \id{long int} words) is given by:
  \begin{itemize}
  \item base value: \id{leniw} $= 38 + (m + 6)*N_i ~ + ~ $\id{nrtfn};  
  \item with \id{IDASVtolerances}: \id{leniw} $=$ \id{leniw} $+ N_i$;
  \item with constraint checking: \id{lenrw} $=$ \id{lenrw} $+ N_i$;
  \item with \id{id} specified: \id{lenrw} $=$ \id{lenrw} $+ N_i$;
  \end{itemize}
  where $N_i$ is the number of integer words in one \id{N\_Vector}
  (= 1 for {\nvecs} and 2*\id{npes} for {\nvecp} on \id{npes} processors).

  For the default value of \id{maxord}, with no rootfinding, no \id{id},
  no constraints, and with no call to \id{IDASVtolerances}, these lengths are
  given roughly by: \id{lenrw} $= 55 + 11N$, \id{leniw} $= 49$.

  Note that additional memory is allocated if quadratures and/or forward sensitivity
  integration is enabled. See \S\ref{ss:quad_init} and \S\ref{ss:sensi_init}
  for more details.
}
%%
\ucfunction{IDAGetNumSteps}
{
  flag = IDAGetNumSteps(ida\_mem, \&nsteps);
}
{
  The function \ID{IDAGetNumSteps} returns the cumulative number of internal 
  steps taken by the solver (total so far).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nsteps] (\id{long int})
    number of steps taken by {\idas}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetNumResEvals}
{
  flag = IDAGetNumResEvals(ida\_mem, \&nrevals);
}
{
  The function \ID{IDAGetNumResEvals} returns the 
  number of calls to the user's residual evaluation function.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nrevals] (\id{long int})
    number of calls to the user's \id{res} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The \id{nrevals} value returned by \id{IDAGetNumResEvals} does not
  account for calls made to \id{res} from a linear solver or preconditioner 
  module. 
}
%%
%%
\ucfunction{IDAGetNumLinSolvSetups}
{
  flag = IDAGetNumLinSolvSetups(ida\_mem, \&nlinsetups);
}
{
  The function \ID{IDAGetNumLinSolvSetups} returns the
  cumulative number of calls made to the linear solver's setup function 
  (total so far).
}
{
  \begin{args}[nlinsetups]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nlinsetups] (\id{long int})
    number of calls made to the linear solver setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetNumErrTestFails}
{
  flag = IDAGetNumErrTestFails(ida\_mem, \&netfails);
}
{
  The function \ID{IDAGetNumErrTestFails} returns the
  cumulative number of local error test failures that have occurred 
  (total so far).
}
{
  \begin{args}[netfails]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[netfails] (\id{long int})
    number of error test failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetLastOrder}
{
  flag = IDAGetLastOrder(ida\_mem, \&klast);
}
{
  The function \ID{IDAGetLastOrder} returns the
  integration method order used during the last internal step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[klast] (\id{int})
    method order used on the last internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetCurrentOrder}
{
  flag = IDAGetCurrentOrder(ida\_mem, \&kcur);
}
{
  The function \ID{IDAGetCurrentOrder} returns the
  integration method order to be used on the next internal step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[kcur] (\id{int})
    method order to be used on the next internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetLastStep}
{
  flag = IDAGetLastStep(ida\_mem, \&hlast);
}
{
  The function \ID{IDAGetLastStep} returns the
  integration step size taken on the last internal step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[hlast] (\id{realtype})
    step size taken on the last internal step by {\ida}, or last artificial
    step size used in \id{IDACalcIC}, whichever was called last.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetCurrentStep}
{
  flag = IDAGetCurrentStep(ida\_mem, \&hcur);
}
{
  The function \ID{IDAGetCurrentStep} returns the
  integration step size to be attempted on the next internal step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[hcur] (\id{realtype})
    step size to be attempted on the next internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetActualInitStep}
{
  flag = IDAGetActualInitStep(ida\_mem, \&hinused);
}
{
  The function \ID{IDAGetActualInitStep} returns the
  value of the integration step size used on the first step.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[hinused] (\id{realtype})
    actual value of initial step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Even if the value of the initial integration step size was specified
  by the user through a call to \id{IDASetInitStep}, this value might have 
  been changed by {\idas} to ensure that the step size is within the 
  prescribed bounds ($h_{\min} \le h_0 \le h_{\max}$), or to meet the
  local error test.
}
%%
%%
\ucfunction{IDAGetCurrentTime}
{
  flag = IDAGetCurrentTime(ida\_mem, \&tcur);
}
{
  The function \ID{IDAGetCurrentTime} returns the
  current internal time reached by the solver.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[tcur] (\id{realtype})
    current internal time reached.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetTolScaleFactor}
{
  flag = IDAGetTolScaleFactor(ida\_mem, \&tolsfac);
}
{
  The function \ID{IDAGetTolScaleFactor} returns a
  suggested factor by which the user's tolerances 
  should be scaled when too much accuracy has been 
  requested for some internal step.
}
{
  \begin{args}[tolsfac]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[tolsfac] (\id{realtype})
    suggested scaling factor for user tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetErrWeights}
{
  flag = IDAGetErrWeights(ida\_mem, eweight);
}
{
  The function \ID{IDAGetErrWeights} returns the solution error weights 
  at the current time. These are the $W_i$ given by Eq. (\ref{e:errwt})
  (or by the user's \id{IDAEwtFn}).
}
{
  \begin{args}[eweight]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[eweight] (\id{N\_Vector})
    solution error weights at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate space for \id{eweight}.
}
%%
%%
\ucfunction{IDAGetEstLocalErrors}
{
  flag = IDAGetEstLocalErrors(ida\_mem, ele);
}
{
  The function \ID{IDAGetEstLocalErrors} returns the estimated local errors.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ele] (\id{N\_Vector})
    estimated local errors at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate space for \id{ele}. \\
  The values returned in \id{ele} are only valid if
  \id{IDASolve} returned a non-negative value.

  The \id{ele} vector, togther with the \id{eweight} vector from
  \id{IDAGetErrWeights}, can be used to determine how the various
  components of the system contributed to the estimated local error
  test.  Specifically, that error test uses the RMS norm of a vector
  whose components are the products of the components of these two vectors.
  Thus, for example, if there were recent error test failures, the components
  causing the failures are those with largest values for the products,
  denoted loosely as \id{eweight[i]*ele[i]}.

}
%%
%%
\ucfunction{IDAGetIntegratorStats}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = IDAGetIntegratorStats(&ida\_mem, \&nsteps, \&nrevals, \&nlinsetups, \\
                                 &\&netfails, \&klast, \&kcur, \&hinused,\\
                                 &\&hlast, \&hcur, \&tcur);
  \end{tabular}
}
{
  The function \ID{IDAGetIntegratorStats} returns the {\idas} integrator statistics
  as a group.
}
{
  \begin{args}[nlinsetups]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nsteps] (\id{long int})
    cumulative number of steps taken by {\idas}.
  \item[nrevals] (\id{long int})
    cumulative number of calls to the user's \id{res} function.
  \item[nlinsetups] (\id{long int})
    cumulative number of calls made to the linear solver setup function.
  \item[netfails] (\id{long int})
    cumulative number of error test failures.
  \item[klast] (\id{int})
    method order used on the last internal step.
  \item[kcur] (\id{int})
    method order to be used on the next internal step.
  \item[hinused] (\id{realtype})
    actual value of initial step size.
  \item[hlast] (\id{realtype})
    step size taken on the last internal step.
  \item[hcur] (\id{realtype})
    step size to be attempted on the next internal step.
  \item[tcur] (\id{realtype})
    current internal time reached.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    the optional output values have been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    the \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetNumNonlinSolvIters}
{
  flag = IDAGetNumNonlinSolvIters(ida\_mem, \&nniters);
}
{
  The function \ID{IDAGetNumNonlinSolvIters} returns the
  cumulative number of nonlinear (functional or Newton) iterations performed. 
}
{
  \begin{args}[nniters]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations performed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetNumNonlinSolvConvFails}
{
  flag = IDAGetNumNonlinSolvConvFails(ida\_mem, \&nncfails);
}
{
  The function \ID{IDAGetNumNonlinSolvConvFails} returns the
  cumulative number of nonlinear convergence failures that have occurred.
}
{
  \begin{args}[nncfails]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetNonlinSolvStats}
{
  flag = IDAGetNonlinSolvStats(ida\_mem, \&nniters, \&nncfails);
}
{
  The function \ID{IDAGetNonlinSolvStats} returns the
  {\idas} nonlinear solver statistics as a group.
}
{
  \begin{args}[nncfails]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nniters] (\id{long int})
    cumulative number of nonlinear iterations performed.
  \item[nncfails] (\id{long int})
    cumulative number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
\ucfunction{IDAGetReturnFlagName}
{
  name = IDAGetReturnFlagName(flag);
}
{
  The function \ID{IDAGetReturnFlagName} returns the
  name of the {\idas} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int}, is a return flag from an {\idas} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
%%
\index{optional output!solver|)}
%%
%%==================================================================================
%%
\subsubsection{Initial condition calculation optional output functions}\label{sss:optout_iccalc}
\index{optional output!initial condition calculation|(}
%%
\ucfunction{IDAGetNumBcktrackOps}
{
  flag = IDAGetNumBacktrackOps(ida\_mem, \&nbacktr);
}
{
  The function \ID{IDAGetNumBacktrackOps} returns the number of backtrack          
  operations done in the linesearch algorithm in \id{IDACalcIC}.
}
{
  \begin{args}[nbacktr]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nbacktr] (\id{long int})
    the cumulative number of backtrack operations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
\ucfunction{IDAGetConsistentIC}
{
  flag = IDAGetConsistentIC(ida\_mem, yy0\_mod, yp0\_mod);
}
{
  The function \ID{IDAGetConsistentIC} returns the corrected initial conditions
  calculated by \id{IDACalcIC}.
}
{
  \begin{args}[yy0\_mod]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[yy0\_mod] (\id{N\_Vector})
    consistent solution vector.
  \item[yp0\_mod] (\id{N\_Vector})
    consistent derivative vector.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_ILL\_INPUT}]
    The function was not called before the first call to \id{IDASolve}.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If the consistent solution vector or consistent derivative vector
  is not desired, pass \id{NULL} for the corresponding argument.

  {\warn} The user must allocate space for \id{yy0\_mod} and \id{yp0\_mod}
  (if not \id{NULL}).
}
%%
\index{optional output!initial condition calculation|)}

%%
%%==================================================================================
%%
\subsubsection{Rootfinding optional output functions}\label{sss:optout_root}
There are two optional output functions associated with rootfinding.
%%
%%
\ucfunction{IDAGetRootInfo}
{
  flag = IDAGetRootInfo(ida\_mem, rootsfound);
}
{
  The function \ID{IDAGetRootInfo} returns an array showing which 
  functions were found to have a root.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[rootsfound] (\id{int *})
    array of length \id{nrtfn} with the indices of the user functions $g_i$ found
    to have a root.  For $i = 0,\ldots, $\id{nrtfn} $-1$,
   \id{rootsfound}[$i$] $\ne 0$ if $g_i$ has a root, and $ = 0$ if not.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Note that, for the components $g_i$ for which a root was found,
  the sign of \id{rootsfound}[$i$] indicates the direction of
  zero-crossing. A value of $+1$ indicates that $g_i$ is increasing,
  while a value of $-1$ indicates a decreasing $g_i$.

  {\warn}The user must allocate memory for the vector \id{rootsfound}.
}
%%
%%
\ucfunction{IDAGetNumGEvals}
{
  flag = IDAGetNumGEvals(ida\_mem, \&ngevals);
}
{
  The function \ID{IDAGetNumGEvals} returns the cumulative
  number of calls to the user root function $g$.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ngevals] (\id{long int})
    number of calls to the user's function \id{g} so far.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}


%%
%%==================================================================================
%%
\subsubsection{Dense/band direct linear solvers optional output functions}
\label{sss:optout_dls}
\index{optional output!dense linear solver|(}
\index{optional output!band linear solver|(}
\index{IDADENSE@{\idadense} linear solver!optional output|(}
\index{IDABAND@{\idaband} linear solver!optional output|(}
The following optional outputs are available from the {\idadls} modules:
workspace requirements, number of calls to the Jacobian routine, number of 
calls to the residual routine for finite-difference Jacobian approximation,
and last return value from an {\idadls} function.
Note that, where the name of an output would otherwise conflict with
the name of an optional output from the main solver, a suffix \id{LS}
(for Linear Solver) has been added here (e.g.  \id{lenrwLS}).
%%
%%
\index{IDADENSE@{\idadense} linear solver!memory requirements} 
\index{IDABAND@{\idaband} linear solver!memory requirements} 
\index{memory requirements!IDADENSE@{\idadense} linear solver}
\index{memory requirements!IDABAND@{\idaband} linear solver}
\ucfunction{IDADlsGetWorkSpace}
{
  flag = IDADlsGetWorkSpace(ida\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{IDADlsGetWorkSpace} returns the sizes of the real and
  integer workspaces used by an {\idadls} linear solver ({\idadense} or
  {\idaband}). 
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lenrwLS] (\id{long int})
    the number of real values in the {\idadls} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\idadls} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_LMEM\_NULL]
  \item[IDADLS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The {\idadls} linear solver has not been initialized.
  \end{args}
}
{
  For the {\idadense} linear solver, in terms of the problem size $N$,
  the actual size of the real workspace is $2N^2$ \id{realtype} words,
  while the actual size of the integer workspace is $N$ integer words.
  For the {\idaband} linear solver, in terms of $N$ 
  and Jacobian half-bandwidths, the actual size of the real workspace is
  $N\,(2$ \id{mupper}$+ 3$ \id{mlower} $+ 2)$ \id{realtype} words,
  while the actual size of the integer workspace is $N$ integer words.
}
%%
%%
\ucfunction{IDADlsGetNumJacEvals}
{
  flag = IDADlsGetNumJacEvals(ida\_mem, \&njevals);
}
{
  The function \ID{IDADlsGetNumJacEvals} returns the
  cumulative number of calls to the {\idadls} (dense or banded) 
  Jacobian approximation function.
}
{
  \begin{args}[njevals]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[njevals] (\id{long int})
    the cumulative number of calls to the Jacobian function (total so far).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_LMEM\_NULL]
  \item[IDADLS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The {\idadense} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDADlsGetNumResEvals}
{
  flag = IDADlsGetNumResEvals(ida\_mem, \&nrevalsLS);
}
{
  The function \ID{IDADlsGetNumResEvals} returns the
  cumulative number of calls to the user residual function due to the 
  finite difference (dense or band) Jacobian approximation.
}
{
  \begin{args}[nrevalsLS]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nrevalsLS] (\id{long int})
    the cumulative number of calls to the user residual function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_LMEM\_NULL]
  \item[IDADLS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The {\idadense} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nrevalsLS} is incremented only if the default 
  internal difference quotient function is used.
}
%%
\ucfunction{IDADlsGetLastFlag}
{
  flag = IDADlsGetLastFlag(ida\_mem, \&lsflag);
}
{
  The function \ID{IDADlsGetLastFlag} returns the
  last return value from an {\idadls} routine. 
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from an {\idadls} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDADLS\_LMEM\_NULL]
  \item[\Id{IDADLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDADLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDADLS\_LMEM\_NULL}]
    The {\idadense} linear solver has not been initialized.
  \end{args}
}
{
  If the {\idadense} setup function failed (i.e., \id{IDASolve} returned
  \id{IDA\_LSETUP\_FAIL}), the value \id{lsflag} is equal to the column index
  (numbered from one) at which a zero diagonal element was encountered during
  the LU factorization of the (dense or band) Jacobian matrix.
  For all other failures, the value of \id{lsflag} is negative.
}
%%
\ucfunction{IDADlsGetReturnFlagName}
{
  name = IDADlsGetReturnFlagName(lsflag);
}
{
  The function \ID{IDADlsGetReturnFlagName} returns the
  name of the {\idadls} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from an {\idadls} function.
}
{
  The return value is a string containing the name of the corresponding
  constant.  If $1 \leq $ \id{lsflag} $ \leq N$ (LU factorization failed), this
  function returns ``NONE''.
}
{}
%%
\index{IDABAND@{\idaband} linear solver!optional output|)}
\index{IDADENSE@{\idadense} linear solver!optional output|)}
\index{optional output!band linear solver|)}
\index{optional output!dense linear solver|)}

%%
%%==================================================================================
%%
\subsubsection{Sparse direct linear solvers optional output functions}\label{sss:optout_sls}
\index{optional output!sparse linear solver|(}
\index{IDAKLU@{\idaklu} linear solver!optional output|(}
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!optional output|(}
The following optional outputs are available from the {\idasls} modules:
number of calls to the Jacobian routine and last return value from an
{\idasls} function.
%%
%%
\ucfunction{IDASlsGetNumJacEvals}
{
  flag = IDASlsGetNumJacEvals(ida\_mem, \&njevals);
}
{
  The function \ID{IDASlsGetNumJacEvals} returns the
  cumulative number of calls to the {\idasls} sparse
  Jacobian approximation function.
}
{
  \begin{args}[njevals]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[njevals] (\id{long int})
    the cumulative number of calls to the Jacobian function (total so far).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_LMEM\_NULL]
  \item[IDASLS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_LMEM\_NULL}]
    The {\idasls} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASlsGetLastFlag}
{
  flag = IDASlsGetLastFlag(ida\_mem, \&lsflag);
}
{
  The function \ID{IDASlsGetLastFlag} returns the
  last return value from an {\idasls} routine. 
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from an {\idasls} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASLS\_LMEM\_NULL]
  \item[\Id{IDASLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDASLS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASLS\_LMEM\_NULL}]
    The {\idasls} linear solver has not been initialized.
  \end{args}
}
{
}
%%
\ucfunction{IDASlsGetReturnFlagName}
{
  name = IDASlsGetReturnFlagName(lsflag);
}
{
  The function \ID{IDASlsGetReturnFlagName} returns the
  name of the {\idasls} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from an {\idasls} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
%%
\index{IDASUPERLUMT@{\idasuperlumt} linear solver!optional output|)}
\index{IDAKLU@{\idaklu} linear solver!optional output|)}
\index{optional output!sparse linear solver|)}

%
%%==================================================================================
%
\subsubsection{Iterative linear solvers optional output functions}\label{sss:optout_spils}
\index{optional output!iterative linear solver|(}
\index{IDASPGMR@{\idaspgmr} linear solver!optional output|(}
\index{IDASPBCG@{\idaspbcg} linear solver!optional output|(}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!optional output|(} 
The following optional outputs are available from the {\idaspils} modules:
workspace requirements, number of linear iterations,
number of linear convergence failures, number of calls to the preconditioner
setup and solve routines, number of calls to the Jacobian-vector product routine,
number of calls to the residual routine for finite-difference  Jacobian-vector
product approximation, and last return value from a linear solver function.
Note that, where the name of an output would otherwise conflict with
the name of an optional output from the main solver, a suffix \id{LS}
(for Linear Solver) has been added here (e.g.  \id{lenrwLS}).
%%
%%
\index{IDASPGMR@{\idaspgmr} linear solver!memory requirements}
\index{IDASPBCG@{\idaspbcg} linear solver!memory requirements}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!memory requirements} 
\index{memory requirements!IDASPGMR@{\idaspgmr} linear solver}
\ucfunction{IDASpilsGetWorkSpace}
{
  flag = IDASpilsGetWorkSpace(ida\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{IDASpilsGetWorkSpace} returns the global sizes of
  the {\idaspils} real and integer workspaces.
}
{
  \begin{args}[lenrwLS]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lenrwLS] (\id{long int})
    global number of real values in the {\idaspils} workspace.
  \item[leniwLS] (\id{long int})
    global number of integer values in the {\idaspils} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$ and maximum subspace size \id{maxl}, 
  the actual size of the real workspace is roughly:\\
  $N*($ \id{maxl} $+ 5) +$ \id{maxl} $*($ \id{maxl} $ + 4) + 1$
  \id{realtype} words for {\idaspgmr},\\
  $10*N$ \id{realtype} words for {\idaspbcg},\\
  and $13*N$ \id{realtype} words for {\idasptfqmr}.

  In a parallel setting, the above values are global, summed over all processors.
}
%%
%%
\ucfunction{IDASpilsGetNumLinIters}
{
  flag = IDASpilsGetNumLinIters(ida\_mem, \&nliters);
}
{
  The function \ID{IDASpilsGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[nliters]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASpilsGetNumConvFails}
{
  flag = IDASpilsGetNumConvFails(ida\_mem, \&nlcfails);
}
{
  The function \ID{IDASpilsGetNumConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[nlcfails]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASpilsGetNumPrecEvals}
{
  flag = IDASpilsGetNumPrecEvals(ida\_mem, \&npevals);
}
{
  The function \ID{IDASpilsGetNumPrecEvals} returns the
  cumulative number of preconditioner evaluations, i.e., the number of 
  calls made to \id{psetup}.
}
{
  \begin{args}[npevals]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[npevals] (\id{long int})
    the cumulative number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASpilsGetNumPrecSolves}
{
  flag = IDASpilsGetNumPrecSolves(ida\_mem, \&npsolves);
}
{
  The function \ID{IDASpilsGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner 
  solve function, \id{psolve}.
}
{
  \begin{args}[npsolves]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[npsolves] (\id{long int})
    the cumulative number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASpilsGetNumJtimesEvals}
{
  flag = IDASpilsGetNumJtimesEvals(ida\_mem, \&njvevals);
}
{
  The function \ID{IDASpilsGetNumJtimesEvals} returns the
  cumulative number of calls made to the Jacobian-vector function,
  \id{jtimes}.
}
{
  \begin{args}[njvevals]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[njvevals] (\id{long int})
    the cumulative number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDASpilsGetNumResEvals}
{
  flag = IDASpilsGetNumResEvals(ida\_mem, \&nrevalsLS);
}
{
  The function \ID{IDASpilsGetNumResEvals} returns the
  cumulative number of calls to the user residual function for
  finite difference Jacobian-vector product approximation.
}
{
  \begin{args}[nrevalsLS]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nrevalsLS] (\id{long int})
    the cumulative number of calls to the user residual function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nrevalsLS} is incremented only if the default 
  \id{IDASpilsDQJtimes} difference quotient function is used.
}
%%
%%
\ucfunction{IDASpilsGetLastFlag}
{
  flag = IDASpilsGetLastFlag(ida\_mem, \&lsflag);
}
{
  The function \ID{IDASpilsGetLastFlag} returns the
  last return value from an {\idaspils} routine. 
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from an {\idaspils} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_LMEM\_NULL]
  \item[\Id{IDASPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDASPILS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    The {\idaspils} linear solver has not been initialized.
  \end{args}
}
{
  If the {\idaspils} setup function failed (\id{IDASolve} returned
  \id{IDA\_LSETUP\_FAIL}), \id{lsflag} will be \id{SPGMR\_PSET\_FAIL\_UNREC},
  \id{SPBCG\_PSET\_FAIL\_UNREC}, or \id{SPTFQMR\_PSET\_FAIL\_UNREC}.

  If the {\idaspgmr} solve function failed (\id{IDASolve} returned 
  \id{IDA\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpgmrSolve} and will be one of:
  \id{SPGMR\_MEM\_NULL}, indicating that the {\spgmr} memory is \id{NULL};
  \id{SPGMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  $J*v$ function;
  \id{SPGMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably;
  \id{SPGMR\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure;
  or \id{SPGMR\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to 
  be singular during the QR solve phase.

  If the {\idaspbcg} solve function failed (\id{IDASolve} returned 
  \id{IDA\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpbcgSolve} and will be one of:
  \id{SPBCG\_MEM\_NULL}, indicating that the {\spbcg} memory is \id{NULL};
  \id{SPBCG\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  $J*v$ function; or
  \id{SPBCG\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably.

  If the {\idasptfqmr} solve function failed (\id{IDASolve} returned 
  \id{IDA\_LSOLVE\_FAIL}), \id{lsflag} contains the error flag from
  \id{SptfqmrSolve} and will be one of:
  \id{SPTFQMR\_MEM\_NULL}, indicating that the {\sptfqmr} memory is \id{NULL};
  \id{SPTFQMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in 
  the $J*v$ function; or
  \id{SPTFQMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably.


}
%%
\ucfunction{IDASpilsGetReturnFlagName}
{
  name = IDASpilsGetReturnFlagName(lsflag);
}
{
  The function \ID{IDASpilsGetReturnFlagName} returns the
  name of the {\idaspils} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from an {\idaspils} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
%%
\index{IDASPTFQMR@{\idasptfqmr} linear solver!optional output|)}
\index{IDASPBCG@{\idaspbcg} linear solver!optional output|)} 
\index{IDASPGMR@{\idaspgmr} linear solver!optional output|)} 
\index{optional output!iterative linear solver|)}

%%===================================================================================

\subsection{IDAS reinitialization function}\label{sss:idareinit}
\index{reinitialization}

The function \ID{IDAReInit} reinitializes the main {\idas} solver for
the solution of a new problem, where a prior call to \Id{IDAInit} has
been made. The new problem must have the same size as the previous one.
\id{IDAReInit} performs the same input checking and initializations 
that \id{IDAInit} does, but does no memory allocation, as it assumes that
the existing internal memory is sufficient for the new problem.
A call to \id{IDAReInit} deletes the solution history that was stored
internally during the previous integration.  Following a successful call to
\id{IDAReInit}, call \id{IDASolve} again for the solution of the new problem.

The use of \id{IDAReInit} requires that the maximum method order,    
\Id{maxord}, is no larger for the new problem than for the problem  
specified in the last call to \id{IDAInit}.  In addition, the same
{\nvector} module set for the previous problem
will be reused for the new problem.

If there are changes to the linear solver specifications, make the
appropriate \id{IDA***} calls, as described in \S\ref{sss:lin_solv_init}.
If there are changes to any optional inputs, make the appropriate
\id{IDASet***} calls, as described in \S\ref{ss:optional_input}.

One important use of the \id{IDAReInit} function is in the treating
of jump discontinuities in the residual function.  Except in cases of
fairly small jumps, it is usually more efficient to stop at each point
of discontinuity and restart the integrator with a readjusted DAE
model, using a call to \id{IDAReInit}.  To stop when the location of
the discontinuity is known, simply make that location a value of tout.
To stop when the location of the discontinuity is determined by the
solution, use the rootfinding feature.  In either case, it is critical
that the residual function {\it not} incorporate the discontinuity, but
rather have a smooth extention over the discontinuity, so that the
step across it (and subsequent rootfinding, if used) can be done
efficiently.  Then use a switch within the residual function (communicated
through \id{user\_data}) that can be flipped between the stopping of
the integration and the restart, so that the restarted problem uses
the new values (which have jumped).  Similar comments apply if there
is to be a jump in the dependent variable vector.

%%
%%
\ucfunction{IDAReInit}
{
  flag = IDAReInit(ida\_mem, t0, y0, yp0);
}
{
  The function \ID{IDAReInit} provides required problem specifications 
  and reinitializes {\idas}.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[t0] (\id{realtype})
    is the initial value of $t$.
  \item[y0] (\id{N\_Vector})
    is the initial value of $y$. 
  \item[yp0] (\id{N\_Vector})
    is the initial value of $\dot{y}$.   
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_NO\_MALLOC]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAReInit} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a 
    previous call to \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    Memory space for the {\idas} memory block was not allocated through a 
    previous call to \id{IDAInit}.
  \item[\Id{IDA\_ILL\_INPUT}] 
    An input argument to \id{IDAReInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{IDAReInit} also sends an error message to the
  error handler function.
}


%%===================================================================================
\section{User-supplied functions}\label{ss:user_fct_sim}
%%===================================================================================

The user-supplied functions consist of one function defining the DAE residual,
(optionally) a function that handles error and warning messages, 
(optionally) a function that provides the error weight vector,
(optionally) a function that provides Jacobian-related information for the linear 
solver (if Newton iteration is chosen), and (optionally) one or two functions 
that define the preconditioner for use in any of the Krylov iteration algorithms.
%%
%%--------------
%%
\subsection{Residual function}\label{ss:resFn}
\index{residual function}
The user must provide a function of type \ID{IDAResFn} defined as follows:
\usfunction{IDAResFn}
{
  typedef int (*IDAResFn)(&realtype tt, N\_Vector yy, N\_Vector yp,  \\
                          &N\_Vector rr, void *user\_data);
}
{
  This function computes the problem residual for given values
  of the independent variable $t$, state vector $y$, and derivative $\dot{y}$.
}
{
  \begin{args}[user\_data]
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[rr]
    is the output residual vector $F(t,y,\dot{y})$.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \end{args}
}
{
  An \id{IDAResFn} function type should return a value of $0$ if successful, 
  a positive value if a recoverable error occurred (e.g. \id{yy} has an illegal
  value), or a negative value if a nonrecoverable error occurred. 
  In the last case, the integrator halts. 
  If a recoverable error occurred, the integrator will attempt to correct and retry.
}
{
  A recoverable failure error return from the \id{IDAResFn} is typically used to
  flag a value of the dependent variable \id{y} that is ``illegal'' in
  some way (e.g., negative where only a non-negative value is physically
  meaningful).  If such a return is made, {\idas} will attempt to recover
  (possibly repeating the Newton iteration, or reducing the step size)
  in order to avoid this recoverable error return.

  For efficiency reasons, the DAE residual function is not evaluated
  at the converged solution of the nonlinear solver. Therefore, in general, a
  recoverable error in that converged value cannot be corrected.  (It may be
  detected when the right-hand side function is called the first time during
  the following integration step, but a successful step cannot be undone.) 
  However, if the user program also includes quadrature integration, the
  state variables can be checked for legality in the call to
  \id{IDAQuadRhsFn}, which is called at the converged solution of the
  nonlinear system, and therefore {\idas} can be flagged to attempt
  to recover from such a situation. Also, if sensitivity analysis is
  performed with the staggered method, the DAE residual
  function is called at the converged solution of the nonlinear system,
  and a recoverable error at that point can be flagged, and {\idas}
  will then try to correct it.

  Allocation of memory for \id{yp} is handled within {\idas}.
}
%%
%%--------------
%%
\subsection{Error message handler function}
\label{ss:ehFn}
\index{error messages!user-defined handler}
As an alternative to the default behavior of directing error and warning messages 
to the file pointed to by \id{errfp} (see \id{IDASetErrFile}), the user may
provide a function of type \ID{IDAErrHandlerFn} to process any such messages.
The function type \id{IDAErrHandlerFn} is defined as follows:
\usfunction{IDAErrHandlerFn}
{
  typedef void (*IDAErrHandlerFn)(&int error\_code, const char *module,\\
                                  &const char *function, char *msg,\\
                                  &void *eh\_data);
}
{
  This function processes error and warning messages from {\idas} and 
  its sub-modules.
}
{
  \begin{args}[error\_code]
  \item[error\_code]
    is the error code.
  \item[module]
    is the name of the {\idas} module reporting the error.
  \item[function]
    is the name of the function in which the error occurred.
  \item[msg]
    is the error message.
  \item[eh\_data]
    is a pointer to user data, the same as the \Id{eh\_data}
    parameter passed to \id{IDASetErrHandlerFn}.   
  \end{args}
}
{
  A \id{IDAErrHandlerFn} function has no return value.
}
{
  \id{error\_code} is negative for errors and positive (\Id{IDA\_WARNING}) for warnings.
  If a function that returns a pointer to memory encounters an
  error, it sets \id{error\_code} to 0.
}
%%
%%--------------
%%
\subsection{Error weight function}
\label{ss:ewtsetFn}
\index{tolerances}
As an alternative to providing the relative and absolute tolerances, the user may
provide a function of type \ID{IDAEwtFn} to compute a vector \id{ewt} containing the
multiplicative weights $W_i$ used in the WRMS norm 
$\|\ v \|_{\mbox{\scriptsize WRMS}} = \sqrt{(1/N)\sum_1^N (W_i \cdot v_i)^2}$.
These weights will used in place of those defined by Eq. (\ref{e:errwt}).
The function type \id{IDAEwtFn} is defined as follows:
\usfunction{IDAEwtFn}
{
  typedef int (*IDAEwtFn)(N\_Vector y, N\_Vector ewt, void *user\_data);
}
{
  This function computes the WRMS error weights for the vector $y$.
}
{
  \begin{args}[user\_data]
  \item[y]
    is the value of the dependent variable vector at which the weight vector
    is to be computed.
  \item[ewt]
    is the output vector containing the error weights.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \end{args}
}
{
  An \id{IDAEwtFn} function type must return $0$ if it successfully set
  the error weights and $-1$ otherwise.
}
{
  Allocation of memory for \id{ewt} is handled within {\idas}.

  {\warn}The error weight vector must have all components positive. It is the
  user's responsiblity to perform this test and return $-1$ if it is not 
  satisfied.
}
%%
%%--------------
%%
\subsection{Rootfinding function}
\label{ss:rootFn}
If a rootfinding problem is to be solved during the integration of the DAE system,
the user must supply a {\CC} function of type \ID{IDARootFn}, defined as follows:
%%
\usfunction{IDARootFn}
{
  typedef int (*IDARootFn)(&realtype t, N\_Vector y, N\_Vector yp, \\
                           &realtype *gout, void *user\_data);
}
{
  This function computes a vector-valued function $g(t,y,\dot{y})$ such that the
  roots of the \id{nrtfn} components $g_i(t,y,\dot{y})$ are to be found during
  the integration.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$, the $t-$derivative of $y$.
  \item[gout]
    is the output array, of length \id{nrtfn}, with components $g_i(t,y,\dot{y})$.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \end{args}
}
{
  An \id{IDARootFn} should return 0 if successful or a non-zero value if
  an error occurred (in which case the integration is halted and \id{IDASolve} returns
  \Id{IDA\_RTFUNC\_FAIL}).
}
{
  Allocation of memory for \id{gout} is handled within {\idas}.
}

%%
%%--------------
%%
\subsection{Jacobian information (direct method with dense Jacobian)}
\label{ss:djacFn}
\index{Jacobian approximation function!dense!user-supplied|(}
If the direct linear solver with dense treatment of the Jacobian is
used (i.e. either \Id{IDADense} or \Id{IDALapackDense} is called in
Step \ref{i:lin_solver} of \S\ref{ss:skeleton_sim}), the user may
provide a function of type \ID{IDADlsDenseJacFn} defined by
\usfunction{IDADlsDenseJacFn}
{
  typedef int (*IDADlsDenseJac&Fn)(long int Neq, realtype tt, realtype cj,\\
                             &N\_Vector yy, N\_Vector yp, N\_Vector rr, \\ 
                             &DlsMat Jac, void *user\_data,  \\
                             &N\_Vector tmp1, N\_Vector tmp2, N\_Vector tmp3);
}
{
  This function computes the dense Jacobian $J$ of the DAE system (or an
  approximation to it), defined by Eq. (\ref{e:DAE_Jacobian}).
  
}
{
  \begin{args}[user\_data]
  \item[Neq]
    is the problem size (number of equations).
  \item[tt]
    is the current value of the independent variable $t$.
  \item[cj]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[rr]
    is the current value of the residual vector $F(t,y,\dot{y})$.
  \item[Jac]
    is the output (approximate) Jacobian matrix,
    $J = \partial{F}/\partial{y} + cj ~ \partial{F}/\partial{\dot{y}}$.  
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated for variables of type \id{N\_Vector} 
    which can be used by \id{IDADlsDenseJacFn} as temporary storage or work space.
  \end{args}
}
{
  An \id{IDADlsDenseJacFn} function type should return $0$ if successful,
  a positive value if a recoverable error occurred, or a negative value
  if a nonrecoverable error occurred. 

  In the case of a recoverable eror return, 
  the integrator will attempt to recover by reducing the stepsize,
  and hence changing $\alpha$ in (\ref{e:DAE_Jacobian}).
}
{
  A user-supplied dense Jacobian function must load the \id{Neq} $\times$ \id{Neq}
  dense matrix \id{Jac} with an approximation to the Jacobian matrix $J(t,y,\dot{y})$
  at the point (\id{tt}, \id{yy}, \id{yp}).  Only nonzero elements need to be loaded
  into \id{Jac} because \id{Jac} is set to the zero matrix before the call
  to the Jacobian function. The type of \id{Jac} is \Id{DlsMat} 
  (described below and in \S\ref{s:dls}). 
  
  The accessor macros \Id{DENSE\_ELEM} and \Id{DENSE\_COL} allow the user to
  read and write dense matrix elements without making explicit
  references to the underlying representation of the \id{DlsMat}
  type. \id{DENSE\_ELEM(Jac, i, j)} references the (\id{i}, \id{j})-th
  element of the dense matrix \id{Jac} (\id{i}, \id{j}$= 0\ldots$ \id{Neq}$-1$).
  This macro is for use in small problems in which efficiency of access is not a
  major concern.  Thus, in terms of indices $m$ and $n$ running from $1$ to
  \id{Neq}, the Jacobian element $J_{m,n}$ can be loaded with the statement
  \id{DENSE\_ELEM(Jac, m-1, n-1) =} $J_{m,n}$.  Alternatively,
  \id{DENSE\_COL(Jac, j)} returns a pointer to the storage for
  the \id{j}th column of \id{Jac} (\id{j}$= 0\ldots$ \id{Neq}$-1$), and the 
  elements of the \id{j}-th column
  are then accessed via ordinary array indexing.  Thus $J_{m,n}$ can be 
  loaded with the statements \id{col\_n = DENSE\_COL(Jac, n-1);}
  \id{col\_n[m-1] =} $J_{m,n}$.  For large problems, it is more 
  efficient to use \id{DENSE\_COL} than to use \id{DENSE\_ELEM}. 
  Note that both of these macros number rows and columns
  starting from $0$, not $1$.  

  The \id{DlsMat} type and the accessor macros \id{DENSE\_ELEM} and 
  \id{DENSE\_COL} are documented in \S\ref{s:dls}.

  If the user's \id{IDADlsDenseJacFn} function uses difference
  quotient approximations, it may need to access quantities not in the
  call list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_data} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  For the sake of uniformity, the argument \id{Neq} is of type \id{long int},
  even in the case that the Lapack dense solver is to be used.
}
\index{Jacobian approximation function!dense!user-supplied|)}
%%
%%--------------
%%
\subsection{Jacobian information (direct method with banded Jacobian)}
\label{ss:bjacFn}
\index{Jacobian approximation function!band!user-supplied|(}
\index{half-bandwidths|(}
If the direct linear solver with banded treatment of the Jacobian is
used (i.e. either \Id{IDABand} or \Id{IDALapackBand} is called in Step
\ref{i:lin_solver} of \S\ref{ss:skeleton_sim}), the user may provide a
function of type \ID{IDADlsBandJacFn} defined as follows:
\usfunction{IDADlsBandJacFn}
{
 typedef int (*IDADlsBandJacFn&)(long int Neq, long int mupper,\\
                             &long int mlower, realtype tt, realtype cj,\\ 
                             &N\_Vector yy, N\_Vector yp, N\_Vector rr, \\
                             &DlsMat Jac, void *user\_data, \\
                             &N\_Vector tmp1, N\_Vector tmp2,N\_Vector tmp3);
}
{
  This function computes the banded Jacobian $J$ of the DAE system (or a banded
  approximation to it), defined by Eq. (\ref{e:DAE_Jacobian}).

}
{
  \begin{args}[user\_data]
  \item[Neq]
    is the problem size.
  \item[mupper]
  \item[mlower]
    are the upper and lower half bandwidth of the Jacobian.
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[rr]
    is the current value of the residual vector $F(t,y,\dot{y})$.
  \item[cj]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[Jac]
    is the output (approximate) Jacobian matrix,
    $J = \partial{F}/\partial{y} + cj ~ \partial{F}/\partial{\dot{y}}$.
    \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated for variables of type \id{N\_Vector} 
    which can be used by \id{IDADlsBandJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A \id{IDADlsBandJacFn} function type should return $0$ if successful,
  a positive value if a recoverable error occurred, or a negative value
  if a nonrecoverable error occurred. 

  In the case of a recoverable eror return, 
  the integrator will attempt to recover by reducing the stepsize,
  and hence changing $\alpha$ in (\ref{e:DAE_Jacobian}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{Jac}
  of type \Id{DlsMat} with the elements of the Jacobian $J(t,y,\dot{y})$ at the
  point (\id{tt}, \id{yy}, \id{yp}).  Only nonzero elements need to be loaded into
  \id{Jac} because \id{Jac} is preset to zero before the call to the
  Jacobian function.  

  The accessor macros \Id{BAND\_ELEM}, \Id{BAND\_COL}, and \Id{BAND\_COL\_ELEM} 
  allow the user to read and write band matrix elements without making specific 
  references to the underlying representation of the \id{DlsMat} type.
  \id{BAND\_ELEM(Jac, i, j)} references the (\id{i}, \id{j})th element of the 
  band matrix \id{Jac}, counting from $0$.
  This macro is for use in small problems in which efficiency of access is not
  a major concern.  Thus, in terms of indices $m$ and $n$ running from $1$ to
  \id{Neq} with $(m,n)$ within the band defined by \id{mupper} and
  \id{mlower}, the Jacobian element $J_{m,n}$ can be loaded with the 
  statement \id{BAND\_ELEM(Jac, m-1, n-1) =} $J_{m,n}$. The elements within
  the band are those with \id{-mupper} $\le$ \id{m-n} $\le$ \id{mlower}.
  Alternatively, \id{BAND\_COL(Jac, j)} returns a pointer to the diagonal element
  of the \id{j}th column of \id{Jac}, and if we assign this address to 
  \id{realtype *col\_j}, then the \id{i}th element of the \id{j}th column is
  given by \id{BAND\_COL\_ELEM(col\_j, i, j)}, counting from $0$.
  Thus for $(m,n)$ within the band, $J_{m,n}$ can be loaded by setting 
  \id{col\_n = BAND\_COL(Jac, n-1);} \id{BAND\_COL\_ELEM(col\_n, m-1, n-1) =} $J_{m,n}$.
  The elements of the \id{j}th column can also be accessed
  via ordinary array indexing, but this approach requires knowledge of
  the underlying storage for a band matrix of type \id{DlsMat}.  
  The array \id{col\_n} can be indexed from $-$\id{mupper} to \id{mlower}.
  For large problems, it is more efficient to use the combination of
  \id{BAND\_COL} and \id{BAND\_COL\_ELEM} than to use the
  \id{BAND\_ELEM}.  As in the dense case, these macros all number rows
  and columns starting from $0$, not $1$.  

  The \id{DlsMat} type and the accessor macros \id{BAND\_ELEM}, \id{BAND\_COL}, and
  \id{BAND\_COL\_ELEM} are documented in \S\ref{s:dls}.

  If the user's \id{IDADlsBandJacFn} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_data} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  For the sake of uniformity, the arguments \id{Neq}, \id{mlower}, and \id{mupper} are
  of type \id{long int}, even in the case that the Lapack band solver is to be used.
}
\index{half-bandwidths|)}
\index{Jacobian approximation function!band!user-supplied|)}
%%
%%----------------
%%
\subsection{Jacobian information (direct method with sparse Jacobian)}
\label{ss:sjacFn}
\index{Jacobian approximation function!sparse!user-supplied|(}
If the direct linear solver with sparse treatment of the Jacobian is
used (i.e. either \Id{IDAKLU} or \Id{IDASuperLUMT} is called in Step
\ref{i:lin_solver} of \S\ref{ss:skeleton_sim}), the user must provide a
function of type \ID{IDASlsSparseJacFn} defined as follows:
\usfunction{IDASlsSparseJacFn}
{
 typedef int (*IDASlsSparseJacFn&)(realtype t, realtype c\_j,\\ 
                             &N\_Vector y, N\_Vector yp, N\_Vector r, \\
                             &SlsMat Jac, void *user\_data, \\
                             &N\_Vector tmp1, N\_Vector tmp2,N\_Vector tmp3);
}
{
  This function computes the sparse Jacobian $J$ of the DAE system (or an
  approximation to it), defined by Eq. (\ref{e:DAE_Jacobian}).

}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[r]
    is the current value of the residual vector $F(t,y,\dot{y})$.
  \item[c\_j]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[Jac]
    is the output (approximate) Jacobian matrix,
    $J = \partial{F}/\partial{y} + cj ~ \partial{F}/\partial{\dot{y}}$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated for variables of type \id{N\_Vector} 
    which can be used by \id{IDASlsSparseJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A \id{IDASlsSparseJacFn} function type should return $0$ if successful,
  a positive value if a recoverable error occurred, or a negative value
  if a nonrecoverable error occurred. 

  In the case of a recoverable error return, 
  the integrator will attempt to recover by reducing the stepsize,
  and hence changing $\alpha$ in (\ref{e:DAE_Jacobian}).
}
{
  A user-supplied sparse Jacobian function must load the
  compressed-sparse-column matrix \id{Jac} with the elements of the
  Jacobian $J(t,y,\dot{y})$ at the point (\id{t}, \id{y}, \id{yp}).
  Storage for \id{Jac} already exists on entry to this function,
  although the user should ensure that sufficient space is allocated
  in \id{Jac} to hold the nonzero values to be set; if the existing
  space is insufficient the user may reallocate the data and row index
  arrays as needed.  The type of \id{Jac} is \id{SlsMat}, and the
  amount of allocated space is available within the \id{SlsMat}
  structure as \id{NNZ}.  The \id{SlsMat} type is further documented
  in the Section \S\ref{s:sls}. 
 
  If the user's \id{IDASlsSparseJacFn} function uses difference quotient
  approximations to set the specific nonzero matrix entries, then it
  may need to access quantities not in the argument list. These
  include the current step size, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_data} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{Jacobian approximation function!sparse!user-supplied|)}
%%
%%----------------
%%
\subsection{Jacobian information (matrix-vector product)}
\label{ss:jtimesFn}
\index{Jacobian approximation function!Jacobian times vector!user-supplied|(}
If one of the Krylov iterative linear solvers {\spgmr}, {\spbcg}, or {\sptfqmr} is
selected (\id{IDASp*} is called in step \ref{i:lin_solver} of
\S\ref{ss:skeleton_sim}), the user may provide a function
of type \ID{IDASpilsJacTimesVecFn}, described below,
to compute matrix-vector products $Jv$. If such a function is not supplied,
the default is a difference quotient approximation to these products.
%
\usfunction{IDASpilsJacTimesVecFn}
{
  typedef int (*IDASpilsJacTimesVecFn)(&realtype tt, N\_Vector yy, \\
                                       &N\_Vector yp, N\_Vector rr, \\
                                       &N\_Vector v, N\_Vector Jv, \\
                                       &realtype cj, void *user\_data, \\
                                       &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the product $Jv$ of the DAE system Jacobian $J$
 (or an approximation to it) and a given vector \id{v}, where $J$ is defined by
  Eq. (\ref{e:DAE_Jacobian}).
}
{
  \begin{args}[user\_data]
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[rr]
    is the current value of the residual vector $F(t,y,\dot{y})$.
  \item[v]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[Jv]
      is the computed output vector.
  \item[cj]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{IDASetUserData}.   
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by \id{IDASpilsJacTimesVecFn} as temporary storage or work space.
  \end{args}
}
{
  The value to be returned by the Jacobian-times-vector function should be 0 if
  successful.  A nonzero value indicates that a nonrecoverable error occurred. 
}
{
  If the user's \id{IDASpilsJacTimesVecFn} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_data} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{Jacobian approximation function!Jacobian times vector!user-supplied|)}
%%
%%--------------
%%
\subsection{Preconditioning (linear system solution)}
\label{ss:psolveFn}
\index{preconditioning!user-supplied}
\index{IDASPGMR@{\idaspgmr} linear solver!preconditioner solve function}
\index{IDASPBCG@{\idaspbcg} linear solver!preconditioner solve function}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!preconditioner solve function}
If preconditioning is used, then the user must provide a {\CC} function to
solve the linear system $Pz = r$ where $P$ is a left preconditioner
matrix which approximates (at least crudely) the Jacobian matrix 
$J = \partial{F}/\partial{y} + cj ~ \partial{F}/\partial{\dot{y}}$.
This function must be of type \ID{IDASpilsPrecSolveFn}, defined as follows:
%%
%%
\usfunction{IDASpilsPrecSolveFn}
{
  typedef int (*IDASpilsPrecSolveFn)(&realtype tt, N\_Vector yy, \\
                                     &N\_Vector yp, N\_Vector rr, \\
                                     &N\_Vector rvec, N\_Vector zvec, \\ 
                                     &realtype cj, realtype delta, \\
                                     &void *user\_data, N\_Vector tmp);
}
{
  This function solves the preconditioning system $Pz = r$.
}
{  
  \begin{args}[user\_data]
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[rr]
    is the current value of the residual vector $F(t,y,\dot{y})$.
  \item[rvec]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvec]
    is the computed output vector.
  \item[cj]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[delta]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.  In that case, the residual 
    vector $Res = r - P z$ of the system should be made less than 
    \id{delta} in weighted $l_2$ norm,     
    i.e., $\sqrt{\sum_i (Res_i \cdot ewt_i)^2 } <$ \id{delta}.
    To obtain the \id{N\_Vector} \id{ewt}, call \id{IDAGetErrWeights} 
    (see \S\ref{sss:optout_main}).
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to the function \id{IDASetUserData}.
  \item[tmp]
    is a pointer to memory allocated for a variable of type    
    \id{N\_Vector} which can be used for work space.
  \end{args}
}
{
  The value to be returned by the preconditioner solve function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  negative for an unrecoverable error (in which case the integration is halted). 
}
{}
%%
%%-----------------
%%
\subsection{Preconditioning (Jacobian data)}
\label{ss:precondFn}
\index{preconditioning!user-supplied}
\index{IDASPGMR@{\idaspgmr} linear solver!preconditioner setup function}
\index{IDASPBCG@{\idaspbcg} linear solver!preconditioner setup function}
\index{IDASPTFQMR@{\idasptfqmr} linear solver!preconditioner setup function}
If the user's preconditioner requires that any Jacobian-related data
be evaluated or preprocessed, then this needs to be done in a
user-supplied {\CC} function of type \ID{IDASpilsPrecSetupFn}, defined as follows:
\usfunction{IDASpilsPrecSetupFn}
{
  typedef int (*IDASpilsPrecSetupFn)(&realtype tt, N\_Vector yy, \\
                                     &N\_Vector yp, N\_Vector rr, \\
                                     &realtype cj, void *user\_data,\\
                                     &N\_Vector tmp1, N\_Vector tmp2,\\
                                     &N\_Vector tmp3);
}
{
  This function evaluates and/or preprocesses Jacobian-related data needed
  by the preconditioner.
}
{
  The arguments of an \id{IDASpilsPrecSetupFn} are as follows:
  \begin{args}[user\_data]
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[rr]
    is the current value of the residual vector $F(t,y,\dot{y})$.
  \item[cj]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to the function \id{IDASetUserData}.
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by \id{IDASpilsPrecSetupFn} as temporary storage or work space.
  \end{args}
}
{
  The value to be returned by the preconditioner setup function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  negative for an unrecoverable error (in which case the integration is halted). 
}
{
  The operations performed by this function might include forming a crude
  approximate Jacobian, and performing an LU factorization on the resulting
  approximation.

  Each call to the preconditioner setup function is preceded by a call to the
  \id{IDAResFn} user function with the same (\id{tt}, \id{yy}, \id{yp}) arguments.  
  Thus the preconditioner setup function can use any auxiliary data that is 
  computed and saved during the evaluation of the DAE residual.
  
  This function is not called in advance of every call to the preconditioner solve
  function, but rather is called only as often as needed to achieve convergence in
  the Newton iteration.

  If the user's \id{IDASpilsPrecSetupFn} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_data} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}


%%
%%===================================================================================
\section{Integration of pure quadrature equations}
%%===================================================================================
%%

{\idas} allows the DAE system to include {\em pure quadratures}.  In
this case, it is more efficient to treat the quadratures separately by
excluding them from the nonlinear solution stage.  To do this, begin
by excluding the quadrature variables from the vectors \id{yy} and
\id{yp} and the quadrature equations from within \id{res}.  Thus a
separate vector \id{yQ} of quadrature variables is to satisfy
$(d/dt)$\id{yQ} = $f_Q(t,y,\dot{y})$.  The following is an overview of the
sequence of calls in a user's main program in this situation. Steps
that are unchanged from the skeleton program presented in
\S\ref{ss:skeleton_sim} are grayed out.

\index{User main program!integration of quadratures}
\begin{Steps}
  
\item 
  \textcolor{gray}{\bf {\p} {\h} Initialize MPI}

\item
  {\bf Set problem dimensions}

  {\s} {\omp} {\pt} Set \id{N} to the problem size $N$ (excluding quadrature
  variables), and \id{Nq} to the number of quadrature variables.

  {\omp, \pt} Set \id{num\_threads}, the number of threads to use within
  the threaded vector functions.

  {\p} {\h} Set \id{Nlocal} to the local vector length (excluding quadrature
  variables), and \id{Nqlocal} to the local number of quadrature variables.
  
\item
  \textcolor{gray}{\bf Set vectors of initial values}
 
\item\label{i:quad_ida_create}
  \textcolor{gray}{\bf Create {\idas} object}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item
  \textcolor{gray}{\bf Attach linear solver module}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

\item
  {\bf Set vector of initial values for quadrature variables}

  Typically, the quadrature variables should be initialized to $0$.

\item
  {\bf Initialize quadrature integration}

  Call \id{IDAQuadInit} to specify the quadrature equation right-hand
  side function and to allocate internal memory related to quadrature integration. 
  See \S\ref{ss:quad_init} for details.

\item\label{i:quad_optional_inputs}
  {\bf Set optional inputs for quadrature integration}

  Call \id{IDASetQuadErrCon} to indicate whether or not quadrature variables
  should be used in the step size control mechanism. If so, one of the 
  \id{IDAQuad*tolerances} functions  must be called to specify the integration 
  tolerances for quadrature variables.
  See \S\ref{ss:quad_optional_input} for details.

\item\label{i:quad_ida_solve}
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Extract quadrature variables}

  Call \id{IDAGetQuad} or \id{IDAGetQuadDky} to obtain the values of the quadrature 
  variables or their derivatives at the current time. See \S\ref{ss:quad_get} for details.

\item
  \textcolor{gray}{\bf Get optional outputs}

\item
  {\bf Get quadrature optional outputs}

  Call \id{IDAGetQuad*} functions to obtain optional output related to
  the integration of quadratures.
  See \S\ref{ss:quad_optional_output} for details.

\item
  {\bf Deallocate memory for solution vectors and for the vector of quadrature variables}
  
\item
  {\bf Free solver memory}

\item 
  \textcolor{gray}{\bf {\p} {\h} Finalize MPI}
  
\end{Steps}
%%
\id{IDAQuadInit} can be called and quadrature-related optional inputs 
(step \ref{i:quad_optional_inputs} above) can be set, anywhere between steps 
\ref{i:quad_ida_create} and \ref{i:quad_ida_solve}.

%%===================================================================================

\subsection{Quadrature initialization and deallocation functions}\label{ss:quad_init}

The function \id{IDAQuadInit} activates integration of quadrature equations 
and allocates internal memory related to these calculations.
The form of the call to this function is as follows:
%%
\ucfunction{IDAQuadInit}
{
flag = IDAQuadInit(ida\_mem, rhsQ, yQ0);
}
{
  The function \ID{IDAQuadInit} provides required problem specifications,
  allocates internal memory, and initializes quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[rhsQ] (\Id{IDAQuadRhsFn})
    is the {\CC} function which computes $f_Q$, the right-hand side of the quadrature
    equations. This function has the form 
    \id{fQ(t, yy, yp, rhsQ, user\_data)} (for full details see \S\ref{ss:user_fct_quad}).
  \item[yQ0] (\id{N\_Vector})
    is the initial value of $y_Q$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_MEM\_FAIL]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadInit} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory was not initialized by a prior call to \id{IDACreate}.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request failed.
  \end{args}
}
{
  If an error occurred, \id{IDAQuadInit} also sends an error message to the
  error handler function.
}
%%
\index{memory requirements!IDAS@{\idas} solver}
In terms of the number of quadrature variables $N_q$ and maximum
method order \id{maxord}, the size of the real workspace is increased
as follows:
\begin{itemize}
\item Base value: \id{lenrw} $=$ \id{lenrw} $+$ (\id{maxord+5})$N_q$
\item If \id{IDAQuadSVtolerances} is called: \id{lenrw} $=$ \id{lenrw} $+ N_q$ 
\end{itemize}
and the size of the integer workspace is increased as follows:
\begin{itemize}
\item Base value: \id{leniw} $=$ \id{leniw} $+$ (\id{maxord+5})$N_q$
\item If \id{IDAQuadSVtolerances} is called: \id{leniw} $=$ \id{leniw} $+ N_q$ 
\end{itemize}

The function \id{IDAQuadReInit}, useful during the solution of a
sequence of problems of same size, reinitializes the quadrature-related
internal memory and must follow a call to \Id{IDAQuadInit} (and maybe
a call to \id{IDAReInit}).  The number \id{Nq} of quadratures is
assumed to be unchanged from the prior call to \id{IDAQuadInit}.  The
call to the \id{IDAQuadReInit} function has the following form:
%%
\ucfunction{IDAQuadReInit}
{
  flag = IDAQuadReInit(ida\_mem, yQ0);
}
{
  The function \ID{IDAQuadReInit} provides required problem specifications 
  and reinitializes the quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[yQ0] (\id{N\_Vector})
    is the initial value of $y_Q$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAReInit} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory was not initialized by a prior call to \id{IDACreate}.
  \item[\Id{IDA\_NO\_QUAD}] 
    Memory space for the quadrature integration was not allocated by a prior
    call to \id{IDAQuadInit}.
  \end{args}
}
{
  If an error occurred, \id{IDAQuadReInit} also sends an error message to the
  error handler function.
}
%%
%%
\ucfunction{IDAQuadFree}
{
  IDAQuadFree(ida\_mem);
}
{
  The function \ID{IDAQuadFree} frees the memory allocated for quadrature integration.
}
{
  The argument is the pointer to the {\idas} memory block (of type \id{void *}).
}
{
  The function \id{IDAQuadFree} has no return value.
}
{
  In general, \id{IDAQuadFree} need not be called by the user as it is
  invoked automatically by \id{IDAFree}.
}

%%===================================================================================

\subsection{IDAS solver function}

Even if quadrature integration was enabled, the call to the main solver 
function \id{IDASolve} is exactly the same as in \S\ref{sss:idasolve}. However, in
this case the return value \id{flag} can also be one of the following:
\begin{args}[IDA\_FIRST\_QRHSFUNC\_FAIL]
\item[\Id{IDA\_QRHS\_FAIL}]
  The quadrature right-hand side function failed in an unrecoverable manner.
\item[\Id{IDA\_FIRST\_QRHS\_ERR}]
  The quadrature right-hand side function failed at the first call.
\item[\Id{IDA\_REP\_QRHS\_ERR}]
  Convergence test failures occurred too many times due to repeated
  recoverable errors in the quadrature right-hand side function. This
  value will also be returned if the quadrature right-hand side function
  had repeated recoverable errors during the estimation of an initial step
  size (assuming the quadrature variables are included in the error tests).
  \end{args}

%%===================================================================================

\subsection{Quadrature extraction functions}\label{ss:quad_get}

If quadrature integration has been initialized by a call to \id{IDAQuadInit},
or reinitialized by a call to \id{IDAQuadReInit}, then {\idas} computes both a solution
and quadratures at time \id{t}. However, \id{IDASolve} will still return only the solution
$y$ in \id{y}. Solution quadratures can be obtained using the following function:
%%
%%
\ucfunction{IDAGetQuad}
{
  flag = IDAGetQuad(ida\_mem, \&tret, yQ);
}
{
  The function \ID{IDAGetQuad} returns the quadrature solution vector after a
  successful return from \id{IDASolve}.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{IDAInit}.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yQ] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
{
  The return value \id{flag} of \id{IDAGetQuad} is one of:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetQuad} was successful.
  \item[IDA\_MEM\_NULL] 
    \id{ida\_mem} was NULL.
  \item[IDA\_NO\_QUAD] 
    Quadrature integration was not initialized.
  \item[IDA\_BAD\_DKY] 
    \id{yQ} is \id{NULL}.
  \end{args}
}
{}
%%
%%
\index{optional output!interpolated quadratures}
The function \Id{IDAGetQuadDky} computes the \id{k}-th derivatives of the interpolating 
polynomials for the quadrature variables at time \id{t}.
This function is called by \id{IDAGetQuad} with \id{k = 0} and with the current
time at which \id{IDASolve} has returned, but may also be called 
directly by the user.
%%
\ucfunction{IDAGetQuadDky}
{
  flag = IDAGetQuadDky(ida\_mem, t, k, dkyQ);
}
{
  The function \ID{IDAGetQuadDky} returns derivatives of the quadrature solution 
  vector after a successful return from \id{IDASolve}.
}
{
  \begin{args}[ida\_mem]
  \item[\id{ida\_mem}] (\id{void *})
    pointer to the memory previously allocated by \id{IDAInit}.
  \item[\id{t}] (\id{realtype})
    the time at which quadrature information is 
    requested. The time \id{t} must fall within the interval defined by the last 
    successful step taken by {\idas}.
  \item[\id{k}] (\id{int}) order of the requested derivative.  This
    must be $\leq klast$. 
  \item[\id{dkyQ}] (\id{N\_Vector})
    the vector containing the derivative. This vector must be allocated by the user. 
  \end{args}
}
{
  The return value \id{flag} of \id{IDAGetQuadDky} is one of:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}]
    \id{IDAGetQuadDky} succeeded.
  \item[\Id{IDA\_MEM\_NULL}]
    The pointer to \id{ida\_mem} was NULL.
  \item[\Id{IDA\_NO\_QUAD}] 
    Quadrature integration was not initialized.
  \item[\Id{IDA\_BAD\_DKY}] 
    The vector \id{dkyQ} is \id{NULL}.
  \item[\Id{IDA\_BAD\_K}]
    \id{k} is not in the range $0, 1, ..., klast$.
  \item[\Id{IDA\_BAD\_T}] 
    The time \id{t} is not in the allowed range.
  \end{args}
}
{}
%%
%%

%%===================================================================================

\subsection{Optional inputs for quadrature integration}\label{ss:quad_optional_input}
\index{optional input!quadrature integration|(}
{\idas} provides the following optional input functions to control the integration
of quadrature equations.
%%
\ucfunction{IDASetQuadErrCon}
{
 flag = IDASetQuadErrCon(ida\_mem, errconQ);
}
{
  The function \ID{IDASetQuadErrCon} specifies whether or not the
  quadrature variables are to be used in the step size control mechanism
  within {\idas}.  If they are, the user must call either \id{IDAQuadSStolerances}
  or \id{IDAQuadSVtolerances} to specify the 
  integration tolerances for the quadrature variables.  
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[errconQ] (\id{booleantype})
    specifies whether quadrature variables are included (\id{TRUE}) or not
    (\id{FALSE}) in the error control mechanism. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{
  By default, \id{errconQ} is set to \id{FALSE}. 

  {\warn}It is illegal to call \id{IDASetQuadErrCon} before a call 
  to \id{IDAQuadInit}.
}


If the quadrature variables are part of the step size control mechanism, 
one of the following functions must be called to specify the
integration tolerances for quadrature variables. 

\ucfunction{IDAQuadSStolerances}
{
 flag = IDAQuadSVtolerances(ida\_mem, reltolQ, abstolQ);
}
{
  The function \ID{IDAQuadSStolerances} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[reltolQ] (\id{realtype})
    \index{tolerances}
    is the scalar relative error tolerance.
  \item[abstolQ] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration was not initialized.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}

\ucfunction{IDAQuadSVtolerances}
{
 flag = IDAQuadSVtolerances(ida\_mem, reltolQ, abstolQ);
}
{
  The function \ID{IDAQuadSVtolerances} specifies scalar relative and 
  vector absolute tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[reltolQ] (\id{realtype})
    \index{tolerances}
    is the scalar relative error tolerance.
  \item[abstolQ] (\id{N\_Vector})
    is the vector absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration was not initialized.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}
\index{optional input!quadrature integration|)}
%%
%%

%%===================================================================================

\subsection{Optional outputs for quadrature integration}\label{ss:quad_optional_output}
\index{optional output!quadrature integration|(}

{\idas} provides the following functions that can be used to obtain solver
performance information related to quadrature integration.

\ucfunction{IDAGetQuadNumRhsEvals}
{
  flag = IDAGetQuadNumRhsEvals(ida\_mem, \&nrhsQevals);
}
{
  The function \ID{IDAGetQuadNumRhsEvals} returns the 
  number of calls made to the user's quadrature right-hand side function.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nrhsQevals] (\id{long int})
    number of calls made to the user's \id{rhsQ} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetQuadNumErrTestFails}
{
  flag = IDAGetQuadNumErrTestFails(ida\_mem, \&nQetfails);
}
{
  The function \ID{IDAGetQuadNumErrTestFails} returns the
  number of local error test failures due to quadrature variables.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nQetfails] (\id{long int})
    number of error test failures due to quadrature variables.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{IDAGetQuadErrWeights}
{
  flag = IDAGetQuadErrWeights(ida\_mem, eQweight);
}
{
  The function \ID{IDAGetQuadErrWeights} returns the quadrature error weights 
  at the current time.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[eQweight] (\id{N\_Vector})
    quadrature error weights at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{eQweight}.

  If quadratures were not included in the error control mechanism (through a 
  call to \id{IDASetQuadErrCon} with \id{errconQ = TRUE}), 
  \id{IDAGetQuadErrWeights} does not set the \id{eQweight} vector.
}
%%
%%
\ucfunction{IDAGetQuadStats}
{
  flag = IDAGetQuadStats(ida\_mem, \&nrhsQevals, \&nQetfails);
}
{
  The function \ID{IDAGetQuadStats} returns the {\idas} integrator statistics
  as a group.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[nrhsQevals] (\id{long int})
    number of calls to the user's \id{rhsQ} function.
  \item[nQetfails] (\id{long int})
    number of error test failures due to quadrature variables.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[\Id{IDA\_SUCCESS}] 
    the optional output values have been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    the \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
\index{optional output!quadrature integration|)}
%%
%%

%%===================================================================================

\subsection{User-supplied function for quadrature integration}
\label{ss:user_fct_quad}

\index{right-hand side function!quadrature equations}
For integration of quadrature equations, the user must provide a function 
that defines the right-hand side of the quadrature equations (in other words,
the integrand function of the integral that must be evaluated). This function
must be of type \Id{IDAQuadRhsFn} defined as follows:
\usfunction{IDAQuadRhsFn}
{
  typedef int (*IDAQuadRhsFn)(&realtype t, N\_Vector yy, N\_Vector yp,\\
                             &N\_Vector rhsQ, void *user\_data);
}
{
  This function computes the quadrature equation right-hand side for a given value
  of the independent variable $t$ and state vectors $y$ and $\dot{y}$.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of the dependent variable derivative vector, $\dot{y}(t)$.
  \item[rhsQ]
    is the output vector $f_Q(t,y,\dot{y})$.
  \item[user\_data]
    is the \Id{user\_data} pointer passed to \id{IDASetUserData}.   
  \end{args}
}
{
  A \id{IDAQuadRhsFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \Id{IDA\_QRHS\_FAIL} is returned).
}
{
  Allocation of memory for \id{rhsQ} is automatically handled within {\idas}.

  Both \id{y} and \id{rhsQ} are of type \id{N\_Vector},
  but they  typically have different internal representations. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  There is one situation in which recovery is not possible even if \id{IDAQuadRhsFn}
  function returns a recoverable error flag.  This is when this occurs at the very
  first call to the \id{IDAQuadRhsFn} (in which case {\idas} returns
  \Id{IDA\_FIRST\_QRHS\_ERR}).
}


%%===================================================================================
\section{A parallel band-block-diagonal preconditioner module}\label{sss:idabbdpre}
%%===================================================================================

A principal reason for using a parallel DAE solver such as {\idas} lies
in the solution of partial differential equations (PDEs).  Moreover,
the use of a Krylov iterative method for the solution of many such
problems is motivated by the nature of the underlying linear system of
equations (\ref{e:DAE_Newtoncorr}) that must be solved at each time step.  The
linear algebraic system is large, sparse, and structured. However, if
a Krylov iterative method is to be effective in this setting, then a
nontrivial preconditioner needs to be used.  Otherwise, the rate of
convergence of the Krylov iterative method is usually unacceptably
slow.  Unfortunately, an effective preconditioner tends to be
problem-specific.

However, we have developed one type of preconditioner that treats a
rather broad class of PDE-based problems.  It has been successfully
used for several realistic, large-scale problems \cite{HiTa:98} and is
included in a software module within the {\idas} package. This module
works with the parallel vector module {\nvecp} and 
generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix. The blocks need not have the same number of
super- and sub-diagonals and these numbers may vary from block to
block. This Band-Block-Diagonal Preconditioner module is called
{\idabbdpre}.

\index{IDABBDPRE@{\idabbdpre} preconditioner!description|(}
\index{preconditioning!band-block diagonal}
One way to envision these preconditioners is to think of the domain of
the computational PDE problem as being subdivided into $M$ non-overlapping
sub-domains.  Each of these sub-domains is then assigned to one of the
$M$ processors to be used to solve the DAE system. The basic idea is
to isolate the preconditioning so that it is local to each processor,
and also to use a (possibly cheaper) approximate residual
function. This requires the definition of a new function $G(t,y,\dot{y})$
which approximates the function $F(t, y, \dot{y})$ in the definition of the DAE
system (\ref{e:DAE}). However, the user may set $G = F$.  Corresponding
to the domain decomposition, there is a decomposition of the solution
vectors $y$ and $\dot{y}$ into $M$ disjoint blocks $y_m$ and $\dot{y}_m$, and a
decomposition of $G$ into blocks $G_m$.  The block $G_m$ depends on $y_m$
and $\dot{y}_m$, and also on components of $y_{m'}$ and $\dot{y}_{m'}$ associated with
neighboring sub-domains (so-called ghost-cell data).  Let $\bar{y}_m$
and $\bar{\dot{y}}_m$ denote $y_m$ and $\dot{y}_m$ (respectively) augmented
with those other components on which $G_m$ depends.  Then we have
\begin{equation}
  G(t,y,\dot{y}) = [G_1(t,\bar{y}_1,\bar{\dot{y}}_1), G_2(t,\bar{y}_2,\bar{\dot{y}}_2),
               \ldots, G_M(t,\bar{y}_M,\bar{\dot{y}}_M)]^T ~,
\end{equation}
and each of the blocks $G_m(t,\bar{y}_m,\bar{\dot{y}}_m)$ is uncoupled from
the others.

The preconditioner associated with this decomposition has the form 
\begin{equation}
  P= diag[P_1, P_2, \ldots, P_M]
\end{equation}
where 
\begin{equation}
  P_m \approx \partial G_m / \partial y_m
  + \alpha \partial G_m / \partial \dot{y}_m
\end{equation}
This matrix is taken to be banded, with
upper and lower half-bandwidths \id{mudq} and \id{mldq} defined as
the number of non-zero diagonals above and below the main diagonal,
respectively. The difference quotient approximation is computed using
\id{mudq} $+$ \id{mldq} $+ 2$ evaluations of $G_m$, but only a matrix
of bandwidth \id{mukeep} $+$ \id{mlkeep} $+ 1$ is retained.

Neither pair of parameters need be the true half-bandwidths of the Jacobians
of the local block of $G$, if smaller values provide a more efficient
preconditioner.  Such an efficiency gain may occur if the couplings
in the DAE system outside a certain bandwidth are considerably weaker than
those within the band.  Reducing \id{mukeep} and \id{mlkeep} while keeping
\id{mudq} and \id{mldq} at their true values, discards the elements
outside the narrower band.  Reducing both pairs has the additional
effect of lumping the outer Jacobian elements into the computed elements
within the band, and requires more caution and experimentation.

The solution of the complete linear system
\begin{equation}
  Px = b
\end{equation}
reduces to solving each of the equations 
\begin{equation}
  P_m x_m = b_m
\end{equation}
and this is done by banded LU factorization of $P_m$ followed by a banded
backsolve.
\index{IDABBDPRE@{\idabbdpre} preconditioner!description|)}

Similar block-diagonal preconditioners could be considered with different
treatment of the blocks $P_m$. For example, incomplete LU factorization or
an iterative method could be used instead of banded LU factorization.

%%
%%------------------------------------------------------------------------------------
%%

\index{IDABBDPRE@{\idabbdpre} preconditioner!user-supplied functions|(}
%%
The {\idabbdpre} module calls two user-provided functions to construct $P$: 
a required function \id{Gres} (of type \id{IDABBDLocalFn}) which approximates
the residual function $G(t,y,\dot{y}) \approx F(t,y,\dot{y})$ and which is computed locally,
and an optional function \id{Gcomm} (of type \id{IDABBDCommFn}) which performs
all inter-process communication necessary to evaluate the approximate residual $G$.
These are in addition to the user-supplied residual function \id{res}.
Both functions take as input the same pointer \id{user\_data} as passed
by the user to \id{IDASetUserData} and passed to the user's function \id{res}.
The user is responsible for providing space (presumably within
\id{user\_data}) for components of \id{yy} and \id{yp} that are
communicated by \id{Gcomm} from the other processors, and that are
then used by \id{Gres}, which should not do any communication.
%%
%%
\usfunction{IDABBDLocalFn}
{
  typedef int (*IDABBDLocalFn)(&long int Nlocal, realtype tt,  \\
                                &N\_Vector yy, N\_Vector yp, N\_Vector gval, \\
                                &void *user\_data);
}
{
  This \id{Gres} function computes $G(t,y,\dot{y})$. It loads the vector
  \id{gval} as a function of \id{tt}, \id{yy}, and \id{yp}.  
}
{
  \begin{args}[user\_data]
  \item[Nlocal] 
    is the local vector length.
  \item[tt]
    is the value of the independent variable.
  \item[yy]
    is the dependent variable. 
  \item[yp]
    is the derivative of the dependent variable. 
  \item[gval]
    is the output vector.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{IDASetUserData}.  
  \end{args}
}
{
  An \id{IDABBDLocalFn} function type should return 0 to indicate success,
  1 for a recoverable error, or -1 for a non-recoverable error.
}
{
  This function must assume that all inter-processor communication of data needed to 
  calculate \id{gval} has already been done, and this data is accessible within
  \id{user\_data}.

  The case where $G$ is mathematically identical to $F$ is allowed.
}
%%
%%
\usfunction{IDABBDCommFn}
{
  typedef int (*IDABBDCommFn)(&long int Nlocal, realtype tt,  \\
                               &N\_Vector yy, N\_Vector yp, void *user\_data);
}
{
  This \id{Gcomm} function performs all inter-processor communications necessary 
  for the execution of the \id{Gres} function above, using the input 
  vectors \id{yy} and \id{yp}.
}
{
  \begin{args}[user\_data]
  \item[Nlocal] 
    is the local vector length.
  \item[tt]
    is the value of the independent variable.
  \item[yy]
    is the dependent variable. 
  \item[yp]
    is the derivative of the dependent variable. 
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{IDASetUserData}.  
  \end{args}
}
{
  An \id{IDABBDCommFn} function type should return 0 to indicate success,
  1 for a recoverable error, or -1 for a non-recoverable error.
}
{
  The \id{Gcomm} function is expected to save communicated data in space defined
  within the structure \id{user\_data}. 

  Each call to the \id{Gcomm} function is preceded by a call to the residual
  function \id{res} with the same (\id{tt}, \id{yy}, \id{yp}) arguments.  
  Thus \id{Gcomm} can omit any communications done by \id{res} if relevant to the 
  evaluation of \id{Gres}.  
  If all necessary communication was done in \id{res}, then \id{Gcomm} $=$ \id{NULL}
  can be passed in the call to \id{IDABBDPrecInit} (see below).

}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-supplied functions|)}

%%
%%------------------------------------------------------------------------------------
%%

\index{IDABBDPRE@{\idabbdpre} preconditioner!usage|(}
%%
Besides the header files required for the integration of the DAE problem
(see \S\ref{ss:header_sim}),  to use the {\idabbdpre} module, the main program 
must include the header file \id{idas\_bbdpre.h} which declares the needed
function prototypes.\index{header files}

The following is a summary of the usage of this module and describes the sequence 
of calls in the user main program. Steps that are unchanged from the user main
program presented in \S\ref{ss:skeleton_sim} are grayed-out.
%%
%%
\index{User main program!IDABBDPRE@{\idabbdpre} usage}
\begin{Steps}
\item 
  \textcolor{gray}{\bf Initialize MPI}

\item
  \textcolor{gray}{\bf Set problem dimensions}

\item
  \textcolor{gray}{\bf Set vector of initial values}
 
\item
  \textcolor{gray}{\bf Create {\idas} object}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item \label{i:bbdpre_attach}
  {\bf Attach iterative linear solver, one of:}

  \begin{itemize}
  \item[(a) ] \id{flag = IDASpgmr(ida\_mem, maxl);}
  \item[(b) ] \id{flag = IDASpbcg(ida\_mem, maxl);}
  \item[(c) ] \id{flag = IDASptfqmr(ida\_mem, maxl);}
  \end{itemize}

\item \label{i:bbdpre_init}
  {\bf Initialize the {\idabbdpre} preconditioner module}

  Specify the upper and lower bandwidths \id{mudq}, \id{mldq} and
  \id{mukeep}, \id{mlkeep} and call 

   \id{
     \begin{tabular}[t]{@{}r@{}l@{}}
       flag = IDABBDPrecInit(&ida\_mem, Nlocal, mudq, mldq, \\
                             &mukeep, mlkeep, dq\_rel\_yy, Gres, Gcomm);
     \end{tabular}
   }

  to allocate memory and initialize the internal preconditioner data.
  The last two arguments of \id{IDABBDPrecInit} are the two user-supplied 
  functions described above.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

  Note that the user should not overwrite the preconditioner setup function
  or solve function through calls to {\idaspils} optional input functions.

\item
  \textcolor{gray}{\bf Correct initial values}

\item
  \textcolor{gray}{\bf Specify rootfinding problem}

\item
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Get optional outputs}

  Additional optional outputs associated with {\idabbdpre} are available by 
  way of two routines described below,
  \id{IDABBDPrecGetWorkSpace} and \id{IDABBDPrecGetNumGfnEvals}.

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item
  \textcolor{gray}{\bf Free solver memory}
  
\item 
  \textcolor{gray}{\bf Finalize MPI}

\end{Steps}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!usage|)}
%%
%%------------------------------------------------------------------------------------
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-callable functions|(}
%%
The user-callable functions that initialize (step \ref{i:bbdpre_init}
above) or re-initialize the {\idabbdpre} preconditioner module are
described next.
%%
\index{half-bandwidths}
\ucfunction{IDABBDPrecInit}
{
   \begin{tabular}[t]{@{}r@{}l@{}}
     flag = IDABBDPrecInit(&ida\_mem, Nlocal, mudq, mldq, \\
                           &mukeep, mlkeep, dq\_rel\_yy, Gres, Gcomm);
   \end{tabular}
}
{
  The function \ID{IDABBDPrecInit} initializes and allocates (internal)
  memory for the {\idabbdpre} preconditioner.
}
{
  \begin{args}[dq\_rel\_yy]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[Nlocal] (\id{long int})
    local vector dimension.
  \item[mudq] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldq] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeep] (\id{long int})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeep] (\id{long int})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dq\_rel\_yy] (\id{realtype})
    the relative increment in components of \id{y} used in the difference quotient
    approximations.  The default 
    is \id{dq\_rel\_yy}$ = \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dq\_rel\_yy}$ = 0.0$.
  \item[Gres] (\id{IDABBDLocalFn})
    the {\CC} function which computes the local residual approximation 
    $G(t,y,\dot{y})$.
  \item[Gcomm] (\id{IDABBDCommFn})
    the optional {\CC} function which performs all inter-process communication
    required for the computation of $G(t,y,\dot{y})$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_ILL\_INPUT]
  \item[IDASPILS\_SUCCESS]
    The call to \id{IDABBDPrecInit} was successful.
  \item[\id{IDASPILS\_MEM\_NULL}] 
    The \id{ida\_mem} pointer was \id{NULL}.
  \item[\Id{IDASPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    An {\idaspils} linear solver memory was not attached.
  \item[\Id{IDASPILS\_ILL\_INPUT}]
    The supplied vector implementation was not compatible with block band preconditioner.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} to be used in the 
  difference-quotient calculation of the approximate Jacobian is negative or 
  exceeds the value \id{Nlocal}$-1$, it is replaced by 0 or \id{Nlocal}$-1$
  accordingly.

  The half-bandwidths \id{mudq} and \id{mldq} need not be the true 
  half-bandwidths of the Jacobian of the local block of $G$,    
  when smaller values may provide a greater efficiency.       

  Also, the half-bandwidths \id{mukeep} and \id{mlkeep} of the retained 
  banded approximate Jacobian block may be even smaller,      
  to reduce storage and computation costs further.            

  For all four half-bandwidths, the values need not be the    
  same on every processor.
}



The {\idabbdpre} module also provides a reinitialization function to allow
for a sequence of problems of the same size with {\idaspgmr}/{\idabbdpre},
{\idaspbcg}/{\idabbdpre}, or {\idasptfqmr}/{\idabbdpre}, provided there is no
change in \id{local\_N}, \id{mukeep}, or \id{mlkeep}.
After solving one problem, and after calling \id{IDAReInit} to re-initialize 
{\idas} for a subsequent problem, a call to \id{IDABBDPrecReInit} can be made
to change any of the following: the half-bandwidths \id{mudq} and \id{mldq} 
used in the difference-quotient Jacobian approximations, the relative increment 
\id{dq\_rel\_yy}, or one of the user-supplied functions \id{Gres} and \id{Gcomm}.
%%
%%
%%
\ucfunction{IDABBDPrecReInit}
{
  flag = IDABBDPrecReInit(ida\_mem, mudq, mldq, dq\_rel\_yy);
}
{
  The function \ID{IDABBDPrecReInit} reinitializes the {\idabbdpre} preconditioner.
}
{
  \begin{args}[dq\_rel\_yy]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[mudq] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldq] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[dq\_rel\_yy] (\id{realtype})
    the relative increment in components of \id{y} used in the difference quotient
    approximations.  
    The default is \id{dq\_rel\_yy} $= \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dq\_rel\_yy} $= 0.0$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_PMEM\_NULL]
  \item[IDASPILS\_SUCCESS]
    The call to \id{IDABBDPrecReInit} was successful.
  \item[\id{IDASPILS\_MEM\_NULL}] 
    The \id{ida\_mem} pointer was \id{NULL}.
  \item[\Id{IDASPILS\_LMEM\_NULL}]
    An {\idaspils} linear solver memory was not attached.
  \item[\Id{IDASPILS\_PMEM\_NULL}]
    The function \id{IDABBDPrecInit} was not previously called.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} is negative or
  exceeds the value \id{Nlocal}$-1$, it is replaced by 0 or \id{Nlocal}$-1$,
  accordingly.
}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-callable functions|)}
%%
%%------------------------------------------------------------------------------------
%%
\index{optional output!band-block-diagonal preconditioner|(}
\index{IDABBDPRE@{\idabbdpre} preconditioner!optional output|(}
The following two optional output functions are available for use with
the {\idabbdpre} module:
%%
\index{memory requirements!IDABBDPRE@{\idabbdpre} preconditioner}
\ucfunction{IDABBDPrecGetWorkSpace}
{
  flag = IDABBDPrecGetWorkSpace(ida\_mem, \&lenrwBBDP, \&leniwBBDP);
}
{
  The function \ID{IDABBDPrecGetWorkSpace} returns the local sizes
  of the {\idabbdpre} real and integer workspaces.
}
{
  \begin{args}[lenrwBBDP]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[lenrwBBDP] (\id{long int})
    local number of real values in the {\idabbdpre} workspace.
  \item[leniwBBDP] (\id{long int})
    local number of integer values in the {\idabbdpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_PMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\id{IDASPILS\_MEM\_NULL}] 
    The \id{ida\_mem} pointer was \id{NULL}.
  \item[\Id{IDASPILS\_PMEM\_NULL}]
    The {\idabbdpre} preconditioner has not been initialized.
  \end{args}
}
{
  In terms of the local vector dimension $N_l$, and
  \id{smu} = $\min ( N_l - 1 ,$ \id{mukeep} $+$ \id{mlkeep}$)$,
  the actual size of the real workspace is
  $N_l \,(2$ \id{mlkeep} $+$ \id{mukeep} $+$ \id{smu} $+2)$ \id{realtype} words.
  The actual size of the integer workspace is $N_l$ integer words.
}
%%
%%
\ucfunction{IDABBDPrecGetNumGfnEvals}
{
  flag = IDABBDPrecGetNumGfnEvals(ida\_mem, \&ngevalsBBDP);
}
{
  The function \ID{IDABBDPrecGetNumGfnEvals} returns the
  cumulative number of calls to the user \id{Gres} function due to the 
  finite difference approximation of the Jacobian blocks used within
  {\idabbdpre}'s preconditioner setup function.
}
{
  \begin{args}[ngevalsBBDP]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ngevalsBBDP] (\id{long int})
    the cumulative number of calls to the user \id{Gres} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDASPILS\_PMEM\_NULL]
  \item[IDASPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\id{IDASPILS\_MEM\_NULL}] 
    The \id{ida\_mem} pointer was \id{NULL}.
  \item[\Id{IDASPILS\_PMEM\_NULL}]
    The {\idabbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!optional output|)}
\index{optional output!band-block-diagonal preconditioner|)}

In addition to the \id{ngevalsBBDP} \id{Gres} evaluations,
the costs associated with {\idabbdpre} also include \id{nlinsetups} LU
factorizations, \id{nlinsetups} calls to \id{Gcomm}, \id{npsolves} banded
backsolve calls, and \id{nrevalsLS} residual function evaluations,
where \id{nlinsetups} is an optional {\idas} output (see
\S\ref{sss:optout_main}), and \id{npsolves} and \id{nrevalsLS} are
linear solver optional outputs (see \S\ref{sss:optout_spils}).

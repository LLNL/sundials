%===================================================================================
\chapter{Using CVODES for Adjoint Sensitivity Analysis}\label{s:adjoint}
%===================================================================================

This chapter describes the use of {\cvodes} to compute sensitivities of derived 
functions using adjoint sensitivity analysis. As mentioned before, the adjoint
sensitivity module of {\cvodes} provides the infrastructure for integrating
backward in time any system of ODEs that depends on the solution of the original
IVP, by providing various interfaces to the main {\cvodes} integrator, as well 
as several supporting user-callable functions. For this reason, in the following
sections we refer to the {\em backward problem} and not to the 
{\em adjoint problem} when discussing details relevant to the ODEs that
are integrated backward in  time. The backward problem can be the adjoint problem
(\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}), and
can be augmented with some quadrature differential equations.

{\cvodes} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

We begin with a brief overview, in the form of a skeleton user program.
Following that are detailed descriptions of the interface to the
various user-callable functions and of the user-supplied functions that were not
already described in Chapter \ref{s:simulation}.

%%
%%---------------------------------------------
%%---------------------------------------------
\section{A skeleton of the user's main program}
\label{ss:skeleton_adj}
%%---------------------------------------------
%%---------------------------------------------
%%

The following is a skeleton of the user's main program as an application of
{\cvodes}. The user program is to have these steps in the order indicated, 
unless otherwise noted. For the sake of brevity, we defer many of the details to 
the later sections.
As in \S\ref{ss:skeleton_sim}, most steps are independent of the {\nvector}
implementation used; where this is not the case, refer to Chapter
\ref{s:nvector} for specifics.
Steps that are unchanged from the skeleton programs presented in
\S\ref{ss:skeleton_sim}, \S\ref{s:forward_usage}, and \S\ref{s:forward_quad_usage},
are grayed out.

\index{User main program!Adjoint sensitivity analysis}
\begin{Steps}

\item
  \textcolor{gray}{\bf Include necessary header files}
  
  The \id{cvodes.h} header file also defines additional types, constants, and
  function prototypes for the adjoint sensitivity module user-callable functions.
  In addition, the main program should include an {\nvector} implementation
  header file (for the particular implementation used), and, if Newton
  iteration was selected, the main header file of the desired linear solver module.

\item
  \textcolor{gray}{\bf Initialize parallel or multi-threaded environment,
  if appropriate}

  \vspace{0.2in}\centerline{\bf Forward problem}

\item
  \textcolor{gray}{\bf Set problem dimensions etc. for the forward problem}

\item
  \textcolor{gray}{\bf Set initial conditions for the forward problem}

\item
  \textcolor{gray}{\bf Create {\cvodes} object for the forward problem}

\item
  \textcolor{gray}{\bf Allocate internal memory for the forward problem}

\item
  \textcolor{gray}{\bf Specify integration tolerances for forward problem}

\item
  \textcolor{gray}{\bf Set optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Attach linear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Initialize quadrature problem or problems for forward
    problems, using \id{CVodeQuadInit} and/or \id{CVodeQuadSensInit}.}

\item
  \textcolor{gray}{\bf Initialize forward sensitivity problem}

\item
  {\bf Allocate space for the adjoint computation}

  Call \Id{CVodeAdjInit}\id{()} to allocate memory for the 
  combined forward-backward problem (see \S\ref{sss:cvadjinit} for details).
  This call requires \id{Nd}, the number of steps between two consecutive checkpoints.
  \Id{CVodeAdjInit} also specifies the type of interpolation used 
  (see \S\ref{ss:checkpointing}).

\item
  {\bf Integrate forward problem}

  Call \Id{CVodeF}, a wrapper for the {\cvodes} main integration
  function \id{CVode}, either in \Id{CV\_NORMAL} mode to the time 
  \id{tout} or in \Id{CV\_ONE\_STEP} mode inside a loop (if intermediate
  solutions of the forward problem are desired (see \S\ref{sss:cvsolvef})).
  The final value of \id{tret} is then the maximum allowable value for the
  endpoint $T$ of the backward problem.

  \vspace{0.2in}\centerline{\bf Backward problem(s)}

 \item \label{i:back_start}
   {\bf Set problem dimensions etc. for the backward problem}
   
   This generally includes the backward problem vector length \id{NB},
   and possibly the local vector length \id{NBlocal}.

\item
  {\bf Set initial values for the backward problem}

  Set the endpoint time \id{tB0} $= T$ and the corresponding vector \id{yB0}
  at which the backward problem starts.

\item
  {\bf Create the backward problem}

  Call \Id{CVodeCreateB}, a wrapper for \id{CVodeCreate}, to
  create the {\cvodes} memory block for the new backward problem. Unlike
  \id{CVodeCreate}, the function \id{CVodeCreateB} does not return a pointer to
  the newly created memory block (see \S\ref{sss:cvinitb}). Instead, this pointer
  is attached to the internal adjoint memory  block (created by \id{CVodeAdjInit})
  and returns an identifier called \id{which} that the user must later specify
  in any actions on the newly created backward problem.

\item
  {\bf Allocate memory for the backward problem}

  Call \Id{CVodeInitB} (or \Id{CVodeInitBS}, when the backward problem depends on the
  forward sensitivities). The two functions are actually wrappers for \id{CVodeInit} 
  and allocate internal memory, specify problem data, and initialize {\cvodes} 
  at \id{tB0} for the backward problem (see \S\ref{sss:cvinitb}).

\item 
  {\bf Specify integration tolerances for backward problem}
  
  Call \id{CVodeSStolerancesB}\id{(...)} or \id{CVodeSVtolerancesB}\id{(...)}
  to specify a scalar relative tolerance and scalar absolute tolerance or
  scalar relative tolerance and a vector of absolute tolerances, respectively.
  The functions are wrappers for \id{CVodeSStolerances} and
  \id{CVodeSVtolerances}, but they require an extra argument \id{which},
  the identifier of the backward problem returned by \id{CVodeCreateB}.
  See \S\ref{sss:cvtolerances_b} for more information.


\item
  {\bf Set optional inputs for the backward problem}

  Call \id{CVodeSet*B} functions to change from their default values
  any optional inputs that control the behavior of {\cvodes}. Unlike
  their counterparts for the forward problem, these functions take an
  extra argument \id{which}, the identifier of the backward problem returned 
  by \id{CVodeCreateB} (see \S\ref{ss:optional_input_b}).


\item \label{i:lin_solverB}
  {\bf Attach linear solver module for the backward problem}

  Initialize the linear solver module 
  for the backward problem by calling the appropriate wrapper
  function: \id{CVDenseB}, \id{CVBandB}, \id{CVLapackDenseB}, \id{CVLapackBandB},
  \id{CVDiagB}, \id{CVKLUB}, \id{CVSuperLUMTB}, \id{CVodeSpgmrB},
  \id{CVodeSpbcgB}, or \id{CVodeSptfqmrB} (see \S\ref{sss:lin_solv_b}).  Note that
  it is not required to use the same linear solver module for both the forward 
  and the backward problems; for example, the forward problem could be solved
  with the {\cvdense} linear solver and the backward problem with {\cvspgmr}.

\item \label{i:quadB}
  {\bf Initialize quadrature calculation}

  If additional quadrature equations must be evaluated, 
  call \id{CVodeQuadInitB} or \id{CVodeQuadInitBS} (if quadrature depends also on the
  forward sensitivities) as shown in \S\ref{sss:cvquadinitb}. These functions are
  wrappers around \id{CVodeQuadInit} and can be used to initialize and allocate 
  memory for quadrature integration. Optionally, call \id{CVodeSetQuad*B} functions 
  to change from their default values optional inputs that control the integration 
  of quadratures during the backward phase.

\item
  {\bf Integrate backward problem}

  Call \Id{CVodeB}, a second wrapper around the {\cvodes} main integration
  function \id{CVode}, to integrate the backward problem from \id{tB0}
  (see \S\ref{sss:cvsolveb}). This function can be called either in \id{CV\_NORMAL}
  or \id{CV\_ONE\_STEP} mode. Typically, \id{CVodeB} will be called in \id{CV\_NORMAL}
  mode with an end time equal to the initial time $t_0$ of the forward problem.

\item \label{i:back_end}
  {\bf Extract quadrature variables}

  If applicable, call \Id{CVodeGetQuadB}, a wrapper around \id{CVodeGetQuad},
  to extract the values of the quadrature variables at the time returned
  by the last call to \id{CVodeB}. See \S\ref{sss:quad_get_b}.

\item
  {\bf Deallocate memory}

  Upon completion of the backward integration, call all necessary deallocation
  functions. These include appropriate destructors for the vectors 
  \id{y} and \id{yB}, a call to \id{CVodeFree} to free the {\cvodes} memory block 
  for the forward problem.  If one or more additional Adjoint
  Sensitivity Analyses are
  to be done for this problem, a call to \id{CVodeAdjFree} (see \S\ref{sss:cvadjinit})
  may be made to free and deallocate memory allocated for the backward problems, 
  followed by a call to \id{CVodeAdjInit}.

\item
  \textcolor{gray}{\bf Finalize MPI, if used}

\end{Steps}

The above user interface to the adjoint sensitivity module in {\cvodes} was motivated by
the desire to keep it as close as possible in look and feel to the one for ODE IVP 
integration. Note that if steps (\ref{i:back_start})-(\ref{i:back_end}) are not present, 
a program with the above structure will have the same functionality as one described in
\S\ref{ss:skeleton_sim} for integration of ODEs, albeit with some overhead due to 
the checkpointing scheme.

If there are multiple backward problems associated with the same forward problem,
repeat steps (\ref{i:back_start})-(\ref{i:back_end}) above for each successive
backward problem.  In the process, each call to \id{CVodeCreateB} creates a new
value of the identifier \id{which}.

%%
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
\section{User-callable functions for adjoint sensitivity analysis}
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
%%

%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity allocation and deallocation functions}
\label{sss:cvadjinit}
%%-------------------------------------------------------------------------------

After the setup phase for the forward problem, but before the call
to \id{CVodeF}, memory for the combined forward-backward problem must be
allocated by a call to the function \id{CVodeAdjInit}.
The form of the call to this function is
%%
%%
\ucfunction{CVodeAdjInit}
{
  flag = CVodeAdjInit(cvode\_mem, Nd, interpType);
}
{
  The function \ID{CVodeAdjInit} updates {\cvodes} memory block by allocating 
  the internal memory needed for backward integration.
  Space is allocated for the \id{Nd} $= N_d$ interpolation data points, and a linked 
  list of checkpoints is initialized.
}
{
  \begin{args}[interpType]
  \item[cvode\_mem] (\id{void *}) 
    is the pointer to the {\cvodes} memory block returned by a previous call to
    \id{CVodeCreate}.
  \item[Nd] (\id{long int}) 
    is the number of integration steps between two consecutive checkpoints.
  \item[interpType] (\id{int})
    specifies the type of interpolation used and can be \Id{CV\_POLYNOMIAL}
    or \Id{CV\_HERMITE}, indicating variable-degree polynomial and cubic Hermite
    interpolation, respectively (see \S\ref{ss:checkpointing}).
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_ILL\_INPUT]
   \item[\Id{CV\_SUCCESS}] 
     \id{CVodeAdjInit} was successful.
   \item[\Id{CV\_MEM\_FAIL}]
     A memory allocation request has failed.
   \item[CV\_MEM\_NULL] 
     \id{cvode\_mem} was NULL.
   \item[\Id{CV\_ILL\_INPUT}]
     One of the parameters was invalid: \id{Nd} was not positive or \id{interpType}
     is not one of the \id{CV\_POLYNOMIAL} or \id{CV\_HERMITE}.
   \end{args}
}
{
  The user must set \id{Nd} so that all data needed for interpolation of the 
  forward problem solution between two checkpoints fits in memory. \id{CVodeAdjInit}
  attempts to allocate space for $(2$\id{Nd}$+3)$ variables of type \id{N\_Vector}.

  If an error occurred, \id{CVodeAdjInit} also sends a message to the
  error handler function.
}
%%
%%
\ucfunction{CVodeAdjReInit}
{
  flag = CVodeAdjReInit(cvode\_mem);
}
{
  The function \ID{CVodeAdjReInit} reinitializes the {\cvodes} memory
  block for ASA, assuming that the number of steps between check
  points and the type of interpolation remain unchanged.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *}) 
    is the pointer to the {\cvodes} memory block returned by a previous call to
    \id{CVodeCreate}.
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_MEM\_NULL]
   \item[\Id{CV\_SUCCESS}] 
     \id{CVodeAdjReInit} was successful.
   \item[CV\_MEM\_NULL] 
     \id{cvode\_mem} was NULL.
   \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} was not previously called.
   \end{args}
}
{
  The list of check points (and associated memory) is deleted.

  The list of backward problems is kept. However, new backward problems can 
  be added to this list by calling \id{CVodeCreateB}. If a new list of backward
  problems is also needed, then free the adjoint memory (by calling
  \id{CVodeAdjFree}) and reinitialize ASA with \id{CVodeAdjInit}.

  The {\cvodes} memory for the forward and backward problems can be reinitialized
  separately by calling \id{CVodeReInit} and \id{CVodeReInitB}, respectively.
}
%%
%%
\ucfunction{CVodeAdjFree}
{
  CVodeAdjFree(cvode\_mem);
}
{
  The function \ID{CVodeAdjFree} frees the memory related to backward integration
  allocated by a previous call to \id{CVodeAdjInit}.
}
{
  The only argument is the {\cvodes} memory block pointer returned by a previous call 
  to \id{CVodeCreate}.
}
{
  The function \id{CVodeAdjFree} has no return value.
}
{
  This function frees all memory allocated by \id{CVodeAdjInit}. This
  includes workspace memory, the linked list of checkpoints, memory
  for the interpolation data, as well as the {\cvodes} memory for the
  backward integration phase.  Unless one or more further calls to \id{CVodeAdjInit}
  are to be made, \id{CVodeAdjFree} should not be called by the user, as it is
  invoked automatically by \id{CVodeFree}.
}
%%
%%

%%---------------------------------------------------------------------
\subsection{Forward integration function}
\label{sss:cvsolvef}
%%---------------------------------------------------------------------

The function \ID{CVodeF} is very similar to the {\cvodes} function \id{CVode}
(see \S\ref{sss:cvode}) in that it integrates the solution of the forward
problem and returns the solution in \id{y}. At the same time, however, 
\id{CVodeF} stores checkpoint data every \id{Nd} integration steps. \id{CVodeF} 
can be called repeatedly by the user.
%%
The call to this function has the form
%%
\ucfunction{CVodeF}
{
  flag = CVodeF(cvode\_mem, tout, yret, \&tret, itask, \&ncheck);
}
{
  The function \ID{CVodeF} integrates the forward problem over an interval in $t$
  and saves checkpointing data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[yret] (\id{N\_Vector})
    the computed solution vector $y$.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}}
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{CV\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to   
    return an approximate value of $y($\id{tout}$)$. 
    The \Id{CV\_ONE\_STEP} option tells the solver to just take one internal step  
    and return the solution at the point reached by that step. 
  \item[ncheck] (\id{int})
    the number of (internal) checkpoints stored so far.
  \end{args}
}
{
  On return, \id{CVodeF} returns the vector \id{yret} and a corresponding 
  independent variable value $t =$ \id{tret}, such that \id{yret} is the computed 
  value of $y(t)$. Additionally, it returns in \id{ncheck} the number of
  internal checkpoints saved; the total number of checkpoint intervals is
  \id{ncheck}$ + 1$.
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:cvode}.
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeF} succeeded.
  \item[\Id{CV\_TSTOP\_RETURN}]
    \id{CVodeF} succeeded by reaching the optional stopping point.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVodeF} is illegal.
  \item[\Id{CV\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tout}. 
  \item[\Id{CV\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Error test failures occurred too many times during one 
    internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{CV\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during 
    one internal time step or occurred with $|h| = h_{min}$.             
  \item[\Id{CV\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed (in an attempt to allocate space
    for a new checkpoint).
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{CVodeF} failures.

  At this time, \id{CVodeF} stores checkpoint information in memory only. 
  Future versions will provide for a safeguard option of dumping checkpoint
  data into a temporary file as needed. The data stored at each checkpoint is basically
  a snapshot of the {\cvodes} internal memory block and contains enough information
  to restart the integration from that time and to proceed with the same step size and
  method order sequence as during the forward integration.
  
  In addition, \id{CVodeF} also stores interpolation data between consecutive checkpoints
  so that, at the end of this first forward integration phase, interpolation information
  is already available from the last checkpoint forward. In particular,
  if no checkpoints were necessary, there is no need for the second forward integration phase.

  {\warn}It is illegal to change the integration tolerances between consecutive calls
  to \id{CVodeF}, as this information is not captured in the checkpoint data.
}  

%%---------------------------------------------------------------------
\subsection{Backward problem initialization functions}
\label{sss:cvinitb}
%%---------------------------------------------------------------------

The functions \id{CVodeCreateB} and \id{CVodeInitB} (or \id{CVodeInitBS}) must be 
called in the order listed. They instantiate a {\cvodes} solver object, provide problem 
and solution specifications, and allocate internal memory for the backward problem.
%%
%%
\ucfunction{CVodeCreateB}
{
  flag = CVodeCreateB(cvode\_mem, lmmB, iterB, \&which);
}
{
  The function \ID{CVodeCreateB} instantiates a {\cvodes} solver object and specifies 
  the solution method for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[lmmB] (\id{int})
    specifies the linear multistep method and may be one of two
    possible values: \Id{CV\_ADAMS} or \Id{CV\_BDF}.     
  \item[iterB] (\id{int})
    specifies the type of nonlinear solver iteration and may be
    either \Id{CV\_NEWTON} or \Id{CV\_FUNCTIONAL}. 
  \item[which] (\id{int})
    contains the identifier assigned by {\cvodes} for the newly created backward 
    problem. Any call to \id{CVode*B} functions requires such an identifier.
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_MEM\_FAIL]
   \item[\Id{CV\_SUCCESS}]
     The call to \id{CVodeCreateB} was successful.
   \item[\Id{CV\_MEM\_NULL}]
     \id{cvode\_mem} was \id{NULL}.
   \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} has not been previously called.
   \item[\Id{CV\_MEM\_FAIL}]
     A memory allocation request has failed.
   \end{args}
}
{}
%%
%%

There are two initialization functions for the backward problem -- one for
the case when the backward problem does not depend on the forward
sensitivities, and one for the case when it does.  These two functions
are described next.

The function \id{CVodeInitB} initializes the backward problem when it does
not depend on the forward sensitivities.  It is essentially a wrapper for 
\id{CVodeInit} with some particularization for backward integration, as described below.

\ucfunction{CVodeInitB}
{
  flag = CVodeInitB(cvode\_mem, which, rhsB, tB0, yB0);
}
{
  The function \ID{CVodeInitB} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[rhsB] (\Id{CVRhsFnB})
    is the {\CC} function which computes $fB$, the right-hand side of the 
    backward ODE problem. This function has the form 
    \id{rhsB(t, y, yB, yBdot, user\_dataB)} (for full details see \S\ref{ss:ODErhs_b}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem, normally equal to the endpoint of the forward integration.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or either
    \id{yB0} or \id{rhsB} was \id{NULL}.
  \end{args}
}
{
  The memory allocated by \id{CVodeInitB} is deallocated by the function 
  \id{CVodeAdjFree}.
}

For the case when backward problem also depends on the forward
sensitivities, user must call \id{CVodeInitBS} instead of \id{CVodeInitB}.
Only the third argument of each function differs between these two
functions.

\ucfunction{CVodeInitBS}
{
  flag = CVodeInitBS(cvode\_mem, which, rhsBS, tB0, yB0);
}
{
  The function \ID{CVodeInitBS} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[rhsBS] (\Id{CVRhsFnBS})
    is the {\CC} function which computes $fB$, the right-hand side of the 
    backward ODE problem. This function has the form 
    \id{rhsBS(t, y, yS, yB, yBdot, user\_dataB)} 
    (for full details see \S\ref{ss:ODErhs_bs}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, 
    either \id{yB0} or \id{rhsBS} was \id{NULL},
    or sensitivities were not active during the forward integration.
  \end{args}
}
{
  The memory allocated by \id{CVodeInitBS} is deallocated by the function 
  \id{CVodeAdjFree}.  
}

The function \id{CVodeReInitB} reinitializes {\cvodes} for the solution of a series
of backward problems, each identified by a value of the parameter \id{which}.
\id{CVodeReInitB} is essentially a wrapper for \id{CVodeReInit}, and so
all details given for \id{CVodeReInit} in \S\ref{sss:cvreinit} apply
here.\index{reinitialization}  Also note that \id{CVodeReInitB} can be called to
reinitialize the backward problem even it has been initialized with the
sensitivity-dependent version \id{CVodeInitBS}.
Before calling \id{CVodeReInitB} for a new backward problem, call any
desired solution extraction functions \id{CVodeGet**} associated with the
previous backward problem.
The call to the \id{CVodeReInitB} function has the form
%%
%%
\ucfunction{CVodeReInitB}
{
  flag = CVodeReInitB(cvode\_mem, which, tB0, yB0)
}
{
  The function \ID{CVodeReInitB} reinitializes a {\cvodes} backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}] 
    The \id{cvode\_mem} memory block pointer was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} is outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or
    \id{yB0} was \id{NULL}.
  \end{args}
}
{}

%%
%%==============================================================================
\subsection{Tolerance specification functions for backward problem}
\label{sss:cvtolerances_b}
%%==============================================================================
%%
One of the following two functions must be called to specify the integration 
tolerances for the backward problem. Note that this call must be made after the 
call to \id{CVodeInitB} or \id{CVodeInitBS}.
%%
\ucfunction{CVodeSStolerancesB}
{
  flag = CVodeSStolerancesB(cvode\_mem, which, reltolB, abstolB);
}
{
  The function \ID{CVodeSStolerancesB} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltolB] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstolB] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSStolerancesB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}] 
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunction{CVodeSVtolerancesB}
{
  flag = CVodeSVtolerancesB(cvode\_mem, which, reltolB, abstolB);
}
{
  The function \ID{CVodeSVtolerancesB} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSVtolerancesB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}] 
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}] 
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the state vector $y$.
}
%%

%%---------------------------------------------------------------------
\subsection{Linear solver initialization functions for backward problem}
\label{sss:lin_solv_b}
%%---------------------------------------------------------------------

\index{CVODES@{\cvodes} linear solvers!usage with adjoint module|(} 
All linear solver modules in {\cvodes} available for forward problems
provide additional specification functions for backward problems.
The initialization functions described in \S\ref{sss:lin_solv_init} cannot be
directly used since the optional user-defined Jacobian-related functions have
different prototypes for the backward problem than for the forward problem
(see \S\ref{ss:user_fct_adj}).\index{CVODES@{\cvodes} linear solvers!usage with adjoint module|)} 

The following wrapper functions can be used to initialize one of the linear
solver modules for the backward problem. Their arguments are identical to those
of the functions in \S\ref{sss:lin_solv_init} with the exception of the additional
second argument, \id{which}, the identifier of the backward problem.
\begin{verbatim}
  flag = CVDenseB(cvode_mem, which, nB);
  flag = CVBandB(cvode_mem, which, nB, mupperB, mlowerB);
  flag = CVLapackDenseB(cvode_mem, which, nB);
  flag = CVLapackBandB(cvode_mem, which, nB, mupperB, mlowerB);
  flag = CVDiagB(cvode_mem, which);
  flag = CVSuperLUMTB(cvode_mem, num_threads, which, nB, nnzB);
  flag = CVKLUB(cvode_mem, which, nB, nnzB);
  flag = CVSpgmrB(cvode_mem, which, pretypeB, maxlB);
  flag = CVSpbcgB(cvode_mem, which, pretypeB, maxlB);
  flag = CVSptfqmrB(cvode_mem, which, pretypeB, maxlB);
\end{verbatim}

Their return value \id{flag} (of type \id{int}) can have any of the return values 
of their counterparts.
%%
If the \id{cvode\_mem} argument was \id{NULL}, 
\id{flag} will be \id{CVDLS\_MEM\_NULL}, \id{CVSLS\_MEM\_NULL},
\id{CVDIAG\_MEM\_NULL}, or \id{CVSPILS\_MEM\_NULL}.  
%%
Also, if \id{which} is not a valid identifier, the functions will return 
\id{CVDLS\_ILL\_INPUT}, \id{CVSLS\_ILL\_INPUT},
\id{CVDIAG\_ILL\_INPUT}, or \id{CVSPILS\_ILL\_INPUT}. 


%%---------------------------------------------------------------------
\subsection{Backward integration function}
\label{sss:cvsolveb}
%%---------------------------------------------------------------------

The function \ID{CVodeB} performs the integration of the backward problem.
It is essentially a wrapper for the {\cvodes} main integration function 
\id{CVode} and, in the case in which checkpoints were needed, it evolves 
the solution of the backward problem through a sequence of forward-backward 
integration pairs between consecutive checkpoints. 
The first run of each pair integrates the original IVP forward in time and
stores interpolation data; the second run integrates the backward problem 
backward in time and performs the required interpolation to provide
the solution of the IVP to the backward problem.

The function \id{CVodeB} does not return the solution \id{yB} itself.
To obtain that, call the function \id{CVodeGetB}, which is also
described below.

The call to \id{CVodeB} has the form
%%
%%
\ucfunction{CVodeB}
{
  flag = CVodeB(cvode\_mem, tBout, itaskB);
}
{
  The function \ID{CVodeB} integrates the backward ODE problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[tBout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[itaskB] (\id{int})
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{CV\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified value \id{tBout}.
    The solver then interpolates in order to   
    return an approximate value of $yB($\id{tBout}$)$. 
    The \Id{CV\_ONE\_STEP} option tells the solver to take just one internal step in
    the direction of \id{tBout} and return. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:cvode}.
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeB} succeeded.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_NO\_BCK}]
    No backward problem has been added to the list of backward problems by
    a call to \id{CVodeCreateB}
  \item[\Id{CV\_NO\_FWD}]
    The function \id{CVodeF} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVodeB} is illegal.
  \item[\Id{CV\_BAD\_ITASK}]
    The \id{itaskB} argument has an illegal value.
  \item[\Id{CV\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tBout}. 
  \item[\Id{CV\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Error test failures occurred too many times during one internal time step.
  \item[\Id{CV\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during one internal time step.
  \item[\Id{CV\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_SOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_BCKMEM\_NULL}]
    The solver memory for the backward problem was not created with
    a call to \id{CVodeCreateB}.
  \item[\Id{CV\_BAD\_TBOUT}]
    The desired output time \id{tBout} is outside the interval over which the 
    forward problem was solved.
  \item[\Id{CV\_REIFWD\_FAIL}]
    Reinitialization of the forward problem failed at the first checkpoint
    (corresponding to the initial time of the forward problem).
  \item[\Id{CV\_FWD\_FAIL}]
    An error occurred during the integration of the forward problem.
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{CVodeB} failures.

  In the case of multiple checkpoints and multiple backward problems, a given
  call to \id{CVodeB} in \id{CV\_ONE\_STEP} mode may not advance every problem
  one step, depending on the relative locations of the current times reached.
  But repeated calls will eventually advance all problems to \id{tBout}.
}
%%
%%
To obtain the solution \id{yB} to the backward problem, call the function
\id{CVodeGetB} as follows:
%%
\ucfunction{CVodeGetB}
{
  flag = CVodeGetB(cvode\_mem, which, \&tret, yB);
}
{
  The function \ID{CVodeGetB} provides the solution \id{yB} of the backward ODE
  problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yB] (\id{N\_Vector})
    the backward solution at time \id{tret}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
   \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args} 
}
{
  {\warn} The user must allocate space for \id{yB}.
}


%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity optional input}

At any time during the integration of the forward problem, the user can disable
the checkpointing of the forward sensitivities by calling the following function:

\ucfunction{CVodeAdjSetNoSensi}
{
  flag = CVodeAdjSetNoSensi(cvode\_mem);
}
{
  The function \ID{CVodeAdjSetNoSensi} instructs \id{CVodeF} not
  to save checkpointing data for forward sensitivities anymore.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes}  memory block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_FAIL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeCreateB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \end{args}
}
{}
%%-------------------------------------------------------------------------------


%%---------------------------------------------------------------------
\subsection{Optional input functions for the backward problem}
\label{ss:optional_input_b}
%%---------------------------------------------------------------------
%%
\subsubsection{Main solver optional input functions}
\index{optional input!backward solver|(}

The adjoint module in {\cvodes} provides wrappers for most of the optional 
input functions defined in \S\ref{sss:optin_main}. The only difference is 
that the user must specify the identifier \id{which} of the backward problem 
within the list managed by {\cvodes}. 

The optional input functions defined for the backward problem are:
\begin{verbatim}
  flag = CVodeSetUserDataB(cvode_mem, which, user_dataB);
  flag = CVodeSetIterTypeB(cvode_mem, which, iterB);
  flag = CVodeSetMaxOrdB(cvode_mem, which, maxordB);
  flag = CVodeSetMaxNumStepsB(cvode_mem, which, mxstepsB);
  flag = CVodeSetInitStepB(cvode_mem, which, hinB)
  flag = CVodeSetMinStepB(cvode_mem, which, hminB);
  flag = CVodeSetMaxStepB(cvode_mem, which, hmaxB);
  flag = CVodeSetStabLimDetB(cvode_mem, which, stldetB);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of their counterparts, but it can also be \Id{CV\_NO\_ADJ} if \id{CVodeAdjInit} 
has not been called, or \Id{CV\_ILL\_INPUT} if \id{which} was an invalid identifier. 

\index{optional input!backward solver|)}

\subsubsection{Dense linear solver}
\index{optional input!dense linear solver|(}
\index{CVDENSE@{\cvdense} linear solver!optional input|(}
Optional inputs for the {\cvdense} linear solver module can be set for the backward
problem through the following two functions:
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\ucfunction{CVDlsSetDenseJacFnB}
{
  flag = CVDlsSetDenseJacFnB(cvode\_mem, which, jacB);
}
{
  The function \ID{CVDlsSetDenseJacFnB} specifies the dense Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{CVDlsDenseJacFnB})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDLS\_ILL\_INPUT]
  \item[\Id{CVDLS\_SUCCESS}] 
    \id{CVDlsSetDenseJacFnB} succeeded.
  \item[\Id{CVDLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVDLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVDLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{CVDenseB}
    or \id{CVLapackDenseB}.
  \item[\Id{CVDLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVDlsDenseJacFnB} is described in \S\ref{ss:densejac_b}.
}
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\ucfunction{CVDlsSetDenseJacFnBS}
{
  flag = CVDlsSetDenseJacFnBS(cvode\_mem, which, jacBS);
}
{
  The function \ID{CVDlsSetDenseJacFnBS} specifies the dense Jacobian
  approximation function to be used for the backward problem, in the
  case where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{CVDlsDenseJacFnBS})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDLS\_ILL\_INPUT]
  \item[\Id{CVDLS\_SUCCESS}] 
    \id{CVDlsSetDenseJacFnBS} succeeded.
  \item[\Id{CVDLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVDLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVDLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{CVDenseB}
    or \id{CVLapackDenseB}.
  \item[\Id{CVDLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVDlsDenseJacFnBS} is described in \S\ref{ss:densejac_b}.
}
\index{CVDENSE@{\cvdense} linear solver!optional input|)}
\index{optional input!dense linear solver|)}


\subsubsection{Band linear solver}
\index{optional input!band linear solver|(}
\index{CVBAND@{\cvband} linear solver!optional input|(}
Optional inputs for the {\cvband} linear solver module can be set for the backward
problem through the following two functions:
%%
\index{Jacobian approximation function!band!user-supplied (backward)}
\ucfunction{CVDlsSetBandJacFnB}
{
  flag = CVDlsSetBandJacFnB(cvode\_mem, which, jacB);
}
{
  The function \ID{CVDlsSetBandJacFnB} specifies the banded Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{CVDlsBandJacFnB})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDLS\_ILL\_INPUT]
  \item[\Id{CVDLS\_SUCCESS}] 
    \id{CVDlsSetBandJacFnB} succeeded.
  \item[\Id{CVDLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVDLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVDLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{CVBandB}
    or \id{CVLapackBandB}.
  \item[\Id{CVDLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVDlsBandJacFnB} is described in \S\ref{ss:bandjac_b}.
}
\index{CVBAND@{\cvband} linear solver!optional input|)}
\index{optional input!band linear solver|)}
%%
\index{Jacobian approximation function!band!user-supplied (backward)}
\ucfunction{CVDlsSetBandJacFnBS}
{
  flag = CVDlsSetBandJacFnBS(cvode\_mem, which, jacBS);
}
{
  The function \ID{CVDlsSetBandJacFnBS} specifies the banded Jacobian
  approximation function to be used for the backward problem, in the
  case where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{CVDlsBandJacFnBS})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDLS\_ILL\_INPUT]
  \item[\Id{CVDLS\_SUCCESS}] 
    \id{CVDlsSetBandJacFnBS} succeeded.
  \item[\Id{CVDLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVDLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVDLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{CVBandB}
    or \id{CVLapackBandB}.
  \item[\Id{CVDLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVDlsBandJacFnBS} is described in \S\ref{ss:bandjac_b}.
}
\index{CVBAND@{\cvband} linear solver!optional input|)}
\index{optional input!band linear solver|)}


\subsubsection{Sparse linear solvers}
\index{optional input!sparse linear solver|(}
\index{CVKLU@{\cvklu} linear solver!optional input|(}
\index{CVSUPERLUMT@{\cvsuperlumt} linear solver!optional input|(}
Optional inputs for the {\cvklu} and {\cvsuperlumt} linear solver
modules can be set for the backward problem through the following
functions.

The following wrapper functions can be used to set the fill-reducing
ordering and, in the case of KLU, reinitialize the sparse solver in the
sparse linear solver modules for the backward problem.  
Their arguments are identical to those
of the functions in \S\ref{sss:lin_solv_init} with the exception of the additional
second argument, \id{which}, the identifier of the backward problem.
\begin{verbatim}
  flag = CVKLUReInitB(cvode_mem, which, nB, nnzB, reinit_typeB);
  flag = CVKLUSetOrderingB(cvode_mem, which, ordering_choiceB);
  flag = CVSuperLUMTSetOrderingB(cvode_mem, which, ordering_choiceB);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return 
values of their counterparts.
%%
If the \id{cvode\_mem} argument was \id{NULL}, 
\id{flag} will be \id{CVSLS\_MEM\_NULL}.
%%
Also, if \id{which} is not a valid identifier, the functions will return 
\id{CVSLS\_ILL\_INPUT}.
%%
\index{Jacobian approximation function!sparse!user-supplied (backward)}
\ucfunction{CVSlsSetSparseJacFnB}
{
  flag = CVSlsSetSparseJacFnB(cvode\_mem, which, jacB);
}
{
  The function \ID{CVSlsSetSparseJacFnB} specifies the sparse Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{CVSlsSparseJacFnB})
    user-defined sparse Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSLS\_ILL\_INPUT]
  \item[\Id{CVSLS\_SUCCESS}] 
    \id{CVSlsSetSparseJacFnB} succeeded.
  \item[\Id{CVSLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{CVKLUB}
    or \id{CVSuperLUMTB}.
  \item[\Id{CVSLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVSlsSparseJacFnB} is described in \S\ref{ss:sparsejac_b}.
}
%%
\index{Jacobian approximation function!sparse!user-supplied (backward)}
\ucfunction{CVSlsSetSparseJacFnBS}
{
  flag = CVSlsSetSparseJacFnBS(cvode\_mem, which, jacBS);
}
{
  The function \ID{CVSlsSetSparseJacFnBS} specifies the sparse Jacobian
  approximation function to be used for the backward problem, in the
  case where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{CVSlsSparseJacFnBS})
    user-defined sparse Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSLS\_ILL\_INPUT]
  \item[\Id{CVSLS\_SUCCESS}] 
    \id{CVSlsSetSparseJacFnBS} succeeded.
  \item[\Id{CVSLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \id{CVKLUB}
    or \id{CVSuperLUMTB}.
  \item[\Id{CVSLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVSlsSparseJacFnBS} is described in \S\ref{ss:sparsejac_b}.
}
%%
\index{CVSUPERLUMT@{\cvsuperlumt} linear solver!optional input|)}
\index{CVKLU@{\cvklu} linear solver!optional input|)}
\index{optional input!sparse linear solver|)}


\subsubsection{SPILS linear solvers}
\index{optional input!iterative linear solver|(}
\index{CVSPGMR@{\cvspgmr} linear solver!optional input|(}
\index{CVSPBCG@{\cvspbcg} linear solver!optional input|(}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional input|(}
Optional inputs for the {\cvspils} linear solver module can be set for the backward
problem through the following functions:
%%
\index{preconditioning!user-supplied|(}
\ucfunction{CVSpilsSetPreconditionerB}
{
  flag = CVSpilsSetPreconditionerB(cvode\_mem, which, psetupB, psolveB);
}
{
  The function \ID{CVSpilsSetPrecSolveFnB} specifies the preconditioner
  setup and solve functions for the backward integration.
}
{
  \begin{args}[psetupB]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupB] (\id{CVSpilsPrecSetupFnB})
    user-defined preconditioner setup function.
  \item[psolveB] (\id{CVSpilsPrecSolveFnB})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
   The function types \id{CVSpilsPrecSolveFnB} and \id{CVSpilsPrecSetupFnB} are
   described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, resp.
   The \id{psetupB} argument may be \id{NULL} if no setup operation is involved
   in the preconditioner.
}
%%
\ucfunction{CVSpilsSetPreconditionerBS}
{
  flag = CVSpilsSetPreconditionerBS(cvode\_mem, which, psetupBS, psolveBS);
}
{
  The function \ID{CVSpilsSetPrecSolveFnBS} specifies the preconditioner
  setup and solve functions for the backward integration, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[psetupBS]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupBS] (\id{CVSpilsPrecSetupFnBS})
    user-defined preconditioner setup function.
  \item[psolveBS] (\id{CVSpilsPrecSolveFnBS})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
   The function types \id{CVSpilsPrecSolveFnBS} and \id{CVSpilsPrecSetupFnBS} are
   described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, resp.
   The \id{psetupBS} argument may be \id{NULL} if no setup operation is involved
   in the preconditioner.
}
%%
\index{preconditioning!user-supplied|)}
%%
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
\ucfunction{CVSpilsSetJacTimesVecFnB}
{
  flag = CVSpilsSetJacTimesVecFnB(cvode\_mem, which, jtvB);
}
{
  The function \ID{CVSpilsSetJacTimesFnB} specifies the Jacobian-vector 
  product function to be used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtvB] (\id{CVSpilsJacTimesVecFnB})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVSpilsJacTimesVecFnB} is described in \S\ref{ss:jtimesv_b}.
}
%%
\ucfunction{CVSpilsSetJacTimesVecFnBS}
{
  flag = CVSpilsSetJacTimesVecFnBS(cvode\_mem, which, jtvBS);
}
{
  The function \ID{CVSpilsSetJacTimesFnBS} specifies the Jacobian-vector 
  product function to be used, in the case where the backward problem
  depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtvBS] (\id{CVSpilsJacTimesVecFnBS})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVSpilsJacTimesVecFnBS} is described in \S\ref{ss:jtimesv_b}.
}
%%
\ucfunction{CVSpilsSetGSTypeB}
{
  flag = CVSpilsSetGSType(cvode\_mem, which, gstypeB);
}
{
  The function \ID{CVSpilsSetGSTypeB} specifies the type of
  Gram-Schmidt orthogonalization to be used with {\cvspgmr}.
  This must be one of the enumeration constants \ID{MODIFIED\_GS}
  or \ID{CLASSICAL\_GS}. These correspond to using modified Gram-Schmidt 
  and classical Gram-Schmidt, respectively. 
  \index{Gram-Schmidt procedure}
}
{
  \begin{args}[gstypeB]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[gstypeB] (\id{int})
    type of Gram-Schmidt orthogonalization.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or the 
    value of \id{gstypeB} was not valid.
  \end{args}
}
{
  The default value is \id{MODIFIED\_GS}.

  {\warn}This option is available only with {\cvspgmr}.
}
%%
\ucfunction{CVSpilsSetMaxlB}
{
  flag = CVSpilsSetMaxlB(cvode\_mem, which, maxlB);
}
{
  The function \ID{CVSpilsSetMaxlB} resets maximum Krylov subspace
  dimension for the Bi-CGStab\index{Bi-CGStab method} or TFQMR\index{TFQMR method} 
  methods.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[maxlB] (\id{realtype})
    maximum dimension of the Krylov subspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The maximum subspace dimension is initially specified in the call
  to \id{CVodeSpbcgB} or \id{CVodeSptfqmrB}.
  The call to \id{CVodeSpilsSetMaxlB} is needed only if \id{maxlB} is being changed
  from its previous value.

  {\warn}This option is available only for the {\cvspbcg} and {\cvsptfqmr} linear solvers.

}
%%
\ucfunction{CVSpilsSetEpsLinB}
{
  flag = CVSpilsSetEpsLinB(cvode\_mem, which, eplifacB);
}
{
  The function \ID{CVSpilsSetEpsLinB} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the Newton iteration test constant.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[eplifacB] (\id{realtype})
    value of the convergence test constant reduction factor ($\geq 0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or
    \id{eplifacB} was negative.
  \end{args}
}
{
  The default value is $0.05$.
  Passing a value \id{eplifacB}$ = 0.0$ also indicates using the default value.
}
%%
\ucfunction{CVSpilsSetPrecTypeB}
{
  flag = CVSpilsSetPrecTypeB(cvode\_mem, which, pretypeB);
}
{
  The function \ID{CVSpilsSetPrecTypeB} resets the type
  of preconditioning to be used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[pretypeB] (\id{int})
    \index{pretypeB@\texttt{pretypeB}}
    specifies the type of prconditioning and must be one of:
    \Id{PREC\_NONE}, \Id{PREC\_LEFT}, \Id{PREC\_RIGHT}, or \Id{PREC\_BOTH}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    The {\cvspils} linear solver has not been initialized.
  \item[\Id{CVSPILS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or
    the value of \id{pretypeB} was not valid.
  \end{args}
}
{
  The preconditioning type is initially specified in the call
  to the linear solver specification function (see \S\ref{sss:lin_solv_b}). 
  The call to \id{CVSpilsSetPrecTypeB} is needed only if \id{pretypeB} is being
  changed from its previous value.
}
%%
\index{CVSPGMR@{\cvspgmr} linear solver!optional input|)}
\index{CVSPBCG@{\cvspbcg} linear solver!optional input|)}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!optional input|)}
\index{optional input!iterative linear solver|)}

%---------------------------------------------------------------------------
\subsection{Optional output functions for the backward problem}\label{ss:optional_output_b}
\index{optional output!backward solver|(}
%%
The user of the adjoint module in {\cvodes} has access to any of the optional
output functions described in \S\ref{ss:optional_output}, both for the main solver
and for the linear solver modules. The first argument of these \id{CVodeGet*} and
\id{CVode*Get*} functions is the pointer to the {\cvodes} memory block for the
backward problem. In order to call any of these functions, the user must first 
call the following function to obtain this pointer.
%%
\ucfunction{CVodeGetAdjCVodeBmem}
{
  cvode\_memB = CVodeGetAdjCVodeBmem(cvode\_mem, which);
}
{
  The function \ID{CVodeGetAdjCVodeBmem} returns a pointer to the {\cvodes}
  memory block for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block created by \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \end{args}
}
{
  The return value, \id{cvode\_memB} (of type \id{void *}), is a pointer to the
  {\cvodes} memory for the backward problem.
}
{
  {\warn}The user should not modify \id{cvode\_memB} in any way.

  Optional output calls should pass \id{cvode\_memB} as the first argument;
  for example, to get the number of integration steps:
  \id{flag = CVodeGetNumSteps(cvodes\_memB, \&nsteps)}.
}
\index{optional output!backward solver|)}

To get values of the {\it forward} solution during a backward integration,
use the following function.  The input value of \id{t} would typically be
equal to that at which the backward solution has just been obtained with
\id{CVodeGetB}.  In any case, it must be within the last checkpoint interval
used by \id{CVodeB}.

\ucfunction{CVodeGetAdjY}
{
  flag = CVodeGetAdjY(cvode\_mem, t, y);
}
{
  The function \ID{CVodeGetAdjY} returns the interpolated value of
  the forward solution $y$ during a backward integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block created by \id{CVodeCreate}.
  \item[t] (\id{realtype})
    value of the independent variable at which $y$ is desired (input).
  \item[y] (\id{N\_Vector}) forward solution $y(t)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
 \begin{args}[CV\_GETY\_BADT]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetAdjY} was successful. 
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_GETY\_BADT}]
    The value of \id{t} was outside the current checkpoint interval.
  \end{args}
}
{
  {\warn} The user must allocate space for \id{y}.
}

%%---------------------------------------------------------------------
\subsection{Backward integration of quadrature equations}
%%---------------------------------------------------------------------

Not only the backward problem but also the backward quadrature equations 
may or may not depend on the forward sensitivities.  Accordingly, either 
\id{CVodeQuadInitB} or \id{CVodeQuadInitBS} should be used to allocate internal 
memory and to initialize backward quadratures.  For any other operation 
(extraction, optional input/output, reinitialization, deallocation),
the same function is callable regardless of whether or not the quadratures
are sensitivity-dependent.

\subsubsection{Backward quadrature initialization functions}
\label{sss:cvquadinitb}

The function \id{CVodeQuadInitB} initializes and allocates memory for the backward
integration of quadrature equations that do not depend on forward sensitivities.
It has the following form:
%%
%%
\ucfunction{CVodeQuadInitB}
{
flag = CVodeQuadInitB(cvode\_mem, which, rhsQB, yQB0);
}
{
  The function \ID{CVodeQuadInitB} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQB] (\Id{CVQuadRhsFnB})
    is the {\CC} function which computes $fQB$, the right-hand side of the 
    backward quadrature equations. This function has the form 
    \id{rhsQB(t, y, yB, qBdot, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_B}).
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInitB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%
%%

The function \id{CVodeQuadInitBS} initializes and allocates memory for the backward
integration of quadrature equations that depends on the forward sensitivities.
%%
%%
\ucfunction{CVodeQuadInitBS}
{
flag = CVodeQuadInitBS(cvode\_mem, which, rhsQBS, yQBS0);
}
{
  The function \ID{CVodeQuadInitBS} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQBS] (\Id{CVQuadRhsFnBS})
    is the {\CC} function which computes $fQBS$, the right-hand side of the 
    backward quadrature equations. This function has the form 
    \id{rhsQBS(t, y, yS, yB, qBdot, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_sens_B}).
  \item[yQBS0] (\id{N\_Vector})
    is the value of the sensitivity-dependent quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInitBS} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}


The integration of quadrature equations during the backward phase can be
re-initialized by calling the following function.
Before calling \id{CVodeQuadReInitB} for a new backward problem, call any
desired solution extraction functions \id{CVodeGet**} associated with the
previous backward problem.
%%
%%
\ucfunction{CVodeQuadReInitB}
{
  flag = CVodeQuadReInitB(cvode\_mem, which, yQB0);
}
{
  The function \ID{CVodeQuadReInitB} re-initializes the backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadReInitB} was successful.
 \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{CV\_NO\_QUAD}] 
    Quadrature integration was not activated through a  previous 
    call to \id{CVodeQuadInitB}.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  The function \id{CVodeQuadReInitB} can be called after a call to either
  \id{CVodeQuadInitB} or \id{CVodeQuadInitBS}.
}

\subsubsection{Backward quadrature extraction function}
\label{sss:quad_get_b}
To extract the values of the quadrature variables at the last return time
of \id{CVodeB}, {\cvodes} provides a wrapper for the function \ID{CVodeGetQuad}
(see \S\ref{ss:quad_get}). The call to this function has the form
%%
%%
\ucfunction{CVodeGetQuadB}
{
  flag = CVodeGetQuadB(cvode\_mem, which, \&tret, yQB);
}
{
  The function \ID{CVodeGetQuadB} returns the quadrature solution vector after
  a successful return from \id{CVodeB}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yQB] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuadB} is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}] 
    \id{CVodeGetQuadB} was successful.
  \item[\Id{CV\_MEM\_NULL}] 
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[CV\_NO\_QUAD] 
    Quadrature integration was not initialized.
  \item[CV\_BAD\_DKY] 
    \id{yQB} was \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%\subsubsection{Tolerance specification functions for backward quadrature integration}

\subsubsection{Optional input/output functions for backward quadrature integration}
\label{sss:quad_optional_input_B}
\index{optional input!quadrature integration}
\index{optional output!quadrature integration}
Optional values controlling the backward integration of quadrature equations can be 
changed from their default values through calls to one of the following functions 
which are wrappers for the corresponding optional input functions defined in 
\S\ref{ss:quad_optional_input}. The user must specify  the identifier \id{which} 
of the backward problem for which the optional values are specified.

\begin{verbatim}
  flag = CVodeSetQuadErrConB(cvode_mem, which, errconQ);
  flag = CVodeQuadSStolerancesB(cvode_mem, which, reltolQ, abstolQ);
  flag = CVodeQuadSVtolerancesB(cvode_mem, which, reltolQ, abstolQ);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of its counterparts, but it can also be \Id{CV\_NO\_ADJ} if the function 
\id{CVodeAdjInit} has not been previously called or \Id{CV\_ILL\_INPUT} if the
parameter \id{which} was an invalid identifier.

Access to optional outputs related to backward quadrature integration can be 
obtained by calling the corresponding \id{CVodeGetQuad*} functions 
(see \S\ref{ss:quad_optional_output}).  A pointer \id{cvode\_memB} to the 
{\cvodes} memory block for the backward problem, required as the first 
argument of these functions, can be obtained through a call to the functions 
\id{CVodeGetAdjCVodeBmem} (see \S\ref{ss:optional_output_b}).


%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
\section{User-supplied functions for adjoint sensitivity analysis}
\label{ss:user_fct_adj}
%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
%%

In addition to the required ODE right-hand side function and any optional functions
for the forward problem, when using the adjoint sensitivity module in {\cvodes},
the user must supply one function defining the backward problem ODE and, optionally,
functions to supply Jacobian-related information and one or two functions 
that define the preconditioner (if one of the {\cvspils} solvers is
selected) for the backward problem.
Type definitions for all these user-supplied functions are given below.

\subsection{ODE right-hand side for the backward problem}\label{ss:ODErhs_b}
\index{adjoint sensitivity analysis!right-hand side evaluation}
\index{right-hand side function!backward problem}

If the backward problem does not depend on the forward sensitivities,
the user must provide a \id{rhsB} function of type \ID{CVRhsFnB} defined as follows:
\usfunction{CVRhsFnB}
{
  typedef int (*CVRhsFnB)(&realtype t, N\_Vector y, \\
                          &N\_Vector yB, N\_Vector yBdot, void *user\_dataB);
}
{
  This function evaluates the right-hand side $f_B(t,y,y_B)$ of the backward problem
  ODE system.  This could be either (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[yBdot]
    is the output vector containing the right-hand side $f_B$ of the backward ODE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_RHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{yBdot} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{yBdot} arguments are all 
  of type \id{N\_Vector}, but \id{yB} and \id{yBdot} typically have 
  different internal representations from \id{y}. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{rhsB} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{rhsB} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_RHSFUNC\_FAIL}.
}

\subsection{ODE right-hand side for the backward problem depending on the forward sensitivities}\label{ss:ODErhs_bs}
\index{adjoint sensitivity analysis!right-hand side evaluation}
\index{right-hand side function!backward problem}

If the backward problem does depend on the forward sensitivities,
the user must provide a \id{rhsBS} function of type \ID{CVRhsFnBS} defined as follows:
\usfunction{CVRhsFnBS}
{
  typedef int (*CVRhsFnBS)(&realtype t, N\_Vector y, N\_Vector *yS, \\
                           &N\_Vector yB, N\_Vector yBdot, void *user\_dataB);
}
{
  This function evaluates the right-hand side $f_B(t, y, y_B, s)$ of the backward problem 
  ODE system.  This could be either (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[yBdot]
    is the output vector containing the right-hand side $f_B$ of the backward ODE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_RHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{qBdot} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{yBdot} arguments are all of type \id{N\_Vector}, 
  but \id{yB} and \id{yBdot} typically have different internal representations 
  from \id{y}.  Likewise for each \id{yS[i]}.  It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{rhsBS} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{rhsBS} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_RHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Quadrature right-hand side for the backward problem}
\index{right-hand side function!quadrature backward problem}
\index{adjoint sensitivity analysis!quadrature evaluation}
\label{sss:rhs_quad_B}
The user must provide an \id{fQB} function of type \ID{CVQuadRhsFnB} defined by
\usfunction{CVQuadRhsFnB}
{
  typedef int (*CVQuadRhsFnB)(&realtype t, N\_Vector y, N\_Vector yB, \\
                              &N\_Vector qBdot, void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[qBdot]
    is the output vector containing the right-hand side \id{fQB} of the backward
    quadrature equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVQuadRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQ} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{qBdot} arguments are all of type \id{N\_Vector},
  but they typically do not all have the same representation. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQB} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{fQB} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_QRHSFUNC\_FAIL}.
}

\subsection{Sensitivity-dependent quadrature right-hand side for the backward problem}
\index{right-hand side function!sensitivity-dep. quadrature backward problem}
\index{adjoint sensitivity analysis!sensitivity-dependent quadrature evaluation}
\label{sss:rhs_quad_sens_B}
The user must provide an \id{fQBS} function of type \ID{CVQuadRhsFnBS} defined by
\usfunction{CVQuadRhsFnBS}
{
  typedef int (*CVQuadRhsFnBS)(&realtype t, N\_Vector y, N\_Vector *yS, \\
  &N\_Vector yB, N\_Vector qBdot, \\
  &void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[qBdot]
    is the output vector containing the right-hand side \id{fQBS} of the backward
    quadrature equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVQuadRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{qBdot} is handled within {\cvodes}.

  The \id{y}, \id{yS}, and \id{qBdot} arguments are all of type \id{N\_Vector},
  but they typically do not all have the same internal representation.
  Likewise for each \id{yS[i]}.  It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\cvodes} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQBS} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{fQBS} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_QRHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem 
  (direct method with dense Jacobian)}\label{ss:densejac_b}
  
If the direct linear solver with dense treatment of the Jacobian is selected
for the backward problem (i.e. \Id{CVDenseB} or \Id{CVLapackDenseB} is called in 
step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), the user may provide, 
through a call to \id{CVDlsSetDenseJacFnB} or \id{CVDlsSetDenseJacFnBS}
(see \S\ref{ss:optional_input_b}), a function of one of the following two types:
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\usfunction{CVDlsDenseJacFnB}
{
  typedef int (*CVDlsDenseJacFnB)(&long int NeqB, realtype t, N\_Vector y, \\
                                 &N\_Vector yB, N\_Vector fyB, \\
                                 &DlsMat JacB, void *user\_dataB, \\
                                 &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                 &N\_Vector tmp3B);
}
{
  This function computes the dense Jacobian of the backward problem (or an approximation
  to it). 
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size (number of equations).
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate dense Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVDlsDenseJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDlsDenseJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvdense} sets
  \id{last\_flag} to \Id{CVDLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} to 
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the \id{NeqB} by \id{NeqB}
  dense matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{t},\id{y},\id{yB}), where \id{y} is the solution
  of the original IVP at time \id{tt} and \id{yB} is the solution of the
  backward problem at the same time.
  Only nonzero elements need to be loaded into \id{JacB} as this matrix 
  is set to zero before the call to the Jacobian function. 
  The type of \id{JacB} is \Id{DlsMat}. The user is referred to 
  \S\ref{ss:djacFn} for details regarding accessing a \id{DlsMat} object.

  {\warn}Before calling the user's \id{CVDlsDenseJacFnB}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} to 
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}
%%
\index{Jacobian approximation function!dense!user-supplied (backward)}
\usfunction{CVDlsDenseJacFnBS}
{
  typedef int (*CVDlsDenseJacFnBS)(&long int NeqB, realtype t, N\_Vector y, \\
                                 &N\_Vector *yS, N\_Vector yB, N\_Vector fyB, \\
                                 &DlsMat JacB, void *user\_dataB, \\
                                 &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                 &N\_Vector tmp3B);
}
{
  This function computes the dense Jacobian of the backward problem (or an
  approximation to it), in the case where the backward problem depends on the
  forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size (number of equations).
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate dense Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVDlsDenseJacFnBS} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDlsDenseJacFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvdense} sets
  \id{last\_flag} to \Id{CVDLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} to 
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the \id{NeqB} by \id{NeqB}
  dense matrix \id{JacB} with an approximation to the Jacobian matrix at the point 
  (\id{t},\id{y},\id{yS},\id{yB}), where \id{y} is the solution of the original
  IVP at time \id{tt}, \id{yS} is the vector of forward sensitivities at time \id{tt},
  and \id{yB} is the solution of the backward problem at the same time.
  Only nonzero elements need to be loaded into \id{JacB} as this matrix 
  is set to zero before the call to the Jacobian function. 
  The type of \id{JacB} is \Id{DlsMat}. The user is referred to 
  \S\ref{ss:djacFn} for details regarding accessing a \id{DlsMat} object.

  {\warn}Before calling the user's \id{CVDlsDenseJacFnBS}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} to 
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem
  (direct method with banded Jacobian)}\label{ss:bandjac_b}
\index{Jacobian approximation function!band!user-supplied (backward)}
If the direct linear solver with banded treatment of the Jacobian is selected
for the backward problem (i.e. \Id{CVBandB} or \Id{CVLapackBandB} is called in
step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), the user may provide,
through a call to \id{CVDlsSetBandJacFnB} or \id{CVDlsSetBandJacFnBS}
(see \S\ref{ss:optional_input_b}), a function of one of the following two types:
%%
\usfunction{CVDlsBandJacFnB}
{
 typedef int (*CVDlsBandJacFnB)(&long int NeqB,\\
                             &long int mupperB, long int mlowerB,\\
                             &realtype t, N\_Vector y, \\
                             &N\_Vector yB, N\_Vector fyB, \\
                             &DlsMat JacB, void *user\_dataB, \\
                             &N\_Vector tmp1B, N\_Vector tmp2B, \\
                             &N\_Vector tmp3B);
}
{
  This function computes the banded Jacobian of the backward problem
  (or a banded approximation to it).
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size.
  \item[mlowerB]
  \item[mupperB]
    are the lower and upper half-bandwidth of the Jacobian.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate band Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVDlsBandJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDlsBandJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvband} sets
  \id{last\_flag} to \Id{CVDLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} to 
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{JacB}
  (of type \Id{DlsMat}) with the elements of the Jacobian at the
  point (\id{t},\id{y},\id{yB}), where \id{y} is the solution
  of the original IVP at time \id{tt} and \id{yB} is the solution of the
  backward problem at the same time.  
  Only nonzero elements need to be loaded into
  \id{JacB} because \id{JacB} is preset to zero before the call to the
  Jacobian function. More details on the accessor macros provided for
  a \id{DlsMat} object and on the rest of the arguments passed to a function
  of type \id{CVDlsBandJacFnB} are given in \S\ref{ss:bjacFn}.

  {\warn}Before calling the user's \id{CVDlsBandJacFnB}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvband} sets \id{last\_flag} to
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}
%%
\usfunction{CVDlsBandJacFnBS}
{
 typedef int (*CVDlsBandJacFnBS)(&long int NeqB,\\
                             &long int mupperB, long int mlowerB,\\
                             &realtype t, N\_Vector y, N\_Vector *yS,\\
                             &N\_Vector yB, N\_Vector fyB, \\
                             &DlsMat JacB, void *user\_dataB, \\
                             &N\_Vector tmp1B, N\_Vector tmp2B, \\
                             &N\_Vector tmp3B);
}
{
  This function computes the banded Jacobian of the backward problem
  (or a banded approximation to it), in the case where the backward problem
  depends on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[NeqB]
    is the backward problem size.
  \item[mlowerB]
  \item[mupperB]
    are the lower and upper half-bandwidth of the Jacobian.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate band Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVDlsBandJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVDlsBandJacFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvband} sets
  \id{last\_flag} to \Id{CVDLS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvdense} sets \id{last\_flag} to 
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied band Jacobian function must load the band matrix \id{JacB}
  (of type \Id{DlsMat}) with the elements of the Jacobian at the
  point (\id{t},\id{y},\id{yS},\id{yB}), where \id{y} is the solution
  of the original IVP at time \id{tt}, \id{yS} is the vector of forward
  sensitivities at time \id{tt}, and \id{yB} is the solution of the
  backward problem at the same time.  
  Only nonzero elements need to be loaded into
  \id{JacB} because \id{JacB} is preset to zero before the call to the
  Jacobian function. More details on the accessor macros provided for
  a \id{DlsMat} object and on the rest of the arguments passed to a function
  of type \id{CVDlsBandJacFnBS} are given in \S\ref{ss:bjacFn}.

  {\warn}Before calling the user's \id{CVDlsBandJacFnBS}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvband} sets \id{last\_flag} to
  \Id{CVDLS\_JACFUNC\_UNRECVR}).
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem
  (direct method with sparse Jacobian)}\label{ss:sparsejac_b}
\index{Jacobian approximation function!sparse!user-supplied (backward)}
If the direct linear solver with sparse treatment of the Jacobian is selected
for the backward problem (i.e. \Id{CVKLUB} or \Id{CVSuperLUMTB} is called in
step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), the user must provide,
through a call to \id{CVSlsSetSparseJacFnB} or \id{CVSlsSetSparseJacFnBS}
(see \S\ref{ss:optional_input_b}), a function of one of the following two types:
%%
\usfunction{CVSlsSparseJacFnB}
{
 typedef int (*CVSlsSparseJacFnB)(&realtype t, N\_Vector y, \\
                                  &N\_Vector yB, N\_Vector fyB, \\
                                  &SlsMat JacB, void *user\_dataB, \\
                                  &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                  &N\_Vector tmp3B);
}
{
  This function computes the sparse Jacobian of the backward problem
  (or an approximation to it).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate sparse Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVSlsSparseJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVSlsSparseJacFnB} should return 0 if successful, a positive
  value if a recoverable error occurred (in which case {\cvodes} will
  attempt to correct, while {\cvklu} or {\cvsuperlumt} sets
  \id{last\_flag} to \Id{CVSLS\_JACFUNC\_RECVR}), or a negative value
  if it failed unrecoverably (in which case the integration is halted,
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL} and {\cvklu} or
  {\cvsuperlumt} sets \id{last\_flag} to  \Id{CVSLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied sparse Jacobian function must load the
  compressed-sparse-column matrix \id{JacB} with the elements of the
  Jacobian at the point (\id{t},\id{y},\id{yB}), where \id{y} is the
  solution of the original IVP at time \id{tt} and \id{yB} is the
  solution of the backward problem at the same time.  Storage for
  \id{JacB} already exists on entry to this function, although the
  user should ensure that sufficient space is allocated in \id{JacB}
  to hold the nonzero values to be set; if the existing space is
  insufficient the user may reallocate the data and row index arrays
  as needed.  The type of \id{JacB} is \id{SlsMat}, and the amount of
  allocated space is available within the \id{SlsMat} structure as
  \id{NNZ}.  The \id{SlsMat} type is further documented in the Section
  \S\ref{s:sls}.  More details on the rest of the arguments passed to
  a function of type \id{CVSlsSparseJacFnB} are given in \S\ref{ss:sjacFn}.

  {\warn}Before calling the user's \id{CVSlsSparseJacFnB}, {\cvodes}
  needs to evaluate (through interpolation) the values of the states
  from the forward integration.  If an error occurs in the
  interpolation, {\cvodes} triggers an unrecoverable failure in the
  Jacobian function which will halt the integration (\id{CVodeB}
  returns \id{CV\_LSETUP\_FAIL} and {\cvklu} or {\cvsuperlumt} sets
  \id{last\_flag} to \Id{CVSLS\_JACFUNC\_UNRECVR}).
}
%%
\usfunction{CVSlsSparseJacFnBS}
{
 typedef int (*CVSlsSparseJacFnBS)(&realtype t, N\_Vector y, N\_Vector *yS,\\
                                   &N\_Vector yB, N\_Vector fyB, \\
                                   &SlsMat JacB, void *user\_dataB, \\
                                   &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                   &N\_Vector tmp3B);
}
{
  This function computes the sparse Jacobian of the backward problem
  (or an approximation to it), in the case where the backward problem
  depends on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate sparse Jacobian matrix. 
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{CVSlsSparseJacFnB} as temporary storage or work space.    
  \end{args}
}
{
  A \id{CVSlsSparseJacFnBS} should return 0 if successful, a positive
  value if a recoverable error occurred (in which case {\cvodes} will
  attempt to correct, while {\cvklu} or {\cvsuperlumt} sets
  \id{last\_flag} to \Id{CVSLS\_JACFUNC\_RECVR}), or a negative value
  if it failed unrecoverably (in which case the integration is halted,
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL} and {\cvklu} or
  {\cvsuperlumt} sets \id{last\_flag} to \Id{CVSLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied sparse Jacobian function must load the
  compressed-sparse-column matrix \id{JacB} with the elements of the
  Jacobian at the point (\id{t},\id{y},\id{yS},\id{yB}), where \id{y}
  is the solution of the original IVP at time \id{tt}, \id{yS} is the
  vector of forward sensitivities at time \id{tt}, and \id{yB} is the
  solution of the backward problem at the same time.  Storage for
  \id{JacB} already exists on entry to this function, although the
  user should ensure that sufficient space is allocated in \id{JacB}
  to hold the nonzero values to be set; if the existing space is
  insufficient the user may reallocate the data and row index arrays
  as needed.  The type of \id{JacB} is \id{SlsMat}, and the amount of
  allocated space is available within the \id{SlsMat} structure as
  \id{NNZ}.  The \id{SlsMat} type is further documented in the Section
  \S\ref{s:sls}.  More details on the rest of the arguments passed to
  a function of type \id{CVSlsSparseJacFnBS} are given in
  \S\ref{ss:sjacFn}.

  {\warn}Before calling the user's \id{CVSlsSparseJacFnBS}, {\cvodes}
  needs to evaluate (through interpolation) the values of the states
  from the forward integration.  If an error occurs in the
  interpolation, {\cvodes} triggers an unrecoverable failure in the
  Jacobian function which will halt the integration (\id{CVodeB}
  returns \id{CV\_LSETUP\_FAIL} and {\cvklu} or {\cvsuperlumt} sets
  \id{last\_flag} to \Id{CVSLS\_JACFUNC\_UNRECVR}).
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian information for the backward problem
 (matrix-vector product)}\label{ss:jtimesv_b}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
If one of the Krylov iterative linear solvers {\spgmr}, {\spbcg}, or {\sptfqmr}
is selected (\id{CVodeSp*B} is called in step \ref{i:lin_solverB} of \S\ref{ss:skeleton_adj}), 
the user may provide a function of one of the following two types:
%%
\usfunction{CVSpilsJacTimesVecFnB}
{
  typedef int (*CVSpilsJacTimesVecFnB)(&N\_Vector vB, N\_Vector JvB, \\
                                       &realtype t, N\_Vector y, N\_Vector yB,\\
                                       &N\_Vector fyB, void *user\_dataB,\\
                                       &N\_Vector tmpB);
}
{
  This function computes the action of the Jacobian \id{JB} for
  the backward problem on a given vector \id{vB}.
}
{
  \begin{args}[user\_dataB]
  \item[vB]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[JvB]
    is the computed output vector \id{JB*vB}.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type \id{N\_Vector} which
    can be used by \id{CVSpilsJacTimesVecFn} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{CVSpilsJtimesFnB} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem 
  at the point (\id{t},\id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{CVSpilsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
  If the backward problem is the adjoint of ${\dot y} = f(t, y)$, then this 
  function is to compute $-(\dfdyI)^T v_B$.
}
\usfunction{CVSpilsJacTimesVecFnBS}
{
  typedef int (*CVSpilsJacTimesVecFn&BS)(N\_Vector vB, N\_Vector JvB, \\
                                    &realtype t, N\_Vector y, N\_Vector *yS,\\
                                    &N\_Vector yB, N\_Vector fyB,\\
                                    &void *user\_dataB, N\_Vector tmpB);
}
{
  This function computes the action of the Jacobian \id{JB} for
  the backward problem on a given vector \id{vB}, in the case where
  the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[vB]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[JvB]
    is the computed output vector \id{JB*vB}.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    is a pointer to an array containing the forward sensitivity vectors.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type \id{N\_Vector} which
    can be used by \id{CVSpilsJacTimesVecFn} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{CVSpilsJtimesFnBS} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem 
  at the point (\id{t},\id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{CVSpilsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
 }

%%-------------------------------------------------------------------------------------
\subsection{Preconditioning for the backward problem
 (linear system solution)}\label{ss:psolve_b}
\index{preconditioning!user-supplied}
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner solve function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner solve function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner solve function}
If preconditioning is used during integration of the backward problem, 
then the user must provide a {\CC} function to solve the linear system 
$Pz = r$, where $P$ may be either a left or a right preconditioner matrix.
Here $P$ should approximate (at least crudely) the Newton matrix 
$M_B = I - \gamma_B J_B$, where $J_B = \partial f_B/ \partial y_B$.  If
preconditioning is done on both sides, the product of the two
preconditioner matrices should approximate $M_B$.
This function must be of one of the following two types:
%%
\usfunction{CVSpilsPrecSolveFnB}
{
  typedef int (*CVSpilsPrecSolveFnB)(&realtype t, N\_Vector y, \\
                                     &N\_Vector yB, N\_Vector fyB, \\
                                     &N\_Vector rvecB, N\_Vector zvecB, \\
                                     &realtype gammaB, realtype deltaB, \\
                                     &void *user\_dataB, N\_Vector tmpB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[gammaB]
    is the scalar appearing in the Newton matrix, $M_B = I - \gamma_B J_B$.
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type    
    \id{N\_Vector} which can be used for work space.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{}
%
\usfunction{CVSpilsPrecSolveFnBS}
{
  typedef int (*CVSpilsPrecSolveFnBS)(&realtype t, N\_Vector y, N\_Vector *yS,\\
                                      &N\_Vector yB, N\_Vector fyB, \\
                                      &N\_Vector rvecB, N\_Vector zvecB, \\
                                      &realtype gammaB, realtype deltaB, \\
                                      &void *user\_dataB, N\_Vector tmpB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem,
  in the case where the backward problem depends on the forward sensitivities.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    is a pointer to an array containing the forward sensitivity vectors.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[gammaB]
    is the scalar appearing in the Newton matrix, $M_B = I - \gamma_B J_B$.
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type    
    \id{N\_Vector} which can be used for work space.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioning for the backward problem
 (Jacobian data)}\label{ss:psetup_b}
\index{preconditioning!user-supplied}
\index{CVSPGMR@{\cvspgmr} linear solver!preconditioner setup function}
\index{CVSPBCG@{\cvspbcg} linear solver!preconditioner setup function}
\index{CVSPTFQMR@{\cvsptfqmr} linear solver!preconditioner setup function}
If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied {\CC} function of one of the following two types:
%%
\usfunction{CVSpilsPrecSetupFnB}
{
  typedef int (*CVSpilsPrecSetupFn&B)(realtype t, N\_Vector y, \\
                                     &N\_Vector yB, N\_Vector fyB, \\ 
                                     &booleantype jokB, booleantype *jcurPtrB,\\
                                     &realtype gammaB, void *user\_dataB,\\
                                     &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                     &N\_Vector tmp3B);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem.
}
{
  The arguments of a \id{CVSpilsPrecSetupFnB} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{FALSE}) or information saved 
    from a previous invokation can be safely used (\id{jokB}=\id{TRUE}).
  \item[jcurPtr]
    is an output flag which must be set to \id{TRUE} if Jacobian-relatd data 
    was recomputed or \id{FALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the Newton matrix.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated for vectors which can be used           
    as temporary storage or work space.    
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{}

\usfunction{CVSpilsPrecSetupFnBS}
{
  typedef int (*CVSpilsPrecSetupFn&BS)(realtype t, N\_Vector y, N\_Vector *yS,\\
                                     &N\_Vector yB, N\_Vector fyB, \\ 
                                     &booleantype jokB, booleantype *jcurPtrB,\\
                                     &realtype gammaB, void *user\_dataB,\\
                                     &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                     &N\_Vector tmp3B);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem, in the case where the
  backward problem depends on the forward sensitivities.

}
{
  The arguments of a \id{CVSpilsPrecSetupFnBS} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    is a pointer to an array containing the forward sensitivity vectors.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{FALSE}) or information saved 
    from a previous invokation can be safely used (\id{jokB}=\id{TRUE}).
  \item[jcurPtr]
    is an output flag which must be set to \id{TRUE} if Jacobian-relatd data 
    was recomputed or \id{FALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the Newton matrix.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated for vectors which can be used           
    as temporary storage or work space.    
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{}
%%
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
\section{Using CVODES preconditioner modules for the backward problem}
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
%%

As on the forward integration phase, the efficiency of Krylov iterative methods 
for the solution of linear systems can be greatly enhanced through preconditioning.
Both preconditioner modules provided with {\sundials}, the serial banded
preconditioner {\cvbandpre} and the parallel band-block-diagonal preconditioner
module {\cvbbdpre}, provide interface functions through which they can be used 
on the backward integration phase.


%%-------------------------------------------------------------------
\subsection{Using the banded preconditioner CVBANDPRE}
%%-------------------------------------------------------------------

\index{CVBANDPRE@{\cvbandpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\cvodes} offers an interface to the banded 
preconditioner module {\cvbandpre} described in section \S\ref{sss:cvbandpre}.
This preconditioner, usable only in a serial setting, provides a band matrix 
preconditioner based on difference quotients of the backward problem right-hand 
side function \id{fB}.  It generates
a banded approximation to the Jacobian with $m_{lB}$ sub-diagonals and $m_{uB}$
super-diagonals to be used with one of the Krylov linear solvers.

In order to use the {\cvbandpre} module in the solution of the backward problem,
the user need not define any additional functions. 
Instead, {\em after} one of the {\cvspils} linear solvers has been specified,
by calling the appropriate function (see \S\ref{sss:lin_solv_b}), the following call
to the {\cvbandpre} module initialization function must be made.
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|(}
\ucfunction{CVBandPrecInitB}
{
  flag = CVBandPrecInitB(cvode\_mem, which, nB, muB, mlB);
}
{
  The function \ID{CVBandPrecInitB} initializes and allocates
  memory for the {\cvbandpre} preconditioner for the backward problem.
  It creates, allocates, and stores (internally in the {\cvodes} 
  solver block) a pointer to the newly created {\cvbandpre} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[nB] (\id{long int})
    backward problem dimension.
  \item[muB] (\id{long int})
    upper half-bandwidth of the backward problem Jacobian approximation.
  \item[mlB] (\id{long int})
    lower half-bandwidth of the backward problem Jacobian approximation.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}]
    The call to \id{CVodeBandPrecInitB} was successful.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|)}
For more details on {\cvbandpre} see \S\ref{sss:cvbandpre}.
\index{CVBANDPRE@{\cvbandpre} preconditioner!usage with adjoint module|)}



%%-------------------------------------------------------------------
\subsection{Using the band-block-diagonal preconditioner CVBBDPRE}
%%-------------------------------------------------------------------
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\cvodes} offers an interface to the band-block-diagonal
preconditioner module {\cvbbdpre} described in section \S\ref{sss:cvbbdpre}.
This generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix and can be used with one of the Krylov linear solvers
and with the MPI-parallel vector module {\nvecp}.

In order to use the {\cvbbdpre} module in the solution of the backward problem,
the user must define one or two additional functions, described at the
end of this section.

\subsubsection{Initialization of CVBBDPRE}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|(}
The {\cvbbdpre} module is initialized by calling the following function,
{\em after} one of the {\cvspils} linear solvers has been specified
by calling the appropriate function (see \S\ref{sss:lin_solv_b}).
%%
%%
\ucfunction{CVBBDPrecInitB}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVBBDPrecInitB(&cvode\_mem, which, NlocalB, mudqB, mldqB,\\
                          &mukeepB, mlkeepB, dqrelyB, glocB, gcommB);
  \end{tabular}
}
{
  The function \ID{CVBBDPrecInitB} initializes and allocates
  memory for the {\cvbbdpre} preconditioner for the backward problem.
  It creates, allocates, and stores (internally in the {\cvodes} solver
  block) a pointer to the newly created {\cvbbdpre} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[NlocalB] (\id{long int})
    local vector dimension for the backward problem.
  \item[mudqB] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeepB] (\id{long int})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeepB] (\id{long int})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.  The default is \id{dqrelyB}$ = \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dqrely}$ = 0.0$.
  \item[glocB] (\id{CVBBDLocalFnB})
    the {\CC} function which computes the function $g_B(t,y,y_B)$ approximating
    the right-hand side of the backward problem. 
  \item[gcommB] (\id{CVBBDCommFnB})
    the optional {\CC} function which performs all interprocess communication required for
    the computation of $g_B$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}]
    The call to \id{CVodeBBDPrecInitB} was successful.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
To reinitialize the {\cvbbdpre} preconditioner module for the backward problem,
possibly with changes in \id{mudqB}, \id{mldqB}, or \id{dqrelyB}, call the following 
function:
%%
\ucfunction{CVBBDPrecReInitB}
{
  flag = CVBBDPrecReInitB(cvode\_mem, which, mudqB, mldqB, dqrelyB);
}
{
  The function \ID{CVBBDPrecReInitB} reinitializes the {\cvbbdpre} preconditioner
  for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[mudqB] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVSPILS\_ILL\_INPUT]
  \item[\Id{CVSPILS\_SUCCESS}]
    The call to \id{CVodeBBDPrecReInitB} was successful.
  \item[\Id{CVSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVSPILS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVSPILS\_PMEM\_NULL}]
    The \id{CVodeBBDPrecInitB} has not been previously called.
  \item[\Id{CVSPILS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVSPILS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|)}
%%
For more details on {\cvbbdpre} see \S\ref{sss:cvbbdpre}.

\subsubsection{User-supplied functions for CVBBDPRE}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|(}
To use the {\cvbbdpre} module, the user must supply one or two functions which the
module calls to construct the preconditioner: a required function \id{glocB} 
(of type \id{CVBBDLocalFnB}) which approximates the right-hand side of the backward
problem and which is computed locally, and an optional function \id{gcommB} 
(of type \id{CVBBDCommFnB}) which performs all interprocess communication necessary 
to evaluate this approximate right-hand side (see \S\ref{sss:cvbbdpre}).
The prototypes for these two functions are described below.
%%
%%
\usfunction{CVBBDLocalFnB}
{
  typedef int (*CVBBDLocalFnB)(&long int NlocalB, realtype t, N\_Vector y,\\
                               &N\_Vector yB, N\_Vector gB, void *user\_dataB);
}
{
  This \id{glocB} function loads the vector \id{gB}, an approximation to the
  right-hand side $f_B$ of the backward problem, as a function of \id{t}, \id{y},
  and \id{yB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length for the backward problem.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[gB]
    is the output vector, $g_B(t, y, y_B)$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}      
    parameter passed to \id{CVodeSetUserDataB}.  
  \end{args}
}
{
  An \id{CVBBDLocalFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL}). 
}
{
  This routine must assume that all interprocess communication of data needed to 
  calculate \id{gB} has already been done, and this data is accessible within
  \id{user\_dataB}.

  {\warn}Before calling the user's \id{CVBBDLocalFnB}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the preconditioner setup function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL}).
}
%%
%%
\usfunction{CVBBDCommFnB}
{
  typedef int (*CVBBDCommFnB)(&long int NlocalB, realtype t, N\_Vector y,\\
                              &N\_Vector yB, void *user\_dataB);
}
{
  This \id{gcommB} function must perform all interprocess communications necessary 
  for the execution of the \id{glocB} function above, using the input 
  vectors \id{y} and \id{yB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  An \id{CVBBDCommFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL}). 
}
{
  The \id{gcommB} function is expected to save communicated data in space defined within the
  structure \id{user\_dataB}. 

  Each call to the \id{gcommB} function is preceded by a call to the function that 
  evaluates the right-hand side of the backward problem with the same \id{t}, \id{y}, 
  and \id{yB}, arguments. If there is no additional communication needed, then 
  pass \id{gcommB = NULL} to \id{CVBBDPrecInitB}.
}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|)}
%%
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage with adjoint module|)}

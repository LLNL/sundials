%%==============================================================================
\chapter{FKINSOL, an Interface Module for FORTRAN Applications}\label{s:fcmix}
%%==============================================================================

The {\fkinsol} interface module is a package of {\CC} functions which support
the use of the {\kinsol} solver, for the solution of nonlinear systems
$F(u)=0$, in a mixed {\F}/{\CC} setting.  While {\kinsol} is written
in {\CC}, it is assumed here that the user's calling program and
user-supplied problem-defining routines are written in {\F}.
This package provides the necessary interface to {\kinsol} for all supplied
serial and parallel {\nvector} implementations.

%%==============================================================================
% Pull in sections on portability and data types.
%%==============================================================================
\input{fortran}

%% In this package, the names of the interface functions, and the names of
%% the {\F} user routines called by them, appear as dummy names
%% which are mapped to actual values by a series of definitions in the
%% header files \id{fkinsol.h} and \id{fkinbbd.h}.
%% By default, those mapping definitions depend in turn on the {\CC} macro
%% \id{F77\_FUNC} defined in the header file \id{sundials\_config.h} and
%% decided upon at configuration time (see Appendix \ref{c:install}).

%% The user must also ensure that variables in the user {\F} code are
%% declared in a manner consistent with their counterparts in {\kinsol}.
%% All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
%% or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
%% depending on whether {\kinsol} was built in single, double or extended precision 
%% (see Appendix \ref{c:install}). Moreover, some of the {\F} integer variables
%% must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
%% {\CC} type \id{long int}. These integer variables include:
%% the optional input (\id{IVAL}), the problem size and bandwidth parameters
%% (\id{NEQ}, \id{NLOCAL}, \id{NGLOBAL}, \id{ML}, \id{MU}, etc.),
%% and the array of integer optional outputs (\id{IOUT}).
%% EXCEPTION: In the case that LAPACK linear solvers are to be used, the
%% input arguments to \id{FKINLAPACKDENSE} or \id{FKINLAPACKBAND} (\id{NEQ},
%% \id{ML}, and \id{MU}) must be declared to be consistent with {\CC} type \id{int}.
%% This type consistency is particularly important when using
%% {\kinsol} and the {\fkinsol} package on 64-bit architectures.

%%==============================================================================
\section{FKINSOL routines}\label{sss:fkinroutines}
%%==============================================================================

\index{FKINSOL@{\fkinsol} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\kinsol} functions,
are as follows:
\begin{itemize}
\item
  Interface to the {\nvector} modules
  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs}) 
    interfaces to \id{N\_VNewEmpty\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp}) 
    interfaces to \id{N\_VNewEmpty\_Parallel}.
  \item \id{FNVINITOMP} (defined by {\nvecopenmp}) 
    interfaces to \id{N\_VNewEmpty\_OpenMP}.
  \item \id{FNVINITPTS} (defined by {\nvecpthreads}) 
    interfaces to \id{N\_VNewEmpty\_Pthreads}.
  \end{itemize}
\item
  Interface to the {\sunmatrix} modules
  \begin{itemize}
  \item \id{FSUNBANDMATINIT} (defined by {\sunmatband}) 
    interfaces to \id{SUNBandMatrix}.
  \item \id{FSUNDENSEMATINIT} (defined by {\sunmatdense}) 
    interfaces to \id{SUNDenseMatrix}.
  \item \id{FSUNSPARSEMATINIT} (defined by {\sunmatsparse}) 
    interfaces to \id{SUNSparseMatrix}.
  \end{itemize}
\item
  Interface to the {\sunlinsol} modules
  \begin{itemize}
  \item \id{FSUNBANDLINSOLINIT} (defined by {\sunlinsolband}) 
    interfaces to \id{SUNLinSol\_Band}.
  \item \id{FSUNDENSELINSOLINIT} (defined by {\sunlinsoldense}) 
    interfaces to \id{SUNLinSol\_Dense}.
  \item \id{FSUNKLUINIT} (defined by {\sunlinsolklu}) 
    interfaces to \id{SUNLinSol\_KLU}.
  \item \id{FSUNKLUREINIT} (defined by {\sunlinsolklu}) 
    interfaces to \id{SUNLinSol\_KLUReinit}.
  \item \id{FSUNLAPACKBANDINIT} (defined by {\sunlinsollapband}) 
    interfaces to \id{SUNLinSol\_LapackBand}.
  \item \id{FSUNLAPACKDENSEINIT} (defined by {\sunlinsollapdense}) 
    interfaces to \id{SUNLinSol\_LapackDense}.
  \item \id{FSUNPCGINIT} (defined by {\sunlinsolpcg}) 
    interfaces to \id{SUNLinSol\_PCG}.
  \item \id{FSUNSPBCGSINIT} (defined by {\sunlinsolspbcgs}) 
    interfaces to \id{SUNLinSol\_SPBCGS}.
  \item \id{FSUNSPFGMRINIT} (defined by {\sunlinsolspfgmr}) 
    interfaces to \id{SUNLinSol\_SPFGMR}.
  \item \id{FSUNSPGMRINIT} (defined by {\sunlinsolspgmr}) 
    interfaces to \id{SUNLinSol\_SPGMR}.
  \item \id{FSUNSPTFQMRINIT} (defined by {\sunlinsolsptfqmr}) 
    interfaces to \id{SUNLinSol\_SPTFQMR}.
  \item \id{FSUNSUPERLUMTINIT} (defined by {\sunlinsolslumt}) 
    interfaces to \id{SUNLinSol\_SuperLUMT}.
  \end{itemize}
\item Interface to the main {\kinsol} module
  \begin{itemize}
  \item \id{FKINCREATE}
    interfaces to \id{KINCreate}.
  \item \id{FKINSETIIN} and \id{FKINSETRIN}
    interface to \id{KINSet*} functions.
  \item \id{FKININIT}
    interfaces to \id{KINInit}.
  \item \id{FKINSETVIN}
    interfaces to \id{KINSetConstraints}.
  \item \id{FKINSOL}
    interfaces to \id{KINSol}, \id{KINGet*} functions, and to the optional
    output functions for the selected linear solver module.
  \item \id{FKINFREE}    
    interfaces to \id{KINFree}.
  \end{itemize}  
\item Interface to the {\kinls} module
  \begin{itemize}
  \item \id{FKINLSINIT}    
    interfaces to \id{KINSetLinearSolver}.
  \item \id{FKINLSSETJAC}
    interfaces to \id{KINSetJacTimesVecFn}.
  \item \id{FKINLSSETPREC}
    interfaces to \id{KINSetPreconditioner}.
  \item \id{FKINDENSESETJAC}
    interfaces to \id{KINSetJacFn}.
  \item \id{FKINBANDSETJAC}
    interfaces to \id{KINSetJacFn}.
  \item \id{FKINSPARSESETJAC}
    interfaces to \id{KINSetJacFn}.
 \end{itemize}

\end{itemize}
\index{FKINSOL@{\fkinsol} interface module!user-callable functions|)}

\index{FKINSOL@{\fkinsol} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding internal
interface function which calls it (and its type within {\kinsol}), are as follows:
\begin{center}
\begin{tabular}{l||l|l}
{\fkinsol} routine      &  {\kinsol} function & {\kinsol} type of \\
({\F}, user-supplied)  &  ({\CC}, interface) & interface function \\ \hline\hline
\id{FKFUN}     & \id{FKINfunc}       & \id{KINSysFn} \\
\id{FKDJAC}    & \id{FKINDenseJac}   & \id{KINLsJacFn} \\
\id{FKBJAC}    & \id{FKINBandJac}    & \id{KINLsJacFn} \\
\id{FKINSPJAC} & \id{FKINSparseJac}  & \id{KINLsJacFn} \\
\id{FKPSET}    & \id{FKINPSet}       & \id{KINLsPrecSetupFn} \\
\id{FKPSOL}    & \id{FKINPSol}       & \id{KINLsPrecSolveFn} \\
\id{FKJTIMES}  & \id{FKINJtimes}     & \id{KINLsJacTimesVecFn} \\
\end{tabular}
\end{center}
In contrast to the case of direct use of {\kinsol}, the names of all 
user-supplied routines here are fixed, in order to maximize portability 
for the resulting mixed-language program.

%%==============================================================================
\section{Usage of the FKINSOL interface module}\label{ss:fkinsol_usage}
%%==============================================================================
\index{FKINSOL@{\fkinsol} interface module!usage|(}

The usage of {\fkinsol} requires calls to a few different interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\kinsol} functions for information on the arguments 
of any given user-callable interface routine, or of a given user-supplied 
function called by an interface function.

%
\index{User main program!FKINSOL@{\fkinsol} usage}
\begin{Steps}
 
%%====================
\item {\bf Nonlinear system function specification}
%%====================
  
  The user must, in all cases, supply the following {\F} routine
  \index{FKFUN@\texttt{FKFUN}}
\begin{verbatim}
      SUBROUTINE FKFUN (U, FVAL, IER)
      DIMENSION U(*), FVAL(*)
\end{verbatim}
  It must set the \id{FVAL} array to $F(u)$, the system function,
  as a function of \id{U =} $u$.  
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol}
  will attempt to correct), or a negative value if it failed unrecoverably
  (in which case the solution process is halted).

%%====================
\item  {\bf {\nvector} module initialization}
%%====================

  If using one of the {\nvector} modules supplied with {\sundials},
  the user must make a call of the form
\begin{verbatim}
      CALL FNVINIT***(...)
\end{verbatim}
in which the name and call sequence are as described in the appropriate
section of Chapter \ref{s:nvector}.

%%====================
\item\label{i:fkin_matrix_init} {\bf {\sunmatrix} module initialization}
%%====================

  If using a Newton or Picard iteration with a matrix-based
  {\sunlinsol} linear solver module and one of the {\sunmatrix}
  modules supplied with {\sundials}, the user must make a call of the
  form 
\begin{verbatim}
      CALL FSUN***MATINIT(...)
\end{verbatim}
in which the name and call sequence are as described in the appropriate
section of Chapter \ref{s:sunmatrix}.  Note that the dense, band, or
sparse matrix options are usable only in a serial or multi-threaded
environment. 

%%====================
\item\label{i:fkin_linsol_init} {\bf {\sunlinsol} module initialization}
%%====================

  If using a Newton or Picard iteration with one of the {\sunlinsol} linear
  solver modules supplied with {\sundials}, the user must make a call
  of the form 
\begin{verbatim}
      CALL FSUNBANDLINSOLINIT(...)
      CALL FSUNDENSELINSOLINIT(...)
      CALL FSUNKLUINIT(...)
      CALL FSUNLAPACKBANDINIT(...)
      CALL FSUNLAPACKDENSEINIT(...)
      CALL FSUNPCGINIT(...)
      CALL FSUNSPBCGSINIT(...)
      CALL FSUNSPFGMRINIT(...)
      CALL FSUNSPGMRINIT(...)
      CALL FSUNSPTFQMRINIT(...)
      CALL FSUNSUPERLUMTINIT(...)
\end{verbatim}
in which the call sequence is as described in the appropriate
section of Chapter \ref{s:sunlinsol}.  Note that the dense, band, or
sparse solvers are usable only in a serial or multi-threaded
environment.

Once one of these solvers has been initialized, its solver parameters may be
modified using a call to the functions
\begin{verbatim}
      CALL FSUNKLUSETORDERING(...)
      CALL FSUNSUPERLUMTSETORDERING(...)
      CALL FSUNPCGSETPRECTYPE(...)
      CALL FSUNPCGSETMAXL(...)
      CALL FSUNSPBCGSSETPRECTYPE(...)
      CALL FSUNSPBCGSSETMAXL(...)
      CALL FSUNSPFGMRSETGSTYPE(...)
      CALL FSUNSPFGMRSETPRECTYPE(...)
      CALL FSUNSPGMRSETGSTYPE(...)
      CALL FSUNSPGMRSETPRECTYPE(...)
      CALL FSUNSPTFQMRSETPRECTYPE(...)
      CALL FSUNSPTFQMRSETMAXL(...)
\end{verbatim}
where again the call sequences are described in the appropriate
sections of Chapter \ref{s:sunlinsol}.

%%====================
\item {\bf Problem specification}
%%====================

  To create the main solver memory block, make the following call:
  \index{FKINCREATE@\texttt{FKINCREATE}}
  \ucfunction{FKINCREATE}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l@{}}
        &CALL FKINCREATE (IER)
    \end{tabular}
  }
  {
    This function creates the {\kinsol} memory structure.
  }
  {
    \begin{args}[IOUT\,]
    \item[None.]
    \end{args}
  }
  {
    \id{IER} is the return completion flag. Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
  }

%%====================
\item\label{i:fkinsol_opt_input}{\bf Set optional inputs} 
%%====================

  Call \id{FKINSETIIN}, \id{FKINSETRIN}, and/or \id{FKINSETVIN}, to set desired 
  optional inputs, if any.  See \S\ref{fkin_opt_inout} for details.

%%====================
\item {\bf Solver Initialization}
%%====================

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FKININIT@\texttt{FKININIT}}
  \ucfunction{FKININIT}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l@{}}
        &CALL FKININIT (IOUT, ROUT, IER)
    \end{tabular}
  }
  {
    This function specifies the optional output arrays,
    allocates internal memory, and initializes {\kinsol}.
  }
  {
    \begin{args}[IOUT\,]
    \item[IOUT] is an integer array for integer optional outputs.
    \item[ROUT] is a real array for real optional outputs.
    \end{args}
  }
  {
    \id{IER} is the return completion flag. Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
    The user integer data array \id{IOUT} must be declared as \id{INTEGER*4} or
    \id{INTEGER*8} according to the {\CC} type \id{long int}.

    The optional outputs associated with the main {\kinsol} integrator
    are listed in Table~\ref{t:fkinsol_out}.
  }

%%====================
\item\label{i:fkinsol_lin_solv_spec}{\bf Linear solver interface specification} 
%%====================

  The Newton and Picard solution methods in {\kinsol} involve the solution of linear systems 
  related to the Jacobian of the nonlinear system. 
  To attach the linear solver (and optionally the matrix) objects
  initialized in steps \ref{i:fkin_matrix_init} and
  \ref{i:fkin_linsol_init} above, the user of {\fkinsol} must initialize
  the {\kinls} linear solver interface.

  \index{KINLS@{\kinls} linear solver interface!use in {\fkinsol}}
  To attach any {\sunlinsol} object (and optional {\sunmatrix} object)
  to the {\kinls} interface, then following calls to initialize the
  {\sunlinsol} (and {\sunmatrix}) object(s) in steps
  \ref{i:fkin_matrix_init} and \ref{i:fkin_linsol_init} above, the
  user must make the call: 
  \index{FKINLSINIT@\texttt{FKINLSINIT}}
\begin{verbatim}
      CALL FKINLSINIT (IER)
\end{verbatim}
  where \id{IER} is an error return flag which is $0$ for success or 
  $-1$ if a memory allocation failure occurred.

  The previous routines \Id{FKINDLSINIT} and \Id{FKINSPILSINIT} are now
  wrappers for this routine, and may still be used for
  backward-compatibility.  However, these will be deprecated in future
  releases, so we recommend that users transition to the new routine
  name soon.
  
  {\bf {\kinls} with dense Jacobian matrix}

  \index{Jacobian approximation function!dense!use in {\fkinsol}}
  As an option when using the {\kinls} interface with the
  {\sunlinsoldense} or {\sunlinsollapdense} linear solvers, the user
  may supply a routine that computes a dense approximation of the
  system Jacobian $J = \partial F / \partial u$. If supplied, it must
  have the following form: 
  \index{FKDJAC@\texttt{FKDJAC}}
\begin{verbatim}
      SUBROUTINE FKDJAC (NEQ, U, FVAL, DJAC, WK1, WK2, IER)
      DIMENSION U(*), FVAL(*), DJAC(NEQ,*), WK1(*), WK2(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{U}, and \id{DJAC}. 
  It must compute the Jacobian and store it columnwise in \id{DJAC}.
  The input arguments \id{U} and \id{FVAL} contain the current
  values of $u$ and $F(u)$, respectively.
  The vectors \id{WK1} and \id{WK2},
  of length \id{NEQ}, are provided as work space for use in \id{FKDJAC}.
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol}
  will attempt to correct), or a negative value if \id{FKDJAC} failed
  unrecoverably (in which case the solution process is halted).
  NOTE: The argument \id{NEQ} has a type consistent with {\CC} type \id{long int}
  even in the case when the LAPACK dense solver is to be used.

  If the \id{FKDJAC} routine is provided, then, 
  following the call to \id{FKINLSINIT}, the user must make the call:
  \index{FKINDENSESETJAC@\texttt{FKINDENSESETJAC}}
\begin{verbatim}
      CALL FKINDENSESETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.

  %%-------------------------------------------------

  {\bf {\kinls} with band Jacobian matrix}
  \index{Jacobian approximation function!band!use in {\fkinsol}}
  
  As an option when using the {\kinls} interface with the 
  {\sunlinsolband} or {\sunlinsollapband} linear solvers, the user may supply a
  routine that computes a band approximation of the system Jacobian 
  $J = \partial F / \partial u$. If supplied, it must have the following form:
  \index{FKBJAC@\texttt{FKBJAC}}
\begin{verbatim}
      SUBROUTINE FKBJAC (NEQ, MU, ML, MDIM, U, FVAL, BJAC, WK1, WK2, IER)
      DIMENSION U(*), FVAL(*), BJAC(MDIM,*), WK1(*), WK2(*)
\end{verbatim}
  Typically this routine will use only \id{NEQ}, \id{MU}, \id{ML},
  \id{U}, and \id{BJAC}.
  It must load the \id{MDIM} by \id{N} array \id{BJAC} with the Jacobian matrix
  at the current $u$ in band form.  Store in \id{BJAC}$(k,j)$ the Jacobian
  element $J_{i,j}$ with $k = i - j + $ \id{MU} $ + 1$ ($k = 1 \cdots $
  \id{ML + MU + 1}) and $j = 1 \cdots N$.
  The input arguments \id{U} and \id{FVAL} contain the current
  values of $u$, and $F(u)$, respectively.
  The vectors \id{WK1} and \id{WK2}
  of length \id{NEQ} are provided as work space for use in
  \id{FKBJAC}.
  \id{IER} is an error return flag, which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol} will
  attempt to correct), or a negative value if \id{FKBJAC} failed unrecoverably
  (in which case the solution process is halted).
  NOTE: The arguments \id{NEQ}, \id{MU}, \id{ML}, and \id{MDIM} have a type
  consistent with {\CC} type \id{long int} even in the case when the LAPACK band
  solver is to be used.

  If the \id{FKBJAC} routine is provided, then, following the call to \id{FKINLSINIT},
  the user must make the call:
  \index{FKINBANDSETJAC@\texttt{FKINBANDSETJAC}}
\begin{verbatim}
      CALL FKINBANDSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian approximation.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.

  %%-------------------------------------------------

  {\bf {\kinls} with sparse Jacobian matrix} 
  \index{Jacobian approximation function!sparse!use in {\fkinsol}}
  \index{FKINSPJAC@\texttt{FKINSPJAC}}

  When using the {\kinls} interface with either of the {\sunlinsolklu}
  or {\sunlinsolslumt} linear solvers, the user must supply the \id{FKINSPJAC} routine
  that computes a compressed-sparse-column or compressed-sparse-row 
  approximation of the system Jacobian $J = \partial F / \partial u$.
  If supplied, it must have the following form:
\begin{verbatim}
       SUBROUTINE FKINSPJAC(Y, FY, N, NNZ, JDATA, JINDEXVALS, 
      &                     JINDEXPTRS, WK1, WK2, IER)
\end{verbatim}
  Typically this routine will use only \id{N, NNZ, JDATA, JINDEXVALS} and 
  \id{JINDEXPTRS}. It must load the \id{N} by \id{N} 
  compressed sparse column  [or compressed sparse row] matrix 
  with storage for \id{NNZ} nonzeros, stored in the arrays \id{JDATA} (nonzero
  values), \id{JINDEXVALS} (row [or column] indices for each nonzero), \id{JINDEXPTRS} (indices 
  for start of each column [or row]), with the Jacobian matrix at the current
  (y) in CSC [or CSR] form (see \id{sunmatrix\_sparse.h} for more information).
  The arguments are \id{Y}, an array containing state variables; \id{FY}, an
  array containing residual values; \id{N}, the number of matrix rows/columns 
  in the Jacobian; \id{NNZ}, allocated length of nonzero storage; \id{JDATA},
  nonzero values in the Jacobian (of length \id{NNZ}); 
  \id{JINDEXVALS}, row [or column] indices for each nonzero in Jacobian (of length \id{NNZ});
  \id{JINDEXPTRS}, pointers to each Jacobian column [or row] in the two preceding arrays
  (of length \id{N}+1); \id{WK*}, work arrays containing temporary workspace 
  of same size as \id{Y}; and \id{IER}, error return code (0 if successful,
  $>0$ if a recoverable error occurred, or $<0$ if an unrecoverable error occurred.)

  To indicate that the \id{FKINSPJAC} routine has been provided, then
  following the call to \id{FKINLSINIT}, the
  following call must be made    
  \index{FKINSPARSESETJAC@\texttt{FKINSPARSESETJAC}}
\begin{verbatim}
      CALL FKINSPARSESETJAC (IER)
\end{verbatim}
  The int return flag \id{IER} is an error return flag which is $0$
  for success or nonzero for an error.


  %%-------------------------------------------------
  {\bf {\kinls} with Jacobian-vector product}

  As an option when using the {\kinls} linear solver interface, the
  user may supply a routine that computes the product of the system
  Jacobian and a given vector.  If supplied, it must have the
  following form:
  \index{FKINJTIMES@\texttt{FKINJTIMES}}
\begin{verbatim}
      SUBROUTINE FKINJTIMES (V, FJV, NEWU, U, IER)
      DIMENSION V(*), FJV(*), U(*)
\end{verbatim}
  Typically this routine will use only \id{U}, \id{V}, and \id{FJV}.
  It must compute the product vector $Jv$, where the vector $v$ is
  stored in \id{V}, and store the product in \id{FJV}.  
  The input argument \id{U} contains the current value of $u$.  On return, set
  \id{IER = 0} if \id{FKINJTIMES} was successful, and nonzero otherwise.
  \id{NEWU} is a flag to indicate if \id{U} has been changed since the last
  call; if it has, then \id{NEWU = 1}, and \id{FKINJTIMES} should recompute any
  saved Jacobian data it uses and reset \id{NEWU} to 0.  (See \S\ref{ss:jtimesFn}.)

  To indicate that the \id{FKINJTIMES} routine has been provided, then
  following the call to \id{FKINLSINIT}, the following call must be made
  \index{FKINLSSETJAC@\texttt{FKINLSSETJAC}}
\begin{verbatim}
      CALL FKINLSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied
  Jacobian-times-vector approximation.
  The argument \id{IER} is an error return flag which is $0$ 
  for success or non-zero if an error occurred.

  The previous routine \Id{FKINSPILSETJAC} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
  
  
  %%-------------------------------------------------
  {\bf {\kinls} with preconditioning}
  \index{Preconditioner setup routine!use in {\fkinsol}}
  \index{Preconditioner solve routine!use in {\fkinsol}}

  If user-supplied preconditioning is to be included, the following routine must be
  supplied, for solution of the preconditioner linear system:
  \index{FKPSOL@\texttt{FKPSOL}}
\begin{verbatim}
      SUBROUTINE FKPSOL (U, USCALE, FVAL, FSCALE, VTEM, IER)
      DIMENSION U(*), USCALE(*), FVAL(*), FSCALE(*), VTEM(*)
\end{verbatim}
  Typically this routine will use only \id{U}, \id{FVAL}, and \id{VTEM}
  It must solve the preconditioned linear system $Pz = r$, where
  $r = $ \id{VTEM} is input, and store the solution $z$ in \id{VTEM} as well. 
  Here $P$ is the right preconditioner. If scaling is being used, the
  routine supplied must also account for scaling on either coordinate
  or function value, as given in the arrays \id{USCALE} and
  \id{FSCALE}, respectively.
  
  If the user's preconditioner requires that any Jacobian-related data be evaluated
  or preprocessed, then the following routine can be used for the evaluation and
  preprocessing of the preconditioner:
  \index{FKPSET@\texttt{FKPSET}}
\begin{verbatim}
      SUBROUTINE FKPSET (U, USCALE, FVAL, FSCALE, IER)
      DIMENSION U(*), USCALE(*), FVAL(*), FSCALE(*)
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and
  preprocessing needed for the solution of the preconditioned linear
  systems by \id{FKPSOL}. The variables \id{U} through \id{FSCALE} are for use in the
  preconditioning setup process. Typically, the system function \id{FKFUN} is
  called before any calls to \id{FKPSET}, so that \id{FVAL} will have
  been updated. \id{U} is the current solution
  iterate. 
  If scaling is being used, \id{USCALE} and \id{FSCALE} are available for those operations
  requiring scaling.
  
  On return, set \id{IER} $= 0$ if \id{FKPSET} was successful, or set \id{IER} $= 1$
  if an error occurred.

  To indicate that the \id{FKINPSET} and \id{FKINPSOL} routines are
  supplied, then the user must call
  \index{FKINLSSETPREC@\texttt{FKINLSSETPREC}}
\begin{verbatim}
      CALL FKINLSSETPREC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if
  successful, or negative if a memory error occurred.
  In addition, the user program must include
  preconditioner routines \id{FKPSOL} and \id{FKPSET} (see below).

  The previous routine \Id{FKINSPILSETPREC} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
  
  {\warn} If the user calls \id{FKINLSSETPREC}, the routine \id{FKPSET} must
  be provided, even if it is not needed, and then it should return \id{IER = 0}.


  
%%====================
\item {\bf Problem solution}
%%====================

  Solving the nonlinear system is accomplished by making the following call:
  \index{FKINSOL@\texttt{FKINSOL}}
\begin{verbatim}
      CALL FKINSOL (U, GLOBALSTRAT, USCALE, FSCALE, IER)
\end{verbatim}
  The arguments are as follows.
  \id{U} is an array containing the initial guess on input, and the
  solution on return.
  \id{GLOBALSTRAT} is an integer (type \id{INTEGER}) defining the global strategy 
  choice ($0$ specifies Inexact Newton, $1$ indicates Newton with line search,
  $2$ indicates Picard iteration, and $3$ indicates Fixed Point iteration).
  \id{USCALE} is an array of scaling factors for the \id{U} vector.
  \id{FSCALE} is an array of scaling factors for the \id{FVAL} vector.
  \id{IER} is an integer completion flag and will have one of the following values:
  $0$ to indicate success,
  $1$ to indicate that the initial guess satisfies $F(u) = 0$ within tolerances,
  $2$ to indicate apparent stalling (small step), or a negative value to indicate
  an error or failure. These values correspond to the \id{KINSol} returns
  (see \S\ref{sss:kinsol} and \S\ref{s:kinsol_out_constants}). The values of
  the optional outputs are available in \id{IOPT} and \id{ROPT}
  (see Table~\ref{t:fkinsol_out}).

%%====================
\item {\bf Memory deallocation}
%%====================

  To free the internal memory created by calls to \id{FKINCREATE},
  \id{FKININIT}, \id{FNVINIT*}, \id{FKINLSINIT}, and \id{FSUN***MATINIT}, make the call
  \index{FKINFREE@\texttt{FKINFREE}}
\begin{verbatim}
      CALL FKINFREE
\end{verbatim}

\end{Steps}
\index{FKINSOL@{\fkinsol} interface module!usage|)}


%%==============================================================================
\section{FKINSOL optional input and output}\label{fkin_opt_inout}
%%==============================================================================
\index{FKINSOL@{\fkinsol} interface module!optional input and output}

In order to keep the number of user-callable {\fkinsol} interface routines to
a minimum, optional inputs to the {\kinsol} solver are passed through only three
routines: \Id{FKINSETIIN} for integer optional inputs, \ID{FKINSETRIN} for real
optional inputs, and \ID{FKINSETVIN} for real vector (array) optional inputs.
These functions should be called as follows:
\begin{verbatim}
      CALL FKINSETIIN (KEY, IVAL, IER)
      CALL FKINSETRIN (KEY, RVAL, IER)
      CALL FKINSETVIN (KEY, VVAL, IER)
\end{verbatim}
where \id{KEY} is a quoted string indicating which optional input is set,
\id{IVAL} is the integer input value to be used,
\id{RVAL} is the real input value to be used, and
\id{VVAL} is the input real array to be used.
\id{IER} is an integer return flag which is set to $0$ on success and
a negative value if a failure occurred.
For the legal values of \id{KEY} in calls to \ID{FKINSETIIN} and \ID{FKINSETRIN},
see Table \ref{t:fkinsol_in}.  The one legal value of \id{KEY} for \ID{FKINSETVIN}
is \id{CONSTR\_VEC}, for providing the array of inequality constraints to be
imposed on the solution, if any.
The integer \id{IVAL} should be declared in a manner consistent with {\CC}
type \id{long int}.

The optional outputs from the {\kinsol} solver are accessed not through
individual functions, but rather through a pair of arrays, \Id{IOUT}
(integer type) of dimension at least $15$, and \Id{ROUT} (real type) of
dimension at least $2$.  These arrays are owned (and allocated) by the user
and are passed as arguments to \id{FKININIT}.
Table \ref{t:fkinsol_out} lists the entries in these two arrays and specifies the
optional variable as well as the {\kinsol} function which is actually called to
extract the optional output.

For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Keys for setting {\fkinsol} optional inputs}
\label{t:fkinsol_in}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer optional inputs \id{FKINSETIIN}}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{PRNT\_LEVEL}     & Verbosity level of output & $0$ \\
\Id{MAA}             & Number of prior residuals for Anderson Acceleration & 0 \\
\Id{MAX\_NITERS}     & Maximum no. of nonlinear iterations & $200$ \\
\Id{ETA\_FORM}       & Form of $\eta$ coefficient & $1$ (\id{KIN\_ETACHOICE1}) \\
\Id{MAX\_SETUPS}     & Maximum no. of iterations without prec. setup & $10$ \\
\Id{MAX\_SP\_SETUPS} & Maximum no. of iterations without residual check & $5$ \\
\Id{NO\_INIT\_SETUP} & No initial preconditioner setup & \id{SUNFALSE} \\
\Id{NO\_MIN\_EPS}    & Lower bound on $\epsilon$ & \id{SUNFALSE} \\
\Id{NO\_RES\_MON}    & No residual monitoring & \id{SUNFALSE} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real optional inputs (\id{FKINSETRIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\
\hline
\Id{FNORM\_TOL}   & Function-norm stopping tolerance & uround$^{1/3}$ \\
\Id{SSTEP\_TOL}   & Scaled-step stopping tolerance & uround$^{2/3}$ \\
\Id{MAX\_STEP}    & Max. scaled length of Newton step & $1000 \| D_u u_0 \|_2$ \\
\Id{RERR\_FUNC}   & Relative error for F.D. $Jv$ & $\sqrt{\text{uround}}$ \\
\Id{ETA\_CONST}   & Constant value of $\eta$ & $0.1$ \\
\Id{ETA\_PARAMS}  & Values of $\gamma$ and $\alpha$ & $0.9$ and $2.0$ \\
\Id{RMON\_CONST}  & Constant value of $\omega$ & $0.9$ \\
\Id{RMON\_PARAMS} & Values of $\omega_{min}$ and $\omega_{max}$ & $0.00001$ and $0.9$ \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Description of the {\fkinsol} optional output arrays \Id{IOUT} and \Id{ROUT}}
\label{t:fkinsol_out}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer output array \id{IOUT}} \\
\hline
{\bf Index} & {\bf Optional output} & {\kinsol} {\bf function} \\
\hline
\multicolumn{3}{|c|}{{\kinsol} main solver} \\
\hline
1  & \id{LENRW}  & \id{KINGetWorkSpace} \\
2  & \id{LENIW}  & \id{KINGetWorkSpace} \\
3  & \id{NNI}    & \id{KINGetNumNonlinSolvIters} \\
4  & \id{NFE}    & \id{KINGetNumFuncEvals} \\
5  & \id{NBCF}   & \id{KINGetNumBetaCondFails} \\
6  & \id{NBKTRK} & \id{KINGetNumBacktrackOps} \\
\hline
\multicolumn{3}{|c|}{{\kinls} linear solver interface}\\
\hline
7  & \id{LENRWLS}  & \id{KINGetLinWorkSpace} \\ 
8  & \id{LENIWLS}  & \id{KINGetLinWorkSpace} \\ 
9  & \id{LS\_FLAG} & \id{KINGetLastLinFlag} \\ 
10 & \id{NFELS}    & \id{KINGetNumLinFuncEvals} \\ 
11 & \id{NJE}      & \id{KINGetNumJacEvals} \\ 
12 & \id{NJTV}     & \id{KINGetNumJtimesEvals} \\
13 & \id{NPE}      & \id{KINGetNumPrecEvals} \\
14 & \id{NPS}      & \id{KINGetNumPrecSolves} \\
15 & \id{NLI}      & \id{KINGetNumLinIters} \\
16 & \id{NCFL}     & \id{KINGetNumLinConvFails} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real output array \id{ROUT}}\\
\hline
{\bf Index} & {\bf Optional output} & {\kinsol} {\bf function} \\ 
\hline
1  & \id{FNORM} & \id{KINGetFuncNorm} \\
2  & \id{SSTEP} & \id{KINGetStepLength} \\
\hline
\end{tabular}
\end{table}                                                                  


%%==============================================================================
\section{Usage of the FKINBBD interface to KINBBDPRE}
%%==============================================================================
\index{FKINBBD@{\fkinbbd} interface module!interface to the {\kinbbdpre} module|(}

The {\fkinbbd} interface sub-module is a package of {\CC} functions which,
as part of the {\fkinsol} interface module, support the use of the
{\kinsol} solver with the parallel {\nvecp} module and the {\kinbbdpre} 
preconditioner module (see \S\ref{sss:kinbbdpre}), for the solution of 
nonlinear problems in a mixed {\F}/{\CC} setting.  

The user-callable functions in this package, with the corresponding
{\kinsol} and {\kinbbdpre} functions, are as follows: 
\begin{itemize}
\item \id{FKINBBDINIT}
  interfaces to \id{KINBBDPrecInit}.
\item \id{FKINBBDOPT}
  interfaces to {\kinbbdpre} optional output functions.
\end{itemize}

In addition to the {\F} right-hand side function \id{FKFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\kinbbdpre} or {\kinsol}):
\begin{center}
\begin{tabular}{l||l|l}
{\fkinbbd} routine     &  {\kinsol} function & {\kinsol} type of \\
({\F}, user-supplied)  &  ({\CC}, interface) & interface function \\ \hline\hline
\id{FKLOCFN}           & \id{FKINgloc}       & \id{KINBBDLocalFn} \\
\id{FKCOMMF}           & \id{FKINgcomm}      & \id{KINBBDCommFn} \\
\id{FKJTIMES}          & \id{FKINJtimes}     & \id{KINLsJacTimesVecFn} \\
\end{tabular}
\end{center}
As with the rest of the {\fkinsol} routines, the names of all user-supplied routines
here are fixed, in order to maximize portability for the resulting mixed-language
program. Additionally, based on flags discussed above in \S\ref{sss:fkinroutines},
the names of the user-supplied routines are mapped to actual values through a
series of definitions in the header file \id{fkinbbd.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fkinsol_usage} are grayed-out.

\index{User main program!FKINBBD@{\fkinbbd} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Nonlinear system function specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item {\bf {\sunlinsol} module initialization}

  Initialize one of the iterative {\sunlinsol} modules, by calling one
  of \id{FSUNPCGINIT}, \id{FSUNSPBCGSINIT}, \id{FSUNSPFGMRINIT},
  \id{FSUNSPGMRINIT} or \id{FSUNSPTFQMRINIT}.

\item \textcolor{gray}{\bf Problem specification}

\item \textcolor{gray}{\bf Set optional inputs}

\item \textcolor{gray}{\bf Solver Initialization}

\item {\bf Linear solver interface specification}

  Initialize the {\kinls} iterative linear solver interface
  by calling \id{FKINLSINIT}.

  To initialize the {\kinbbdpre} preconditioner, make the following call:
  \index{FKINBBDINIT@\texttt{FKINBBDINIT}}
\begin{verbatim}
      CALL FKINBBDINIT (NLOCAL, MUDQ, MLDQ, MU, ML, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors for this process.
  \id{MUDQ} and \id{MLDQ} are the upper and lower half-bandwidths to be used
  in the computation of the local Jacobian blocks by difference quotients;
  these may be smaller than the true half-bandwidths of the Jacobian of the
  local block of $G$, when smaller values may provide greater efficiency.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band
  matrix that is retained as an approximation of the local Jacobian block;
  these may be smaller than \id{MUDQ} and \id{MLDQ}.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.

  Optionally, to specify that the {\spgmr}, {\spfgmr}, {\spbcg}, or {\sptfqmr} solver should use
  the supplied \id{FKJTIMES}, make the call
  \index{FKINLSSETJAC@\texttt{FKINLSSETJAC}}
\begin{verbatim}
      CALL FKINLSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.
  (See step \ref{i:fkinsol_lin_solv_spec} in \S\ref{ss:fkinsol_usage}).

\item \textcolor{gray}{\bf Problem solution}

\item {\bf {\kinbbdpre} Optional outputs}

  Optional outputs specific to the {\spgmr}, {\spfgmr}, {\spbcg}, or {\sptfqmr} solver are
  listed in Table \ref{t:fkinsol_out}.
  To obtain the optional outputs associated with the {\kinbbdpre} module, make
  the following call:
  \index{FKINBBDOPT@\texttt{FKINBBDOPT}}
\begin{verbatim}
      CALL FKINBBDOPT (LENRBBD, LENIBBD, NGEBBD)
\end{verbatim}
  The arguments should be consistent with {\CC} type \id{long int}.  Their
  returned values are as follows:
  \id{LENRBBD} is the length of real preconditioner work space, in \id{realtype}
  words. \id{LENIBBD} is the length of integer preconditioner work space, in
  integer words. These sizes are local to the current process.
  \id{NGEBBD} is the cumulative number of $G(u)$ evaluations (calls to \id{FKLOCFN})
  so far.
  
\item \textcolor{gray}{\bf Memory deallocation}

  (The memory allocated for the {\fkinbbd} module is deallocated automatically
  by \id{FKINFREE}.)
\index{FKINSOL@{\fkinsol} interface module!interface to the {\kinbbdpre} module|)}

\item {\bf User-supplied routines}

  The following two routines must be supplied for use with the {\kinbbdpre}
  module:
  \index{FKLOCFN@\texttt{FKLOCFN}}
\begin{verbatim}
      SUBROUTINE FKLOCFN (NLOC, ULOC, GLOC, IER)
      DIMENSION ULOC(*), GLOC(*)
\end{verbatim}
  This routine is to evaluate the function $G(u)$ approximating $F$
  (possibly identical to $F$), in terms of the array
  \id{ULOC} (of length \id{NLOC}), which is the sub-vector
  of $u$ local to this processor.  The resulting (local) sub-vector
  is to be stored in the array \id{GLOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol} will
  attempt to correct), or a negative value if \id{FKLOCFN} failed unrecoverably
  (in which case the solution process is halted).

  \index{FKCOMMFN@\texttt{FKCOMMFN}}
\begin{verbatim}
      SUBROUTINE FKCOMMFN (NLOC, ULOC, IER)
      DIMENSION ULOC(*)
\end{verbatim}
  This routine is to perform the inter-processor communication necessary
  for the \id{FKLOCFN} routine.
  Each call to \id{FKCOMMFN} is preceded by a call to the system function
  routine \id{FKFUN} with the same argument \id{ULOC}.
  \id{IER} is an error return flag which should be set to $0$ if successful,
  a positive value if a recoverable error occurred (in which case {\kinsol} will
  attempt to correct), or a negative value if \id{FKCOMMFN} failed recoverably
  (in which case the solution process is halted).

  {\warn}The subroutine \id{FKCOMMFN} must be supplied even if it is not needed
  and must return \id{IER = 0}.

  \index{FKINJTIMES@\texttt{FKINJTIMES}}
  \index{FKINJTSETUP@\texttt{FKINJTSETUP}}
  Optionally, the user can supply a routine \id{FKINJTIMES} for the evaluation of
  Jacobian-vector products, as described above in step \ref{i:fkinsol_lin_solv_spec}
  in \S\ref{ss:fkinsol_usage}.  Note that this routine is required if using
  Picard iteration.

\end{Steps}

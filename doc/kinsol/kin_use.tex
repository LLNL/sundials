%===================================================================================
\chapter{Using KINSOL for C Applications}\label{c:usage}
%===================================================================================

This chapter is concerned with the use of {\kinsol} for the solution
of nonlinear systems. The following subsections treat the header
files, the layout of the user's main program, description of the
{\kinsol} user-callable routines, and user-supplied functions.
The sample programs described in the companion document
\cite{kinsol_ex} may also be helpful.  Those codes may be used as
templates (with the removal of some lines involved in testing), and
are included in the {\kinsol} package.

Users with applications written in {\F} should see Chapter \ref{s:fcmix},
which describes the {\F}/{\CC} interface module.

The user should be aware that not all {\sunlinsol} and {\sunmatrix}
modules are compatible with all {\nvector} implementations.
\index{KINSOL@{\kinsol} linear solvers!NVECTOR@{\nvector} compatibility}
Details on compatability are given in the documentation for each
{\sunmatrix} module (Chapter \ref{s:sunmatrix}) and each {\sunlinsol}
module (Chapter \ref{s:sunlinsol}). For example, {\nvecp} is not
compatible with the dense, banded, or sparse {\sunmatrix} types, or with
the corresponding dense, banded, or sparse {\sunlinsol} modules.  Please
check Chapters \ref{s:sunmatrix} and \ref{s:sunlinsol} to verify
compatability between these modules.  In addition to that
documentation, we note that the preconditioner module {\kinbbdpre}
can only be used with {\nvecp}.
It is not recommended to use a threaded vector module with SuperLU\_MT
unless it is the {\nvecopenmp} module, and SuperLU\_MT is also compiled
with OpenMP.

{\kinsol} uses various constants for both input and output. These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

%%==============================================================================
\section{Access to library and header files}\label{ss:file_access}
%%==============================================================================

At this point, it is assumed that the installation of {\kinsol},
following the procedure described in Appendix \ref{c:install}, has
been completed successfully.

Regardless of where the user's application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
{\kinsol}.  The relevant library files are
\begin{itemize}
\item {\em libdir}\id{/libsundials\_kinsol.}{\em lib},
\item {\em libdir}\id{/libsundials\_nvec*.}{\em lib} (one to four files),
\end{itemize}
where the file extension .{\em lib} is typically \id{.so} for shared libraries
and \id{.a} for static libraries. The relevant header files are located in
the subdirectories
\begin{itemize}
\item {\em incdir}\id{/include/kinsol}
\item {\em incdir}\id{/include/sundials}
\item {\em incdir}\id{/include/nvector}
\item {\em incdir}\id{/include/sunmatrix}
\item {\em incdir}\id{/include/sunlinsol}
\end{itemize}
The directories {\em libdir} and {\em incdir} are the install library
and include directories, respectively.  For a default installation,
these are {\em builddir}\id{/lib} and {\em builddir}\id{/include},
respectively, where {\em builddir} was defined in Appendix \ref{c:install}.

%%----------------------------------
\section{Data types}\label{s:types}
%%----------------------------------
\input{types}

%------------------------
\section{Header files}\label{s:header_sol}
%------------------------
\index{header files}
The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%
\begin{itemize}
\item  \Id{kinsol/kinsol.h},
  the header file for {\kinsol}, which defines several
  types and various constants, and includes function prototypes.  This
  includes the header file for {\kinls}, \Id{kinsol/kinsol\_ls.h}.
\end{itemize}
%
\id{kinsol.h} also includes \Id{sundials\_types.h},
which defines the types \id{realtype}, \id{sunindextype}, and \id{booleantype}
and constants \id{SUNFALSE} and \id{SUNTRUE}.

The calling program must also include an {\nvector} implementation header file,
of the form \id{nvector/nvector\_***.h}.  See Chapter \ref{s:nvector} for the appropriate
name.  This file in turn includes the header file \Id{sundials\_nvector.h}
which defines the abstract \Id{N\_Vector} data type.

If using a Newton or Picard nonlinear solver that requires the
solution of a linear system, then a linear solver module header file
will be required.
\index{KINSOL@{\kinsol} linear solvers!header files}
The header files corresponding to the various {\sundials}-provided
linear solver modules available for use with {\kinsol} are:
%%
\begin{itemize}
\item Direct linear solvers:
  \begin{itemize}
  \item \Id{sunlinsol/sunlinsol\_dense.h},
    which is used with the dense linear solver module,
    {\sunlinsoldense};

  \item \Id{sunlinsol/sunlinsol\_band.h},
    which is used with the banded linear solver module,
    {\sunlinsolband};

  \item \Id{sunlinsol/sunlinsol\_lapackdense.h},
    which is used with the LAPACK package dense linear solver module,
    {\sunlinsollapdense};

  \item \Id{sunlinsol/sunlinsol\_lapackband.h},
    which is used with the LAPACK package banded linear solver module,
    {\sunlinsollapband};

  \item \Id{sunlinsol/sunlinsol\_klu.h},
    which is used with the {\klu} sparse linear solver module,
    {\sunlinsolklu};

  \item \Id{sunlinsol/sunlinsol\_superlumt.h},
    which is used with the {\superlumt} sparse linear solver
    module, {\sunlinsolslumt};
  \end{itemize}

\item Iterative linear solvers:
  \begin{itemize}
  \item \Id{sunlinsol/sunlinsol\_spgmr.h},
   which is used with the scaled, preconditioned GMRES Krylov linear
    solver module, {\sunlinsolspgmr};

  \item \Id{sunlinsol/sunlinsol\_spfgmr.h},
    which is used with the scaled, preconditioned FGMRES Krylov linear
    solver module, {\sunlinsolspfgmr};

  \item \Id{sunlinsol/sunlinsol\_spbcgs.h},
    which is used with the scaled, preconditioned Bi-CGStab Krylov
    linear solver module, {\sunlinsolspbcgs};

  \item \Id{sunlinsol/sunlinsol\_sptfqmr.h},
    which is used with the scaled, preconditioned TFQMR Krylov linear
    solver module, {\sunlinsolsptfqmr};

  \item \Id{sunlinsol/sunlinsol\_pcg.h},
    which is used with the scaled, preconditioned CG Krylov linear
    solver module, {\sunlinsolpcg};
  \end{itemize}
\end{itemize}

The header files for the {\sunlinsoldense} and {\sunlinsollapdense}
linear solver modules include the file
\id{sunmatrix/sunmatrix\_dense.h}, which defines the {\sunmatdense}
matrix module, as as well as various functions and macros acting on
such matrices.

The header files for the {\sunlinsolband} and {\sunlinsollapband}
linear solver modules include the file
\id{sunmatrix/sunmatrix\_band.h}, which defines the {\sunmatband}
matrix module, as as well as various functions and macros acting on
such matrices.

The header files for the {\sunlinsolklu} and {\sunlinsolslumt}
sparse linear solvers include the file
\id{sunmatrix/sunmatrix\_sparse.h}, which defines the {\sunmatsparse}
matrix module, as well as various functions and macros acting on such
matrices.

The header files for the Krylov iterative solvers include the file
\id{sundials/sundials\_iterative.h}, which enumerates the kind of
preconditioning, and (for the {\spgmr} and {\spfgmr} solvers) the
choices for the Gram-Schmidt process.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, in the \id{kinFoodWeb\_kry\_p}
example (see \cite{kinsol_ex}), preconditioning is done with a
block-diagonal matrix. For this, even though the {\sunlinsolspgmr} linear
solver is used, the header \id{sundials/sundials\_dense.h} is included for
access to the underlying generic dense matrix arithmetic routines.

%--------------------------------------------------------------------
\section{A skeleton of the user's main program}\label{ss:skeleton_sol}
%--------------------------------------------------------------------

The following is a skeleton of the user's main program (or calling
program) for the solution of a nonlinear system problem.
Most of the steps are independent of the {\nvector}, {\sunmatrix}, and {\sunlinsol}
implementations used.
For the steps that are not, refer to Chapter \ref{s:nvector},
\ref{s:sunmatrix}, and \ref{s:sunlinsol}  for the
specific name of the function to be called or macro to be referenced.
%%
\index{User main program!KINSOL@{\kinsol} usage}
\begin{Steps}

\item
  {\bf Initialize parallel or multi-threaded environment, if appropriate}

  For example, call \id{MPI\_Init} to initialize {\mpi} if used, or
  set \id{num\_threads}, the number of threads to use within the threaded
  vector functions, if used.

\item
  {\bf Set problem dimensions etc.}

  This generally includes the problem size \id{N}, and may include
  the local vector length \id{Nlocal}.

  Note: The variables \id{N} and \id{Nlocal} should be of type \id{sunindextype}.

\item
  {\bf Set vector with initial guess}

  To set the vector \id{u} of initial guess values, use the appropriate
  functions defined by the particular {\nvector} implementation.

  For native {\sundials} vector implementations
  (except the {\cuda} and {\raja}-based ones), use a call
  of the form \id{u = N\_VMake\_***(..., udata)} if the \id{realtype} array
  \id{udata} containing the initial values of $u$ already exists.
  Otherwise, create a new vector by making a call of the form
  \id{u = N\_VNew\_***(...)}, and then set its elements by accessing
  the underlying data with a call of the form
  \id{ ydata = N\_VGetArrayPointer(u)}.
  See \S\ref{ss:nvec_ser}-\ref{ss:nvec_pthreads} for details.

  For the {\hypre} and {\petsc} vector wrappers, first create and initialize
  the underlying vector and then create an {\nvector} wrapper with a call
  of the form \id{u = N\_VMake\_***(uvec)}, where \id{uvec} is a {\hypre}
  or {\petsc} vector. Note that calls like \id{N\_VNew\_***(...)} and
  \id{N\_VGetArrayPointer(...)} are not available for these vector wrappers.
  See \S\ref{ss:nvec_parhyp} and \S\ref{ss:nvec_petsc} for details.

  If using either the {\cuda}- or {\raja}-based vector implementations
  use a call of the form
  \id{u = N\_VMake\_***(..., c)} where \id{c} is a pointer to a \id{suncudavec}
  or \id{sunrajavec} vector class if this class already exists.  Otherwise,
  create a new vector
  by making a call of the form \id{u = N\_VNew\_***(...)}, and then set its
  elements by accessing the underlying data where it is located
  with a call of the form
  \id{N\_VGetDeviceArrayPointer\_***} or \id{N\_VGetHostArrayPointer\_***}.
  Note that the vector class will allocate memory on both the host and device
  when instantiated.  See \S\ref{ss:nvec_cuda}-\ref{ss:nvec_raja} for details.

%   If a \id{realtype} array \id{udata} containing the initial values of $u$
%   already exists, it may be possible to do this either with a call of the form
%   \id{u = N\_VMake\_***(..., udata);}
%   or by making a call of the form
%   \id{u = N\_VNew\_***(...);}
%   and loading values into the structure defined by \id{NV\_DATA\_***(u)},
%   provided these functions and macro exist for the {\nvector} module chosen.

\item\label{i:kinsol_create}
  {\bf Create {\kinsol} object}

  Call \id{kin\_mem = KINCreate()} to create the {\kinsol} memory block.
  \id{KINCreate} returns a pointer to the {\kinsol} memory structure.
  See \S\ref{sss:kinmalloc} for details.

\item\label{i:kinsol_malloc}
  {\bf Allocate internal memory}

  Call \id{KINInit(...)}
  to specify the problem defining function $F$,
  allocate internal memory for {\kinsol},
  and initialize {\kinsol}.
  \id{KINInit} returns a flag to indicate success or an illegal argument value.
  See \S\ref{sss:kinmalloc} for details.

\item\label{i:matrix}
  {\bf Create matrix object}

  If a matrix-based linear solver is to be used within a Newton or Picard iteration,
  then a template Jacobian matrix must be created by using the
  appropriate functions defined by the particular {\sunmatrix}
  implementation.

  For the {\sundials}-supplied {\sunmatrix} implementations, the
  matrix object may be created using a call of the form

  \id{SUNMatrix J = }\Id{SUNBandMatrix}\id{(...);}

   or

  \id{SUNMatrix J = }\Id{SUNDenseMatrix}\id{(...);}

   or

  \id{SUNMatrix J = }\Id{SUNSparseMatrix}\id{(...);}

  NOTE: The dense, banded, and sparse matrix objects are usable only in a
  serial or threaded environment.

\item\label{i:lin_solver}
  {\bf Create linear solver object}

  If a Newton or Picard iteration is chosen, then the desired linear solver
  object must be created by using the appropriate functions defined by
  the particular {\sunlinsol} implementation.

  For any of the {\sundials}-supplied {\sunlinsol} implementations,
  the linear solver object may be created using a call of the form

  \id{SUNLinearSolver LS = SUNLinSol\_*(...);}

  where \id{*} can be replaced with ``Dense'', ``SPGMR'', or other
  options, as discussed in \S\ref{sss:lin_solv_init} and Chapter {\ref{s:sunlinsol}}.

\item
  {\bf Set linear solver optional inputs}

  Call \id{*Set*} functions from the selected linear solver module
  to change optional inputs specific to that linear solver.
  See the documentation for each {\sunlinsol} module in Chapter
  {\ref{s:sunlinsol}} for details.

\item\label{i:lin_solver_interface}
  {\bf Attach linear solver module}

  If a Newton or Picard iteration is chosen, initialize the {\kinls}
  linear solver interface by attaching the linear solver object (and
  matrix object, if applicable) with one of the following calls (for
  details see \S\ref{sss:lin_solv_init}):

  \id{ier = }\Id{KINSetLinearSolver}\id{(...);}

\item
  {\bf Set optional inputs}

  Call \id{KINSet*} routines to change from their default values any
  optional inputs that control the behavior of {\kinsol}.
  See \S\ref{ss:optional_input} for details.

\item
  {\bf Solve problem}

  Call \id{ier = }\Id{KINSol}\id{(...)} to solve the nonlinear problem for a given
  initial guess. See \S\ref{sss:kinsol} for details.

\item
  {\bf Get optional outputs}

  Call \id{KINGet*} functions to obtain optional output.
  See \S\ref{ss:optional_output} for details.

\item
  {\bf Deallocate memory for solution vector}

  Upon completion of the solution, deallocate memory for the vector \id{u} by
  calling the appropriate destructor function defined by the {\nvector} implementation:

  \id{N\_VDestroy(u);}

\item
  {\bf Free solver memory}

  Call \id{KINFree(\&kin\_mem)} to free the memory allocated for {\kinsol}.

\item
  {\bf Free linear solver and matrix memory}

  Call \Id{SUNLinSolFree} and \ID{SUNMatDestroy} to free any memory
  allocated for the linear solver and matrix objects created above.

\item
  {\bf Finalize MPI, if used}

  Call \id{MPI\_Finalize()} to terminate {\mpi}.

\end{Steps}

\input{linear-vector-table}

%%==============================================================================

\section{User-callable functions}\label{s:kinsol_fct_sol}

This section describes the {\kinsol} functions that are called by the
user to set up and solve a nonlinear problem. Some of these are required.
However, starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs can be
skipped for a casual use of {\kinsol}. In any case, refer to
\S\ref{ss:skeleton_sol} for the correct order of these calls.

The return flag (when present) for each of these routines is a
negative integer if an error occurred, and non-negative otherwise.

%%-------------------------------------------------------------------------------

\subsection{KINSOL initialization and deallocation functions}
\label{sss:kinmalloc}

The following three functions must be called in the order listed. The last one
is to be called only after the problem solution is complete, as it frees the
{\kinsol} memory block created and allocated by the first two calls.
%%
\ucfunction{KINCreate}
{
  kin\_mem = KINCreate();
}
{
  The function \ID{KINCreate} instantiates a {\kinsol} solver object.
}
{
  This function has no arguments.
}
{
  If successful, \id{KINCreate} returns a pointer to the newly created
  {\kinsol} memory block (of type \id{void *}).
  If an error occurred, \id{KINCreate} prints an error message to \id{stderr}
  and returns \id{NULL}.
}
{}
%%
%%
\ucfunction{KINInit}
{
flag = KINInit(kin\_mem, func, tmpl);
}
{
  The function \ID{KINInit} specifies the problem-defining
  function, allocates internal memory, and initializes {\kinsol}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block returned by \id{KINCreate}.
  \item[func] (\Id{KINSysFn})
    is the {\CC} function which computes the system function $F$
    (or $G(u)$ for fixed-point iteration) in the nonlinear
    problem.  This function has the form \id{func(u, fval, user\_data)}.
    (For full details see \S\ref{ss:sysFn}.)
  \item[tmpl] (\id{N\_Vector})
    is any \id{N\_Vector} (e.g. the initial guess vector \id{u}) which is used
    as a template to create (by cloning) necessary vectors in \id{kin\_mem}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The call to \id{KINInit} was successful.
  \item[\Id{KIN\_MEM\_NULL}]
    The {\kinsol} memory block was not initialized through a previous call
    to \id{KINCreate}.
  \item[\Id{KIN\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{KIN\_ILL\_INPUT}]
    An input argument to \id{KINInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{KINInit} sends an error message to the
  error handler function.
}
%%
%%
\ucfunction{KINFree}
{
  KINFree(\&kin\_mem);
}
{
  The function \ID{KINFree} frees the memory allocated by
  a previous call to \id{KINCreate}.
}
{
  The argument is the address of the pointer to the {\kinsol} memory block
  returned by \id{KINCreate} (of type \id{void *}).
}
{
  The function \id{KINFree} has no return value.
}
{}
%%

%%-------------------------------------------------------------------------------

\subsection{Linear solver specification function}\label{sss:lin_solv_init}

As previously explained, Newton and Picard iterations require the solution of
linear systems of the form $J\delta = -F$. Solution of these linear
systems is handled using the {\kinls} linear solver interface.  This
interface supports all valid {\sunlinsol} modules.  Here, matrix-based
{\sunlinsol} modules utilize {\sunmatrix} objects to store the
Jacobian matrix $J = \partial{F}/\partial{u}$ and factorizations used
throughout the solution process.  Conversely, matrix-free {\sunlinsol}
modules instead use iterative methods to solve the linear systems of
equations, and only require the \emph{action} of the Jacobian on a
vector, $Jv$.

With most iterative linear solvers, preconditioning can be done on the
left only, on the right only, on both the left and the right, or not
at all.  However, only right preconditioning is supported within
{\kinls}.  If preconditioning is done, user-supplied
functions define the linear operator corresponding to a right
preconditioner matrix $P$, which should approximate the system
Jacobian matrix $J$.  For the specification of a preconditioner, see
the iterative linear solver sections in \S\ref{ss:optional_input} and
\S\ref{ss:user_fct_sol}. A preconditioner matrix $P$ must approximate
the Jacobian $J$, at least crudely.

\index{KINSOL{\kinsol} linear solvers!selecting one|(}
To specify a generic linear solver to {\kinsol}, after the call to
\id{KINCreate} but before any calls to \id{KINSol}, the user's
program must create the appropriate {\sunlinsol} object and call
the function \Id{KINSetLinearSolver}, as documented below.
To create the \id{SUNLinearSolver} object, the user may call one of
the {\sundials}-packaged {\sunlinsol} module constructor routines via
a call of the form

\begin{verbatim}
      SUNLinearSolver LS = SUNLinSol_*(...);
\end{verbatim}

The current list of such constructor routines includes
\Id{SUNLinSol\_Dense},
\Id{SUNLinSol\_Band},
\Id{SUNLinSol\_LapackDense},
\Id{SUNLinSol\_LapackBand},
\Id{SUNLinSol\_KLU},
\Id{SUNLinSol\_SuperLUMT},
\Id{SUNLinSol\_SPGMR},
\Id{SUNLinSol\_SPFGMR},
\Id{SUNLinSol\_SPBCGS},
\Id{SUNLinSol\_SPTFQMR}, and
\Id{SUNLinSol\_PCG}.

Alternately, a user-supplied
\id{SUNLinearSolver} module may be created and used instead.  The use
of each of the generic linear solvers involves certain constants,
functions and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific {\sunmatrix} or {\sunlinsol} module in
question, as described in Chapters \ref{s:sunmatrix} and
\ref{s:sunlinsol}.

Once this solver object has been constructed, the user should attach
it to {\kinsol} via a call to \Id{KINSetLinearSolver}.  The first
argument passed to this function is the {\kinsol} memory pointer
returned by \id{KINCreate}; the second argument is the desired
{\sunlinsol} object to use for solving Newton or Picard systems.  The
third argument is an optional {\sunmatrix} object to accompany
matrix-based {\sunlinsol} inputs (for matrix-free linear solvers, the
third argument should be \id{NULL}).  A call to this function
initializes the {\kinls} linear solver interface, linking it to the
main {\kinsol} solver, and allows the user to specify additional
parameters and routines pertinent to their choice of linear solver.
%%
\index{KINSOL@{\kinsol} linear solvers!selecting one|)}
\index{KINSOL@{\kinsol} linear solver interface!KINLS@{\kinls}}
\ucfunction{KINSetLinearSolver}
{
  flag = KINSetLinearSolver(kin\_mem, LS, J);
}
{
  The function \ID{KINSetLinearSolver} attaches a generic {\sunlinsol}
  object \id{LS} and corresponding template Jacobian {\sunmatrix}
  object \id{J} (if applicable) to {\kinsol}, initializing the
  {\kinls} linear solver interface.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[LS] (\id{SUNLinearSolver})
    {\sunlinsol} object to use for solving Newton linear systems.
  \item[J] (\id{SUNMatrix})
    {\sunmatrix} object for used as a template for the Jacobian (or
    \id{NULL} if not applicable).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}
  [KINLS\_ILL\_INPUT]
  \item[\Id{KINLS\_SUCCESS}]
    The {\kinls} initialization was successful.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_ILL\_INPUT}]
    The {\kinls} interface is not compatible with the \id{LS} or
    \id{J} input objects or is incompatible with the current
    {\nvector} module.
  \item[\Id{KINLS\_SUNLS\_FAIL}]
    A call to the \id{LS} object failed.
  \item[\Id{KINLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  If \id{LS} is a matrix-based linear solver, then the template
  Jacobian matrix \id{J} will be used in the solve process, so if
  additional storage is required within the {\sunmatrix} object
  (e.g. for factorization of a banded matrix), ensure that the input
  object is allocated with sufficient size (see the documentation of
  the particular {\sunmatrix} type in Chapter \ref{s:sunmatrix} for
  further information).

  The previous routines \Id{KINDlsSetLinearSolver} and
  \Id{KINSpilsSetLinearSolver} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
%%

%--------------------------------------------------------------------
\subsection{KINSOL solver function}\label{sss:kinsol}
%--------------------------------------------------------------------

This is the central step in the solution process, the call to solve
the nonlinear algebraic system.
%
\ucfunction{KINSol}
{
  flag = KINSol(kin\_mem, u, strategy, u\_scale, f\_scale);
}
{
  The function \ID{KINSol} computes an approximate solution to the nonlinear
  system.
}
{
  \begin{args}[strategy]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[u] (\id{N\_Vector})
    vector set to initial guess by user before calling \id{KINSol},
    but which upon return contains an approximate solution of
    the nonlinear system $F(u) = 0$.
  \item[strategy] (\id{int})
    strategy used to solve the nonlinear system. It must be of the following: \\
    \ID{KIN\_NONE}  basic Newton iteration \\
    \ID{KIN\_LINESEARCH} Newton with globalization \\
    \ID{KIN\_FP} fixed-point iteration with Anderson Acceleration
                 (no linear solver needed)\\
    \ID{KIN\_PICARD} Picard iteration with Anderson Acceleration
                     (uses a linear solver)\\
  \item[u\_scale] (\id{N\_Vector})
    vector containing diagonal elements of scaling matrix $D_u$ for vector \id{u}
    chosen so that the components of $D_u \cdot$\id{u}
    (as a matrix multiplication) all have roughly the same magnitude when
    \id{u} is close to a root of $F(u)$.
  \item[f\_scale] (\id{N\_Vector})
    vector containing diagonal elements of scaling matrix $D_F$ for $F(u)$ chosen
    so that the components of $D_F \cdot F($\id{u}$)$
    (as a matrix multiplication) all have roughly the same magnitude when
    \id{u} is not too near a root of $F(u)$. In the case of a fixed-point
    iteration, consider $F(u) = G(u) - u$.
  \end{args}
}
{
  On return, \id{KINSol} returns the approximate solution in the vector \id{u}
  if successful.  The return value \id{flag} (of type \id{int}) will be one of
  the following:
  \begin{args}[a]

  \item[\Id{KIN\_SUCCESS}]\rule{0pt}{0pt}

    \id{KINSol} succeeded; the scaled norm of $F(u)$ is less than \id{fnormtol}.

  \item[\Id{KIN\_INITIAL\_GUESS\_OK}]\rule{0pt}{0pt}

    The guess \id{u} $=u_0$ satisfied the system $F(u)=0$
    within the tolerances specified (the scaled norm of $F(u_0)$ is less than
    0.01*\id{fnormtol}).

  \item[\Id{KIN\_STEP\_LT\_STPTOL}]\rule{0pt}{0pt}

    {\kinsol} stopped based on scaled step length.
    This means that the current iterate may be an approximate solution of the given
    nonlinear system, but it is also quite possible that the algorithm is ``stalled"
    (making insufficient progress) near an invalid solution, or that the
    scalar \id{scsteptol} is too large (see \id{KINSetScaledStepTol} in
    \S\ref{ss:optional_input} to change \id{scsteptol} from its default value).

  \item[\Id{KIN\_MEM\_NULL}]\rule{0pt}{0pt}

    The {\kinsol} memory block pointer was \id{NULL}.

  \item[\Id{KIN\_ILL\_INPUT}]\rule{0pt}{0pt}

    An input parameter was invalid.

  \item[\Id{KIN\_NO\_MALLOC}]\rule{0pt}{0pt}

    The {\kinsol} memory was not allocated by a call to \id{KINCreate}.

  \item[\Id{KIN\_MEM\_FAIL}]\rule{0pt}{0pt}

    A memory allocation failed.

  \item[\Id{KIN\_LINESEARCH\_NONCONV}]\rule{0pt}{0pt}

    The line search algorithm was unable to find an iterate sufficiently distinct
    from the current iterate, or could not find an iterate satisfying
    the sufficient decrease condition.

    Failure to satisfy the sufficient decrease condition could mean the current
    iterate is ``close" to an approximate solution of the given nonlinear system,
    the difference approximation of the matrix-vector product $J(u) v$ is inaccurate,
    or the real scalar \id{scsteptol} is too large.

  \item[\Id{KIN\_MAXITER\_REACHED}] \rule{0pt}{0pt}

    The maximum number of nonlinear iterations has been reached.

  \item[\Id{KIN\_MXNEWT\_5X\_EXCEEDED}]\rule{0pt}{0pt}

    Five consecutive steps have been taken that satisfy the inequality
    $\|D_u p\|_{L2} > 0.99 \,$ \id{mxnewtstep}, where $p$ denotes the current step
    and \id{mxnewtstep} is a scalar upper bound on the scaled step length.
    Such a failure may mean that $\|D_F F(u)\|_{L2}$ asymptotes from above to a
    positive value, or the real scalar \id{mxnewtstep} is too small.

  \item[\Id{KIN\_LINESEARCH\_BCFAIL}]\rule{0pt}{0pt}

    The line search algorithm was unable to satisfy the ``beta-condition'' for
    \id{MXNBCF} $+ 1$ nonlinear iterations (not necessarily consecutive),
    which may indicate the algorithm is making poor progress.

  \item[\Id{KIN\_LINSOLV\_NO\_RECOVERY}]\rule{0pt}{0pt}

    The user-supplied routine \id{psolve} encountered a recoverable error, but
    the preconditioner is already current.

  \item[\Id{KIN\_LINIT\_FAIL}]\rule{0pt}{0pt}

    The {\kinls} initialization routine (\id{linit}) encountered an error.

  \item[\Id{KIN\_LSETUP\_FAIL}]\rule{0pt}{0pt}

    The {\kinls} setup routine (\id{lsetup}) encountered an error;
    e.g., the user-supplied routine \id{pset} (used to set up the
    preconditioner data) encountered an unrecoverable error.

  \item[\Id{KIN\_LSOLVE\_FAIL}]\rule{0pt}{0pt}

    The {\kinls} solve routine (\id{lsolve}) encountered an error;
    e.g., the user-supplied routine \id{psolve} (used to to solve the preconditioned
    linear system) encountered an unrecoverable error.

  \item[\Id{KIN\_SYSFUNC\_FAIL}]\rule{0pt}{0pt}

    The system function failed in an unrecoverable manner.

  \item[\Id{KIN\_FIRST\_SYSFUNC\_ERR}]\rule{0pt}{0pt}

    The system function failed recoverably at the first call.

  \item[\Id{KIN\_REPTD\_SYSFUNC\_ERR}]\rule{0pt}{0pt}

    The system function had repeated recoverable errors. No recovery is possible.


  \end{args}
}
{
  The components of vectors \id{u\_scale} and \id{f\_scale} should be strictly positive.

  \id{KIN\_SUCCESS} $=0$, \id{KIN\_INITIAL\_GUESS\_OK} $=1$, and
  \id{KIN\_STEP\_LT\_STPTOL} $=2$.
  %%
  All remaining return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{KINSol} failures.
}


%%==============================================================================
\subsection{Optional input functions}\label{ss:optional_input}
%%==============================================================================

There are numerous optional input parameters that control the behavior
of the {\kinsol} solver.  {\kinsol} provides functions that can be used
to change these from their default values.  Table \ref{t:optional_input}
lists all optional input functions in {\kinsol} which are then
described in detail in the remainder of this section, beginning with
those for the main {\kinsol} solver and continuing with those for the
{\kinls} linear solver interface. For the most casual use of {\kinsol}, the
reader can skip to \S\ref{ss:user_fct_sol}.

We note that, on error return, all of these functions also send an error message
to the error handler function.\index{error messages}
We also note that all error return values are negative, so a test \id{flag} $<0$
will catch any error.

\begin{table}
\centering
\caption{Optional inputs for {\kinsol} and {\kinls}}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf KINSOL main solver} \\
\hline
Error handler function & \id{KINSetErrHandlerFn} & internal fn. \\
Pointer to an error file & \id{KINSetErrFile} & \id{stderr}  \\
Info handler function & \id{KINSetInfoHandlerFn} & internal fn. \\
Pointer to an info file & \id{KINSetInfoFile} & \id{stdout} \\
Data for problem-defining function & \id{KINSetUserData} & \id{NULL} \\
Verbosity level of output & \id{KINSetPrintLevel} & 0 \\
Max. number of nonlinear iterations & \id{KINSetNumMaxIters} & 200 \\
No initial matrix setup & \id{KINSetNoInitSetup} & \id{SUNFALSE} \\
No residual monitoring${}^{*}$ & \id{KINSetNoResMon} & \id{SUNFALSE} \\
Max. iterations without matrix setup & \id{KINSetMaxSetupCalls} & 10 \\
Max. iterations without residual check${}^{*}$ & \id{KINSetMaxSubSetupCalls} & 5 \\
Form of $\eta$ coefficient & \id{KINSetEtaForm} &  \id{KIN\_ETACHOICE1}\\
Constant value of $\eta$ & \id{KINSetEtaConstValue} &  0.1 \\
Values of $\gamma$ and $\alpha$ & \id{KINSetEtaParams} & 0.9 and 2.0 \\
Values of $\omega_{min}$ and $\omega_{max}$${}^{*}$ & \id{KINSetResMonParams} & 0.00001 and 0.9 \\
Constant value of $\omega$${}^{*}$ & \id{KINSetResMonConstValue} & 0.9 \\
Lower bound on $\epsilon$ & \id{KINSetNoMinEps} & \id{SUNFALSE} \\
Max. scaled length of Newton step & \id{KINSetMaxNewtonStep} & $1000 \| D_u u_0 \|_2$ \\
Max. number of $\beta$-condition failures & \id{KINSetMaxBetaFails} & 10 \\
Rel. error for D.Q. $Jv$ & \id{KINSetRelErrFunc} & $\sqrt{\text{uround}}$ \\
Function-norm stopping tolerance & \id{KINSetFuncNormTol} & uround$^{1/3}$ \\
Scaled-step stopping tolerance & \id{KINSetScaledSteptol} & $\text{uround}^{2/3}$ \\
Inequality constraints on solution & \id{KINSetConstraints} & \id{NULL} \\
Nonlinear system function & \id{KINSetSysFunc} & none \\
Anderson Acceleration subspace size & \id{KINSetMAA} & 0 \\
Anderson Acceleration damping parameter & \id{KINSetDampingAA} & 1.0 \\
\hline
\multicolumn{3}{|c|}{\bf KINLS linear solver interface} \\
\hline
Jacobian function & \id{KINSetJacFn} &  DQ \\
Preconditioner functions and data & \id{KINSetPreconditioner} & \id{NULL}, \id{NULL}, \id{NULL} \\
Jacobian-times-vector function and data & \id{KINSetJacTimesVecFn} & internal DQ, \\
&&\id{NULL} \\
\hline
\end{tabular}
\end{table}

\subsubsection{Main solver optional input functions}\label{ss:optin_main}
\index{optional input!solver|(}

The calls listed here can be executed in any order. However, if either of the
functions \id{KINSetErrFile} or \id{KINSetErrHandlerFn} is to be called, that
call should be first, in order to take effect for any later error message.
%%
\index{error messages!redirecting}
\ucfunction{KINSetErrFile}
{
flag = KINSetErrFile(kin\_mem, errfp);
}
{
  The function \ID{KINSetErrFile} specifies the pointer to the file
  where all {\kinsol} messages should be directed when the default
  {\kinsol} error handler function is used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}.

  Passing a value of \id{NULL} disables all future error message output
  (except for the case in which the {\kinsol} memory pointer is \id{NULL}).
  This use of \id{KINSetErrFile} is strongly discouraged.

  {\warn}If \id{KINSetErrFile} is to be called, it should be called before any
  other optional input functions, in order to take effect for any later error message.
}
%%
\index{error message!user-defined handler}
\ucfunction{KINSetErrHandlerFn}
{
flag = KINSetErrHandlerFn(kin\_mem, ehfun, eh\_data);
}
{
  The function \ID{KINSetErrHandlerFn} specifies the optional user-defined function
  to be used in handling error messages.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ehfun] (\id{KINErrHandlerFn})
    is the user's {\CC} error handler function (see \S\ref{ss:ehFn}).
  \item[eh\_data] (\id{void *})
    pointer to user data passed to \id{ehfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The function \id{ehfun} and data pointer \id{eh\_data} have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default internal error handler function directs error messages to the
  file specified by the file pointer \id{errfp} (see \id{KINSetErrFile} above).

  Error messages indicating that the {\kinsol} solver memory is \id{NULL} will
  always be directed to \id{stderr}.
}
%%
\index{info messages!redirecting}
\ucfunction{KINSetInfoFile}
{
flag = KINSetInfoFile(kin\_mem, infofp);
}
{
  The function \ID{KINSetInfoFile} specifies the pointer to the file
  where all informative (non-error) messages should be directed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[infofp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{infofp} is \id{stdout}.
}
%%
%%
\index{info message!user-defined handler}
\ucfunction{KINSetInfoHandlerFn}
{
flag = KINSetInfoHandlerFn(kin\_mem, ihfun, ih\_data);
}
{
  The function \ID{KINSetInfoHandlerFn} specifies the optional user-defined function
  to be used in handling informative (non-error) messages.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ihfun] (\id{KINInfoHandlerFn})
    is the user's {\CC} information handler function (see \S\ref{ss:ihFn}).
  \item[ih\_data] (\id{void *})
    pointer to user data passed to \id{ihfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The function \id{ihfun} and data pointer \id{ih\_data} have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default internal information handler function directs informative (non-error)
  messages to the file specified by the file pointer \id{infofp} (see
  \id{KINSetInfoFile} above).
}
%%
%%
\ucfunction{KINSetPrintLevel}
{
flag = KINSetPrintLevel(kin\_mem, printfl);
}
{
  The function \ID{KINSetPrintLevel} specifies the level of verbosity
  of the output.
}
{
  \begin{args}[kin\_mem]

  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.

  \item[printfl] (\id{int})
    flag indicating the level of verbosity. Must be one of:

    \begin{itemize}
    \item[0]
      no information displayed.

    \item[1]
      for each nonlinear iteration display
      the following information: the scaled
      Euclidean $\ell_2$ norm of the system function
      evaluated at the current iterate, the
      scaled norm of the Newton step (only if
      using \id{KIN\_NONE}), and the
      number of function evaluations performed
      so far.

    \item[2]
      display level 1 output and the
      following values for each iteration:

      $\|F(u)\|_{D_F}$
      (only for \id{KIN\_NONE}).

      $\|F(u)\|_{D_F,\infty}$
      (for \id{KIN\_NONE} and
      \id{KIN\_LINESEARCH}).

    \item[3]
      display level 2 output plus additional
      values used by the global strategy
      (only if using \id{KIN\_LINESEARCH}), and
      statistical information for iterative linear
      solver modules.
    \end{itemize}

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{printfl} had an illegal value.
  \end{args}
}
{
  The default value for \id{printfl} is $0$.
}
%%
\ucfunction{KINSetUserData}
{
flag = KINSetUserData(kin\_mem, user\_data);
}
{
  The function \ID{KINSetUserData} specifies the pointer to user-defined memory
  that is to be passed to all user-supplied functions.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[user\_data] (\id{void *})
    pointer to the user-defined memory.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If specified, the pointer to \id{user\_data} is passed to all user-supplied
  functions that have it as an argument. Otherwise, a \id{NULL} pointer is passed.

  {\warn}If \id{user\_data} is needed in user linear solver or
  preconditioner functions, the call to
  \id{KINSetUserData} must be made {\it before} the call to specify the
  linear solver module.
}
%%
%%
\ucfunction{KINSetNumMaxIters}
{
flag = KINSetNumMaxIters(kin\_mem, mxiter);
}
{
  The function \ID{KINSetNumMaxIters} specifies the maximum number of
  nonlinear iterations allowed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxiter] (\id{long int})
    maximum number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The maximum number of iterations was non-positive.
  \end{args}
}
{
  The default value for \id{mxiter} is \id{MXITER\_DEFAULT} $=200$.
}
%%
%%
\ucfunction{KINSetNoInitSetup}
{
flag = KINSetNoInitSetup(kin\_mem, noInitSetup);
}
{
  The function \ID{KINSetNoInitSetup} specifies whether an initial call
  to the preconditioner or Jacobian setup function should be made or not.
}
{
  \begin{args}[noInitSeti[]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noInitSetup] (\id{booleantype})
    flag controlling whether an initial call to the preconditioner or Jacobian
    setup function is made (pass \id{SUNFALSE}) or not made (pass \id{SUNTRUE}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{noInitSetup} is \id{SUNFALSE}, meaning that an initial call
  to the preconditioner or Jacobian setup function will be made.

  A call to this function is useful when solving a sequence of problems, in which
  the final preconditioner or Jacobian value from one problem is to be used initially
  for the next problem.
}
%%
%%
\ucfunction{KINSetNoResMon}
{
flag = KINSetNoResMon(kin\_mem, noNNIResMon);
}
{
  The function \ID{KINSetNoResMon} specifies whether or not the nonlinear
  residual monitoring scheme is used to control Jacobian updating
}
{
  \begin{args}[noNNIResMon]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noNNIResMon] (\id{booleantype})
    flag controlling whether residual monitoring is used (pass \id{SUNFALSE})
    or not used (pass \id{SUNTRUE}).

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  When using a direct solver, the default value for \id{noNNIResMon} is \id{SUNFALSE},
  meaning that the nonlinear residual will be monitored.

  {\warn}Residual monitoring is only available for use with
  matrix-based linear solver modules.
}
%%
%%
\ucfunction{KINSetMaxSetupCalls}
{
flag = KINSetMaxSetupCalls(kin\_mem, msbset);
}
{
  The function \ID{KINSetMaxSetupCalls} specifies the maximum number of
  nonlinear iterations that can be performed between calls to the
  preconditioner or Jacobian setup function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[msbset] (\id{long int})
    maximum number of nonlinear iterations without a call to the
    preconditioner or Jacobian setup function.  Pass 0 to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{msbset} was negative.
  \end{args}
}
{
  The default value for \id{msbset} is \id{MSBSET\_DEFAULT} $=10$.

  The value of \id{msbset} should be a multiple of \id{msbsetsub} (see
  \id{KINSetMaxSubSetupCalls}).
}
%%
%%
\ucfunction{KINSetMaxSubSetupCalls}
{
flag = KINSetMaxSubSetupCalls(kin\_mem, msbsetsub);
}
{
  The function \ID{KINSetMaxSubSetupCalls} specifies the maximum number of
  nonlinear iterations between checks by the residual monitoring algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[msbsetsub] (\id{long int})
    maximum number of nonlinear iterations without checking the
    nonlinear residual. Pass 0 to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{msbsetsub} was negative.
  \end{args}
}
{
  The default value for \id{msbsetsub} is \id{MSBSET\_SUB\_DEFAULT} $=5$.

  The value of \id{msbset} (see \id{KINSetMaxSetupCalls}) should be a multiple
  of \id{msbsetsub}.

  {\warn}Residual monitoring is only available for use with
  matrix-based linear solver modules.
}
%%
%%
\ucfunction{KINSetEtaForm}
{
flag = KINSetEtaForm(kin\_mem, etachoice);
}
{
  The function \ID{KINSetEtaForm} specifies the method for computing
  the value of the $\eta$ coefficient used in the calculation of the
  linear solver convergence tolerance.
}
{
  \begin{args}[etachoice]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[etachoice] (\id{int})
    flag indicating the method for computing $\eta$. The value must be one
    of \Id{KIN\_ETACHOICE1}, \Id{KIN\_ETACHOICE2}, or \Id{KIN\_ETACONSTANT}
    (see Chapter \ref{s:math} for details).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{etachoice} had an illegal value.
  \end{args}
}
{
  The default value for \id{etachoice} is \id{KIN\_ETACHOICE1}.

  When using either \id{KIN\_ETACHOICE1} or \id{KIN\_ETACHOICE2} the safeguard
  \begin{equation*}
    \eta_n = \max(\eta_n, \eta_{\text{safe}})
  \end{equation*}
  is applied when $\eta_{\text{safe}} > 0.1$. For \id{KIN\_ETACHOICE1}
  \begin{equation*}
    \eta_{\text{safe}} = \eta_{n-1}^{\frac{1+\sqrt{5}}{2}}
  \end{equation*}
  and for \id{KIN\_ETACHOICE2}
  \begin{equation*}
    \eta_{\text{safe}} = \gamma \eta_{n-1}^{\alpha}
  \end{equation*}
  where $\gamma$ and $\alpha$ can be set with \id{KINSetEtaParams}.

  The following safeguards are always applied when using either
  \id{KIN\_ETACHOICE1} or \id{KIN\_ETACHOICE2} so that
  $\eta_{\text{min}} \leq \eta_n \leq \eta_{\text{max}}$:
  \begin{align*}
    \eta_n &= \max(\eta_n, \eta_{\text{min}}) \\
    \eta_n &= \min(\eta_n, \eta_{\text{max}})
  \end{align*}
  where $\eta_{\text{min}} = 10^{-4}$ and $\eta_{\text{max}} = 0.9$.
}
%%
%%
\ucfunction{KINSetEtaConstValue}
{
flag = KINSetEtaConstValue(kin\_mem, eta);
}
{
  The function \ID{KINSetEtaConstValue} specifies the constant value
  for $\eta$ in the case \\ \id{etachoice = KIN\_ETACONSTANT}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[eta] (\id{realtype})
    constant value for $\eta$.  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{eta} had an illegal value
  \end{args}
}
{
  The default value for \id{eta} is $0.1$.
  The legal values are $0.0 <$ \id{eta} $\le 1.0$.
}
%%
%%
\ucfunction{KINSetEtaParams}
{
flag = KINSetEtaParams(kin\_mem, egamma, ealpha);
}
{
  The function \ID{KINSetEtaParams} specifies the parameters $\gamma$ and
  $\alpha$ in the formula for $\eta$, in the case \id{etachoice = KIN\_ETACHOICE2}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[egamma] (\id{realtype})
    value of the $\gamma$ parameter.  Pass $0.0$ to indicate the default.
  \item[ealpha] (\id{realtype})
    value of the $\alpha$ parameter.  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    One of the arguments \id{egamma} or \id{ealpha} had an illegal value.
  \end{args}
}
{
  The default values for \id{egamma} and \id{ealpha} are $0.9$ and $2.0$, respectively.

  The legal values are $0.0 <$ \id{egamma} $\le 1.0$ and
  $1.0<$ \id{ealpha} $\le 2.0$.
}
%%
%%
\ucfunction{KINSetResMonConstValue}
{
flag = KINSetResMonConstValue(kin\_mem, omegaconst);
}
{
  The function \ID{KINSetResMonConstValue} specifies the constant value
  for $\omega$ when using residual monitoring.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[omegaconst] (\id{realtype})
    constant value for $\omega$.  Passing $0.0$ results in using
    Eqn. (\ref{resmon_omega}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{omegaconst} had an illegal value
  \end{args}
}
{
  The default value for \id{omegaconst} is $0.9$.
  The legal values are $0.0 <$ \id{omegaconst} $< 1.0$.
}
%%
%%
\ucfunction{KINSetResMonParams}
{
flag = KINSetResMonParams(kin\_mem, omegamin, omegamax);
}
{
  The function \ID{KINSetResMonParams} specifies the parameters $\omega_{min}$ and
  $\omega_{max}$ in the formula (\ref{resmon_omega}) for $\omega$.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[omegamin] (\id{realtype})
    value of the $\omega_{min}$ parameter.  Pass $0.0$ to indicate the default.
  \item[omegamax] (\id{realtype})
    value of the $\omega_{max}$ parameter.  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    One of the arguments \id{omegamin} or \id{omegamax} had an illegal value.
  \end{args}
}
{
  The default values for \id{omegamin} and \id{omegamax} are $0.00001$ and $0.9$,
  respectively.

  The legal values are $0.0 <$ \id{omegamin} $<$ \id{omegamax} $< 1.0$.
}
%%
%%
\ucfunction{KINSetNoMinEps}
{
flag = KINSetNoMinEps(kin\_mem, noMinEps);
}
{
  The function \ID{KINSetNoMinEps} specifies a flag that controls whether or not
  the value of $\epsilon$, the scaled linear residual tolerance, is
  bounded from below.
}
{
  \begin{args}[noMinEps]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noMinEps] (\id{booleantype})
    flag controlling the bound on $\epsilon$. If \id{SUNFALSE} is passed the
    value of $\epsilon$ is constrained and if \id{SUNTRUE} is passed then
    $\epsilon$ is not constrained.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{noMinEps} is \id{SUNFALSE}, meaning that a
  positive minimum value, equal to $0.01$*\id{fnormtol}, is applied to
  $\epsilon$ (see \id{KINSetFuncNormTol} below).
}
%%
%%
\ucfunction{KINSetMaxNewtonStep}
{
flag = KINSetMaxNewtonStep(kin\_mem, mxnewtstep);
}
{
  The function \ID{KINSetMaxNewtonStep} specifies the maximum allowable scaled
  length of the Newton step.
}
{
  \begin{args}[mxnewtstep]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxnewtstep] (\id{realtype})
    maximum scaled step length ($\geq 0.0$).  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The input value was negative.
  \end{args}
}
{
  The default value of \id{mxnewtstep} is $1000\, \| u_0 \|_{D_u}$,
  where $u_0$ is the initial guess.
}
%%
%%
\ucfunction{KINSetMaxBetaFails}
{
flag = KINSetMaxBetaFails(kin\_mem, mxnbcf);
}
{
  The function \ID{KINSetMaxBetaFails} specifies the maximum number of
  $\beta$-condition failures in the linesearch algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxnbcf] (\id{realtype})
    maximum number of $\beta$-condition failures.  Pass $0.0$ to indicate the
    default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    \id{mxnbcf} was negative.
  \end{args}
}
{
  The default value of \id{mxnbcf} is \id{MXNBCF\_DEFAULT} $=10$.
}
%%
%%
\ucfunction{KINSetRelErrFunc}
{
flag = KINSetRelErrFunc(kin\_mem, relfunc);
}
{
  The function \ID{KINSetRelErrFunc} specifies the relative error in
  computing $F(u)$, which is used in the difference quotient approximation to
  the Jacobian matrix [see Eq.(\ref{e:sigmaDQ_direct})] or the Jacobian-vector
  product [see Eq.(\ref{e:sigmaDQ_iterative})]. The value stored is
  $\sqrt{\id{relfunc}}$.
}
{
  \begin{args}[relfunc]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[relfunc] (\id{realtype})
    relative error in $F(u)$ (\id{relfunc} $\geq 0.0$).  Pass $0.0$ to indicate
    the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The relative error was negative.
  \end{args}
}
{
  The default value for \id{relfunc} is $U$ = unit roundoff.
}
%%
%%
\ucfunction{KINSetFuncNormTol}
{
flag = KINSetFuncNormTol(kin\_mem, fnormtol);
}
{
  The function \ID{KINSetFuncNormTol} specifies the scalar used as a stopping
  tolerance on the scaled maximum norm of the system function $F(u)$.
}
{
  \begin{args}[fnormtol]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[fnormtol] (\id{realtype})
    tolerance for stopping based on scaled function norm ($\geq 0.0$).
    Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The tolerance was negative.
  \end{args}
}
{
  The default value for \id{fnormtol} is (unit roundoff)$^{1/3}$.
}
%%
%%
\ucfunction{KINSetScaledStepTol}
{
flag = KINSetScaledStepTol(kin\_mem, scsteptol);
}
{
  The function \ID{KINSetScaledStepTol} specifies the scalar used
  as a stopping tolerance on the minimum scaled step length.
}
{
  \begin{args}[scsteptol]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[scsteptol] (\id{realtype})
    tolerance for stopping based on scaled step length ($\geq 0.0$).
    Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The tolerance was non-positive.
  \end{args}
}
{
  The default value for \id{scsteptol} is (unit roundoff)$^{2/3}$.
}
%%
%%
\ucfunction{KINSetConstraints}
{
flag = KINSetConstraints(kin\_mem, constraints);
}
{
  The function \ID{KINSetConstraints} specifies a vector that defines
  inequality constraints for each component of the solution vector $u$.
}
{
  \begin{args}[constraints]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[constraints] (\id{N\_Vector})
    vector of constraint flags. If \id{constraints[i]} is
    \begin{itemize}
    \item[$0.0$] then no constraint is imposed on $u_i$.
    \item[$1.0$] then $u_i$ will be constrained to be $u_i \ge 0.0$.
    \item[$-1.0$] then $u_i$ will be constrained to be $u_i \le 0.0$.
    \item[$2.0$] then $u_i$ will be constrained to be $u_i > 0.0$.
    \item[$-2.0$] then $u_i$ will be constrained to be $u_i < 0.0$.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The constraint vector contains illegal values.
  \end{args}
}
{
  The presence of a non-\id{NULL} constraints vector that is not $0.0$ in
  all components will cause constraint checking to be performed. If a \id{NULL}
  vector is supplied, constraint checking will be disabled.

  The function creates a private copy of the constraints vector. Consequently,
  the user-supplied vector can be freed after the function call, and
  the constraints can only be changed by calling this function.
}
%%
%%
\ucfunction{KINSetSysFunc}
{
flag = KINSetSysFunc(kin\_mem, func);
}
{
  The function \ID{KINSetSysFunc} specifies the user-provided function
  that evaluates the nonlinear system function $F(u)$ or $G(u)$.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[func] (\id{KINSysFn})
    user-supplied function that evaluates $F(u)$ (or $G(u)$ for fixed-point
    iteration).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{func} was \id{NULL}.
  \end{args}
}
{
  The nonlinear system function is initially specified through \id{KINInit}.
  The option of changing the system function is provided for a user who wishes
  to solve several problems of the same size but with different functions.
}
%%
%%
\ucfunction{KINSetMAA}
{
flag = KINSetMAA(kin\_mem, maa);
}
{
  The function \ID{KINSetMAA} specifies the size of the subspace used with
  Anderson acceleration in conjunction with Picard or fixed-point iteration.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maa] (\id{long int})
    subspace size for various methods.  A value of 0 means no acceleration,
    while a positive value means acceleration will be done.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{maa} was negative.
  \end{args}
}
{
  This function sets the subspace size, which needs to be $> 0$ if Anderson
  Acceleration is to be used.
  It also allocates additional memory necessary for Anderson Acceleration.

  The default value of \id{maa} is 0, indicating no acceleration.  The value of \id{maa}
  should always be less than \id{mxiter}.

  This function MUST be called before calling \ID{KINInit}.

  If the user calls the function KINSetNumMaxIters, that call should be made
  before the call to KINSetMAA, as the latter uses the value of \id{mxiter}.
}
%
%
\ucfunction{KINSetDampingAA}
{
flag = KINSetDampingAA(kin\_mem, beta);
}
{
  The function \ID{KINSetDampingAA} specifies the value of the Anderson
  acceleration damping paramter.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[beta] (\id{realtype})
    the damping parameter value $0 < beta \leq 1.0$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{beta} was zero or negative.
  \end{args}
}
{
  This function sets the damping parameter value, which needs to be greater than zero
  and less than one if damping is to be used. A value $\geq 1$ disables damping.

  The default value of \id{beta} is 1.0, indicating no damping.
}
%%
%%
%%
\index{optional input!solver|)}

%%==============================================================================
\subsubsection{Linear solver interface optional input functions}\label{sss:optin_ls}
%%==============================================================================
\index{optional input!generic linear solver interface|(}
\index{KINLS@{\kinls} linear solver interface!optional input|(}

For matrix-based linear solver modules, the
\index{KINLS@{\kinls} linear solver interface!Jacobian approximation used by}
{\kinls} solver interface needs a function to compute an approximation to
the Jacobian matrix $J(u)$.  This function must be of type \id{KINLsJacFn}.
The user can supply a Jacobian function, or if using a dense or banded
matrix $J$ can use the default internal difference quotient approximation
\index{Jacobian approximation function!difference quotient}
that comes with the {\kinls} solver.
To specify a user-supplied Jacobian function \id{jac}, {\kinls} provides
the function \id{KINSetJacFn}.
The {\kinls} interface passes the pointer \id{user\_data}
to the Jacobian function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without
using global data in the program.  The pointer \id{user\_data} may be
specified through \id{KINSetUserData}.
%%
\index{Jacobian approximation function!user-supplied}
\ucfunction{KINSetJacFn}
{
  flag = KINSetJacFn(kin\_mem, jac);
}
{
  The function \ID{KINSetJacFn} specifies the Jacobian
  approximation function to be used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[jac] (\id{KINLsJacFn})
    user-defined Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}
  \item[\Id{KINLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  By default, {\kinls} uses an internal difference quotient function
  for dense and band matrices.  If \id{NULL} is passed to \id{jac},
  this default function is used.  An error will occur if no \id{jac}
  is supplied when using a sparse or user-supplied matrix.

  This function must be called \emph{after} the {\kinls} linear solver
  interface has been initialized through a call to
  \id{KINSetLinearSolver}.

  The function type \id{KINLsJacFn} is described in \S\ref{ss:jacFn}.

  The previous routine \Id{KINDlsSetJacFn} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
%%
\index{KINLS@{\kinls} linear solver!Jacobian-vector product approximation used by}
When using matrix-free linear solver modules, the {\kinls} linear
solver interface requires a function to compute an approximation to
the product between the Jacobian matrix $J(u)$ and a vector $v$.
The user can supply his/her own Jacobian-times-vector approximation function,
or use the internal difference quotient approximation
\index{Jacobian approximation function!Jacobian times vector!difference quotient}
that comes with the {\kinls} solver interface.  A user-defined Jacobian-vector
function must be of type \id{KINLsJacTimesVecFn} and
can be specified through a call to \id{KINLsSetJacTimesVecFn}
(see \S\ref{ss:jtimesFn} for specification details).

The pointer \id{user\_data} received through \id{KINSetUserData} (or a
pointer to \id{NULL} if \id{user\_data} was not specified) is passed
to the Jacobian-times-vector function \id{jtimes} each time it is
called.  This allows the user to create an arbitrary structure with
relevant problem data and access it during the execution of the
user-supplied functions without using global data in the program.
%%
\index{Jacobian approximation function!Jacobian times vector!user-supplied}
\ucfunction{KINSetJacTimesVecFn}
{
  flag = KINSetJacTimesVecFn(kin\_mem, jtimes);
}
{
  The function \ID{KINSetJacTimesVecFn} specifies the Jacobian-vector
  product function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[jtimes] (\id{KINLsJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_SUNLS\_FAIL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver has not been initialized.
  \item[\Id{KINLS\_SUNLS\_FAIL}]
    An error occurred when setting up the system matrix-times-vector
    routines in the {\sunlinsol} object used by the {\kinls}
    interface.
  \end{args}
}
{
  The default is to use an internal difference quotient for
  \id{jtimes}.  If \id{NULL} is passed as \id{jtimes}, this default
  is used.

  This function must be called \emph{after} the {\kinls} linear solver
  interface has been initialized through a call to
  \id{KINSetLinearSolver}.

  The function type \id{KINLsJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.

  The previous routine \Id{KINSpilsSetJacTimesVecFn} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}


\index{preconditioning!user-supplied|(}
When using an iterative linear solver, the user may supply a
preconditioning operator to aid in solution of the system.  This
operator consists of two user-supplied functions, \id{psetup} and
\id{psolve}, that are supplied to {\kinls} using the function
\Id{KINSetPreconditioner}.  The \id{psetup} function supplied to
this routine should handle evaluation and preprocessing of any
Jacobian data needed by the user's preconditioner solve function,
\id{psolve}.  Both of these functions are fully specified in
\S\ref{ss:user_fct_sol}.  The user data pointer received through
\id{KINSetUserData} (or a pointer to \id{NULL} if user data was not
specified) is passed to the \id{psetup} and \id{psolve} functions.
This allows the user to create an arbitrary structure with relevant
problem data and access it during the execution of the user-supplied
preconditioner functions without using global data in the program.


\index{KINLS@{\kinls} linear solver interface!preconditioner solve function}
\index{KINLS@{\kinls} linear solver interface!preconditioner setup function}
\ucfunction{KINSetPreconditioner}
{
  flag = KINSetPreconditioner(kin\_mem, psetup, psolve);
}
{
  The function \ID{KINSetPreconditioner} specifies the preconditioner
  setup and solve functions.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[psetup] (\id{KINLsPrecSetupFn})
    user-defined function to set up the preconditioner.  Pass \id{NULL} if no setup
    operation is necessary.
  \item[psolve] (\id{KINLsPrecSolveFn})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional values have been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver has not been initialized.
  \item[\Id{KINLS\_SUNLS\_FAIL}]
    An error occurred when setting up preconditioning in the
    {\sunlinsol} object used by the {\kinls} interface.
  \end{args}
}
{
  The default is \id{NULL} for both arguments (i.e., no
  preconditioning).

  This function must be called \emph{after} the {\kinls} linear solver
  interface has been initialized through a call to
  \id{KINSetLinearSolver}.

  The function type \id{KINLsPrecSolveFn} is described in \S\ref{ss:psolveFn}.

  The function type \id{KINLsPrecSetupFn} is described in \S\ref{ss:precondFn}.

  The previous routine \Id{KINSpilsSetPreconditioner} is now a wrapper
  for this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\index{preconditioning!user-supplied|)}
\index{optional input!generic linear solver interface|)}
\index{KINLS@{\kinls} linear solver interface!optional input|)}
%%
%%

%%==============================================================================
\subsection{Optional output functions}\label{ss:optional_output}
%%==============================================================================

{\kinsol} provides an extensive list of functions that can be used to obtain
solver performance information.
Table \ref{t:optional_output} lists all optional output functions in {\kinsol},
which are then described in detail in the remainder of this section, beginning with those
for the main {\kinsol} solver and continuing with those for the
{\kinls} linear solver interface. Where the name of an output from a
linear solver module would otherwise conflict with the name of an
optional output from the main solver, a suffix \id{LS} (for Linear
Solver) has been added here ({\em e.g.}, \id{lenrwLS}).

\newlength{\colAA}
\settowidth{\colAA}{No. of $F$ calls for D.Q. Jacobian[-vector] evals.}
\newlength{\colBB}
\settowidth{\colBB}{\id{KINGetNumNonlinSolvConvFails}}



\begin{table}
\centering
\caption{Optional outputs from {\kinsol} and {\kinls}}
\label{t:optional_output}
\medskip
\begin{tabular}{|p{\colAA}|p{\colBB}|}
\hline
{\bf Optional output} & {\bf Function name} \\
\hline
\multicolumn{2}{|c|}{\bf KINSOL main solver} \\
\hline
Size of {\kinsol} real and integer workspaces & \id{KINGetWorkSpace} \\
Number of function evaluations  & \id{KINGetNumFuncEvals} \\
Number of nonlinear iterations & \id{KINGetNumNolinSolvIters} \\
Number of $\beta$-condition failures & \id{KINGetNumBetaCondFails} \\
Number of backtrack operations & \id{KINGetNumBacktrackOps} \\
Scaled norm of $F$ & \id{KINGetFuncNorm} \\
Scaled norm of the step & \id{KINGetStepLength} \\
\hline
\multicolumn{2}{|c|}{\bf KINLS linear solver interface} \\
\hline
Size of real and integer workspaces & \id{KINGetLinWorkSpace} \\
No. of Jacobian evaluations & \id{KINGetNumJacEvals} \\
No. of $F$ calls for D.Q. Jacobian[-vector] evals. & \id{KINGetNumLinFuncEvals} \\
No. of linear iterations & \id{KINGetNumLinIters} \\
No. of linear convergence failures & \id{KINGetNumLinConvFails} \\
No. of preconditioner evaluations & \id{KINGetNumPrecEvals} \\
No. of preconditioner solves & \id{KINGetNumPrecSolves} \\
No. of Jacobian-vector product evaluations & \id{KINGetNumJtimesEvals} \\
Last return from a {\kinls} function & \id{KINGetLastLinFlag} \\
Name of constant associated with a return flag & \id{KINGetLinReturnFlagName} \\
\hline
\end{tabular}
\end{table}

%%==============================================================================
%% SUNDIALS-wide functions for getting version information
\input{sundials_version}
%%==============================================================================

%%==============================================================================
\subsubsection{Main solver optional output functions}\label{sss:output_main}
%%==============================================================================
\index{optional output!solver|(}
%%
{\kinsol} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements and solver performance statistics.
%%
These optional output functions are described next.
%%
%%
\ucfunction{KINGetWorkSpace}
{
  flag = KINGetWorkSpace(kin\_mem, \&lenrw, \&leniw);
}
{
  The function \ID{KINGetWorkSpace} returns the
  {\kinsol} integer and real workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrw] (\id{long int})
    the number of \id{realtype} values in the {\kinsol} workspace.
  \item[leniw] (\id{long int})
    the number of integer values in the {\kinsol} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  \index{memory requirements!KINSOL@{\kinsol} solver}
  In terms of the problem size $N$, the actual size of the real workspace
  is $17 + 5 N$ \id{realtype} words. The real workspace is increased by
  an additional $N$ words if constraint checking is enabled (see \id{KINSetConstraints}).

  The actual size of the integer workspace (without distinction between \id{int}
  and \id{long int}) is $22 + 5 N$ (increased by $N$ if constraint checking is enabled).
}
%%
%%
\ucfunction{KINGetNumFuncEvals}
{
  flag = KINGetNumFuncEvals(kin\_mem, \&nfevals);
}
{
  The function \ID{KINGetNumFuncEvals} returns the number of evaluations
  of the system function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevals] (\id{long int})
    number of calls to the user-supplied function that evaluates $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumNonlinSolvIters}
{
  flag = KINGetNumNonlinSolvIters(kin\_mem, \&nniters);
}
{
  The function \ID{KINGetNumNonlinSolvIters} returns the number
  of nonlinear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumBetaCondFails}
{
  flag = KINGetNumBetaCondFails(kin\_mem, \&nbcfails);
}
{
  The function \ID{KINGetNumBetaCondFails} returns the number
  of $\beta$-condition failures.
}
{
  \begin{args}[nbcfails]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nbcfails] (\id{long int})
    number of $\beta$-condition failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumBacktrackOps}
{
  flag = KINGetNumBacktrackOps(kin\_mem, \&nbacktr);
}
{
  The function \ID{KINGetNumBacktrackOps} returns the number of
  backtrack operations (step length adjustments) performed by the
  line search algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nbacktr] (\id{long int})
    number of backtrack operations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetFuncNorm}
{
  flag = KINGetFuncNorm(kin\_mem, \&fnorm);
}
{
  The function \ID{KINGetFuncNorm} returns the scaled Euclidean $\ell_2$ norm of the
  nonlinear system function $F(u)$ evaluated at the current iterate.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[fnorm] (\id{realtype})
    current scaled norm of $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetStepLength}
{
  flag = KINGetStepLength(kin\_mem, \&steplength);
}
{
  The function \ID{KINGetStepLength} returns the scaled Euclidean $\ell_2$ norm of
  the step used during the previous iteration.
}
{
  \begin{args}[steplength]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[steplength] (\id{realtype})
    scaled norm of the Newton step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\index{optional output!solver|)}

%%==============================================================================
\subsubsection{{\kinls} linear solver interface optional output functions}
\label{sss:optout_ls}
%%==============================================================================
\index{optional output!generic linear solver interface|(}
\index{KINLS@{\kinls} linear solver interface!optional output|(}

The following optional outputs are available from the {\kinls} module:
workspace requirements,
number of calls to the Jacobian routine,
number of calls to the system function routine for difference quotient Jacobian or Jacobian-vector approximation,
number of linear iterations,
number of linear convergence failures,
number of calls to the preconditioner setup and solve routines,
number of calls to the Jacobian-vector product routine,
and last return value from a {\kinls} function.
%%
%%
\index{KINLS@{\kinls} linear solver!memory requirements}
\index{memory requirements!KINLS@{\kinls} linear solver}
\ucfunction{KINGetLinWorkSpace}
{
  flag = KINGetLinWorkSpace(kin\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{KINGetLinWorkSpace} returns the
  {\kinls} real and integer workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\kinls} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\kinls} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The workspace requirements reported by this routine correspond only
  to memory allocated within this interface and to memory allocated by
  the {\sunlinsol} object attached to it.  The template Jacobian
  matrix allocated by the user outside of {\kinls} is not included in
  this report.

  In a parallel setting, the above values are global (i.e., summed over all
  processors).

  The previous routines \Id{KINDlsGetWorkspace} and
  \Id{KINSpilsGetWorkspace} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumJacEvals}
{
  flag = KINGetNumJacEvals(kin\_mem, \&njevals);
}
{
  The function \ID{KINGetNumJacEvals} returns the cummulative
  number of calls to the {\kinls} Jacobian approximation function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njevals] (\id{long int})
    the number of calls to the Jacobian function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The previous routine \Id{KINDlsGetNumJacEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumLinFuncEvals}
{
  flag = KINGetNumLinFuncEvals(kin\_mem, \&nfevalsLS);
}
{
  The function \ID{KINGetNumLinFuncEvals} returns the number of calls
  to the user system function used to compute the difference quotient
  approximation to the Jacobian or to the Jacobian-vector product.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls to the user system function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if one of the default
  internal difference quotient functions is used.

  The previous routines \Id{KINDlsGetNumFuncEvals} and
  \Id{KINSpilsGetNumFuncEvals} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumLinIters}
{
  flag = KINGetNumLinIters(kin\_mem, \&nliters);
}
{
  The function \ID{KINGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The previous routine \Id{KINSpilsGetNumLinIters} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumLinConvFails}
{
  flag = KINGetNumLinConvFails(kin\_mem, \&nlcfails);
}
{
  The function \ID{KINGetNumLinConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The previous routine \Id{KINSpilsGetNumConvFails} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumPrecEvals}
{
  flag = KINGetNumPrecEvals(kin\_mem, \&npevals);
}
{
  The function \ID{KINGetNumPrecEvals} returns the cumulative number
  of preconditioner evaluations, i.e., the number of calls made to
  \id{psetup}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npevals] (\id{long int})
    the current number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The previous routine \Id{KINSpilsGetNumPrecEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumPrecSolves}
{
  flag = KINGetNumPrecSolves(kin\_mem, \&npsolves);
}
{
  The function \ID{KINGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner
  solve function, \id{psolve}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npsolves] (\id{long int})
    the current number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The previous routine \Id{KINSpilsGetNumPrecSolves} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunction{KINGetNumJtimesEvals}
{
  flag = KINGetNumJtimesEvals(kin\_mem, \&njvevals);
}
{
  The function \ID{KINGetNumJtimesEvals} returns the
  cumulative number made to the Jacobian-vector product function,
  \id{jtimes}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njvevals] (\id{long int})
    the current number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  The previous routine \Id{KINSpilsGetNumJtimesEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunction{KINGetLastLinFlag}
{
  flag = KINGetLastLinFlag(kin\_mem, \&lsflag);
}
{
  The function \ID{KINGetLastLinFlag} returns the
  last return value from a {\kinls} routine.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from a {\kinls} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_LMEM\_NULL]
  \item[\Id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \end{args}
}
{
  If the {\kinls} setup function failed (i.e. \id{KINSolve} returned
  \id{KIN\_LSETUP\_FAIL}) when using the {\sunlinsoldense} or
  {\sunlinsolband} modules, then the value of \id{lsflag} is equal to
  the column index (numbered from one) at which a zero diagonal
  element was encountered during the LU factorization of the (dense or
  banded) Jacobian matrix.

  If the {\kinls} setup function failed when using another
  {\sunlinsol} module, then \id{lsflag} will be
  \id{SUNLS\_PSET\_FAIL\_UNREC}, \id{SUNLS\_ASET\_FAIL\_UNREC}, or
  \id{SUNLS\_PACKAGE\_FAIL\_UNREC}.

  If the {\kinls} solve function failed (i.e., \id{KINSol} returned
  \id{KIN\_LSOLVE\_FAIL}), then \id{lsflag} contains the error return
  flag from the {\sunlinsol} object, which will be one of the following: \\
  \id{SUNLS\_MEM\_NULL}, indicating that the {\sunlinsol} memory is \id{NULL}; \\
  \id{SUNLS\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the
  Jacobian-times-vector function; \\
  \id{SUNLS\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function, \id{psolve}, failed with an unrecoverable error; \\
  \id{SUNLS\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure
  (generated only in {\spgmr} or {\spfgmr}); \\
  \id{SUNLS\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
  singular during the QR solve phase ({\spgmr} and {\spfgmr} only); or  \\
  \id{SUNLS\_PACKAGE\_FAIL\_UNREC}, indicating an unrecoverable
  failure in an external iterative linear solver package.

  The previous routines \Id{KINDlsGetLastFlag} and
  \Id{KINSpilsGetLastFlag} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\ucfunction{KINGetLinReturnFlagName}
{
  name = KINGetLinReturnFlagName(lsflag);
}
{
  The function \ID{KINGetLinReturnFlagName} returns the
  name of the {\kinls} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from an {\kinls} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{
  The previous routines \Id{KINDlsGetReturnFlagName} and
  \Id{KINSpilsGetReturnFlagName} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
\index{optional output!generic linear solver interface|)}
\index{KINLS@{\kinls} linear solver interface!optional output|)}


%%==============================================================================
\section{User-supplied functions}\label{ss:user_fct_sol}
%%==============================================================================

The user-supplied functions consist of one function defining the nonlinear system,
(optionally) a function that handles error and warning messages,
(optionally) a function that handles informational messages,
(optionally) one or two functions that provides Jacobian-related information for the linear
solver, and (optionally) one or two functions that define the preconditioner for
use in any of the Krylov iterative algorithms.

%%==============================================================================
\subsection{Problem-defining function}\label{ss:sysFn}
%%==============================================================================
\index{problem-defining function}

The user must provide a function of type \ID{KINSysFn} defined as follows:
\usfunction{KINSysFn}
{
  typedef int (*KINSysFn)(N\_Vector u, N\_Vector fval, void *user\_data);
}
{
  This function computes $F(u)$ (or $G(u)$ for fixed-point iteration and Anderson
  acceleration) for a given value of the vector $u$.
}
{
  \begin{args}[user\_data]
  \item[u]
    is the current value of the variable vector, $u$.
  \item[fval]
    is the output vector $F(u)$.
  \item[user\_data]
    is a pointer to user data, the pointer \Id{user\_data}
    passed to \id{KINSetUserData}.
  \end{args}
}
{
  A \id{KINSysFn} function should return $0$ if successful, a positive value
  if a recoverable error occurred (in which case {\kinsol} will attempt to
  correct), or a negative value if it failed unrecoverably (in which case
  the solution process is halted and \id{KIN\_SYSFUNC\_FAIL} is returned).
}
{
  Allocation of memory for \id{fval} is handled within {\kinsol}.
}

%%==============================================================================
\subsection{Error message handler function}
\label{ss:ehFn}
%%==============================================================================
\index{error messages!user-defined handler}
As an alternative to the default behavior of directing error and warning messages
to the file pointed to by \id{errfp} (see \id{KINSetErrFile}), the user may
provide a function of type \ID{KINErrHandlerFn} to process any such messages.
The function type \id{KINErrHandlerFn} is defined as follows:
\usfunction{KINErrHandlerFn}
{
  typedef void (*KINErrHandlerFn)(&int error\_code, const char *module, \\
                                  &const char *function, char *msg, \\
                                  &void *eh\_data);
}
{
  This function processes error and warning messages from {\kinsol} and
  its sub-modules.
}
{
  \begin{args}[error\_code]
  \item[error\_code]
    is the error code.
  \item[module]
    is the name of the {\kinsol} module reporting the error.
  \item[function]
    is the name of the function in which the error occurred.
  \item[msg]
    is the error message.
  \item[eh\_data]
    is a pointer to user data, the same as the \Id{eh\_data}
    parameter passed to \id{KINSetErrHandlerFn}.
  \end{args}
}
{
  A \id{KINErrHandlerFn} function has no return value.
}
{
  \id{error\_code} is negative for errors and positive (\Id{KIN\_WARNING}) for warnings.
  If a function that returns a pointer to memory encounters an
  error, it sets \id{error\_code} to 0.
}

%%==============================================================================
\subsection{Informational message handler function}
\label{ss:ihFn}
%%==============================================================================
\index{informational messages!user-defined handler}
As an alternative to the default behavior of directing informational (meaning non-error) messages
to the file pointed to by \id{infofp} (see \id{KINSetInfoFile}), the user may
provide a function of type \ID{KINInfoHandlerFn} to process any such messages.
The function type \id{KINInfoHandlerFn} is defined as follows:
\usfunction{KINInfoHandlerFn}
{
  typedef void (*KINInfoHandlerFn)(&const char *module, \\
                                   &const char *function, char *msg, \\
                                   &void *ih\_data);
}
{
  This function processes informational messages from {\kinsol} and
  its sub-modules.
}
{
  \begin{args}[function]
  \item[module]
    is the name of the {\kinsol} module reporting the information.
  \item[function]
    is the name of the function reporting the information.
  \item[msg]
    is the message.
  \item[ih\_data]
    is a pointer to user data, the same as the \Id{ih\_data}
    parameter passed to \id{KINSetInfoHandlerFn}.
  \end{args}
}
{
  A \id{KINInfoHandlerFn} function has no return value.
}
{}

%%==============================================================================
\subsection{Jacobian construction (matrix-based linear solvers)}
\label{ss:jacFn}
%%==============================================================================
\index{Jacobian approximation function!user-supplied|(}

If a matrix-based linear solver module is used (i.e., a non-\id{NULL}
{\sunmatrix} object \id{J} was supplied to \Id{KINSetLinearSolver}),
the user may provide a function of type \ID{KINLsJacFn} defined as
follows
%%
\usfunction{KINLsJacFn}
{
  typedef int (*KINLsJacFn)(&N\_Vector u, N\_Vector fu,\\
                            &SUNMatrix J, void *user\_data,\\
                            &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the Jacobian matrix $J(u)$
  (or an approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[u]
    is the current (unscaled) iterate.
  \item[fu]
    is the current value of the vector $F(u)$.
  \item[J]
    is the output approximate Jacobian matrix, $J = \partial{F}/\partial{u}$,
    of type \id{SUNMatrix}.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to \id{KINSetUserData}.
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated
    for variables of type \id{N\_Vector} which can be used by
    the \id{KINJacFn} function as temporary storage or work space.
  \end{args}
}
{
  A function of type \id{KINLsJacFn} should return $0$ if successful
  or a non-zero value otherwise.
}
{
  Information regarding the structure of the specific {\sunmatrix}
  structure (e.g.~number of rows, upper/lower bandwidth, sparsity
  type) may be obtained through using the implementation-specific
  {\sunmatrix} interface functions (see Chapter \ref{s:sunmatrix} for
  details).

  With direct linear solvers (i.e., linear solvers with type
  \Id{SUNLINEARSOLVER\_DIRECT}), the Jacobian matrix $J(u)$ is zeroed out prior
  to calling the user-supplied Jacobian function so only nonzero elements need
  to be loaded into \id{J}.

  If the user's \id{KINLsJacFn} function uses difference quotient
  approximations, it may need to access quantities not in the call list.
  These quantities may include the scale vectors and the unit roundoff.
  To obtain the scale vectors, the user will need to add to \id{user\_data}
  pointers to \id{u\_scale} and/or \id{f\_scale} as needed.
  The unit roundoff can be accessed as \id{UNIT\_ROUNDOFF} defined in
  \id{sundials\_types.h}.

  {\bf dense:}\\
  A user-supplied dense Jacobian function must load the \id{N} $\times$ \id{N}
  dense matrix \id{J} with an approximation to the Jacobian matrix $J(u)$
  at the point (\id{u}).  The accessor macros \Id{SM\_ELEMENT\_D}
  and \Id{SM\_COLUMN\_D} allow the user to read and write dense matrix
  elements without making explicit references to the underlying
  representation of the {\sunmatdense} type.
  \id{SM\_ELEMENT\_D(J, i, j)} references the (\id{i}, \id{j})-th
  element of the dense matrix \id{J} (with \id{i}, \id{j }$= 0\ldots
  \id{N}-1$). This macro is meant for small problems for which efficiency
  of access is not a major concern.  Thus, in terms of the indices $m$
  and $n$ ranging from $1$ to $N$, the Jacobian element $J_{m,n}$ can
  be set using the statement \id{SM\_ELEMENT\_D(J, m-1, n-1) =}
  $J_{m,n}$.  Alternatively, \id{SM\_COLUMN\_D(J, j)} returns a
  pointer to the first element of the \id{j}-th column of \id{J}
  (with \id{j }$= 0\ldots \id{N}-1$), and the elements of the \id{j}-th column
  can then be accessed using ordinary array indexing.  Consequently,
  $J_{m,n}$ can be loaded using the statements
  \id{col\_n = SM\_COLUMN\_D(J, n-1);} \id{col\_n[m-1] =} $J_{m,n}$.
  For large problems, it is more efficient to use \id{SM\_COLUMN\_D}
  than to use \id{SM\_ELEMENT\_D}.  Note that both of these macros
  number rows and columns starting from $0$.  The {\sunmatdense} type
  and accessor macros are documented in \S\ref{ss:sunmat_dense}.

 {\bf banded}:\\
  A user-supplied banded Jacobian function must load the \id{N} $\times$ \id{N}
  banded matrix \id{J} with an approximation to the Jacobian matrix $J(u)$
  at the point (\id{u}).
  The accessor macros \Id{SM\_ELEMENT\_B},
  \Id{SM\_COLUMN\_B}, and \Id{SM\_COLUMN\_ELEMENT\_B} allow the user
  to read and write banded matrix elements without making specific
  references to the underlying representation of the {\sunmatband}
  type.  \id{SM\_ELEMENT\_B(J, i, j)} references the (\id{i},
  \id{j})-th element of the banded matrix \id{J}, counting from $0$.
  This macro is meant for use in small problems for which efficiency
  of access is not a major concern.  Thus, in terms of the indices $m$
  and $n$ ranging from $1$ to $\id{N}$ with $(m,n)$ within the band defined
  by \id{mupper} and \id{mlower}, the Jacobian element $J_{m,n}$ can
  be loaded using the statement \id{SM\_ELEMENT\_B(J, m-1, n-1) =}
  $J_{m,n}$. The elements within the band are those with \id{-mupper}
  $\le$ \id{m-n} $\le$ \id{mlower}. Alternatively,
  \id{SM\_COLUMN\_B(J, j)} returns a pointer to the diagonal element
  of the \id{j}-th column of \id{J}, and if we assign this address
  to \id{realtype *col\_j}, then the \id{i}-th element of the
  \id{j}-th column is given by
  \id{SM\_COLUMN\_ELEMENT\_B(col\_j, i, j)}, counting from $0$.  Thus,
  for $(m,n)$ within the band, $J_{m,n}$ can be loaded by setting
  \id{col\_n = SM\_COLUMN\_B(J, n-1);} and
  \id{SM\_COLUMN\_ELEMENT\_B(col\_n, m-1, n-1) =} $J_{m,n}$.  The
  elements of the \id{j}-th column can also be accessed via ordinary
  array indexing, but this approach requires knowledge of the
  underlying storage for a band matrix of type {\sunmatband}.
  The array \id{col\_n} can be indexed from $-$\id{mupper} to
  \id{mlower}. For large problems, it is more efficient to use
  \id{SM\_COLUMN\_B} and \id{SM\_COLUMN\_ELEMENT\_B} than to use the
  \id{SM\_ELEMENT\_B} macro.  As in the dense case, these macros all
  number rows and columns starting from $0$.  The {\sunmatband} type
  and accessor macros are documented in \S\ref{ss:sunmat_band}.

  {\bf sparse}:\\
  A user-supplied sparse Jacobian function must load the \id{N} $\times$ \id{N}
  compressed-sparse-column or compressed-sparse-row matrix \id{J}
  with an approximation to the Jacobian matrix $J(u)$
  at the point (\id{u}).
  Storage for \id{J} already exists on entry to
  this function, although the user should ensure that sufficient space
  is allocated in \id{J} to hold the nonzero values to be set; if
  the existing space is insufficient the user may reallocate the data
  and index arrays as needed.  The amount of allocated space in a
  {\sunmatsparse} object may be accessed using the macro
  \Id{SM\_NNZ\_S} or the routine \Id{SUNSparseMatrix\_NNZ}.  The
  {\sunmatsparse} type and accessor macros are documented in
  \S\ref{ss:sunmat_sparse}.

  The previous function type \Id{KINDlsJacFn} is identical to
  \id{KINLsJacFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
\index{Jacobian approximation function!user-supplied|)}

%%==============================================================================
\subsection{Jacobian-vector product (matrix-free linear solvers)}
\label{ss:jtimesFn}
%%==============================================================================
\index{Jacobian approximation function!Jacobian times vector!user-supplied|(}

If a matrix-free linear solver is to be used (i.e., a \id{NULL}-valued
{\sunmatrix} was supplied to \\ \noindent
\id{KINSetLinearSolver}), the user may
provide a function of type \Id{KINLsJacTimesVecFn} in the following
form, to compute products $J v$.  If such a function is not
supplied, the default is a difference quotient approximation of these
products.
%%
\usfunction{KINLsJacTimesVecFn}
{
  typedef int (*KINLsJacTimesVecFn)(&N\_Vector v, N\_Vector Jv, \\
                                    &N\_Vector u, booleantype *new\_u, \\
                                    &void *user\_data);
}
{
  This \id{jtimes} function computes the product $J v$
  (or an approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[v]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[Jv]
      is the computed output vector.
  \item[u]
    is the current value of the dependent variable vector.
  \item[new\_u]
    is a flag, input from {\kinsol} and possibly reset by the user's
    \id{jtimes} function, indicating whether the iterate vector \id{u} has been
    updated since the last call to \id{jtimes}.  This is useful if the \id{jtimes}
    function computes and saves Jacobian data that depends on \id{u} for use in
    computing $J(u)v$.  The input value of \id{new\_u} is \id{SUNTRUE} following an
    update by {\kinsol}, and in that case any saved Jacobian data depending on
    \id{u} should be recomputed.  The \id{jtimes} routine should then set \id{new\_u}
    to \id{SUNFALSE}, so that on subsequent calls to \id{jtimes} with the same \id{u},
    the saved data can be reused.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to \id{KINSetUserData}.
  \end{args}
}
{
  The value returned by the Jacobian-times-vector function should be
  $0$ if successful. If a recoverable failure occurred, the return
  value should be positive.  In this case, {\kinsol} will attempt to
  correct by calling the preconditioner setup function. If this
  information is current, {\kinsol} halts.  If the
  Jacobian-times-vector function encounters an unrecoverable error, it
  should return a negative value, prompting {\kinsol} to halt.
}
{ If a user-defined routine is not given, then an internal \id{jtimes}
  function, using a difference quotient approximation, is used.

  This function must return a value of $J*v$ that uses the {\it current}
  value of $J$, i.e. as evaluated at the current $u$.

  If the user's \id{KINLsJacTimesVecFn} function uses difference quotient
  approximations, it may need to access quantities not in the call list.
  These might include the scale vectors and the unit roundoff.
  To obtain the scale vectors, the user will need to add to \id{user\_data}
  pointers to \id{u\_scale} and/or \id{f\_scale} as needed.
  The unit roundoff can be accessed as \id{UNIT\_ROUNDOFF} defined in
  \id{sundials\_types.h}.

  The previous function type \Id{KINSpilsJacTimesVecFn} is identical to
  \id{KINLsJacTimesVecFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
\index{Jacobian approximation function!Jacobian times vector!user-supplied|)}
%%
%%==============================================================================
\subsection{Preconditioner solve (iterative linear solvers)} \label{ss:psolveFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{KINLS@{\kinls} linear solver interface!preconditioner solve function}

If a user-supplied preconditioner is to be used with a {\sunlinsol}
solver module, then the user must provide a function to solve the
linear system $Pz = r$ where $P$ is the preconditioner matrix,
approximating (at least crudely) the system Jacobian $J =
\partial{F}/\partial{u}$.  This function must be of type
\ID{KINLsPrecSolveFn}, defined as follows:
%%
%%
\usfunction{KINLsPrecSolveFn}
{
  typedef int (*KINLsPrecSolveFn)(&N\_Vector u, N\_Vector uscale,  \\
                                  &N\_Vector fval, N\_Vector fscale,  \\
                                  &N\_Vector v, void *user\_data);
}
{
  This function solves the preconditioning system $Pz = r$.
}
{
  \begin{args}[prec\_data]
  \item[u]
    is the current (unscaled) value of the iterate.
  \item[uscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{u}.
  \item[fval]
    is the vector $F(u)$ evaluated at \id{u}.
  \item[fscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{fval}.
  \item[v]
    on input, \id{v} is set to the right-hand side vector of the linear
    system, \id{r}. On output, \id{v} must contain the solution \id{z} of
    the linear system $Pz=r$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to the function \id{KINSetUserData}.
  \end{args}
}
{
  The value to be returned by the preconditioner solve function is a flag
  indicating whether it was successful.  This value should be $0$ if successful,
  positive for a recoverable error, and negative for an unrecoverable error.
}
{
  If the preconditioner solve function fails recoverably and if the preconditioner
  information (set by the preconditioner setup function) is out of date, {\kinsol}
  attempts to correct by calling the setup function. If the preconditioner data
  is current, {\kinsol} halts.

  The previous function type \Id{KINSpilsPrecSolveFn} is identical to
  \id{KINLsPrecSolveFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%==============================================================================
\subsection{Preconditioner setup (iterative linear solvers)}\label{ss:precondFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{KINLS@{\kinls} linear solver interface!preconditioner setup function}

If the user's preconditioner requires that any Jacobian-related data
be evaluated or preprocessed, then this needs to be done in a
user-supplied function of type \ID{KINLsPrecSetupFn}, defined as follows:
\usfunction{KINLsPrecSetupFn}
{
typedef int (*KINLsPrecSetupFn)(&N\_Vector u, N\_Vector uscale, \\
                                &N\_Vector fval, N\_Vector fscale,\\
                                &void *user\_data);
}
{
  This function evaluates and/or preprocesses Jacobian-related data needed
  by the preconditioner solve function.
}
{
  \begin{args}[prec\_data]
  \item[u]
    is the current (unscaled) value of the iterate.
  \item[uscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{u}.
  \item[fval]
    is the vector $F(u)$ evaluated at \id{u}.
  \item[fscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{fval}.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to the function \id{KINSetUserData}.
  \end{args}
}
{
  The value to be returned by the preconditioner setup function is a flag
  indicating whether it was successful.  This value should be $0$ if successful,
  any other value resulting in halting the {\kinsol} solver.
}
{
  The user-supplied preconditioner setup subroutine should
  compute the right preconditioner matrix $P$ (stored in the memory
  block referenced by the \id{user\_data} pointer) used to form the
  scaled preconditioned linear system
    $$(D_F J(u) P^{-1} D_u^{-1}) \cdot (D_u P x) = - D_F F(u) \, ,$$
   where $D_u$ and $D_F$ denote the diagonal scaling matrices whose
  diagonal elements are stored in the vectors \id{uscale} and
  \id{fscale}, respectively.

  The preconditioner setup routine will not be called prior
  to every call made to the preconditioner solve function, but will instead be
  called only as often as necessary to achieve convergence of the
  Newton iteration.

  If the user's \id{KINLsPrecSetupFn} function uses difference quotient
  approximations, it may need to access quantities not in the call list.
  These might include the scale vectors and the unit roundoff.
  To obtain the scale vectors, the user will need to add to \id{user\_data}
  pointers to \id{u\_scale} and/or \id{f\_scale} as needed.
  The unit roundoff can be accessed as \id{UNIT\_ROUNDOFF} defined in
  \id{sundials\_types.h}.

  If the preconditioner solve routine requires no preparation, then a
  preconditioner setup function need not be given.

  The previous function type \Id{KINSpilsPrecSetupFn} is identical to
  \id{KINLsPrecSetupFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%==============================================================================
\section{A parallel band-block-diagonal preconditioner module}
\label{sss:kinbbdpre}
%%==============================================================================
The efficiency of Krylov iterative methods for the solution of linear systems
can be greatly enhanced through preconditioning. For problems in which the
user cannot define a more effective, problem-specific preconditioner,
{\kinsol} provides a band-block-diagonal preconditioner module {\kinbbdpre},
to be used with the parallel \id{N\_Vector} module described in \S\ref{ss:nvec_par}.

This module provides a preconditioner matrix for {\kinsol} that
is block-diagonal with banded blocks. The blocking corresponds
to the distribution of the dependent variable vector $u$ amongst
the processes. Each preconditioner block is generated from
the Jacobian of the local part (associated with the current
process) of a given function $G(u)$ approximating $F(u)$
($G = F$ is allowed). The blocks are generated by each process via a
difference quotient scheme, utilizing a specified band structure.
This structure is given by upper and lower half-bandwidths, \id{mudq}
and \id{mldq}, defined as the number of non-zero diagonals above and
below the main diagonal, respectively.  However, from the resulting
approximate Jacobain blocks, only a matrix of bandwidth \id{mukeep} $+$
\id{mlkeep} $+ 1$ is retained.

Neither pair of parameters need be the true half-bandwidths of the Jacobian
of the local block of $G$, if smaller values provide a more efficient
preconditioner.  Such an efficiency gain may occur if the couplings
in the system outside a certain bandwidth are considerably weaker than
those within the band.  Reducing \id{mukeep} and \id{mlkeep} while keeping
\id{mudq} and \id{mldq} at their true values, discards the elements
outside the narrower band.  Reducing both pairs has the additional
effect of lumping the outer Jacobian elements into the computed elements
within the band, and requires more caution and experimentation to see
whether the lower cost of narrower band matrices offsets the loss of
accuracy in the blocks.

\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-supplied functions|(}
The {\kinbbdpre} module calls two user-provided functions to construct $P$:
a required function \id{Gloc} (of type \id{KINBBDLocalFn}) which
approximates the nonlinear system function $G(u) \approx F(u)$ and which
is computed locally, and an optional function \id{Gcomm} (of type \id{KINBBDCommFn})
which performs all interprocess communication necessary to evaluate
the approximate function $G$.
These are in addition to the user-supplied nonlinear system function that
evaluates $F(u)$.
Both functions take as input the same pointer \id{user\_data} as that passed
by the user to \id{KINSetUserData} and passed to the user's function \id{func},
and neither function has a return value. The user is responsible for
providing space (presumably within \id{user\_data}) for components of \id{u}
that are communicated by \id{Gcomm} from the other processes, and that are
then used by \id{Gloc}, which should not do any communication.
%%
%%
\usfunction{KINBBDLocalFn}
{
  typedef int (*KINBBDLocalFn)(&sunindextype Nlocal, N\_Vector u, \\
                               &N\_Vector gval, void *user\_data);
}
{
  This \id{Gloc} function computes $G($\id{u}$)$, and outputs the resulting
  vector as \id{gval}.
}
{
  \begin{args}[user\_data]
  \item[Nlocal]
    is the local vector length.
  \item[u]
    is the current value of the iterate.
  \item[gval]
    is the output vector.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{KINSetUserData}.
  \end{args}
}
{
  A \id{KINBBDLocalFn} function should return 0 if successful or a non-zero
  value if an error occured.
}
{
  This function must assume that all interprocess communication of data needed to
  calculate \id{gval} has already been done, and this data is accessible within
  \id{user\_data}.

  Memory for \id{u} and \id{gval} is handled within the preconditioner module.

  The case where $G$ is mathematically identical to $F$ is allowed.
}
%%
%%
\usfunction{KINBBDCommFn}
{
  typedef int (*KINBBDCommFn)(&sunindextype Nlocal, N\_Vector u, \\
                              &void *user\_data);
}
{
  This \id{Gcomm} function performs all interprocess communications necessary
  for the execution of the \id{Gloc} function above, using the input vector \id{u}.
}
{
  \begin{args}[user\_data]
  \item[Nlocal]
    is the local vector length.
  \item[u]
    is the current value of the iterate.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{KINSetUserData}.
  \end{args}
}
{
  A \id{KINBBDCommFn} function should return 0 if successful or a non-zero
  value if an error occured.
}
{
  The \id{Gcomm} function is expected to save communicated data in space defined
  within the structure \id{user\_data}.

  Each call to the \id{Gcomm} function is preceded by a call to the system function
  \id{func} with the same \id{u} argument.  Thus \id{Gcomm} can omit
  any communications done by \id{func} if relevant to the evaluation of \id{Gloc}.
  If all necessary communication was done in \id{func}, then \id{Gcomm = NULL}
  can be passed in the call to \id{KINBBDPrecInit} (see below).
}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-supplied functions|)}

%%
%% ----------------------------------------
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!usage|(}
%%
Besides the header files required for the solution of a nonlinear problem
(see \S\ref{s:header_sol}),  to use the {\kinbbdpre} module, the main program
must include the header file \id{kinbbdpre.h} which declares the needed
function prototypes.\index{header files}

The following is a summary of the usage of this module and describes the sequence
of calls in the user main program. Steps that are unchanged from the user main
program presented in \S\ref{ss:skeleton_sol} are grayed out.
%%
%%
\index{User main program!KINBBDPRE@{\kinbbdpre} usage}
\begin{Steps}
\item
  \textcolor{gray}{\bf Initialize parallel or multi-threaded environment}

\item
  \textcolor{gray}{\bf Set problem dimensions, etc.}

\item
  \textcolor{gray}{\bf Set vector with initial guess}

\item
  \textcolor{gray}{\bf Create {\kinsol} object}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item
  {\bf Create linear solver object}

  When creating the iterative linear solver object, specify use of
  right preconditioning (\id{PREC\_RIGHT}) as {\kinsol} only supports right preconditioning.

\item \label{i:bbdpre_attach}
  {\bf Attach linear solver module}

\item \label{i:bbdpre_init}
  {\bf Initialize the {\kinbbdpre} preconditioner module}

  Specify the upper and lower half-bandwidth pairs (\id{mudq}, \id{mldq}) and
  (\id{mukeep}, \id{mlkeep}), and call

   \id{
     \begin{tabular}[t]{@{}r@{}l@{}}
       flag = KINBBDPrecInit(&kin\_mem, Nlocal, mudq, mldq, \\
                             &mukeep, mlkeep, dq\_rel\_u, Gloc, Gcomm);
     \end{tabular}
   }

  to allocate memory for and initialize the internal preconditoner data.
  The last two arguments of \id{KINBBDPrecInit} are the two user-supplied
  functions described above.

\item
  \textcolor{gray}{\bf Set optional inputs}

  Note that the user should not overwrite the preconditioner data, setup function,
  or solve function through calls to \id{KINSetPreconditioner}
  optional input functions.

\item
  \textcolor{gray}{\bf Solve problem}

\item
  {\bf Get optional output}

  Additional optional outputs associated with {\kinbbdpre} are available by
  way of two routines described below,
  \id{KINBBDPrecGetWorkSpace} and \id{KINBBDPrecGetNumGfnEvals}.

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item
  \textcolor{gray}{\bf Free solver memory}

\item
  \textcolor{gray}{\bf Free linear solver memory}

\item
  \textcolor{gray}{\bf Finalize MPI, if used}

\end{Steps}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!usage|)}

%%
%% ----------------------------------------
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-callable functions|(}
%%
The user-callable function that initializes {\kinbbdpre} (step \ref{i:bbdpre_init}),
is described in more detail below.
%%
\index{half-bandwidths}
\ucfunction{KINBBDPrecInit}
{
   \begin{tabular}[t]{@{}r@{}l@{}}
     flag = KINBBDPrecInit(&kin\_mem, Nlocal, mudq, mldq, \\
                           &mukeep, mlkeep, dq\_rel\_u, Gloc, Gcomm);
   \end{tabular}
}
{
  The function \ID{KINBBDPrecInit} initializes and allocates
  memory for the {\kinbbdpre} preconditioner.
}
{
  \begin{args}[dq\_rel\_u]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[Nlocal] (\id{sunindextype})
    local vector length.
  \item[mudq] (\id{sunindextype})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldq] (\id{sunindextype})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeep] (\id{sunindextype})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeep] (\id{sunindextype})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dq\_rel\_u] (\id{realtype})
    the relative increment in components of \id{u} used in the difference quotient
    approximations.  The default is \id{dq\_rel\_u}$ = \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dq\_rel\_u}$ = 0.0$.
  \item[Gloc] (\id{KINBBDLocalFn})
    the {\CC} function which computes the approximation $G(u) \approx F(u)$.
  \item[Gcomm] (\id{KINBBDCommFn})
    the optional {\CC} function which performs all interprocess communication required for
    the computation of $G(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINLS\_ILL\_INPUT]
  \item[\id{KINLS\_SUCCESS}]
    The call to \id{KINBBDPrecInit} was successful.
  \item[\id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer was \id{NULL}.
  \item[\Id{KINLS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{KINLS\_LMEM\_NULL}]
    The {\kinls} linear solver interface has not been initialized.
  \item[\Id{KINLS\_ILL\_INPUT}]
    The supplied vector implementation was not compatible with the block band preconditioner.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} to be used in the
  difference-quotient calculation of the approximate Jacobian is negative
  or exceeds the value \id{Nlocal}$-1$, it is replaced with $0$ or
  \id{Nlocal}$-1$ accordingly.

  The half-bandwidths \id{mudq} and \id{mldq} need
  not be the true half-bandwidths of the Jacobian of the local block of $G$,
  when smaller values may provide greater efficiency.

  Also, the half-bandwidths \id{mukeep} and \id{mlkeep} of the retained
  banded approximate Jacobian block may be even smaller, to reduce
  storage and computation costs further.

  For all four half-bandwidths, the values need not be the same for
  every process.
}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-callable functions|)}
%%
\index{optional output!band-block-diagonal preconditioner|(}
\index{KINBBDPRE@{\kinbbdpre} preconditioner!optional output|(}
The following two optional output functions are available for use with
the {\kinbbdpre} module:
%%
\ucfunction{KINBBDPrecGetWorkSpace}
{
  flag = KINBBDPrecGetWorkSpace(kin\_mem, \&lenrwBBDP, \&leniwBBDP);
}
{
  The function \ID{KINBBDPrecGetWorkSpace} returns the local
  {\kinbbdpre} real and integer workspace sizes.
}
{
  \begin{args}[lenrwBBDP]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwBBDP] (\id{long int})
    local number of \id{realtype} values in the {\kinbbdpre} workspace.
  \item[leniwBBDP] (\id{long int})
    local number of integer values in the {\kinbbdpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_PMEM\_NULL]
  \item[\id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer was \id{NULL}.
  \item[\Id{KINLS\_PMEM\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{
  \index{memory requirements!KINBBDPRE@{\kinbbdpre} preconditioner}
  %% In terms of the local vector dimension \id{Nlocal} and
  %% \id{smu} = $\min ( N_l - 1 ,$ \id{mukeep} $+$ \id{mlkeep}$)$, the actual size
  %% of the real workspace is $(2$ \id{mlkeep} $+$ \id{mukeep} $+$ \id{smu} $+2)$ \id{Nlocal}
  %% \id{realtype} words, and the actual size of the integer workspace is
  %% \id{Nlocal} integer words. These values are local to the current processor.

  The workspace requirements reported by this routine correspond only
  to memory allocated within the {\kinbbdpre} module (the banded
  matrix approximation, banded {\sunlinsol} object, temporary vectors).
  These values are local to each process.

  The workspaces referred to here exist in addition to those given by the
  corresponding \id{KINGetLinWorkSpace} function.
}
%%
%%
\ucfunction{KINBBDPrecGetNumGfnEvals}
{
  flag = KINBBDPrecGetNumGfnEvals(kin\_mem, \&ngevalsBBDP);
}
{
  The function \ID{KINBBDPrecGetNumGfnEvals} returns the
  number of calls to the user \id{Gloc} function due to the
  difference quotient approximation of the Jacobian blocks used within
  {\kinbbdpre}'s preconditioner setup function.
}
{
  \begin{args}[ngevalsBBDP]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ngevalsBBDP] (\id{long int})
    the number of calls to the user \id{Gloc} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINLS\_PMEM\_NULL]
  \item[\id{KINLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\id{KINLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer was \id{NULL}.
  \item[\Id{KINLS\_PMEM\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%

\index{KINBBDPRE@{\kinbbdpre} preconditioner!optional output|)}
\index{optional output!band-block-diagonal preconditioner|)}

In addition to the \id{ngevalsBBDP} \id{Gloc} evaluations,
the costs associated with {\kinbbdpre} also include \id{nlinsetups} LU
factorizations, \id{nlinsetups} calls to \id{Gcomm}, \id{npsolves} banded
backsolve calls, and \id{nfevalsLS} right-hand side function evaluations,
where \id{nlinsetups} is an optional {\kinsol} output and \id{npsolves} and
\id{nfevalsLS} are linear solver optional outputs (see \S\ref{ss:optional_output}).

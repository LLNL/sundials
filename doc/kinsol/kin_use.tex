%===================================================================================
\chapter{Using KINSOL for C Applications}\label{c:usage}
%===================================================================================

This chapter is concerned with the use of {\kinsol} for the solution
of nonlinear systems. The following subsections treat the header
files, the layout of the user's main program, description of the
{\kinsol} user-callable routines, and user-supplied functions.
The sample programs described in the companion document
\cite{kinsol_ex} may also be helpful.  Those codes may be used as
templates (with the removal of some lines involved in testing), and
are included in the {\kinsol} package.

Users with applications written in {\F}77 should see Chapter \ref{s:fcmix},
which describes the {\F}/{\C} interface module.

The user should be aware that not all linear solver modules are compatible 
with all {\nvector} implementations. 
\index{KINSOL@{\kinsol} linear solvers!NVECTOR@{\nvector} compatibility}
For example, {\nvecp} is not compatible with the direct dense, direct
band or direct sparse linear solvers since these linear solver modules
need to form the complete 
system Jacobian. The following {\kinsol} modules can only be used with
{\nvecs}, {\nvecopenmp} or {\nvecpthreads}:
{\kindense}, {\kinband}, {\kinklu} and {\kinsuperlumt}. 
It is not recommended to use a threaded vector module with SuperLU\_MT
unless it is the {\nvecopenmp} module, and SuperLU\_MT is also compiled
with openMP.
The preconditioner module {\kinbbdpre} can only be used with {\nvecp}.

{\kinsol} uses various constants for both input and output. These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

%%==============================================================================
\section{Access to library and header files}\label{ss:file_access}
%%==============================================================================

At this point, it is assumed that the installation of {\kinsol},
following the procedure described in Appendix \ref{c:install}, has
been completed successfully.

Regardless of where the user's application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
{\kinsol}.  The relevant library files are
\begin{itemize}
\item {\em libdir}\id{/libsundials\_kinsol.}{\em lib},
\item {\em libdir}\id{/libsundials\_nvec*.}{\em lib} (one to four files),
\end{itemize}
where the file extension .{\em lib} is typically \id{.so} for shared libraries
and \id{.a} for static libraries. The relevant header files are located in
the subdirectories
\begin{itemize}
\item {\em incdir}\id{/include}
\item {\em incdir}\id{/include/kinsol}
\item {\em incdir}\id{/include/sundials}
\end{itemize}
The directories {\em libdir} and {\em incdir} are the install library
and include directories, respectively.  For a default installation,
these are {\em builddir}\id{/lib} and {\em builddir}\id{/include},
respectively, where {\em builddir} was defined in Appendix \ref{c:install}.

%%----------------------------------
\section{Data types}\label{s:types}
%%----------------------------------
\input{types}

%------------------------
\section{Header files}\label{s:header_sol}
%------------------------
\index{header files}
The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%
\begin{itemize}
\item  \Id{kinsol.h}, 
  the header file for {\kinsol}, which defines several
  types and various constants, and includes function prototypes.
\end{itemize}
%
\id{kinsol.h} also includes \Id{sundials\_types.h}, 
which defines the types \id{realtype} and \id{booleantype}
and constants \id{FALSE} and \id{TRUE}.

The calling program must also include an {\nvector} implementation header file
(see Chapter \ref{s:nvector} for details).
For the two {\nvector} implementations that are included in the {\kinsol} package,
the corresponding header files are:
%
\begin{itemize}
\item \Id{nvector\_serial.h}, 
  which defines the serial implementation, {\nvecs};
\item \Id{nvector\_parallel.h}, 
  which defines the parallel {\mpi} implementation, {\nvecp},
\item \Id{nvector\_openmp.h},
  which defines the shared memory parallel openMP implementation,
\item \Id{nvector\_pthreads.h},
  which defines the shared memory parallel Pthreads implementation.
\end{itemize}
%
Note that these files include in turn the header file \Id{sundials\_nvector.h}, which 
defines the abstract \Id{N\_Vector} type. 

Finally, a linear solver module header file is required. 
\index{KINSOL@{\kinsol} linear solvers!header files}
The header files corresponding to the various linear solver options in
{\kinsol} are:
%%
\begin{itemize}
\item \Id{kinsol\_dense.h},
  which is used with the dense direct linear solver;

\item \Id{kinsol\_band.h}, 
  which is used with the band direct linear solver;

\item \Id{kinsol\_lapack.h},
  which is used with Lapack implementations of dense or band direct linear solvers;

\item \Id{kinsol\_klu.h},
  which is used with the KLU sparse direct linear solver;

\item \Id{kinsol\_superlumt.h},
  which is used with the SuperLU\_MT threaded sparse direct linear solver;

\item \Id{kinsol\_spgmr.h}, 
  which is used with the Krylov solver {\spgmr};

\item \Id{kinsol\_spfgmr.h}, 
  which is used with the Krylov solver {\spfgmr};

\item \Id{kinsol\_spbcgs.h}, 
  which is used with the Krylov solver {\spbcg};

\item \Id{kinsol\_sptfqmr.h}, 
  which is used with the Krylov solver {\sptfqmr};

\end{itemize}

The header files for the dense and banded linear solvers (both
internal and Lapack) include the file \id{kinsol\_direct.h} which
defines common functions.  This in turn includes a file
(\id{sundials\_direct.h}) which defines the matrix type for these
direct linear solvers (\id{DlsMat}), as well as various functions and
macros acting on such matrices.

The header files for the KLU and SuperLU\_MT sparse linear solvers
include the file \id{kinsol\_sparse.h}, which defines common functions.
This in turn includes a file (\id{sundials\_sparse.h}) which defines
the matrix type for these sparse direct linear solvers (\id{SlsMat}),
as well as various functions and macros acting on such matrices.

The header files for the Krylov iterative solvers include
\id{kinsol\_spils.h} which defined common functions and which in turn
includes a header file (\id{sundials\_iterative.h}) which enumerates
the kind of preconditioning and for the choices for the Gram-Schmidt
process for {\spgmr}.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, in the \id{kinFoodWeb\_kry\_p}
example (see \cite{kinsol_ex}), preconditioning is done with a
block-diagonal matrix. For this, even though the {\kinspgmr} linear
solver is used, the header \id{sundials\_dense.h} is included for
access to the underlying generic dense linear solver.

%--------------------------------------------------------------------
\section{A skeleton of the user's main program}\label{s:skeleton_sol}
%--------------------------------------------------------------------

The following is a skeleton of the user's main program (or calling
program) for the solution of a nonlinear problem. 
Some steps are independent of the {\nvector} implementation used; 
where this is not the case, usage specifications are given for the implementations 
provided with {\kinsol}: Steps marked {\p} correspond to 
{\nvecp}, steps marked {\omp} correspond to {\nvecopenmp}, steps
marked {\pt} correspond to {\nvecpthreads}, while steps marked {\s}
correspond to {\nvecs}.
%%
%%
\index{User main program!KINSOL@{\kinsol} usage}
\begin{Steps}
  
\item 
  {\bf {\p} Initialize MPI}

  Call \id{MPI\_Init(\&argc, \&argv)} to initialize {\mpi} if used by
  the user's program, aside from the internal use in {\nvecp}.  
  Here \id{argc} and \id{argv} are the command line argument 
  counter and array received by \id{main}.
  
\item
  {\bf Set problem dimensions}

  {\s, \omp, \pt} Set \id{N}, the problem size $N$.

  {\omp, \pt} Set \id{num\_threads}, the number of threads to use within
  the threaded vector functions.

  {\p} Set \id{Nlocal}, the local vector length (the sub-vector length for this process).
  Set \id{N}, the global vector length (the problem size $N$, and the sum of all the
  values of \id{Nlocal}).  Set the active set of processes.

  Note: The variables \id{N} and \id{Nlocal} should be of type
  \id{long int}.  The variable \id{num\_threads} should be of type \id{int}.

\item
  {\bf Set vector with initial guess}
 
  To set the vector \id{u} of initial values, use functions defined by a
  particular {\nvector} implementation.  If a \id{realtype} array  \id{udata}
  already exists, containing the initial guess of $u_0$, make the call:

  {\s} \id{u = N\_VMake\_Serial(N, udata);}

  {\omp} \id{y0 = N\_VMake\_OpenMP(N, num\_threads, ydata);}

  {\pt} \id{y0 = N\_VMake\_Pthreads(N, num\_threads, ydata);}

  {\p} \id{u = N\_VMake\_Parallel(comm, Nlocal, N, udata);}

  Otherwise, make the call:

  {\s} \id{u = N\_VNew\_Serial(N);}

  {\omp} \id{y0 = N\_VNew\_OpenMP(N, num\_threads);}

  {\pt} \id{y0 = N\_VNew\_Pthreads(N, num\_threads);}

  {\p} \id{u = N\_VNew\_Parallel(comm, Nlocal, N);}

  and load initial values into the structure defined by:

  {\s} \id{NV\_DATA\_S(u)}

  {\omp} \id{NV\_DATA\_OMP(y0)}

  {\pt} \id{NV\_DATA\_PT(y0)}

  {\p} \id{NV\_DATA\_P(u)}

  Here \id{comm} is the {\mpi} communicator, set in one of two ways: 
  If a proper subset of active processes is to be used, \id{comm} 
  must be set by suitable {\mpi} calls. Otherwise, to specify that all 
  processes are to be used, \id{comm} must be \id{MPI\_COMM\_WORLD}.
  
\item\label{i:kinsol_create} 
  {\bf Create {\kinsol} object}

  Call \id{kin\_mem = KINCreate()} to create the {\kinsol} memory block.
  \id{KINCreate} returns a pointer to the {\kinsol} memory structure.
  See \S\ref{sss:kinmalloc} for details.

\item
  {\bf Set optional inputs}

  Call \id{KINSet*} routines to change from their default values any
  optional inputs that control the behavior of {\kinsol}.
  See \S\ref{ss:optional_input} for details.

\item\label{i:kinsol_malloc} 
  {\bf Allocate internal memory}

  Call \id{KINInit(...)} 
  to specify the problem defining function $F$,
  allocate internal memory for {\kinsol}, 
  and initialize {\kinsol}.
  \id{KINInit} returns a flag to indicate success or an illegal argument value.
  See \S\ref{sss:kinmalloc} for details.

\item\label{i:lin_solver} 
  {\bf Attach linear solver module}

  Initialize the linear solver module with one of the following calls
  (for details see \S\ref{sss:lin_solv_init}).

  {\s, \omp, \pt} \id{ier = }\Id{KINDense}\id{(...);}

  {\s, \omp, \pt} \id{ier = }\Id{KINBand}\id{(...);}

  {\s, \omp, \pt} \id{ier = }\Id{KINLapackDense}\id{(...);}

  {\s, \omp, \pt} \id{ier = }\Id{KINLapackBand}\id{(...);}

  {\s, \omp, \pt} \id{ier = }\Id{KINKLU}\id{(...);}

  {\s, \omp, \pt} \id{ier = }\Id{KINSuperLUMT}\id{(...);}

  \id{ier = }\Id{KINSpgmr}\id{(...);}
  
  \id{ier = }\Id{KINSpfgmr}\id{(...);}
  
  \id{ier = }\Id{KINSpbcg}\id{(...);}
  
  \id{ier = }\Id{KINSptfqmr}\id{(...);}
  
\item
  {\bf Set linear solver optional inputs}

  Call \id{KIN*Set*} functions from the selected linear solver module to
  change optional inputs specific to that linear solver.
  See \S\ref{ss:optional_input} for details.

\item
  {\bf Solve problem}

  Call \id{ier = }\Id{KINSol}\id{(...)} to solve the nonlinear problem for a given
  initial guess. See \S\ref{sss:kinsol} for details.

\item
  {\bf Get optional outputs}

  Call \id{KINGet*} and \id{KIN*Get*} functions to obtain optional output.
  See \S\ref{ss:optional_output} for details.

\item
  {\bf Deallocate memory for solution vector}

  Upon completion of the solution, deallocate memory for the vector \id{u}
  by calling the destructor function defined by the {\nvector} implementation:

  {\s} \id{N\_VDestroy\_Serial(u);}

  {\omp} \id{N\_VDestroy\_OpenMP(y);}

  {\pt} \id{N\_VDestroy\_Pthreads(y);}

  {\p} \id{N\_VDestroy\_Parallel(u);}
  
\item
  {\bf Free solver memory}

  Call \id{KINFree(\&kin\_mem)} to free the memory allocated for {\kinsol}.
  
\item 
  {\bf {\p} Finalize MPI}

  Call \id{MPI\_Finalize()} to terminate {\mpi}.
  
\end{Steps}

%%==============================================================================

\section{User-callable functions}\label{s:kinsol_fct_sol}

This section describes the {\kinsol} functions that are called by the
user to set up and solve a nonlinear problem. Some of these are required. 
However, starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs can be
skipped for a casual use of {\kinsol}. In any case, refer to
\S\ref{s:skeleton_sol} for the correct order of these calls.

The return flag (when present) for each of these routines is a
negative integer if an error occurred, and non-negative otherwise.

%%-------------------------------------------------------------------------------

\subsection{KINSOL initialization and deallocation functions}
\label{sss:kinmalloc}

The following three functions must be called in the order listed. The last one
is to be called only after the problem solution is complete, as it frees the
{\kinsol} memory block created and allocated by the first two calls.
%%
\ucfunction{KINCreate}
{
  kin\_mem = KINCreate();
}
{
  The function \ID{KINCreate} instantiates a {\kinsol} solver object.
}
{
  This function has no arguments.
}
{
  If successful, \id{KINCreate} returns a pointer to the newly created 
  {\kinsol} memory block (of type \id{void *}).
  If an error occurred, \id{KINCreate} prints an error message to \id{stderr}
  and returns \id{NULL}.
}
{}
%%
%%
\ucfunction{KINInit}
{
flag = KINInit(kin\_mem, func, tmpl);
}
{
  The function \ID{KINInit} specifies the problem-defining
  function, allocates internal memory, and initializes {\kinsol}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block returned by \id{KINCreate}.
  \item[func] (\Id{KINSysFn})
    is the {\C} function which computes the system function $F$ 
    (or $G(u)$ for fixed-point iteration) in the nonlinear
    problem.  This function has the form \id{func(u, fval, user\_data)}. 
    (For full details see \S\ref{ss:sysFn}.)
  \item[tmpl] (\id{N\_Vector})
    is any \id{N\_Vector} (e.g. the initial guess vector \id{u}) which is used
    as a template to create (by cloning) necessary vectors in \id{kin\_mem}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}]
    The call to \id{KINInit} was successful.
  \item[\Id{KIN\_MEM\_NULL}] 
    The {\kinsol} memory block was not initialized through a previous call
    to \id{KINCreate}.
  \item[\Id{KIN\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{KIN\_ILL\_INPUT}] 
    An input argument to \id{KINInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{KINInit} sends an error message to the
  error handler function.
}
%%
%%
\ucfunction{KINFree}
{
  KINFree(\&kin\_mem);
}
{
  The function \ID{KINFree} frees the memory allocated by
  a previous call to \id{KINCreate}.
}
{
  The argument is the address of the pointer to the {\kinsol} memory block
  returned by \id{KINCreate} (of type \id{void *}).
}
{
  The function \id{KINFree} has no return value.
}
{}
%%

%%-------------------------------------------------------------------------------

\subsection{Linear solver specification functions}\label{sss:lin_solv_init}

As previously explained, Newton and Picard iterations require the solution of
linear systems of the form $J\delta = -F$. There are several {\kinsol} linear
solvers currently available for this task: {\kindense}, {\kinband},
{\kinklu}, {\kinsuperlumt}, {\kinspgmr}, {\kinspfgmr}, {\kinspbcg}, and {\kinsptfqmr}.

The first two linear solvers are direct and derive their names from the
type of approximation used for the Jacobian $J = \partial{F}/\partial{u}$;
{\kindense} and {\kinband} work with dense and banded approximations
to $J$, respectively.  The {\sundials} suite includes both internal
implementations of these two linear solvers and interfaces to Lapack
implementations.  Together, these linear solvers are referred to as
{\kindls} (from Direct Linear Solvers).

The second two linear solvers are sparse direct solvers based on
Gaussian elimination, and require user-supplied routines to construct
the linear system matrix (in the case of Newton's method, this is the 
Jacobian $J = \partial{F}/\partial{u}$) in compressed-sparse-column
format. The {\sundials} suite does not include internal
implementations of these solver libraries, instead requiring
compilation of {\sundials} to link with existing installations of
these libraries (if either is missing, {\sundials} will install
without the corresponding interface routines).  Together, these linear
solvers are referred to as {\kinsls} (from Sparse Linear Solvers). 

The remaining {\kinsol} linear solvers --- {\kinspgmr}, {\kinspfgmr}, {\kinspbcg},
and {\kinsptfqmr} --- are Krylov iterative solvers, which use scaled
preconditioned GMRES, scaled preconditioned Flexible GMRES,
scaled preconditioned Bi-CGStab, and scaled
preconditioned TFQMR, respectively.  Together, they are referred to as
{\kinspils} (from Scaled Preconditioned Iterative Linear Solvers).

With any of the Krylov solvers, only right preconditioning is available.
For specification of the preconditioner, see the Krylov solver sections
within \S\ref{ss:optional_input} and \S\ref{ss:user_fct_sol}.
If preconditioning is done, user-supplied functions define the right
preconditioner matrix $P$, which should approximate the system
Jacobian matrix $J$.

\index{KINSOL{\kinsol} linear solvers!selecting one|(}
To specify a {\kinsol} linear solver, after the call to \id{KINCreate}
but before any calls to \id{KINSol}, the user's program must call one of
the functions \Id{KINDense}/\Id{KINLapackDense}, \Id{KINBand}/\Id{KINLapackBand},
\Id{KINKLU}, \Id{KINSuperLUMT}, \Id{KINSpgmr}, \Id{KINSpfgmr}, \Id{KINSpbcg}, or
\Id{KINSptfqmr}, as documented below. 
The first argument passed to these functions is the {\kinsol}
memory pointer returned by \id{KINCreate}. A call to one of these
functions links the main {\kinsol} nonlinear solver to a linear solver and
allows the user to specify parameters which are specific to a
particular solver, such as the half-bandwidths in the {\kinband} case.
%%
The use of each of the linear solvers involves certain constants and possibly 
some macros, that are likely to be needed in the user code.  These are
available in the corresponding header file associated with the linear
solver, as specified below.
\index{KINSOL@{\kinsol} linear solvers!selecting one|)}

\index{KINSOL@{\kinsol} linear solvers!built on generic solvers|)}
In each case, the linear solver module used by {\kinsol} is actually
built on top of a generic linear system solver, which may be of
interest in itself. These generic solvers, denoted {\dense}, {\band},
{\klu}, {\superlumt}, {\spgmr}, {\spfgmr}, {\spbcg}, and {\sptfqmr},
are described separately in Chapter \ref{s:gen_linsolv}.
\index{KINSOL@{\kinsol} linear solvers!built on generic solvers|)}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINDENSE@{\kindense}}
\index{KINDENSE@{\kindense} linear solver!selection of}
\index{KINDENSE@{\kindense} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{KINDense}
{
  flag = KINDense(kin\_mem, N);
}
{
  The function \ID{KINDense} selects the {\kindense} linear solver and indicates
  the use of the internal direct dense linear algebra functions. 

  The user's main program must include the \id{kinsol\_dense.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_ILL\_INPUT]
  \item[\Id{KINDLS\_SUCCESS}] 
    The {\kindense} initialization was successful.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_ILL\_INPUT}]
    The {\kindense} solver is not compatible with the current {\nvector} module.
  \item[\Id{KINDLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\kindense} linear solver is not compatible with all
  implementations of the {\nvector} module.  Of the {\nvector} modules
  provided with {\sundials}, only {\nvecs}, {\nvecopenmp} and
  {\nvecpthreads} are compatible, while {\nvecp} is not.
}
%%
%%
\ucfunction{KINLapackDense}
{
  flag = KINLapackDense(kin\_mem, N);
}
{
  The function \ID{KINLapackDense} selects the {\kindense} linear solver and 
  indicates the use of Lapack functions. 

  The user's main program must include the \id{kinsol\_lapack.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[N] (\id{int})
    problem dimension.
  \end{args}
}
{
  The values of the returned \id{flag} (of type \id{int}) are identical
  to those of \id{KINDense}.
}
{
  Note that \id{N} is restricted to be of type \id{int} here, because
  of the corresponding type restriction in the Lapack solvers.
}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINBAND@{\kinband}}
\index{KINBAND@{\kinband} linear solver!selection of}
\index{KINBAND@{\kinband} linear solver!NVECTOR@{\nvector} compatibility}
\index{half-bandwidths}
\ucfunction{KINBand}
{
  flag = KINBand(kin\_mem, N, mupper, mlower);
}
{
  The function \ID{KINBand} selects the {\kinband} linear solver and indicates
  the use of the internal direct band linear algebra functions.

  The user's main program must include the \id{kinsol\_band.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[N] (\id{long int})
    problem dimension.
  \item[mupper] (\id{long int})
    upper half-bandwidth of the problem Jacobian (or of the approximation of it).
  \item[mlower] (\id{long int})
    lower half-bandwidth of the problem Jacobian (or of the approximation of it).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_ILL\_INPUT]
  \item[\Id{KINDLS\_SUCCESS}] 
    The {\kinband} initialization was successful.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_ILL\_INPUT}]
    The {\kinband} solver is not compatible with the current {\nvector} module, or
    one of the Jacobian half-bandwidths is outside its valid range
    ($0 \ldots$ \id{N}$-1$).
  \item[\Id{KINDLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\kinband} linear solver is not compatible with all
  implementations of the {\nvector} module.  Of the {\nvector} modules
  provided with {\sundials}, only {\nvecs}, {\nvecopenmp} and
  {\nvecpthreads} are compatible, while {\nvecp} is not.
  The half-bandwidths are to be set so that the nonzero locations $(i,j)$ in the
  banded (approximate) Jacobian satisfy $-$\id{mlower} $\leq j-i \leq$ \id{mupper}.
}
%%
\ucfunction{KINLapackBand}
{
  flag = KINLapackBand(kin\_mem, N, mupper, mlower);
}
{
  The function \ID{KINLapackBand} selects the {\kinband} linear solver and
  indicates the use of Lapack functions. 

  The user's main program must include the \id{kinsol\_lapack.h} header file.
}
{
  The input arguments are identical to those of \id{KINBand}, except
  that \id{N}, \id{mupper}, and \id{mlower} are of type \id{int} here.
}
{
  The values of the returned \id{flag} (of type \id{int}) are identical
  to those of \id{KINBand}.
}
{
  Note that \id{N}, \id{mupper}, and \id{mlower} are restricted to be of type \id{int}
  here, because of the corresponding type restriction in the Lapack solvers.
}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINKLU@{\kinklu}}
\index{KINKLU@{\kinklu} linear solver!selection of}
\index{KINKLU@{\kinklu} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{KINKLU}
{
  flag = KINKLU(kin\_mem, N, NNZ);
}
{
  The function \ID{KINKLU} selects the {\kinklu} linear solver and indicates
  the use of sparse-direct linear algebra functions. 

  The user's main program must include the \id{kinsol\_klu.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[N] (\id{int})
    problem dimension.
  \item[NNZ] (\id{int})
    problem dimension.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_ILL\_INPUT]
  \item[\Id{KINSLS\_SUCCESS}] 
    The {\kinklu} initialization was successful.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_ILL\_INPUT}]
    The {\kinklu} solver is not compatible with the current {\nvector} module.
  \item[\Id{KINSLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{KINSLS\_PACKAGE\_FAIL}]
    A call to the KLU library returned a failure flag.
  \end{args}
}
{
  The {\kinklu} linear solver is not compatible with all
  implementations of the {\nvector} module.  Of the {\nvector} modules
  provided with {\sundials}, only {\nvecs}, {\nvecopenmp} and
  {\nvecpthreads} are compatible, while {\nvecp} is not.
}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINSUPERLUMT@{\kinsuperlumt}}
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!selection of}
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!NVECTOR@{\nvector} compatibility}
\ucfunction{KINSuperLUMT}
{
  flag = KINSuperLUMT(kin\_mem, num\_threads, N, NNZ);
}
{
  The function \ID{KINSuperLUMT} selects the {\kinsuperlumt} linear solver and indicates
  the use of sparse-direct linear algebra functions.

  The user's main program must include the \id{kinsol\_superlumt.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[num\_threads] (\id{int})
    the number of threads to use when factoring the linear systems.  
    Note that SuperLU\_MT is thread-parallel only in the factorization routine.
  \item[N] (\id{int})
    problem dimension.
  \item[NNZ] (\id{int})
    maximum number of nonzero entries in the system Jacobian.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_ILL\_INPUT]
  \item[\Id{KINSLS\_SUCCESS}] 
    The {\kinsuperlumt} initialization was successful.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_ILL\_INPUT}]
    The {\kinsuperlumt} solver is not compatible with the current {\nvector} module.
  \item[\Id{KINSLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{KINSLS\_PACKAGE\_FAIL}]
    A call to the SuperLU\_MT library returned a failure flag.
  \end{args}
}
{
  The {\kinsuperlumt} linear solver is not compatible with all
  implementations of the {\nvector} module.  Of the {\nvector} modules
  provided with {\sundials}, only {\nvecs}, {\nvecopenmp} and
  {\nvecpthreads} are compatible, while {\nvecp} is not.
  
  {\warn}Performance will significantly degrade if the user applies the SuperLU\_MT
  package compiled with PThreads while using the {\nvecopenmp} module.
  If a user wants to use a threaded vector kernel with this thread-parallel
  solver, then SuperLU\_MT should be compiled with openMP and the {\nvecopenmp}
  module should be used.  Also, note that the expected benefit of using the threaded
  vector kernel is minimal compared to the potential benefit of the threaded solver,
  unless very long (greater than 100,000 entries) vectors are used.
}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINSPGMR@{\kinspgmr}}
\index{KINSPGMR@{\kinspgmr} linear solver!selection of}
\ucfunction{KINSpgmr}
{
  flag = KINSpgmr(kin\_mem, maxl);
}
{
  The function \ID{KINSpgmr} selects the {\kinspgmr} linear solver.

  The user's main program must include the \id{kinsol\_spgmr.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_ILL\_INPUT]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The {\kinspgmr} initialization was successful.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINSPFGMR@{\kinspfgmr}}
\index{KINSPFGMR@{\kinspfgmr} linear solver!selection of}
\ucfunction{KINSpfgmr}
{
  flag = KINSpfgmr(kin\_mem, maxl);
}
{
  The function \ID{KINSpfgmr} selects the {\kinspfgmr} linear solver.

  The user's main program must include the \id{kinsol\_spfgmr.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_ILL\_INPUT]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The {\kinspfgmr} initialization was successful.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINSPBCG@{\kinspbcg}}
\index{KINSPBCG@{\kinspbcg} linear solver!selection of}
\ucfunction{KINSpbcg}
{
  flag = KINSpbcg(kin\_mem, maxl);
}
{
  The function \ID{KINSpbcg} selects the {\kinspbcg} linear solver.

  The user's main program must include the \id{kinsol\_spbcgs.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_ILL\_INPUT]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The {\kinspbcg} initialization was successful.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}
%%
%%
%%
\index{KINSOL@{\kinsol} linear solvers!KINSPTFQMR@{\kinsptfqmr}}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!selection of}
\ucfunction{KINSptfqmr}
{
  flag = KINSptfqmr(kin\_mem, maxl);
}
{
  The function \ID{KINSptfqmr} selects the {\kinsptfqmr} linear solver.

  The user's main program must include the \id{kinsol\_sptfqmr.h} header file.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxl] (\id{int})
    maximum dimension of the Krylov subspace to be used. Pass $0$ to use the 
    default value \id{KINSPILS\_MAXL}$=5$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_ILL\_INPUT]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The {\kinsptfqmr} initialization was successful.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_ILL\_INPUT}]
    The {\nvector} module used does not implement a required operation.
  \item[\Id{KINSPILS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{}

%--------------------------------------------------------------------
\subsection{KINSOL solver function}\label{sss:kinsol}
%--------------------------------------------------------------------

This is the central step in the solution process, the call to solve
the nonlinear algebraic system.
%
\ucfunction{KINSol}
{
  flag = KINSol(kin\_mem, u, strategy, u\_scale, f\_scale);
}
{
  The function \ID{KINSol} computes an approximate solution to the nonlinear
  system.
}
{
  \begin{args}[strategy]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[u] (\id{N\_Vector})
    vector set to initial guess by user before calling \id{KINSol},
    but which upon return contains an approximate solution of
    the nonlinear system $F(u) = 0$.
  \item[strategy] (\id{int})
    strategy used to solve the nonlinear system. It must be of the following: \\
    \ID{KIN\_NONE}  basic Newton iteration \\
    \ID{KIN\_LINESEARCH} Newton with globalization \\
    \ID{KIN\_FP} fixed-point iteration with Anderson Acceleration \\
    \ID{KIN\_PICARD} Picard iteration with Anderson Acceleration \\
  \item[u\_scale] (\id{N\_Vector})
    vector containing diagonal elements of scaling matrix $D_u$ for vector \id{u}
    chosen so that the components of $D_u \cdot$\id{u}
    (as a matrix multiplication) all have roughly the same magnitude when 
    \id{u} is close to a root of $F(u)$.
  \item[f\_scale] (\id{N\_Vector})
    vector containing diagonal elements of scaling matrix $D_F$ for $F(u)$ chosen 
    so that the components of $D_F \cdot F($\id{u}$)$ 
    (as a matrix multiplication) all have roughly the same magnitude when 
    \id{u} is not too near a root of $F(u)$. In the case of a fixed-point
    iteration, consider $F(u) = G(u) - u$.
  \end{args}
}
{
  On return, \id{KINSol} returns the approximate solution in the vector \id{u}
  if successful.  The return value \id{flag} (of type \id{int}) will be one of
  the following:
  \begin{args}[a]

  \item[\Id{KIN\_SUCCESS}]\rule{0pt}{0pt}

    \id{KINSol} succeeded; the scaled norm of $F(u)$ is less than \id{fnormtol}.

  \item[\Id{KIN\_INITIAL\_GUESS\_OK}]\rule{0pt}{0pt}

    The guess \id{u} $=u_0$ satisfied the system $F(u)=0$
    within the tolerances specified.

  \item[\Id{KIN\_STEP\_LT\_STPTOL}]\rule{0pt}{0pt}

    {\kinsol} stopped based on scaled step length.
    This means that the current iterate may be an approximate solution of the given
    nonlinear system, but it is also quite possible that the algorithm is ``stalled" 
    (making insufficient progress) near an invalid solution, or that the 
    scalar \id{scsteptol} is too large (see \id{KINSetScaledStepTol} in 
    \S\ref{ss:optional_input} to change \id{scsteptol} from its default value).

  \item[\Id{KIN\_MEM\_NULL}]\rule{0pt}{0pt}

    The {\kinsol} memory block pointer was \id{NULL}.
 
  \item[\Id{KIN\_ILL\_INPUT}]\rule{0pt}{0pt}

    An input parameter was invalid.

  \item[\Id{KIN\_NO\_MALLOC}]\rule{0pt}{0pt}

    The {\kinsol} memory was not allocated by a call to \id{KINCreate}.

  \item[\Id{KIN\_LINESEARCH\_NONCONV}]\rule{0pt}{0pt}

    The line search algorithm was unable to find an iterate sufficiently distinct
    from the current iterate, or could not find an iterate satisfying
    the sufficient decrease condition.
    
    Failure to satisfy the sufficient decrease condition could mean the current
    iterate is ``close" to an approximate solution of the given nonlinear system,
    the difference approximation of the matrix-vector product $J(u) v$ is inaccurate,
    or the real scalar \id{scsteptol} is too large.
 
  \item[\Id{KIN\_MAXITER\_REACHED}] \rule{0pt}{0pt}

    The maximum number of nonlinear iterations has been reached.
 
  \item[\Id{KIN\_MXNEWT\_5X\_EXCEEDED}]\rule{0pt}{0pt}
    
    Five consecutive steps have been taken that satisfy the inequality
    $\|D_u p\|_{L2} > 0.99 \,$ \id{mxnewtstep}, where $p$ denotes the current step
    and \id{mxnewtstep} is a scalar upper bound on the scaled step length.
    Such a failure may mean that $\|D_F F(u)\|_{L2}$ asymptotes from above to a
    positive value, or the real scalar \id{mxnewtstep} is too small.
 
  \item[\Id{KIN\_LINESEARCH\_BCFAIL}]\rule{0pt}{0pt}

    The line search algorithm was unable to satisfy the ``beta-condition'' for
    \id{MXNBCF} $+ 1$ nonlinear iterations (not necessarily consecutive),
    which may indicate the algorithm is making poor progress.
 
  \item[\Id{KIN\_LINSOLV\_NO\_RECOVERY}]\rule{0pt}{0pt}

    The user-supplied routine \id{psolve} encountered a recoverable error, but
    the preconditioner is already current.
 
  \item[\Id{KIN\_LINIT\_FAIL}]\rule{0pt}{0pt}

    The linear solver initialization routine (\id{linit}) encountered an error.
 
  \item[\Id{KIN\_LSETUP\_FAIL}]\rule{0pt}{0pt}

    The user-supplied routine \id{pset} (used to set up the preconditioner data)
    encountered an unrecoverable error.
 
  \item[\Id{KIN\_LSOLVE\_FAIL}]\rule{0pt}{0pt}

    Either the user-supplied routine \id{psolve} (used to to solve the preconditioned
    linear system) encountered an unrecoverable error, or the linear solver routine
    (\id{lsolve}) encountered an error condition.

  \item[\Id{KIN\_SYSFUNC\_FAIL}]\rule{0pt}{0pt}

    The system function failed in an unrecoverable manner.

  \item[\Id{KIN\_FIRST\_SYSFUNC\_ERR}]\rule{0pt}{0pt}

    The system function failed recoverably at the first call.

  \item[\Id{KIN\_REPTD\_SYSFUNC\_ERR}]\rule{0pt}{0pt}

    The system function had repeated recoverable errors. No recovery is possible.

 
  \end{args}
}
{
  The components of vectors \id{u\_scale} and \id{f\_scale} should be strictly positive.
  
  \id{KIN\_SUCCESS} $=0$, \id{KIN\_INITIAL\_GUESS\_OK} $=1$, and 
  \id{KIN\_STEP\_LT\_STPTOL} $=2$.
  %%
  All remaining return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{KINSol} failures.
}


%%==============================================================================
\subsection{Optional input functions}\label{ss:optional_input}
%%==============================================================================

There are numerous optional input parameters that control the behavior
of the {\kinsol} solver.  {\kinsol} provides functions that can be used
to change these from their default values.  Table \ref{t:optional_input}
lists all optional input functions in {\kinsol} which are then
described in detail in the remainder of this section, beginning with
those for the main {\kinsol} solver and continuing with those for the
linear solver modules. For the most casual use of {\kinsol}, the
reader can skip to \S\ref{ss:user_fct_sol}.

We note that, on error return, all of these functions also send an error message
to the error handler function.\index{error messages}
We also note that all error return values are negative, so a test \id{flag} $<0$
will catch any error.

\begin{table}
\centering
\caption{Optional inputs for {\kinsol}, {\kindense}, {\kinsparse}, and {\kinspils}}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf KINSOL main solver} \\
\hline
Error handler function & \id{KINSetErrHandlerFn} & internal fn. \\
Pointer to an error file & \id{KINSetErrFile} & \id{stderr}  \\
Info handler function & \id{KINSetInfoHandlerFn} & internal fn. \\
Pointer to an info file & \id{KINSetInfoFile} & \id{stdout} \\
Data for problem-defining function & \id{KINSetUserData} & \id{NULL} \\
Verbosity level of output & \id{KINSetPrintLevel} & 0 \\
Max. number of nonlinear iterations & \id{KINSetNumMaxIters} & 200 \\
No initial matrix setup & \id{KINSetNoInitSetup} & \id{FALSE} \\
No residual monitoring${}^{*}$ & \id{KINSetNoResMon} & \id{FALSE} \\
Max. iterations without matrix setup & \id{KINSetMaxSetupCalls} & 10 \\
Max. iterations without residual check${}^{*}$ & \id{KINSetMaxSubSetupCalls} & 5 \\
Form of $\eta$ coefficient & \id{KINSetEtaForm} &  \id{KIN\_ETACHOICE1}\\
Constant value of $\eta$ & \id{KINSetEtaConstValue} &  0.1 \\
Values of $\gamma$ and $\alpha$ & \id{KINSetEtaParams} & 0.9 and 2.0 \\
Values of $\omega_{min}$ and $\omega_{max}$${}^{*}$ & \id{KINSetResMonParams} & 0.00001 and 0.9 \\
Constant value of $\omega$${}^{*}$ & \id{KINSetResMonConstValue} & 0.9 \\
Lower bound on $\epsilon$ & \id{KINSetNoMinEps} & \id{FALSE} \\
Max. scaled length of Newton step & \id{KINSetMaxNewtonStep} & $1000 \| D_u u_0 \|_2$ \\
Max. number of $\beta$-condition failures & \id{KINSetMaxBetaFails} & 10 \\
Rel. error for D.Q. $Jv$ & \id{KINSetRelErrFunc} & $\sqrt{\text{uround}}$ \\
Function-norm stopping tolerance & \id{KINSetFuncNormTol} & uround$^{1/3}$ \\
Scaled-step stopping tolerance & \id{KINSetScaledSteptol} & $\text{uround}^{2/3}$ \\
Inequality constraints on solution & \id{KINSetConstraints} & \id{NULL} \\
Nonlinear system function & \id{KINSetSysFunc} & none \\
Anderson Acceleration subspace size & \id{KINSetMAA} & 0 \\
\hline
\multicolumn{3}{|c|}{\bf KINDLS linear solvers} \\
\hline
Dense Jacobian function & \id{KINDlsSetDenseJacFn} &  DQ \\
Band Jacobian function  & \id{KINDlsSetBandJacFn} & DQ \\
\hline
\multicolumn{3}{|c|}{\bf KINSLS linear solvers} \\
\hline
Sparse Jacobian function & \id{KINSlsSetSparseJacFn} &  none \\
Sparse matrix ordering algorithm & \id{KINKLUSetOrdering} &  1 for \id{COLAMD} \\
Sparse matrix ordering algorithm & \id{KINSuperLUMTSetOrdering} &  3 for \id{COLAMD} \\
\hline
\multicolumn{3}{|c|}{\bf KINSPILS linear solvers} \\
\hline
Max. number of restarts${}^{**}$ & \id{KINSpilsSetMaxRestarts} & 0 \\
Preconditioner functions and data & \id{KINSpilsSetPreconditioner} & \id{NULL}, \id{NULL}, \id{NULL} \\
Jacobian-times-vector function and data & \id{KINSpilsSetJacTimesVecFn} & internal DQ, \\
&&\id{NULL} \\
\hline
\multicolumn{3}{l}{}\\
\multicolumn{3}{l}{${}^{*}$ Only for the {\kindls} linear solvers} \\
\multicolumn{3}{l}{${}^{**}$ Only for {\kinspgmr} and {\kinspfgmr}}\\
\end{tabular}
\end{table}

\subsubsection{Main solver optional input functions}\label{ss:optin_main}
\index{optional input!solver|(}

The calls listed here can be executed in any order. However, if either of the
functions \id{KINSetErrFile} or \id{KINSetErrHandlerFn} is to be called, that
call should be first, in order to take effect for any later error message.
%%
\index{error messages!redirecting}
\ucfunction{KINSetErrFile}
{
flag = KINSetErrFile(kin\_mem, errfp);
}
{
  The function \ID{KINSetErrFile} specifies the pointer to the file
  where all {\kinsol} messages should be directed when the default
  {\kinsol} error handler function is used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}. 

  Passing a value of \id{NULL} disables all future error message output
  (except for the case in which the {\kinsol} memory pointer is \id{NULL}).
  This use of \id{KINSetErrFile} is strongly discouraged.

  {\warn}If \id{KINSetErrFile} is to be called, it should be called before any
  other optional input functions, in order to take effect for any later error message.
}
%%
\index{error message!user-defined handler}
\ucfunction{KINSetErrHandlerFn}
{
flag = KINSetErrHandlerFn(kin\_mem, ehfun, eh\_data);
}
{
  The function \ID{KINSetErrHandlerFn} specifies the optional user-defined function
  to be used in handling error messages.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ehfun] (\id{KINErrHandlerFn})
    is the user's {\C} error handler function (see \S\ref{ss:ehFn}).
  \item[eh\_data] (\id{void *})
    pointer to user data passed to \id{ehfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The function \id{ehfun} and data pointer \id{eh\_data} have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default internal error handler function directs error messages to the
  file specified by the file pointer \id{errfp} (see \id{KINSetErrFile} above).

  Error messages indicating that the {\kinsol} solver memory is \id{NULL} will
  always be directed to \id{stderr}.
}
%%
\index{info messages!redirecting}
\ucfunction{KINSetInfoFile}
{
flag = KINSetInfoFile(kin\_mem, infofp);
}
{
  The function \ID{KINSetInfoFile} specifies the pointer to the file
  where all informative (non-error) messages should be directed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[infofp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{infofp} is \id{stdout}.
}
%%
%%
\index{info message!user-defined handler}
\ucfunction{KINSetInfoHandlerFn}
{
flag = KINSetInfoHandlerFn(kin\_mem, ihfun, ih\_data);
}
{
  The function \ID{KINSetInfoHandlerFn} specifies the optional user-defined function
  to be used in handling informative (non-error) messages.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ihfun] (\id{KINInfoHandlerFn})
    is the user's {\C} information handler function (see \S\ref{ss:ihFn}).
  \item[ih\_data] (\id{void *})
    pointer to user data passed to \id{ihfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The function \id{ihfun} and data pointer \id{ih\_data} have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default internal information handler function directs informative (non-error)
  messages to the file specified by the file pointer \id{infofp} (see
  \id{KINSetInfoFile} above).
}
%%
%%
\ucfunction{KINSetPrintLevel}
{
flag = KINSetPrintLevel(kin\_mem, printfl);
}
{
  The function \ID{KINSetPrintLevel} specifies the level of verbosity
  of the output.
}
{
  \begin{args}[kin\_mem]

  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.

  \item[printfl] (\id{int})
    flag indicating the level of verbosity. Must be one of:
    
    \begin{itemize}
    \item[0]
      no information displayed.
      
    \item[1]
      for each nonlinear iteration display
      the following information: the scaled
      Euclidean $\ell_2$ norm of the system function
      evaluated at the current iterate, the
      scaled norm of the Newton step (only if
      using \id{KIN\_NONE}), and the
      number of function evaluations performed
      so far.
      
    \item[2]
      display level 1 output and the
      following values for each iteration:
      
      $\|F(u)\|_{D_F}$
      (only for \id{KIN\_NONE}).
      
      $\|F(u)\|_{D_F,\infty}$
      (for \id{KIN\_NONE} and
      \id{KIN\_LINESEARCH}).
      
    \item[3]
      display level 2 output plus additional
      values used by the global strategy
      (only if using \id{KIN\_LINESEARCH}), and
      statistical information for the linear
      solver.
    \end{itemize}

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{printfl} had an illegal value.
  \end{args}
}
{
  The default value for \id{printfl} is $0$.
}
%%
\ucfunction{KINSetUserData}
{
flag = KINSetUserData(kin\_mem, user\_data);
}
{
  The function \ID{KINSetUserData} specifies the pointer to user-defined memory
  that is to be passed to all user-supplied functions.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[user\_data] (\id{void *})
    pointer to the user-defined memory.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If specified, the pointer to \id{user\_data} is passed to all user-supplied 
  functions that have it as an argument. Otherwise, a \id{NULL} pointer is passed.

  {\warn}If \id{user\_data} is needed in user preconditioner functions, the call to
  \id{KINSetUserData} must be made {\it before} the call to specify the
  linear solver.
}
%%
%%
\ucfunction{KINSetNumMaxIters}
{
flag = KINSetNumMaxIters(kin\_mem, mxiter);
}
{
  The function \ID{KINSetNumMaxIters} specifies the maximum number of 
  nonlinear iterations allowed.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxiter] (\id{long int})
    maximum number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The maximum number of iterations was non-positive.
  \end{args}
}
{
  The default value for \id{mxiter} is \id{MXITER\_DEFAULT} $=200$.
}
%%
%%
\ucfunction{KINSetNoInitSetup}
{
flag = KINSetNoInitSetup(kin\_mem, noInitSetup);
}
{
  The function \ID{KINSetNoInitSetup} specifies whether an initial call
  to the preconditioner or Jacobian setup function should be made or not.
}
{
  \begin{args}[noInitSeti[]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noInitSetup] (\id{booleantype})
    flag controlling whether an initial call to the preconditioner or Jacobian
    setup function is made (pass \id{FALSE}) or not made (pass \id{TRUE}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{noInitSetup} is \id{FALSE}, meaning that an initial call
  to the preconditioner or Jacobian setup function will be made.

  A call to this function is useful when solving a sequence of problems, in which
  the final preconditioner or Jacobian value from one problem is to be used initially
  for the next problem. 
}
%%
%%
\ucfunction{KINSetNoResMon}
{
flag = KINSetNoResMon(kin\_mem, noNNIResMon);
}
{
  The function \ID{KINSetNoResMon} specifies whether or not the nonlinear
  residual monitoring scheme is used to control Jacobian updating
}
{
  \begin{args}[noNNIResMon]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noNNIResMon] (\id{booleantype})
    flag controlling whether residual monitoring is used (pass \id{FALSE})
    or not used (pass \id{TRUE}).

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  When using a direct solver, the default value for \id{noNNIResMon} is \id{FALSE},
  meaning that the nonlinear residual will be monitored.

  {\warn}Residual monitoring is only available for use with the direct linear solver
  modules (meaning {\kindense} and {\kinband}).
}
%%
%%
\ucfunction{KINSetMaxSetupCalls}
{
flag = KINSetMaxSetupCalls(kin\_mem, msbset);
}
{
  The function \ID{KINSetMaxSetupCalls} specifies the maximum number of 
  nonlinear iterations that can be performed between calls to the 
  preconditioner or Jacobian setup function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[msbset] (\id{long int})
    maximum number of nonlinear iterations without a call to the
    preconditioner or Jacobian setup function.  Pass 0 to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{msbset} was negative.
  \end{args}
}
{
  The default value for \id{msbset} is \id{MSBSET\_DEFAULT} $=10$.
}
%%
%%
\ucfunction{KINSetMaxSubSetupCalls}
{
flag = KINSetMaxSubSetupCalls(kin\_mem, msbsetsub);
}
{
  The function \ID{KINSetMaxSubSetupCalls} specifies the maximum number of 
  nonlinear iterations between checks by the residual monitoring algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[msbsetsub] (\id{long int})
    maximum number of nonlinear iterations without checking the
    nonlinear residual.  Pass 0 to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{msbsetsub} was negative.
  \end{args}
}
{
  The default value for \id{msbsetsub} is \id{MSBSET\_SUB\_DEFAULT} $=5$.

  {\warn}Residual monitoring is only available for use with the direct linear solver
  modules (meaning {\kindense} and {\kinband}).
}
%%
%%
\ucfunction{KINSetEtaForm}
{
flag = KINSetEtaForm(kin\_mem, etachoice);
}
{
  The function \ID{KINSetEtaForm} specifies the method for computing
  the value of the $\eta$ coefficient used in the calculation of the
  linear solver convergence tolerance.
}
{
  \begin{args}[etachoice]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[etachoice] (\id{int})
    flag indicating the method for computing $\eta$. The value must be one
    of \Id{KIN\_ETACHOICE1}, \Id{KIN\_ETACHOICE2}, or \Id{KIN\_ETACONSTANT}
    (see Chapter \ref{s:math} for details).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{etachoice} had an illegal value.
  \end{args}
}
{
  The default value for \id{etachoice} is \id{KIN\_ETACHOICE1}.
}
%%
%%
\ucfunction{KINSetEtaConstValue}
{
flag = KINSetEtaConstValue(kin\_mem, eta);
}
{
  The function \ID{KINSetEtaConstValue} specifies the constant value
  for $\eta$ in the case \\ \id{etachoice = KIN\_ETACONSTANT}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[eta] (\id{realtype})
    constant value for $\eta$.  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{eta} had an illegal value
  \end{args}
}
{
  The default value for \id{eta} is $0.1$.
  The legal values are $0.0 <$ \id{eta} $\le 1.0$.
}
%%
%%
\ucfunction{KINSetEtaParams}
{
flag = KINSetEtaParams(kin\_mem, egamma, ealpha);
}
{
  The function \ID{KINSetEtaParams} specifies the parameters $\gamma$ and
  $\alpha$ in the formula for $\eta$, in the case \id{etachoice = KIN\_ETACHOICE2}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[egamma] (\id{realtype})
    value of the $\gamma$ parameter.  Pass $0.0$ to indicate the default.
  \item[ealpha] (\id{realtype})
    value of the $\alpha$ parameter.  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    One of the arguments \id{egamma} or \id{ealpha} had an illegal value.
  \end{args}
}
{
  The default values for \id{egamma} and \id{ealpha} are $0.9$ and $2.0$, respectively.

  The legal values are $0.0 <$ \id{egamma} $\le 1.0$ and
  $1.0<$ \id{ealpha} $\le 2.0$. 
}
%%
%%
\ucfunction{KINSetResMonConstValue}
{
flag = KINSetResMonConstValue(kin\_mem, omegaconst);
}
{
  The function \ID{KINSetResMonConstValue} specifies the constant value
  for $\omega$ when using residual monitoring.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[omegaconst] (\id{realtype})
    constant value for $\omega$.  Passing $0.0$ results in using
    Eqn. (\ref{resmon_omega}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{omegaconst} had an illegal value
  \end{args}
}
{
  The default value for \id{omegaconst} is $0.9$.
  The legal values are $0.0 <$ \id{omegaconst} $< 1.0$.
}
%%
%%
\ucfunction{KINSetResMonParams}
{
flag = KINSetResMonParams(kin\_mem, omegamin, omegamax);
}
{
  The function \ID{KINSetResMonParams} specifies the parameters $\omega_{min}$ and
  $\omega_{max}$ in the formula (\ref{resmon_omega}) for $\omega$.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[omegamin] (\id{realtype})
    value of the $\omega_{min}$ parameter.  Pass $0.0$ to indicate the default.
  \item[omegamax] (\id{realtype})
    value of the $\omega_{max}$ parameter.  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    One of the arguments \id{omegamin} or \id{omegamax} had an illegal value.
  \end{args}
}
{
  The default values for \id{omegamin} and \id{omegamax} are $0.00001$ and $0.9$,
  respectively.

  The legal values are $0.0 <$ \id{omegamin} $<$ \id{omegamax} $< 1.0$.
}
%%
%%
\ucfunction{KINSetNoMinEps}
{
flag = KINSetNoMinEps(kin\_mem, noMinEps);
}
{
  The function \ID{KINSetNoMinEps} specifies a flag that controls whether or not
  the value of $\epsilon$, the scaled linear residual tolerance, is
  bounded from below.
}
{
  \begin{args}[noMinEps]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[noMinEps] (\id{booleantype})
    flag controlling the bound on $\epsilon$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{noMinEps} is \id{FALSE}, meaning that a
  positive minimum value, equal to $0.01$*\id{fnormtol}, is applied to
  $\epsilon$.  (See \id{KINSetFuncNormTol} below.)
}
%%
%%
\ucfunction{KINSetMaxNewtonStep}
{
flag = KINSetMaxNewtonStep(kin\_mem, mxnewtstep);
}
{
  The function \ID{KINSetMaxNewtonStep} specifies the maximum allowable scaled
  length of the Newton step.
}
{
  \begin{args}[mxnewtstep]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxnewtstep] (\id{realtype})
    maximum scaled step length ($\geq 0.0$).  Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The input value was negative.
  \end{args}
}
{
  The default value of \id{mxnewtstep} is $1000\, \| u_0 \|_{D_u}$,
  where $u_0$ is the initial guess.
}
%%
%%
\ucfunction{KINSetMaxBetaFails}
{
flag = KINSetMaxBetaFails(kin\_mem, mxnbcf);
}
{
  The function \ID{KINSetMaxBetaFails} specifies the maximum number of
  $\beta$-condition failures in the linesearch algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[mxnbcf] (\id{realtype})
    maximum number of $\beta$-condition failures.  Pass $0.0$ to indicate the
    default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    \id{mxnbcf} was negative.
  \end{args}
}
{
  The default value of \id{mxnbcf} is \id{MXNBCF\_DEFAULT} $=10$.
}
%%
%%
\ucfunction{KINSetRelErrFunc}
{
flag = KINSetRelErrFunc(kin\_mem, relfunc);
}
{
  The function \ID{KINSetRelErrFunc} specifies the relative error in 
  computing $F(u)$, which is used in the difference quotient approximation of the
  Jacobian-vector product.
}
{
  \begin{args}[relfunc]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[relfunc] (\id{realtype})
    relative error in $F(u)$ (\id{relfunc} $\geq 0.0$).  Pass $0.0$ to indicate
    the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The relative error was negative.
  \end{args}
}
{
  The default value for \id{relfunc} is $\sqrt{\text{unit roundoff}}$.
}
%%
%%
\ucfunction{KINSetFuncNormTol}
{
flag = KINSetFuncNormTol(kin\_mem, fnormtol);
}
{
  The function \ID{KINSetFuncNormTol} specifies the scalar used as a stopping
  tolerance on the scaled maximum norm of the system function $F(u)$.
}
{
  \begin{args}[fnormtol]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[fnormtol] (\id{realtype})
    tolerance for stopping based on scaled function norm ($\geq 0.0$).
    Pass $0.0$ to indicate the default.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The tolerance was negative.
  \end{args}
}
{
  The default value for \id{fnormtol} is (unit roundoff)$^{1/3}$.
}
%%
%%
\ucfunction{KINSetScaledStepTol}
{
flag = KINSetScaledStepTol(kin\_mem, scsteptol);
}
{
  The function \ID{KINSetScaledStepTol} specifies the scalar used
  as a stopping tolerance on the minimum scaled step length.
}
{
  \begin{args}[scsteptol]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[scsteptol] (\id{realtype})
    tolerance for stopping based on scaled step length ($\geq 0.0$).
    Pass $0.0$ to indicate the default. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The tolerance was non-positive.
  \end{args}
}
{
  The default value for \id{scsteptol} is (unit roundoff)$^{2/3}$.
}
%%
%%
\ucfunction{KINSetConstraints}
{
flag = KINSetConstraints(kin\_mem, constraints);
}
{
  The function \ID{KINSetConstraints} specifies a vector that defines
  inequality constraints for each component of the solution vector $u$.
}
{
  \begin{args}[constraints]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[constraints] (\id{N\_Vector})
    vector of constraint flags. If \id{constraints[i]} is
    \begin{itemize}    
    \item[$0.0$] then no constraint is imposed on $u_i$. 
    \item[$1.0$] then $u_i$ will be constrained to be $u_i \ge 0.0$.
    \item[$-1.0$] then $u_i$ will be constrained to be $u_i \le 0.0$.
    \item[$2.0$] then $u_i$ will be constrained to be $u_i > 0.0$.
    \item[$-2.0$] then $u_i$ will be constrained to be $u_i < 0.0$.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The constraint vector contains illegal values.
  \end{args}
}
{
  The presence of a non-\id{NULL} constraints vector that is not $0.0$ in
  all components will cause constraint checking to be performed.

  The function creates a private copy of the constraints vector. Consequently,
  the user-supplied vector can be freed after the function call, and
  the constraints can only be changed by calling this function.
}
%%
%%
\ucfunction{KINSetSysFunc}
{
flag = KINSetSysFunc(kin\_mem, func);
}
{
  The function \ID{KINSetSysFunc} specifies the user-provided function
  that evaluates the nonlinear system function $F(u)$ or $G(u)$.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[func] (\id{KINSysFn})
    user-supplied function that evaluates $F(u)$ (or $G(u)$ for fixed-point 
    iteration).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{func} was \id{NULL}.
  \end{args}
}
{
  The nonlinear system function is initially specified through \id{KINInit}.
  The option of changing the system function is provided for a user who wishes 
  to solve several problems of the same size but with different functions.
}
%%
%%
\ucfunction{KINSetMAA}
{
flag = KINSetMAA(kin\_mem, maa);
}
{
  The function \ID{KINSetMAA} specifies the size of the subspace used with
  Anderson acceleration in conjunction with Picard or fixed-point iteration.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maa] (\id{long int})
    subspace size for various methods.  A value of 0 means no acceleration,
    while a positive value means acceleration will be done.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_ILL\_INPUT]
  \item[\Id{KIN\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KIN\_ILL\_INPUT}]
    The argument \id{maa} was negative.
  \end{args}
}
{
  This function sets the subspace size, which needs to be $> 0$ if Anderson
  Acceleration is to be used.  
  It also allocates additional memory necessary for Anderson Acceleration.

  The default value of \id{maa} is 0, indicating no acceleration.  The value of \id{maa}
  should always be less than \id{mxiter}.

  If the user calls the function KINSetNumMaxIters, that call should be made
  before the call to KINSetMAA, as the latter uses the value of \id{mxiter}. 
}
%%
%%
%%
\index{optional input!solver|)}

%%==============================================================================
\subsubsection{Dense direct linear solver optional input functions}\label{sss:optin_dls}
%%==============================================================================
\index{optional input!dense linear solver|(}
\index{KINDENSE@{\kindense} linear solver!optional input|(}
\index{optional input!band linear solver|(}
\index{KINBAND@{\kinband} linear solver!optional input|(}
The \index{KINDENSE@{\kindense} linear solver!Jacobian approximation used by}
{\kindense} solver needs a function to compute a dense approximation to
the Jacobian matrix $J(u)$.  This function must be of type \id{KINDlsDenseJacFn}. 
The user can supply his/her own dense Jacobian function, or use the default 
internal difference quotient approximation
\index{Jacobian approximation function!dense!difference quotient}
that comes with the {\kindense} solver.
To specify a user-supplied Jacobian function \id{djac}, {\kindense} 
provides the function \id{KINDlsSetDenseJacFn}.
The {\kindense} solver passes the pointer \id{user\_data} 
to the dense Jacobian function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without
using global data in the program.  The pointer \id{user\_data} may be
specified through \id{KINSetUserData}.
%%
\index{Jacobian approximation function!dense!user-supplied}
\ucfunction{KINDlsSetDenseJacFn}
{
  flag = KINDlsSetDenseJacFn(kin\_mem, djac);
}
{
  The function \ID{KINDlsSetDenseJacFn} specifies the dense Jacobian
  approximation function to be used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[djac] (\id{KINDlsDenseJacFn})
    user-defined dense Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_LMEM\_NULL]
  \item[\Id{KINDLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_LMEM\_NULL}]
    The {\kindense} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\kindense} uses an internal difference quotient function.
  If \id{NULL} is passed to \id{djac}, this default function is used.

  The function type \id{KINDlsDenseJacFn} is described in \S\ref{ss:djacFn}.
}
%%
%%
The \index{KINBAND@{\kinband} linear solver!Jacobian approximation used by}
{\kinband} solver needs a function to compute a banded approximation to
the Jacobian matrix $J(u)$.  This function must be of type \id{KINDlsBandJacFn}. 
The user can supply his/her own banded Jacobian approximation function, 
or use the default internal difference quotient approximation
\index{Jacobian approximation function!band!difference quotient}
that comes with the {\kinband} solver.
To specify a user-supplied Jacobian function \id{bjac} {\kinband} provides 
the function \id{KINDlsSetBandJacFn}.
The {\kinband} solver passes the pointer \id{user\_data}
to the banded Jacobian approximation function. This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied Jacobian function, without
using global data in the program.  The pointer \id{user\_data} may be
specified through \id{KINSetUserData}.
%%
\index{Jacobian approximation function!band!user-supplied}
\ucfunction{KINDlsSetBandJacFn}
{
  flag = KINDlsSetBandJacFn(kin\_mem, bjac);
}
{
  The function \ID{KINBandSetJacFn} specifies the banded Jacobian
  approximation function to be used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[bjac] (\id{KINDlsBandJacFn})
    user-defined banded Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_LMEM\_NULL]
  \item[\Id{KINDLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_LMEM\_NULL}]
    The {\kinband} linear solver has not been initialized.
  \end{args}
}
{
  By default, {\kinband} uses an internal difference quotient approximation.
  If \id{NULL} is passed to \id{bjac}, this default function is used.

  The function type \id{KINDlsBandJacFn} is described in \S\ref{ss:bjacFn}.
}
%%
%%
\index{KINBAND@{\kinband} linear solver!optional input|)}
\index{optional input!band linear solver|)}
\index{KINDENSE@{\kindense} linear solver!optional input|)}
\index{optional input!dense linear solver|)}

%%==============================================================================
\subsubsection{Sparse linear solvers optional input functions}\label{sss:optin_sls}
%%==============================================================================
\index{optional input!sparse linear solver|(}
\index{KINKLU@{\kinklu} linear solver!optional input|(}
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!optional input|(}
The \index{KINKLU@{\kinklu} linear solver!Jacobian approximation used by}
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!Jacobian approximation used by}
{\kinklu} and {\kinsuperlumt} solvers require a function to compute a
compressed-sparse-column approximation to the Jacobian matrix $J(u)$.
This function must be of type \id{KINSlsSparseJacFn}.  The user must
supply a custom sparse Jacobian function since a difference-quotient
approximation would not leverage the underlying sparse matrix
structure of the problem.  To specify a user-supplied Jacobian
function \id{sjac}, {\kinklu} and {\kinsuperlumt} provide the function
\id{KINSlsSetSparseJacFn}. The {\kinklu} and {\kinsuperlumt} solvers
pass the pointer \id{user\_data} to the sparse Jacobian
function. This mechanism allows the user to create an arbitrary structure with
relevant problem data and access it during the execution of the
user-supplied Jacobian function, without using global data in the
program.  The pointer \id{user\_data} may be specified through
\id{KINSetUserData}.
%%
\index{Jacobian approximation function!sparse!user-supplied}
\ucfunction{KINSlsSetSparseJacFn}
{
  flag = KINSlsSetSparseJacFn(kin\_mem, sjac);
}
{
  The function \ID{KINSlsSetSparseJacFn} specifies the sparse Jacobian
  approximation function to be used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[sjac] (\id{KINSlsSparseJacFn})
    user-defined sparse Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_LMEM\_NULL]
  \item[\Id{KINSLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_LMEM\_NULL}]
    The {\kinsls} linear solver has not been initialized.
  \end{args}
}
{
  The function type \id{KINSlsSparseJacFn} is described in \S\ref{ss:sjacFn}.
}
%
%
\index{KINKLU@{\kinklu} linear solver!reinitialization}
When using a spasre dircet solver, there 
may be instances when the number of state variables does not 
change, but the number of nonzeroes in the Jacobian does change.  
For the {\kinklu} solver, we provide a reinitialization.
This reinitialization routine reinitializes the Jacobian matrix
memory for eth new number fo nnozeroes and sets flags for a new factorization 
(symbolic and numeric) to be conducted at the next solver setup
call.  This routine is useful in the cases where the number of nonzeroes 
has changed or if the structure of the linear system has changed
which would require a new symbolic (and numeric factorization).
%%
\ucfunction{KINKLUReInit}
{
  flag = KINKLUReInit(kin\_mem, n, nnz, reinit\_type);
}
{
  The function \ID{KINKLUReInit} reinitializes Jacobian matrix memory and flags for
  new symbolic and numeric KLU factorizations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[n] (\id{int})
    number of state variables in the system.
  \item[nnz] (\id{int})
    number of nonzeroes in the Jacobian matrix.
  \item[reinit\_type] (\id{int})
    type of reinitialization:
    \begin{itemize}
    \item[1]  The Jacobian matrix will be destroyed and a new one will 
      be allocated based on the \id{nnz} value passed to this call. New symbolic and
      numeric factorizations will be completed at the next
      solver setup.
    \item[2]  Only symbolic and numeric factorizations will be completed.  
      It is assumed that the Jacobian size has not exceeded the size of 
      \id{nnz} given in the prior call to {\kinklu}.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_MEM\_FAIL]
  \item[\Id{KINSLS\_SUCCESS}] 
    The reinitialization succeeded.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_LMEM\_NULL}]
    The {\kinklu} linear solver has not been initialized.
  \item[\Id{KINSLS\_ILL\_INPUT}]
    The given \id{reinit\_type} has an illegal value.
  \item[\Id{KINSLS\_MEM\_FAIL}]
    A memory allocation failed.
  \end{args}
}
{
  The default value for \id{reinit\_type} is $2$.
}
%%
%%
\index{KINKLU@{\kinklu} linear solver!matrix reordering algorithm specification}
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!matrix reordering algorithm specification}
Both the {\kinklu} and {\kinsuperlumt} solvers can apply reordering
algorithms to minimize fill-in for the resulting sparse $LU$
decomposition internal to the solver.  The approximate minimal degree
ordering for nonsymmetric matrices given by the \id{COLAMD} algorithm
is the default algorithm used within both solvers, but alternate
orderings may be chosen through one of the following two functions.
The input values to these functinos are the numeric values used in the respective
packages, and the user-supplied value will be passed directly to the package.
%%
\ucfunction{KINKLUSetOrdering}
{
  flag = KINKLUSetOrdering(kin\_mem, ordering\_choice);
}
{
  The function \ID{KINKLUSetOrdering} specifies the ordering algorithm
  used by {\kinklu} for reducing fill.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ordering\_choice] (\id{int})
    flag denoting algorithm choice:
    \begin{itemize}
    \item[0] \id{AMD}
    \item[1] \id{COLAMD}
    \item[2] natural ordering
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_LMEM\_NULL]
  \item[\Id{KINSLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_ILL\_INPUT}]
    The supplied value of \id{ordering\_choice} is illegal.
  \end{args}
}
{
  The default ordering choice is $1$ for \id{COLAMD}.
}
%%
%%
\ucfunction{KINSuperLUMTSetOrdering}
{
  flag = KINSuperLUMTSetOrdering(kin\_mem, ordering\_choice);
}
{
  The function \ID{KINSuperLUMTSetOrdering} specifies the ordering algorithm
  used by {\kinsuperlumt} for reducing fill.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ordering\_choice] (\id{int})
    flag denoting algorithm choice:
    \begin{itemize}
    \item[0] natural ordering
    \item[1] minimal degree ordering on $J^TJ$
    \item[2] minimal degree ordering on $J^T + J$
    \item[3] \id{COLAMD}
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_LMEM\_NULL]
  \item[\Id{KINSLS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_ILL\_INPUT}]
    The supplied value of \id{ordering\_choice} is illegal.
  \end{args}
}
{
  The default ordering choice is $3$ for \id{COLAMD}.
}
%%
%%
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!optional input|)}
\index{KINKLU@{\kinklu} linear solver!optional input|)}
\index{optional input!sparse linear solver|)}

%%==============================================================================
\subsubsection{Iterative linear solvers optional input functions}\label{sss:optin_spils}
%%==============================================================================
\index{optional input!iterative linear solver|(}
\index{KINSPGMR@{\kinspgmr} linear solver!optional input|(}
\index{KINSPFGMR@{\kinspfgmr} linear solver!optional input|(}
\index{KINSPBCG@{\kinspbcg} linear solver!optional input|(}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!optional input|(}
\index{preconditioning!user-supplied|(}
If any preconditioning is to be done with one of the {\kinspils} linear
solvers, then the user must supply a preconditioner solve function \id{psolve}
and specify its name in a call to \id{KINSpilsSetPreconditioner}.
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner solve function}
\index{KINSPFGMR@{\kinspfgmr} linear solver!preconditioner solve function}
\index{KINSPBCG@{\kinspbcg} linear solver!preconditioner solve function}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!preconditioner solve function}
%%
The evaluation and preprocessing of any Jacobian-related data needed
by the user's preconditioner solve function is done in the optional
user-supplied function \id{psetup}. Both of these functions are
fully specified in \S\ref{ss:user_fct_sol}.
If used, the \id{psetup} function should also be specified in the call to
\id{KINSpilsSetPreconditioner}.
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner setup function}
\index{KINSPFGMR@{\kinspfgmr} linear solver!preconditioner setup function}
\index{KINSPBCG@{\kinspbcg} linear solver!preconditioner setup function}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!preconditioner setup function}
%%
A {\kinspils} solver passes the pointer \id{user\_data}
received through \id{KINSetUserData} to the preconditioner
\id{psetup} and \id{psolve} functions.  This allows the user to create
an arbitrary structure with relevant problem data and access it during
the execution of the user-supplied preconditioner functions without using
global data in the program.

\index{KINSPGMR@{\kinspgmr} linear solver!Jacobian approximation used by}
\index{KINSPFGMR@{\kinspfgmr} linear solver!Jacobian approximation used by}
\index{KINSPBCG@{\kinspbcg} linear solver!Jacobian approximation used by}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!Jacobian approximation used by}
Ther {\kinspils} solvers require a function to compute an approximation to the
product between the Jacobian matrix $J(u)$ and a vector $v$.
The user can supply his/her own Jacobian-times-vector approximation function, 
or use the internal difference quotient approximation
\index{Jacobian approximation function!Jacobian times vector!difference quotient}
that comes with the {\kinspils} solvers.  A user-defined Jacobian-vector
function must be of type \id{KINSpilsJacTimesVecFn} and 
can be specified through a call to \id{KINSpilsSetJacTimesVecFn} 
(see \S\ref{ss:jtimesFn} for specification details).
%%
A {\kinspils} solver passes the pointer \id{user\_data} received through 
\id{KINSetUserData} to the Jacobian-times-vector function \id{jtimes}
each time it is called.  
%%
%%
\ucfunction{KINSpilsSetPreconditioner}
{
  flag = KINSpilsSetPreconditioner(kin\_mem, psetup, psolve);
}
{
  The function \ID{KINSpilsSetPreconditioner} specifies the preconditioner
  setup and solve functions.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[psetup] (\id{KINSpilsPrecSetupFn})
    user-defined preconditioner setup function.  Pass \id{NULL} if no setup
    operation is to be done.
  \item[psolve] (\id{KINSpilsPrecSolveFn})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional values have been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The {\kinspils} linear solver has not been initialized.
  \end{args}
}
{
   The function type \id{KINSpilsPrecSolveFn} is described in \S\ref{ss:psolveFn}.
   The function type \id{KINSpilsPrecSetupFn} is described in \S\ref{ss:precondFn}.
}
%%
%%
\index{preconditioning!user-supplied|)}
\index{Jacobian approximation function!Jacobian times vector!user-supplied}
\ucfunction{KINSpilsSetJacTimesVecFn}
{
  flag = KINSpilsSetJacTimesVecFn(kin\_mem, jtimes);
}
{
  The function \ID{KINSpilsSetJacTimesFn} specifies the Jacobian-vector 
  function to be used.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[jtimes] (\id{KINSpilsJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The {\kinspils} linear solver has not been initialized.
  \end{args}
}
{
  By default, the {\kinspils} linear solvers use an internal difference quotient 
  function \id{KINSpilsDQJtimes}.
  If \id{NULL} is passed as \id{jtimes}, this default function is used.

  The function type \id{KINSpilsJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.
}
%%
%%
\ucfunction{KINSpilsSetMaxRestarts}
{
  flag = KINSpilsSetMaxRestarts(kin\_mem, maxrs);
}
{
  The function \ID{KINSpilsSetMaxRestarts} specifies the maximum
  number of times the iterative linear solver can be restarted.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[maxrs] (\id{int})
    maximum number of restarts ($\geq 0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_ILL\_INPUT]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{KINSPILS\_ILL\_INPUT}]
    The maximum number of restarts specified is negative.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver has not been initialized.
  \end{args}
}
{
  The default value is $0$ (meaning no restarts).

  {\warn}This option is available only for the {\kinspgmr} and {\kinspfgmr} 
  linear solvers.
}
%%
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!optional input|)}
\index{KINSPBCG@{\kinspbcg} linear solver!optional input|)}
\index{KINSPFGMR@{\kinspfgmr} linear solver!optional input|)}
\index{KINSPGMR@{\kinspgmr} linear solver!optional input|)}
\index{optional input!iterative linear solver|)}

%%==============================================================================
\subsection{Optional output functions}\label{ss:optional_output}
%%==============================================================================

{\kinsol} provides an extensive list of functions that can be used to obtain
solver performance information.
Table \ref{t:optional_output} lists all optional output functions in {\kinsol},
which are then described in detail in the remainder of this section, beginning with those
for the main {\kinsol} solver and continuing with those for the linear solver
modules. Where the name of an output from a linear solver module would otherwise conflict
with the name of an optional output from the main solver, a suffix \id{LS} (for Linear Solver)
has been added here ({\em e.g.}, \id{lenrwLS}).

\newlength{\colAA}
\settowidth{\colAA}{No. of $F$ calls for D.Q. Jacobian-vector evals.}
\newlength{\colBB}
\settowidth{\colBB}{\id{KINGetNumNonlinSolvConvFails}}



\begin{table}
\centering
\caption{Optional outputs from {\kinsol}, {\kindls}, {\kinsls}, and {\kinspils}}
\label{t:optional_output}
\medskip
\begin{tabular}{|p{\colAA}|p{\colBB}|}
\hline
{\bf Optional output} & {\bf Function name} \\ 
\hline
\multicolumn{2}{|c|}{\bf KINSOL main solver} \\
\hline
Size of {\kinsol} real and integer workspaces & \id{KINGetWorkSpace} \\
Number of function evaluations  & \id{KINGetNumFuncEvals} \\
Number of nonlinear iterations & \id{KINGetNumNolinSolvIters} \\
Number of $\beta$-condition failures & \id{KINGetNumBetaCondFails} \\
Number of backtrack operations & \id{KINGetNumBacktrackOps} \\
Scaled norm of $F$ & \id{KINGetFuncNorm} \\
Scaled norm of the step & \id{KINGetStepLength} \\
\hline
\multicolumn{2}{|c|}{\bf KINDLS linear solvers} \\
\hline
Size of real and integer workspaces & \id{KINDlsGetWorkSpace} \\
No. of Jacobian evaluations & \id{KINDlsGetNumJacEvals} \\
No. of $F$ calls for D.Q. Jacobian evals. & \id{KINDlsGetNumFuncEvals} \\ 
Last return from a {\kindls} function & \id{KINDlsGetLastFlag} \\ 
\hline
\multicolumn{2}{|c|}{\bf KINSLS linear solvers} \\
\hline
No. of Jacobian evaluations & \id{KINSlsGetNumJacEvals} \\
Last return from a linear solver function & \id{KINSlsGetLastFlag} \\
Name of constant associated with a return flag & \id{KINSlsGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf KINSPILS linear solvers} \\
\hline
Size of real and integer workspaces & \id{KINSpilsGetWorkSpace} \\
No. of linear iterations & \id{KINSpilsGetNumLinIters} \\
No. of linear convergence failures & \id{KINSpilsGetNumConvFails} \\
No. of preconditioner evaluations & \id{KINSpilsGetNumPrecEvals} \\
No. of preconditioner solves & \id{KINSpilsGetNumPrecSolves} \\
No. of Jacobian-vector product evaluations & \id{KINSpilsGetNumJtimesEvals} \\
No. of $F$ calls for D.Q. Jacobian-vector evals. & \id{KINSpilsGetNumFuncEvals} \\ 
Last return from a linear solver function & \id{KINSpilsGetLastFlag} \\ 
\hline
\end{tabular}
\end{table}


%%==============================================================================
\subsubsection{Main solver optional output functions}\label{sss:output_main}
%%==============================================================================
\index{optional output!solver|(}
%%
{\kinsol} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements and solver performance statistics.
%%
These optional output functions are described next.
%%
%%
\ucfunction{KINGetWorkSpace}
{
  flag = KINGetWorkSpace(kin\_mem, \&lenrw, \&leniw);
}
{
  The function \ID{KINGetWorkSpace} returns the
  {\kinsol} integer and real workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrw] (\id{long int})
    the number of \id{realtype} values in the {\kinsol} workspace.
  \item[leniw] (\id{long int})
    the number of integer values in the {\kinsol} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  \index{memory requirements!KINSOL@{\kinsol} solver}
  In terms of the problem size $N$, the actual size of the real workspace 
  is $17 + 5 N$ \id{realtype} words. The real workspace is increased by
  an additional $N$ words if constraint checking is enabled (see \id{KINSetConstraints}).

  The actual size of the integer workspace (without distinction between \id{int} 
  and \id{long int}) is $22 + 5 N$ (increased by $N$ if constraint checking is enabled).
}
%%
%%
\ucfunction{KINGetNumFuncEvals}
{
  flag = KINGetNumFuncEvals(kin\_mem, \&nfevals);
}
{
  The function \ID{KINGetNumFuncEvals} returns the number of evaluations
  of the system function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevals] (\id{long int})
    number of calls to the user-supplied function that evaluates $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumNonlinSolvIters}
{
  flag = KINGetNumNonlinSolvIters(kin\_mem, \&nniters);
}
{
  The function \ID{KINGetNumNonlinSolvIters} returns the number
  of nonlinear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumBetaCondFails}
{
  flag = KINGetNumBetaCondFails(kin\_mem, \&nbcfails);
}
{
  The function \ID{KINGetNumBetaCondFails} returns the number
  of $\beta$-condition failures.
}
{
  \begin{args}[nbcfails]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nbcfails] (\id{long int})
    number of $\beta$-condition failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetNumBacktrackOps}
{
  flag = KINGetNumBacktrackOps(kin\_mem, \&nbacktr);
}
{
  The function \ID{KINGetNumBacktrackOps} returns the number of
  backtrack operations (step length adjustments) performed by the
  line search algorithm.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nbacktr] (\id{long int})
    number of backtrack operations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetFuncNorm}
{
  flag = KINGetFuncNorm(kin\_mem, \&fnorm);
}
{
  The function \ID{KINGetFuncNorm} returns the scaled Euclidean $\ell_2$ norm of the 
  nonlinear system function $F(u)$ evaluated at the current iterate.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[fnorm] (\id{realtype})
    current scaled norm of $F(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunction{KINGetStepLength}
{
  flag = KINGetStepLength(kin\_mem, \&steplength);
}
{
  The function \ID{KINGetStepLength} returns the scaled Euclidean $\ell_2$ norm of
  the step used during the previous iteration.
}
{
  \begin{args}[steplength]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[steplength] (\id{realtype})
    scaled norm of the Newton step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KIN\_MEM\_NULL]
  \item[\Id{KIN\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KIN\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\index{optional output!solver|)}

%%==============================================================================
\subsubsection{Dense direct linear solvers optional output functions}
\label{sss:optout_dense}
%%==============================================================================
\index{optional output!dense linear solver|(}
\index{KINDENSE@{\kindense} linear solver!optional output|(}
\index{optional output!band linear solver|(}
\index{KINBAND@{\kinband} linear solver!optional output|(}
The following optional outputs are available from the {\kindls} module:
workspace requirements, number of calls to the Jacobian routine, number of 
calls to the system function routine for difference quotient Jacobian approximation,
and last return value from a {\kindls} function.
%%
%%
\index{KINDENSE@{\kindense} linear solver!memory requirements} 
\index{memory requirements!KINDENSE@{\kindense} linear solver}
\index{KINBAND@{\kinband} linear solver!memory requirements} 
\index{memory requirements!KINBAND@{\kinband} linear solver}
\ucfunction{KINDlsGetWorkSpace}
{
  flag = KINDlsGetWorkSpace(kin\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{KINDlsGetWorkSpace} returns the
  {\kindense} real and integer workspace sizes.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\kindls} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\kindls} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_LMEM\_NULL]
  \item[\Id{KINDLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_LMEM\_NULL}]
    The {\kindense} linear solver has not been initialized.
  \end{args}
}
{
  For the {\kindense} linear soler, in terms of the problem size $N$, 
  the actual size of the real workspace is $N^2$ \id{realtype} words, 
  and the actual size of the integer workspace is $N$ integer words.

  For the {\kinband} linear solver, in terms of the problem size $N$ 
  and Jacobian half-bandwidths, the actual size of the real workspace, in
  \id{realtype} words, is approximately
  $(2$ \id{mupper}$+ 3$ \id{mlower} $+ 2)\, N$,
  and the actual size of the integer workspace is $N$ integer words.
}
%%
%%
\ucfunction{KINDlsGetNumJacEvals}
{
  flag = KINDlsGetNumJacEvals(kin\_mem, \&njevals);
}
{
  The function \ID{KINDlsGetNumJacEvals} returns the
  number of calls to the dense Jacobian approximation function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njevals] (\id{long int})
    the number of calls to the Jacobian function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_LMEM\_NULL]
  \item[\Id{KINDLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_LMEM\_NULL}]
    The {\kindense} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINDlsGetNumFuncEvals}
{
  flag = KINDlsGetNumFuncEvals(kin\_mem, \&nfevalsLS);
}
{
  The function \ID{KINDlsGetNumFuncEvals} returns the number of calls
  to the user system function used to compute the difference quotient
  approximation to the dense or banded Jacobian.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls to the user system function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_LMEM\_NULL]
  \item[\Id{KINDLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_LMEM\_NULL}]
    The {\kindense} or {\kinband} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if the internal
  difference quotient function is used.
}
%%
%%
\ucfunction{KINDlsGetLastFlag}
{
  flag = KINDlsGetLastFlag(kin\_mem, \&lsflag);
}
{
  The function \ID{KINDlsGetLastFlag} returns the
  last return value from a {\kindense} routine. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from a {\kindense} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINDLS\_LMEM\_NULL]
  \item[\Id{KINDLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINDLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINDLS\_LMEM\_NULL}]
    The {\kindense} linear solver has not been initialized.
  \end{args}
}
{
  If the {\kindls} setup function failed (\id{KINSol} returned \id{KIN\_LSETUP\_FAIL}),
  then \id{lsflag} is equal to the column index (numbered from one) at which
  a zero diagonal element was encountered during the LU factorization of the 
  dense Jacobian matrix.  For all other failures, \id{lsflag} is negative.
}
%%
%%
\index{KINDENSE@{\kindense} linear solver!optional output|)}
\index{optional output!dense linear solver|)}
\index{KINBAND@{\kinband} linear solver!optional output|)}
\index{optional output!band linear solver|)}

%%==============================================================================
\subsubsection{Sparse direct linear solvers optional output functions}
\label{sss:optout_sls}
%%==============================================================================
\index{optional output!sparse linear solver|(}
\index{KINKLU@{\kinklu} linear solver!optional output|(}
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!optional output|(}
The following optional outputs are available from the {\kinsls} module:
number of calls to the Jacobian routine and last return value from a
{\kinsls} function. 
%%
%%
\ucfunction{KINSlsGetNumJacEvals}
{
  flag = KINSlsGetNumJacEvals(kin\_mem, \&njevals);
}
{
  The function \ID{KINSlsGetNumJacEvals} returns the
  number of calls to the sparse Jacobian approximation function.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njevals] (\id{long int})
    the number of calls to the Jacobian function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_LMEM\_NULL]
  \item[\Id{KINSLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_LMEM\_NULL}]
    The {\kinsls} linear solver has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSlsGetLastFlag}
{
  flag = KINSlsGetLastFlag(kin\_mem, \&lsflag);
}
{
  The function \ID{KINSlsGetLastFlag} returns the
  last return value from a {\kinsls} routine. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from a {\kinsls} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSLS\_LMEM\_NULL]
  \item[\Id{KINSLS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSLS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSLS\_LMEM\_NULL}]
    The {\kinsls} linear solver has not been initialized.
  \end{args}
}
{
}
%%
%%
\ucfunction{KINSlsGetReturnFlagName}
{
  name = KINSlsGetReturnFlagName(lsflag);
}
{
  The function \ID{KINSlsGetReturnFlagName} returns the
  name of the {\kinsls} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from a {\kinsls}
  function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
%%
%%
\index{KINSUPERLUMT@{\kinsuperlumt} linear solver!optional output|)}
\index{KINKLU@{\kinklu} linear solver!optional output|)}
\index{optional output!sparse linear solver|)}

%%==============================================================================
\subsubsection{Iterative linear solvers optional output functions}\label{sss:optout_spils}
%%==============================================================================
\index{optional output!iterative linear solver|(}
\index{KINSPGMR@{\kinspgmr} linear solver!optional output|(} 
\index{KINSPFGMR@{\kinspfgmr} linear solver!optional output|(} 
\index{KINSPBCG@{\kinspbcg} linear solver!optional output|(} 
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!optional output|(} 
The following optional outputs are available from the {\kinspils}
modules: workspace requirements, number of linear iterations, number of
linear convergence failures, number of calls to the preconditioner
setup and solve routines, number of calls to the Jacobian-vector
product routine, number of calls to the system function routine for
difference quotient Jacobian-vector product approximation, and last
return value from a linear solver function.
%%
%%
\index{KINSPGMR@{\kinspgmr} linear solver!memory requirements} 
\index{KINSPFGMR@{\kinspfgmr} linear solver!memory requirements} 
\index{KINSPBCG@{\kinspbcg} linear solver!memory requirements} 
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!memory requirements} 
\index{memory requirements!KINSPGMR@{\kinspgmr} linear solver}
\index{memory requirements!KINSPFGMR@{\kinspfgmr} linear solver}
\ucfunction{KINSpilsGetWorkSpace}
{
  flag = KINSpilsGetWorkSpace(kin\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{KINSpilsGetWorkSpace} returns the global sizes of the
  linear solver real and integer workspaces.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the linear solver workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the linear solver workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output values have been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$ and maximum subspace size \id{maxl}, 
  the actual size of the real workspace, in \id{realtype} words, is roughly:\\
  (\id{maxl}$+ 3)*N +$ \id{maxl} $*($ \id{maxl}$ + 4) + 1$ for {\kinspgmr},\\
  (2\id{maxl}$+ 3)*N +$ \id{maxl} $*($ \id{maxl}$ + 4) + 1$ for {\kinspfgmr},\\
  $7*N$  for {\kinspbcg}, and \\
  $11*N$ for {\kinsptfqmr}.

  In a parallel setting, this value is global, summed over all processes.
}
%%
%%
\ucfunction{KINSpilsGetNumLinIters}
{
  flag = KINSpilsGetNumLinIters(kin\_mem, \&nliters);
}
{
  The function \ID{KINSpilsGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPLIS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpilsGetNumConvFails}
{
  flag = KINSpilsGetNumConvFails(kin\_mem, \&nlcfails);
}
{
  The function \ID{KINSpilsGetNumConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpilsGetNumPrecEvals}
{
  flag = KINSpilsGetNumPrecEvals(kin\_mem, \&npevals);
}
{
  The function \ID{KINSpilsGetNumPrecEvals} returns the
  number of preconditioner evaluations, i.e., the number of 
  calls made to \id{psetup}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npevals] (\id{long int})
    the current number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpilsGetNumPrecSolves}
{
  flag = KINSpilsGetNumPrecSolves(kin\_mem, \&npsolves);
}
{
  The function \ID{KINSpilsGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner 
  solve function, \id{psolve}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[npsolves] (\id{long int})
    the current number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpilsGetNumJtimesEvals}
{
  flag = KINSpilsGetNumJtimesEvals(kin\_mem, \&njvevals);
}
{
  The function \ID{KINSpilsGetNumJtimesEvals} returns the
  cumulative number made to the Jacobian-vector product function,
  \id{jtimes}.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[njvevals] (\id{long int})
    the current number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunction{KINSpilsGetNumFuncEvals}
{
  flag = KINSpilsGetNumFuncEvals(kin\_mem, \&nfevalsLS);
}
{
  The function \ID{KINSpilsGetNumFuncEvals} returns the
  number of calls to the user system function for
  difference quotient Jacobian-vector product approximations.
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls to the user system function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if the default 
  \id{KINSpilsDQJtimes} difference quotient function is used.
}
%%
%%
\ucfunction{KINSpilsGetLastFlag}
{
  flag = KINSpilsGetLastFlag(kin\_mem, \&lsflag);
}
{
  The function \ID{KINSpilsGetLastFlag} returns the
  last return value from a {\kinspils} routine. 
}
{
  \begin{args}[kin\_mem]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from a {\kinspils} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_LMEM\_NULL]
  \item[\Id{KINSPILS\_SUCCESS}] 
    The optional output value has been successfully set.
  \item[\Id{KINSPILS\_MEM\_NULL}]
    The \id{kin\_mem} pointer is \id{NULL}.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    The linear solver module has not been initialized.
  \end{args}
}
{
  If the {\kinspils} setup function failed (\id{KINSOL} returned
  \id{KIN\_LSETUP\_FAIL}), \id{lsflag} will be set to
  \id{SPGMR\_PSET\_FAIL\_UNREC}, \id{SPFGMR\_PSET\_FAIL\_UNREC}, 
  \id{SPBCG\_PSET\_FAIL\_UNREC}, or \id{SPTFQMR\_PSET\_FAIL\_UNREC}.

  If the {\kinspgmr} solve function failed (\id{KINSol} returned
  \id{KIN\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpgmrSolve} and will be one of:
  \id{SPGMR\_MEM\_NULL}, indicating that the {\spgmr} memory is \id{NULL};
  \id{SPGMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  Jacobian-times-vector function;
  \id{SPGMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function, \id{psolve}, failed unrecoverably;
  \id{SPGMR\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure; 
  or \id{SPGMR\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
  singular during the QR solve phase.

  If the {\kinspfgmr} solve function failed (\id{KINSol} returned
  \id{KIN\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpfgmrSolve} and will be a similar value to one of the return codes for 
  {\kinspgmr}.
%  \id{SPFGMR\_MEM\_NULL}, indicating that the {\spfgmr} memory is \id{NULL};
%  \id{SPFGMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
%  Jacobian matrix-vector multiply function;
%  \id{SPFGMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
%  function, \id{psolve}, failed unrecoverably;
%  \id{SPFGMR\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure; 
%  or \id{SPFGMR\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
%  singular during the QR solve phase.

  If the {\kinspbcg} solve function failed (\id{KINSol} returned
  \id{KIN\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SpbcgSolve} and will be one of:
  \id{SPBCG\_MEM\_NULL}, indicating that the {\spbcg} memory is \id{NULL};
  \id{SPBCG\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  Jacobian-times-vector function; or
  \id{SPBCG\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function, \id{psolve}, failed unrecoverably.

  If the {\kinsptfqmr} solve function failed (\id{KINSol} returned
  \id{KIN\_LSOLVE\_FAIL}), \id{lsflag} contains the error return flag from
  \id{SptfqmrSolve} and will be one of:
  \id{SPTFQMR\_MEM\_NULL}, indicating that the {\sptfqmr} memory is \id{NULL};
  \id{SPTFQMR\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the 
  $J*v$ function; or 
  \id{SPTFQMR\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function, \id{psolve}, failed unrecoverably.
}
%%
%%
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!optional output|)} 
\index{KINSPBCG@{\kinspbcg} linear solver!optional output|)} 
\index{KINSPFGMR@{\kinspfgmr} linear solver!optional output|)} 
\index{KINSPGMR@{\kinspgmr} linear solver!optional output|)} 
\index{optional output!iterative linear solver|)}


%%==============================================================================
\section{User-supplied functions}\label{ss:user_fct_sol}
%%==============================================================================

The user-supplied functions consist of one function defining the nonlinear system,
(optionally) a function that handles error and warning messages,
(optionally) a function that handles informational messages, 
(optionally) a function that provides Jacobian-related information for the linear
solver, and (optionally) one or two functions that define the preconditioner for 
use in any of the Krylov iterative algorithms.

%%==============================================================================
\subsection{Problem-defining function}\label{ss:sysFn}
%%==============================================================================
\index{problem-defining function}

The user must provide a function of type \ID{KINSysFn} defined as follows:
\usfunction{KINSysFn}
{
  typedef int (*KINSysFn)(N\_Vector u, N\_Vector fval, void *user\_data);
}
{
  This function computes $F(u)$ (or $G(u)$ for fixed-point iteration and Anderson 
  acceleration) for a given value of the vector $u$.
}
{
  \begin{args}[user\_data]
  \item[u]
    is the current value of the variable vector, $u$.
  \item[fval]
    is the output vector $F(u)$.
  \item[user\_data]
    is a pointer to user data, the pointer \Id{user\_data}      
    passed to \id{KINSetUserData}.   
  \end{args}
}
{
  A \id{KINSysFn} function should return $0$ if successful, a positive value
  if a recoverable error occurred (in which case {\kinsol} will attempt to
  correct), or a negative value if it failed unrecoverably (in which case
  the solution process is halted and \id{KIN\_SYSFUNC\_FAIL} is returned).
}
{
  Allocation of memory for \id{fval} is handled within {\kinsol}.
}

%%==============================================================================
\subsection{Error message handler function}
\label{ss:ehFn}
%%==============================================================================
\index{error messages!user-defined handler}
As an alternative to the default behavior of directing error and warning messages 
to the file pointed to by \id{errfp} (see \id{KINSetErrFile}), the user may
provide a function of type \ID{KINErrHandlerFn} to process any such messages.
The function type \id{KINErrHandlerFn} is defined as follows:
\usfunction{KINErrHandlerFn}
{
  typedef void (*KINErrHandlerFn)(&int error\_code, const char *module, \\
                                  &const char *function, char *msg, \\ 
                                  &void *eh\_data); 
}
{
  This function processes error and warning messages from {\kinsol} and 
  its sub-modules.
}
{
  \begin{args}[error\_code]
  \item[error\_code]
    is the error code.
  \item[module]
    is the name of the {\kinsol} module reporting the error.
  \item[function]
    is the name of the function in which the error occurred.
  \item[msg]
    is the error message.
  \item[eh\_data]
    is a pointer to user data, the same as the \Id{eh\_data}
    parameter passed to \id{KINSetErrHandlerFn}.   
  \end{args}
}
{
  A \id{KINErrHandlerFn} function has no return value.
}
{
  \id{error\_code} is negative for errors and positive (\Id{KIN\_WARNING}) for warnings.
  If a function that returns a pointer to memory encounters an
  error, it sets \id{error\_code} to 0.
}

%%==============================================================================
\subsection{Informational message handler function}
\label{ss:ihFn}
%%==============================================================================
\index{informational messages!user-defined handler}
As an alternative to the default behavior of directing informational (meaning non-error) messages 
to the file pointed to by \id{infofp} (see \id{KINSetInfoFile}), the user may
provide a function of type \ID{KINInfoHandlerFn} to process any such messages.
The function type \id{KINInfoHandlerFn} is defined as follows:
\usfunction{KINInfoHandlerFn}
{
  typedef void (*KINInfoHandlerFn)(&const char *module, const char *function, \\ 
                                   &char *msg, void *ih\_data); 
}
{
  This function processes informational messages from {\kinsol} and 
  its sub-modules.
}
{
  \begin{args}[function]
  \item[module]
    is the name of the {\kinsol} module reporting the information.
  \item[function]
    is the name of the function reporting the information.
  \item[msg]
    is the message.
  \item[ih\_data]
    is a pointer to user data, the same as the \Id{ih\_data}
    parameter passed to \id{KINSetInfoHandlerFn}.   
  \end{args}
}
{
  A \id{KINInfoHandlerFn} function has no return value.
}
{}

%%==============================================================================
\subsection{Jacobian information (direct method with dense Jacobian)}
\label{ss:djacFn}
%%==============================================================================
\index{Jacobian approximation function!dense!user-supplied|(}

If the direct linear solver with dense treatment of the Jacobian is used 
(\Id{KINDense} or \id{KINLapackDense} is called in Step \ref{i:lin_solver} 
of \S\ref{s:skeleton_sol}), the user may provide a function of type 
\ID{KINDlsDenseJacFn} defined by
\usfunction{KINDlsDenseJacFn}
{
  typedef int (*KINDlsDenseJacFn)(&long int N, N\_Vector u, N\_Vector fu,\\
                                  &DlsMat J, void *user\_data,\\ 
                                  &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the dense Jacobian $J(u)$ 
  or an approximation to it.
}
{
  \begin{args}[jac\_data]
  \item[N]
    is the problem size.
  \item[u]
    is the current (unscaled) iterate.
  \item[fu]
    is the current value of the vector $F(u)$.
  \item[J]
    is the output approximate Jacobian matrix, $J = \partial{F}/\partial{u}$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{KINSetUserData}.   
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated    
    for variables of type \id{N\_Vector} which can be used by           
    \id{KINDenseJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A function of type \id{KINDlsDenseJacFn} should return $0$ if successful
  or a non-zero value otherwise.
}
{
  A user-supplied dense Jacobian function must load the \id{N} by \id{N}
  dense matrix \id{J} with an approximation to the Jacobian matrix $J(u)$ at \id{u}.
  Only nonzero elements need to be loaded
  into \id{J} because \id{J} is set to the zero matrix before the call
  to the Jacobian function. The type of \id{J} is \Id{DlsMat}. 
  
  The accessor macros \Id{DENSE\_ELEM} and \Id{DENSE\_COL} allow the user to
  read and write dense matrix elements without making explicit
  references to the underlying representation of the \id{DlsMat}
  type. \id{DENSE\_ELEM(J, i, j)} references the (\id{i}, \id{j})-th
  element of the dense matrix \id{J} (\id{i}, \id{j}$= 0\ldots N-1$). This macro
  is for use in small problems in which efficiency of access is not a major
  concern.  Thus, in terms of indices $m$ and $n$ running from $1$ to
  $N$, the Jacobian element $J_{m,n}$ can be loaded with the statement
  \id{DENSE\_ELEM(J, m-1, n-1) =} $J_{m,n}$.  Alternatively,
  \id{DENSE\_COL(J, j)} returns a pointer to the storage for
  the \id{j}th column of \id{J} (\id{j}$= 0\ldots N-1$), and the 
  elements of the \id{j}th column
  are then accessed via ordinary array indexing.  Thus $J_{m,n}$ can be 
  loaded with the statements \id{col\_n = DENSE\_COL(J, n-1);}
  \id{col\_n[m-1] =} $J_{m,n}$.  For large problems, it is more 
  efficient to use \id{DENSE\_COL} than to use \id{DENSE\_ELEM}. 
  Note that both of these macros number rows and columns
  starting from $0$, not $1$.  

  The \id{DlsMat} type and the accessor macros \id{DENSE\_ELEM} and 
  \id{DENSE\_COL} are documented in \S\ref{ss:dense}.

  If the user's \id{KINDlsDenseJacFn} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. 
  To obtain these, the user will need to add the \id{kin\_mem} 
  structure to their \id{user\_data} and 
  use the \id{KINGet*} functions described in
  \S\ref{sss:output_main}. The unit roundoff can be accessed
  as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  For the sake of uniformity, the argument \id{N} is of type \id{long int},
  even in the case that the Lapack dense solver is to be used.
}
\index{Jacobian approximation function!dense!user-supplied|)}

%%==============================================================================
\subsection{Jacobian information (direct method with banded Jacobian)}
\label{ss:bjacFn}
%%==============================================================================
\index{Jacobian approximation function!band!user-supplied|(}
\index{half-bandwidths|(}
If the direct linear solver with banded treatment of the Jacobian is used 
(\Id{KINBand} or \id{KINLapackBand} is called in Step \ref{i:lin_solver}
of \S\ref{s:skeleton_sol}), the user may provide a function of type 
\ID{KINDlsBandJacFn} defined by:
\usfunction{KINDlsBandJacFn}
{
 typedef int (*KINDlsBandJacFn)(&long int N, long int mupper,\\
                                &long int mlower, N\_Vector u, N\_Vector fu,\\
                                &DlsMat J, void *user\_data,\\
                                &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the banded Jacobian $J(u)$ 
  or a banded approximation to it.
}
{
  \begin{args}[jac\_data]
  \item[N]
    is the problem size.
  \item[mlower]
  \item[mupper]
    are the lower and upper half-bandwidths of the Jacobian.
  \item[u]
    is the current (unscaled) iterate.
  \item[fu]
    is the current value of the vector $F(u)$.
  \item[J]
    is the output approximate Jacobian matrix, $J = \partial{F}/\partial{u}$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{KINSetUserData}.   
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated    
    for variables of type \id{N\_Vector} which can be used by           
    \id{KINBandJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A function of type \id{KINDlsBandJacFn} should return $0$ if successful
  or a non-zero value otherwise.
}
{
  A user-supplied band Jacobian function must load the band matrix \id{J}
  of type \Id{DlsMat} with the elements of the Jacobian $J(u)$ at \id{u}.
  Only nonzero elements need to be loaded into
  \id{J} because \id{J} is preset to zero before the call to the
  Jacobian function.  

  The accessor macros \Id{BAND\_ELEM}, \Id{BAND\_COL}, and \Id{BAND\_COL\_ELEM} 
  allow the user to read and write band matrix elements without making specific 
  references to the underlying representation of the \id{DlsMat} type.
  \id{BAND\_ELEM(J, i, j)} references the (\id{i}, \id{j})th element of the 
  band matrix \id{J}, counting from $0$.
  This macro is for use in small problems in which efficiency of access is not
  a major concern.  Thus, in terms of indices $m$ and $n$ running from $1$ to
  $N$ with $(m,n)$ within the band defined by \id{mupper} and
  \id{mlower}, the Jacobian element $J_{m,n}$ can be loaded with the 
  statement \id{BAND\_ELEM(J, m-1, n-1) =} $J_{m,n}$. The elements within
  the band are those with \id{-mupper} $\le$ \id{m-n} $\le$ \id{mlower}.
  Alternatively, \id{BAND\_COL(J, j)} returns a pointer to the diagonal element
  of the \id{j}th column of \id{J}, and if we assign this address to 
  \id{realtype *col\_j}, then the \id{i}th element of the \id{j}th column is
  given by \id{BAND\_COL\_ELEM(col\_j, i, j)}, counting from $0$.
  Thus for $(m,n)$ within the band, $J_{m,n}$ can be loaded by setting 
  \id{col\_n = BAND\_COL(J, n-1);} \id{BAND\_COL\_ELEM(col\_n, m-1, n-1) =}
  $J_{m,n}$.  The elements of the \id{j}th column can also be accessed
  via ordinary array indexing, but this approach requires knowledge of
  the underlying storage for a band matrix of type \id{DlsMat}.  
  The array \id{col\_n} can be indexed from $-$\id{mupper} to \id{mlower}.
  For large problems, it is more efficient to use the combination of
  \id{BAND\_COL} and \id{BAND\_COL\_ELEM} than to use the
  \id{BAND\_ELEM}.  As in the dense case, these macros all number rows
  and columns starting from $0$, not $1$.  

  The \id{DlsMat} type and the accessor macros \id{BAND\_ELEM}, \id{BAND\_COL},
  and \id{BAND\_COL\_ELEM} are documented in \S\ref{ss:band}.

  If the user's \id{KINDlsBandJacFn} function uses difference quotient approximations,
  it may need to access quantities not in the call list. 
  To obtain these, the user will need to add the \id{kin\_mem} 
  structure to their \id{user\_data} and use the
  \id{KINGet*} functions described in \S\ref{sss:output_main}. The unit roundoff
  can be accessed as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  For the sake of uniformity, the arguments \id{N}, \id{mlower}, and \id{mupper} are
  of type \id{long int}, even in the case that the Lapack band solver is to be used.
}
\index{half-bandwidths|)}
\index{Jacobian approximation function!band!user-supplied|)}

%%==============================================================================
\subsection{Jacobian information (direct method with sparse Jacobian)}
\label{ss:sjacFn}
%%==============================================================================
\index{Jacobian approximation function!sparse!user-supplied|(}

If the direct linear solver with sparse treatment of the Jacobian is used 
(\Id{KINKLU} or \id{KINSuperLUMT} is called in Step \ref{i:lin_solver} 
of \S\ref{s:skeleton_sol}), the user may provide a function of type 
\ID{KINSlsSparseJacFn} defined by 
\usfunction{KINSlsSparseJacFn}
{
  typedef int (*KINSlsSparseJacFn)(&N\_Vector u, N\_Vector fu,\\
                                   &SlsMat J, void *user\_data,\\ 
                                   &N\_Vector tmp1, N\_Vector tmp2);
}
{
  This function computes the sparse Jacobian $J(u)$ or an approximation to it.
}
{
  \begin{args}[jac\_data]
  \item[u]
    is the current (unscaled) iterate.
  \item[fu]
    is the current value of the vector $F(u)$.
  \item[J]
    is the output approximate Jacobian matrix, $J = \partial{F}/\partial{u}$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{KINSetUserData}.   
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated    
    for variables of type \id{N\_Vector} which can be used by           
    \id{KINSlsSparseJacFn} as temporary storage or work space.    
  \end{args}
}
{
  A function of type \id{KINSlsSparseJacFn} should return $0$ if successful
  or a non-zero value otherwise.
}
{
  A user-supplied sparse Jacobian function must load the
  compressed-sparse-column matrix \id{J} with an approximation to the
  Jacobian matrix $J(u)$ at the point (\id{u}).  Storage for \id{J}
  already exists on entry to this function, although the user should
  ensure that sufficient space is allocated in \id{J} to hold the
  nonzero values to be set; if the existing space is insufficient the
  user may reallocate the data and row index arrays as needed.  The
  type of \id{J} is \id{SlsMat}, and the amount of allocated space is
  available within the \id{SlsMat} structure as \id{NNZ}.  The
  \id{SlsMat} type is further documented in the Section \S\ref{s:sls}.
  
  If the user's \id{KINSlsSparseJacFn} function uses difference quotient
  approximations to set the specific nonzero matrix entries, then it
  may need to access quantities not in the argument list. To obtain
  these, use the \id{KINGet*} functions described in
  \S\ref{sss:output_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{Jacobian approximation function!sparse!user-supplied|)}

%%==============================================================================
\subsection{Jacobian information (matrix-vector product)}
\label{ss:jtimesFn}
%%==============================================================================
\index{Jacobian approximation function!Jacobian times vector!user-supplied|(}
%%
If one of the Krylov iterative linear solvers {\spgmr}, {\spbcg}, or {\sptfqmr}
is selected (\id{KINSp*} is called in step \ref{i:lin_solver} of
\S\ref{s:skeleton_sol}), the user may provide a \id{jtimes} function of type
\ID{KINSpilsJacTimesVecFn} to compute products $J v$.  If such a function is not
supplied, the default is a difference quotient approximation of these products.
%%
\usfunction{KINSpilsJacTimesVecFn}
{
  typedef int (*KINSpilsJacTimesVecFn)(&N\_Vector v, N\_Vector Jv, \\
                                       &N\_Vector u, booleantype new\_u, \\
                                       &void *user\_data);
}
{
  This \id{jtimes} function computes the product $J v$ 
  (or an approximation to it).
}
{
  \begin{args}[jac\_data]
  \item[v]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[Jv]
      is the computed output vector.
  \item[u]
    is the current value of the dependent variable vector.
  \item[new\_u]
    is a flag, input from {\kinsol} and possibly reset by the user's
    \id{jtimes} function, indicating whether the iterate vector \id{u} has been
    updated since the last call to \id{jtimes}.  This is useful if the \id{jtimes}
    function computes and saves Jacobian data that depends on \id{u} for use in
    computing $J(u)v$.  The input value of \id{new\_u} is \id{TRUE} following an
    update by {\kinsol}, and in that case any saved Jacobian data depending on
    \id{u} should be recomputed.  The \id{jtimes} routine should then set \id{new\_u}
    to \id{FALSE}, so that on subsequent calls to \id{jtimes} with the same \id{u},
    the saved data can be reused.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to \id{KINSetUserData}.
  \end{args}
}
{  
  The value to be returned by the Jacobian-times-vector function   should be
  $0$ if successful. If a recoverable failure occurred, the return
  value should be positive.  In this case, {\kinsol} will attempt to
  correct by calling the preconditioner setup function. If this
  information is current, {\kinsol} halts.  If the
  Jacobian-times-vector function encounters an unrecoverable error, it
  should return a negative value, prompting {\kinsol} to halt.  } { If
  a user-defined routine is not given, then an internal {\kinspgmr}
  function, using difference quotient approximations, is used.

  If the user-provided \id{KINSpilsJacTimesVecFn} function needs the unit roundoff,
  this can be accessed as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.
}
\index{Jacobian approximation function!Jacobian times vector!user-supplied|)}

%%==============================================================================
\subsection{Preconditioning (linear system solution)} \label{ss:psolveFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner solve function}
\index{KINSPFGMR@{\kinspfgmr} linear solver!preconditioner solve function}
\index{KINSPBCG@{\kinspbcg} linear solver!preconditioner solve function}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!preconditioner solve function}

If preconditioning is used, then the user must provide a {\C} function to
solve the linear system $Pz = r$ where $P$ is the preconditioner matrix,
approximating (at least crudely) the system Jacobian $J = \partial{F}/\partial{u}$. 
This function must be of type \ID{KINSpilsPrecSolveFn}, defined as follows:
%%
%%
\usfunction{KINSpilsPrecSolveFn}
{
  typedef int (*KINSpilsPrecSolveFn)(&N\_Vector u, N\_Vector uscale,  \\
                                     &N\_Vector fval, N\_Vector fscale,  \\
                                     &N\_Vector v, void *user\_data, \\
                                     &N\_Vector tmp);
}
{
  This function solves the preconditioning system $Pz = r$.
}
{  
  \begin{args}[prec\_data]
  \item[u] 
    is the current (unscaled) value of the iterate.
  \item[uscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{u}.
  \item[fval]
    is the vector $F(u)$ evaluated at \id{u}.
  \item[fscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{fval}.
  \item[v]
    on input, \id{v} is set to the right-hand side vector of the linear 
    system, \id{r}. On output, \id{v} must contain the solution \id{z} of
    the linear system $Pz=r$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to the function \id{KINSetUserData}.
  \item[tmp]
    is a pointer to memory allocated for a variable of type \id{N\_Vector}
    which can be used for work space.
  \end{args}
}
{
  The value to be returned by the preconditioner solve function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  positive for a recoverable error, and negative for an unrecoverable error.
}
{
  If the preconditioner solve function fails recoverably and if the preconditioner
  information (set by the preconditioner setup function) is out of date, {\kinsol}
  attempts to correct by calling the setup function. If the preconditioner data
  is current, {\kinsol} halts.
}

%%==============================================================================
\subsection{Preconditioning (Jacobian data)}\label{ss:precondFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{KINSPGMR@{\kinspgmr} linear solver!preconditioner setup function}
\index{KINSPFGMR@{\kinspfgmr} linear solver!preconditioner setup function}
\index{KINSPBCG@{\kinspbcg} linear solver!preconditioner setup function}
\index{KINSPTFQMR@{\kinsptfqmr} linear solver!preconditioner setup function}

If the user's preconditioner requires that any Jacobian-related data
be evaluated or preprocessed, then this needs to be done in a
user-supplied {\C} function of type \ID{KINSpilsPrecSetupFn}, defined as follows:
\usfunction{KINSpilsPrecSetupFn}
{
typedef int (*KINSpilsPrecSetupFn)(&N\_Vector u, N\_Vector uscale, \\
                                   &N\_Vector fval, N\_Vector fscale,\\
                                   &void *user\_data, N\_Vector tmp1,\\
                                   &N\_Vector tmp2);
}
{
  This function evaluates and/or preprocesses Jacobian-related data needed
  by the preconditioner solve function.
}
{
  The arguments of a \id{KINSpilsPrecSetupFn} are as follows:
  \begin{args}[prec\_data]
  \item[u] 
    is the current (unscaled) value of the iterate.
  \item[uscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{u}.
  \item[fval]
    is the vector $F(u)$ evaluated at \id{u}.
  \item[fscale]
    is a vector containing diagonal elements
    of the scaling matrix for \id{fval}.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}      
    parameter passed to the function \id{KINSetUserData}.
  \item[tmp1]
  \item[tmp2]
    are pointers to memory allocated for variables of type \id{N\_Vector}
    which can be used by \id{KINSpilsPrecSetupFn} as temporary storage or 
    work space.    
  \end{args}
}
{
  The value to be returned by the preconditioner setup function is a flag
  indicating whether it was successful.  This value should be $0$ if successful, 
  any other value resulting in halting the {\kinsol} solver.
}
{
  The user-supplied preconditioner setup subroutine should
  compute the right preconditioner matrix $P$ (stored in the memory
  block referenced by the \id{user\_data} pointer) used to form the
  scaled preconditioned linear system
    $$(D_F J(u) P^{-1} D_u^{-1}) \cdot (D_u P x) = - D_F F(u) \, ,$$
   where $D_u$ and $D_F$ denote the diagonal scaling matrices whose
  diagonal elements are stored in the vectors \id{uscale} and
  \id{fscale}, respectively.
 
  The preconditioner setup routine will not be called prior
  to every call made to the preconditioner solve function, but will instead be
  called only as often as necessary to achieve convergence of the
  Newton iteration.
 
  If the user's \id{KINSpilsPrecSetupFn} function uses difference quotient approximations,
  it may need to access quantities not in the call list.
  To obtain these, the user will need to add the \id{kin\_mem} 
  structure to their \id{user\_data} and use the
  \id{KINGet*} functions described in \S\ref{sss:output_main}. The unit roundoff
  can be accessed as \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.


  If the preconditioner solve routine requires no preparation, then a
  preconditioner setup function need not be given.
}

%%==============================================================================
\section{A parallel band-block-diagonal preconditioner module}
\label{sss:kinbbdpre}
%%==============================================================================
The efficiency of Krylov iterative methods for the solution of linear systems 
can be greatly enhanced through preconditioning. For problems in which the 
user cannot define a more effective, problem-specific preconditioner,
{\kinsol} provides a band-block-diagonal preconditioner module {\kinbbdpre}, 
to be used with the parallel \id{N\_Vector} module described in \S\ref{ss:nvec_par}.

This module provides a preconditioner matrix for {\kinsol} that
is block-diagonal with banded blocks. The blocking corresponds
to the distribution of the dependent variable vector $u$ amongst
the processes. Each preconditioner block is generated from
the Jacobian of the local part (associated with the current
process) of a given function $G(u)$ approximating $F(u)$
($G = F$ is allowed). The blocks are generated by each process via a
difference quotient scheme, utilizing a specified band structure.
This structure is given by upper and lower half-bandwidths, \id{mudq}
and \id{mldq}, defined as the number of non-zero diagonals above and
below the main diagonal, respectively.  However, from the resulting
approximate Jacobain blocks, only a matrix of bandwidth \id{mukeep} $+$
\id{mlkeep} $+ 1$ is retained.

Neither pair of parameters need be the true half-bandwidths of the Jacobian
of the local block of $G$, if smaller values provide a more efficient
preconditioner.  Such an efficiency gain may occur if the couplings
in the system outside a certain bandwidth are considerably weaker than
those within the band.  Reducing \id{mukeep} and \id{mlkeep} while keeping
\id{mudq} and \id{mldq} at their true values, discards the elements
outside the narrower band.  Reducing both pairs has the additional
effect of lumping the outer Jacobian elements into the computed elements
within the band, and requires more caution and experimentation to see
whether the lower cost of narrower band matrices offsets the loss of
accuracy in the blocks.

\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-supplied functions|(}
The {\kinbbdpre} module calls two user-provided functions to construct $P$: 
a required function \id{Gloc} (of type \id{KINLocalFn}) which
approximates the nonlinear system function function $G(u) \approx F(u)$ and which 
is computed locally, and an optional function \id{Gcomm} (of type \id{KINCommFn}) 
which performs all interprocess communication necessary to evaluate 
the approximate function $G$.  
These are in addition to the user-supplied nonlinear system function that 
evaluates $F(u)$.
Both functions take as input the same pointer \id{user\_data} as that passed
by the user to \id{KINSetUserData} and passed to the user's function \id{func},
and neither function has a return value. The user is responsible for
providing space (presumably within \id{user\_data}) for components of \id{u}
that are communicated by \id{Gcomm} from the other processes, and that are
then used by \id{Gloc}, which should not do any communication.
%%
%%
\usfunction{KINLocalFn}
{
  typedef void (*KINLocalFn)(&long int Nlocal, N\_Vector u, \\
                             &N\_Vector gval, void *user\_data);
}
{
  This \id{Gloc} function computes $G($\id{u}$)$, and outputs the resulting
  vector as \id{gval}.
}
{
  \begin{args}[Nlocal]
  \item[Nlocal] 
    is the local vector length.
  \item[u]
    is the current value of the iterate.
  \item[gval]
    is the output vector.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{KINSetUserData}.  
  \end{args}
}
{
  A \id{KINLocalFn} function type does not have a return value.
}
{
  This function must assume that all interprocess communication of data needed to 
  calculate \id{gval} has already been done, and this data is accessible within
  \id{user\_data}.

   Memory for \id{u} and \id{gval} is handled within the preconditioner module.

  The case where $G$ is mathematically identical to $F$ is allowed.
}
%%
%%
\usfunction{KINCommFn}
{
  typedef void (*KINCommFn)(long int Nlocal, N\_Vector u, void *user\_data);
}
{
  This \id{Gcomm} function performs all interprocess communications necessary 
  for the execution of the \id{Gloc} function above, using the input vector \id{u}.
}
{
  \begin{args}[Nlocal]
  \item[Nlocal] 
    is the local vector length.
  \item[u]
    is the current value of the iterate.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}      
    parameter passed to \id{KINSetUserData}.  
  \end{args}
}
{
  A \id{KINCommFn} function type does not have a return value.
}
{
  The \id{Gcomm} function is expected to save communicated data in space defined
  within the structure \id{user\_data}. 

  Each call to the \id{Gcomm} function is preceded by a call to the system function
  \id{func} with the same \id{u} argument.  Thus \id{Gcomm} can omit 
  any communications done by \id{func} if relevant to the evaluation of \id{Gloc}.
  If all necessary communication was done in \id{func}, then \id{Gcomm = NULL}
  can be passed in the call to \id{KINBBDPrecInit} (see below).
}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-supplied functions|)}

%%
%% ----------------------------------------
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!usage|(}
%%
Besides the header files required for the solution of a nonlinear problem
(see \S\ref{s:header_sol}),  to use the {\kinbbdpre} module, the main program 
must include the header file \id{kinbbdpre.h} which declares the needed
function prototypes.\index{header files}

The following is a summary of the usage of this module and describes the sequence
of calls in the user main program. Steps that are unchanged from the user main
program presented in \S\ref{s:skeleton_sol} are grayed out.
%%
%%
\index{User main program!KINBBDPRE@{\kinbbdpre} usage}
\begin{Steps}
\item 
  \textcolor{gray}{\bf Initialize MPI}

\item
  \textcolor{gray}{\bf Set problem dimensions}

\item
  \textcolor{gray}{\bf Set vector with initial guess}
 
\item
  \textcolor{gray}{\bf Create {\kinsol} object}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item
  \textcolor{gray}{\bf Allocate internal memory}

\item \label{i:bbdpre_attach}
  {\bf Attach iterative linear solver, one of:}

  \id{flag = KINSpgmr(kin\_mem, maxl);}

  \id{flag = KINSpfgmr(kin\_mem, maxl);}

  \id{flag = KINSpbcg(kin\_mem, maxl);}

  \id{flag = KINSptfqmr(kin\_mem, maxl);}


\item \label{i:bbdpre_init}
  {\bf Initialize the {\kinbbdpre} preconditioner module}

  Specify the upper and lower half-bandwidth pairs (\id{mudq}, \id{mldq}) and
  (\id{mukeep}, \id{mlkeep}), and call

   \id{
     \begin{tabular}[t]{@{}r@{}l@{}}
       flag = KINBBDPrecInit(&kin\_mem, Nlocal, mudq, mldq, \\
                             &mukeep, mlkeep, dq\_rel\_u, Gloc, Gcomm);
     \end{tabular}
   }

  to allocate memory for and initialize the internal preconditoner data.
  The last two arguments of \id{KINBBDPrecInit} are the two user-supplied 
  functions described above.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

  Note that the user should not overwrite the preconditioner data, setup function,
  or solve function through calls to {\kinspils} optional input functions.

\item
  \textcolor{gray}{\bf Solve problem}

\item
  {\bf Get optional output}

  Additional optional outputs associated with {\kinbbdpre} are available by 
  way of two routines described below,
  \id{KINBBDPrecGetWorkSpace} and \id{KINBBDPrecGetNumGfnEvals}.

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item
  \textcolor{gray}{\bf Free solver memory}
  
\item 
  \textcolor{gray}{\bf Finalize MPI}

\end{Steps}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!usage|)}

%%
%% ----------------------------------------
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-callable functions|(}
%%
The user-callable function that initializes {\kinbbdpre} (step \ref{i:bbdpre_init}),
is described in more detail below.
%%
\index{half-bandwidths}
\ucfunction{KINBBDPrecInit}
{
   \begin{tabular}[t]{@{}r@{}l@{}}
     flag = KINBBDPrecInit(&kin\_mem, Nlocal, mudq, mldq, \\
                           &mukeep, mlkeep, dq\_rel\_u, Gloc, Gcomm);
   \end{tabular}
}
{
  The function \ID{KINBBDPrecInit} initializes and allocates
  memory for the {\kinbbdpre} preconditioner.
}
{
  \begin{args}[dq\_rel\_u]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[Nlocal] (\id{long int})
    local vector length.
  \item[mudq] (\id{long int})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldq] (\id{long int})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeep] (\id{long int})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeep] (\id{long int})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dq\_rel\_u] (\id{realtype})
    the relative increment in components of \id{u} used in the difference quotient
    approximations.  The default is \id{dq\_rel\_u}$ = \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dq\_rel\_u}$ = 0.0$.
  \item[Gloc] (\id{KINLocalFn})
    the {\C} function which computes the approximation $G(u) \approx F(u)$. 
  \item[Gcomm] (\id{KINCommFn})
    the optional {\C} function which performs all interprocess communication required for
    the computation of $G(u)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[KINSPILS\_ILL\_INPUT]
  \item[KINSPILS\_SUCCESS]
    The call to \id{KINBBDPrecInit} was successful.
  \item[\id{KINSPILS\_MEM\_NULL}] 
    The \id{kin\_mem} pointer was \id{NULL}.
  \item[\Id{KINSPILS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{KINSPILS\_LMEM\_NULL}]
    A {\kinspils} linear solver was not attached.
  \item[\Id{KINSPILS\_ILL\_INPUT}]
    The supplied vector implementation was not compatible with block band preconditioner.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} to be used in the
  difference-quotient calculation of the approximate Jacobian is negative
  or exceeds the value \id{Nlocal}$-1$, it is replaced with $0$ or
  \id{Nlocal}$-1$ accordingly.

  The half-bandwidths \id{mudq} and \id{mldq} need
  not be the true half-bandwidths of the Jacobian of the local block of $G$,    
  when smaller values may provide greater efficiency.

  Also, the half-bandwidths \id{mukeep} and \id{mlkeep} of the retained
  banded approximate Jacobian block may be even smaller, to reduce
  storage and computation costs further.

  For all four half-bandwidths, the values need not be the same for
  every process.
}
%%
\index{KINBBDPRE@{\kinbbdpre} preconditioner!user-callable functions|)}
%%
\index{optional output!band-block-diagonal preconditioner|(}
\index{KINBBDPRE@{\kinbbdpre} preconditioner!optional output|(}
The following two optional output functions are available for use with
the {\kinbbdpre} module:
%%
\ucfunction{KINBBDPrecGetWorkSpace}
{
  flag = KINBBDPrecGetWorkSpace(kin\_mem, \&lenrwBBDP, \&leniwBBDP);
}
{
  The function \ID{KINBBDPrecGetWorkSpace} returns the local
  {\kinbbdpre} real and integer workspace sizes.
}
{
  \begin{args}[lenrwBBDP]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[lenrwBBDP] (\id{long int})
    local number of \id{realtype} values in the {\kinbbdpre} workspace.
  \item[leniwBBDP] (\id{long int})
    local number of integer values in the {\kinbbdpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_PMEM\_NULL]
  \item[KINSPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\id{KINSPILS\_MEM\_NULL}] 
    The \id{kin\_mem} pointer was \id{NULL}.
  \item[\Id{KINSPILS\_PMEM\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{
  \index{memory requirements!KINBBDPRE@{\kinbbdpre} preconditioner}
  In terms of the local vector dimension \id{Nlocal} and
  \id{smu} = $\min ( N_l - 1 ,$ \id{mukeep} $+$ \id{mlkeep}$)$, the actual size
  of the real workspace is $(2$ \id{mlkeep} $+$ \id{mukeep} $+$ \id{smu} $+2)$ \id{Nlocal}
  \id{realtype} words, and the actual size of the integer workspace is
  \id{Nlocal} integer words. These values are local to the current processor.

  The workspaces referred to here exist in addition to those given by the
  corresponding \id{KINSp*GetWorkSpace} function.
}
%%
%%
\ucfunction{KINBBDPrecGetNumGfnEvals}
{
  flag = KINBBDPrecGetNumGfnEvals(kin\_mem, \&ngevalsBBDP);
}
{
  The function \ID{KINBBDPrecGetNumGfnEvals} returns the
  number of calls to the user \id{Gloc} function due to the 
  difference quotient approximation of the Jacobian blocks used within
  {\kinbbdpre}'s preconditioner setup function.
}
{
  \begin{args}[ngevalsBBDP]
  \item[kin\_mem] (\id{void *})
    pointer to the {\kinsol} memory block.
  \item[ngevalsBBDP] (\id{long int})
    the number of calls to the user \id{Gloc} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[KINSPILS\_PMEM\_NULL]
  \item[KINSPILS\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\id{KINSPILS\_MEM\_NULL}] 
    The \id{kin\_mem} pointer was \id{NULL}.
  \item[\Id{KINSPILS\_PMEM\_NULL}]
    The {\kinbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
%%

\index{KINBBDPRE@{\kinbbdpre} preconditioner!optional output|)}
\index{optional output!band-block-diagonal preconditioner|)}

In addition to the \id{ngevalsBBDP} \id{Gloc} evaluations,
the costs associated with {\kinbbdpre} also include \id{nlinsetups} LU
factorizations, \id{nlinsetups} calls to \id{Gcomm}, \id{npsolves} banded
backsolve calls, and \id{nfevalsLS} right-hand side function evaluations,
where \id{nlinsetups} is an optional {\kinsol} output and \id{npsolves} and 
\id{nfevalsLS} are linear solver optional outputs (see \S\ref{ss:optional_output}).

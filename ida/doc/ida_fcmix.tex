%%==============================================================================
\chapter{FIDA, an Interface Module for FORTRAN Applications}\label{s:fcmix}
%%==============================================================================

The {\fida} interface module is a package of {\C} functions which support
the use of the {\ida} solver, for the solution of DAE systems, in a mixed
{\F}/{\C} setting.  While {\ida} is written in {\C}, it is assumed here
that the user's calling program and user-supplied problem-defining routines
are written in {\F}. This package provides the necessary interface to {\ida}
for both the serial and the parallel {\nvector} implementations.

%%==============================================================================
\section{FIDA routines}\label{sss:fidaroutines}
%%==============================================================================

\index{FIDA@{\fida} interface module!user-callable functions|(}
The user-callable functions, with the corresponding {\ida} functions,
are as follows:
\begin{itemize}
\item
  Interface to the {\nvector} modules
  \begin{itemize}
  \item \id{FNVINITS} (defined by {\nvecs}) 
    interfaces to \id{N\_VNewEmpty\_Serial}.
  \item \id{FNVINITP} (defined by {\nvecp}) 
    interfaces to \id{N\_VNewEmpty\_Parallel}.
  \end{itemize}
\item Interface to the main {\ida} module
  \begin{itemize}
  \item \id{FIDAMALLOC}
    interfaces to \id{IDACreate} and \id{IDAMalloc}.
  \item \id{FIDAREINIT}
    interfaces to \id{IDAReInit}.
  \item \id{FIDASETIIN}, \id{FIDASETVIN}, and \id{FIDASETRIN}
    interface to \id{IDASet*} functions.    
  \item \id{FIDATOLREINIT}
    interfaces to \id{IDASetTolerances}.
  \item \id{FIDACALCIC}
    interfaces to \id{IDACalcIC}.
  \item \id{FIDAEWTSET}
    interfaces to \id{IDAEwtSetFn}.
  \item \id{FIDASOLVE}
    interfaces to \id{IDASolve}, \id{IDAGet*} functions, and to the optional
    output functions for the selected linear solver module.
  \item \id{FIDAGETSOL}
    interfaces to \id{IDAGetSolution}.
  \item \id{FIDAGETERRWEIGHTS}
    interfaces to \id{IDAGetErrWeights}.
  \item \id{FIDAGETESTLOCALERR}
    interfaces to \id{IDAGetEstLocalErrors}.
  \item \id{FIDAFREE}    
    interfaces to \id{IDAFree}.
  \end{itemize}
\item Interface to the linear solver modules
  \begin{itemize}
  \item \id{FIDADENSE}
    interfaces to \id{IDADense}.
  \item \id{FIDADENSESETJAC}
    interfaces to \id{IDADenseSetJacFn}.
  \item \id{FIDABAND}
    interfaces to \id{IDABand}.
  \item \id{FIDABANDSETJAC}
    interfaces to \id{IDABandSetJacFn}.
  \item \id{FIDASPGMR}
    interfaces to \id{IDASpgmr} and {\spgmr} optional input functions.
  \item \id{FIDASPGMRREINIT}
    interfaces to {\spgmr} optional input functions.
  \item \id{FIDASPBCG}
    interfaces to \id{IDASpbcg} and {\spbcg} optional input functions.
  \item \id{FIDASPBCGREINIT}
    interfaces to {\spbcg} optional input functions.
  \item \id{FIDASPTFQMR}
    interfaces to \id{IDASptfqmr} and {\sptfqmr} optional input functions.
  \item \id{FIDASPTFQMRREINIT}
    interfaces to {\sptfqmr} optional input functions.
  \item \id{FIDASPILSSETJAC}
   interfaces to \id{IDASpilsSetJacTimesVecFn}.
 \item \id{FIDASPILSSETPREC}
   interfaces to \id{IDASpilsSetPreconditioner}.
 \end{itemize}

\end{itemize}
\index{FIDA@{\fida} interface module!user-callable functions|)}

\index{FIDA@{\fida} interface module!user-supplied functions}
The user-supplied functions, each listed with the corresponding interface
function which calls it (and its type within {\ida}), are as follows:
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\fida} routine ({\F})  &  {\ida} function ({\C}) & {\ida} function type \\\hline
\id{FIDARESFUN} & \id{FIDAresfn}    & \id{IDAResFn} \\
\id{FIDAEWT}    & \id{FIDAEwtSet}   & \id{IDAEwtFn} \\
\id{FIDADJAC}   & \id{FIDADenseJac} & \id{IDADenseJacFn} \\
\id{FIDABJAC}   & \id{FIDABandJac}  & \id{IDABandJacFn} \\
\id{FIDAPSOL}   & \id{FIDAPSol}     & \id{IDASpilsPrecSolveFn} \\
\id{FIDAPSET}   & \id{FIDAPSet}     & \id{IDASpilsPrecSetupFn} \\
\id{FIDAJTIMES} & \id{FIDAJtimes}   & \id{IDASpilsJacTimesVecFn} \\\hline
\end{tabular}
\end{center}
In contrast to the case of direct use of {\ida}, and of most {\F} DAE
solvers, the names of all user-supplied routines here are fixed, in
order to maximize portability for the resulting mixed-language program.

%%==============================================================================
\subsection{Important note on portability}
%%==============================================================================
\index{portability!Fortran}

In this package, the names of the interface functions, and the names of
the {\F} user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files \id{fida.h}, \id{fidaroot.h}, and \id{fidabbd.h}.
By default, those mapping definitions depend in turn on the {\C} macros
\id{F77\_FUNC} and \id{F77\_FUNC\_} defined in the header file
\id{sundials\_config.h} by \id{configure}. 
However, the set of flags \\
\Id{SUNDIALS\_CASE\_UPPER}, \Id{SUNDIALS\_CASE\_LOWER},\\
\Id{SUNDIALS\_UNDERSCORE\_NONE}, \Id{SUNDIALS\_UNDERSCORE\_ONE}, 
and \Id{SUNDIALS\_UNDERSCORE\_TWO}\\
can be explicitly defined in the header file \id{sundials\_config.h}
when configuring {\sundials} via the \id{--with-f77underscore}
and \id{--with-f77case} options to override the default behavior if necessary
(see Chapter \ref{s:install}). Either way, the names into which the dummy names
are mapped are in upper or lower case and have up to two underscores appended.

The user must also ensure that variables in the user {\F} code are
declared in a manner consistent with their counterparts in {\ida}.
All real variables must be declared as \id{REAL}, \id{DOUBLE PRECISION},
or perhaps as \id{REAL*}{\em n}, where {\em n} denotes the number of bytes,
depending on whether {\ida} was built in single, double, or extended precision 
(see Chapter \ref{s:install}). Moreover, some of the {\F} integer variables
must be declared as \id{INTEGER*4} or \id{INTEGER*8} according to the 
{\C} type \id{long int}. These integer variables include: the array of
integer optional outputs (\id{IOUT}), problem dimensions (\id{NEQ},
\id{NLOCAL}, \id{NGLOBAL}), Jacobian half-bandwidths (\id{MU}, \id{ML}, etc.),
as well as the array of user integer data, \id{IPAR}.
This is particularly important when using {\ida} and the {\fida}
package on 64-bit architectures.

%%==============================================================================
\section{Usage of the FIDA interface module}\label{ss:fida_usage}
%%==============================================================================
\index{FIDA@{\fida} interface module!usage|(}

The usage of {\fida} requires calls to five or more interface
functions, depending on the method options selected, and one or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding {\ida} functions for information on the arguments 
of any given user-callable interface routine, or of a given user-supplied 
function called by an interface function.
The usage of {\fida} for rootfinding, and usage of {\fida} with
preconditioner modules, are each described in later sections.

Steps marked with {\s} in the instructions below apply to the serial
{\nvector} implementation ({\nvecs}) only, while those marked with {\p}
apply to {\nvecp}.

\index{User main program!FIDA@{\fida} usage}
\begin{Steps}
  
\item {\bf Residual function specification}
  
  The user must in all cases supply the following {\F} routine
  \index{FIDARESFUN@\texttt{FIDARESFUN}}
\begin{verbatim}
      SUBROUTINE FIDARESFUN (T, Y, YP, R, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), R(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the \id{R} array to $F(t,y,y')$, the residual function of the DAE
  system, as a function of \id{T} $ = t$ and the arrays \id{Y} $ = y$ and
  \id{YP} $ = y'$.  
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  It should return \id{IER} = 0 if it was successful,
  \id{IER} = 1 if it had a recoverable failure, or
  \id{IER} = -1 if it had a non-recoverable failure.
  
\item  {\bf {\nvector} module initialization}

  {\s} To initialize the serial {\nvector} module, the user must make the
  following call:
  \index{FNVINITS@\texttt{FNVINITS}}
\begin{verbatim}
      CALL FNVINITS (KEY, NEQ, IER)
\end{verbatim}
  where 
  \id{KEY} is the solver id (\id{KEY}=1 for {\ida}),
  \id{NEQ} is the size of vectors, and
  \id{IER} is a return flag, which is set to $0$ on success and $-1$ 
  if a failure occurred.
  
  {\p} To initialize the parallel vector module, the user must make the
  following call:
  \index{FNVINITP@\texttt{FNVINITP}}
\begin{verbatim}
      CALL FNVINITP (COMM, KEY, NLOCAL, NGLOBAL, IER)
\end{verbatim}
  in which the arguments are: \id{COMM} = {\mpi} communicator, \id{KEY} = 1,
  \id{NLOCAL} = the local size of all vectors on this processor, and
  \id{NGLOBAL} = the system size (and the global size of vectors, equal to the
  sum of all values of \id{NLOCAL}). The return flag \id{IER} is
  set to $0$ on a successful return and to $-1$ otherwise.

  {\warn} If the header file \id{sundials\_config.h} defines
  \id{SUNDIALS\_MPI\_COMM\_F2C} to be $0$, then the argument
  \id{COMM} is ignored and \id{MPI\_COMM\_WORLD} is used.
  
\item {\bf Problem specification}

  To set various problem and solution parameters and allocate
  internal memory, make the following call:
  \index{FIDAMALLOC@\texttt{FIDAMALLOC}}
  \ucfunction{FIDAMALLOC}
  {
    \begin{tabular}[t]{@{}r@{}l@{}l}
        &CALL FIDAMALLOC(&T0, Y0, YP0, IATOL, RTOL, ATOL,  \\
    {\&}&                &IOUT, ROUT, IPAR, RPAR, IER)
  \end{tabular}
  }
  {
    This function provides required problem and solution specifications, 
    specifies optional inputs,
    allocates internal memory, and initializes {\ida}.
  }
  {
    \begin{args}[IATOL]
    \item[T0] is the initial value of $t$.
    \item[Y0] is an array of initial conditions for $y$.
    \item[YP0] is an array of initial conditions for $y'$.
    \item[IATOL] specifies the type for absolute tolerance \id{ATOL}:
      $1$ for scalar or $2$ for array. If \id{IATOL}$=3$, the arguments
      \id{RTOL} and \id{ATOL} are ignored and the user is expected to
      subsequently call \id{FIDAEWTSET} and provide the function \id{FIDAEWT}.
    \item[RTOL] is the relative tolerance (scalar).
    \item[ATOL] is the absolute tolerance (scalar or array).
    \item[IOUT] is an integer array of length at least 21 for integer optional
                outputs.
    \item[ROUT] is a real array of length at least 6 for real optional outputs.
    \item[IPAR] is an integer array of user data which will be passed
      unmodified to all user-provided routines.
    \item[RPAR] is a real array of user data which will be passed
      unmodified to all user-provided routines.
    \end{args}
  }
  {
    \id{IER} is a return completion flag.  Values are $0$ for successful return
    and $-1$ otherwise. See printed message for details in case of failure.
  }
  {
    The user intger data array \id{IPAR} must be declared as \id{INTEGER*4} or 
    \id{INTEGER*8} according to the {\C} type \id{long int}.

    Modifications to the user data arrays \id{IPAR} and \id{RPAR} inside a 
    user-provided routine will be propagated to all subsequent calls to
    such routines.

    The optional outputs associated with the main {\ida} integrator
    are listed in Table~\ref{t:fida_out}.
  }

  As an alternative to providing tolerances in the call to \ID{FIDAMALLOC}, the
  user may provide a routine to compute the error weights used in the WRMS norm
  evaluations. If supplied, it must have the following form:
  \index{FIDAEWT@\texttt{FIDAEWT}}
\begin{verbatim}
      SUBROUTINE FIDAEWT (Y, EWT, IPAR, RPAR, IER)
      DIMENSION Y(*), EWT(*), IPAR(*), RPAR(*)
\end{verbatim}
  It must set the positive components of the error weight vector \id{EWT} for
  the calculation of the WRMS norm of \id{Y}. On return, set
  \id{IER} = 0 if \id{FIDAEWT} was successful, and nonzero otherwise.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the \id{FIDAEWT} routine is provided, then, 
  following the call to \id{FIDAMALLOC}, the user must make the call:
  \index{FIDAEWTSET@\texttt{FIDAEWTSET}}
\begin{verbatim}
      CALL FIDAEWTSET (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied error weight routine.
  The argument \id{IER} is an error return flag, which is $0$ 
  for success or non-zero if an error occurred.

\item\label{i:fida_lin_solv_spec} {\bf Linear solver specification} 
  
  The variable-order, variable-coefficient \id{BDF} method used by {\ida} involves
  the solution of linear systems related to the system Jacobian
  $J = \partial F / \partial y + \alpha \partial F / \partial y^\prime$.
  See Eq. (\ref{e:DAE_Newtoncorr}).  {\ida} presently includes five choices for
  the treatment of these systems, and the user of {\fida} must call a routine with
  a specific name to make the desired choice.

  %%-------------------------------------------------

  {\s} {\bf Dense treatment of the linear system}
  \index{IDADENSE@{\idadense} linear solver!use in {\fida}}
  
  The user must make the call:
  \index{FIDADENSE@\texttt{FIDADENSE}}
\begin{verbatim}
      CALL FIDADENSE (NEQ, IER)
\end{verbatim}
  where \id{NEQ} is the size of the DAE system.
  The argument \id{IER} is an error return flag, which is $0$ 
  for success , $-1$ if a memory allocation failure occurred, or $-2$ for illegal
  input.  \index{Jacobian approximation function!dense!use in {\fida}}
  As an option when using the {\dense} linear solver, the user may supply a
  routine that computes a dense approximation of the system Jacobian. If supplied,
  it must have the following form:
  \index{FIDADJAC@\texttt{FIDADJAC}}
\begin{verbatim}
      SUBROUTINE FIDADJAC (NEQ, T, Y, YP, R, DJAC, CJ, EWT, H,
     &                     IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), DJAC(NEQ,*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*)
\end{verbatim}
  This routine must compute the Jacobian and store it columnwise in \id{DJAC}.
  The vectors \id{WK1}, \id{WK2}, and \id{WK3} of length \id{NEQ} are provided
  as work space for use in \id{FIDADJAC}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $y'$, $F(t,y,y')$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  
  If the user's \id{FIDADJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the \id{FIDADJAC} routine is provided, then, 
  following the call to \id{FIDADENSE}, the user must make the call:
  \index{FIDADENSESETJAC@\texttt{FIDADENSESETJAC}}
\begin{verbatim}
      CALL FIDADENSESETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag, which is $0$ 
  for success or non-zero if an error occurred.
  
  Optional outputs specific to the {\dense} case are listed in
  Table~\ref{t:fida_out}.

  %%-------------------------------------------------

  {\s} {\bf Band treatment of the linear system}
  \index{IDABAND@{\idaband} linear solver!use in {\fida}}
  
  The user must make the call:
  \index{FIDABAND@\texttt{FIDABAND}}
\begin{verbatim}
      CALL FIDABAND (NEQ, MU, ML, IER)
\end{verbatim}
  The arguments are: \id{MU}, the upper half-bandwidth; \id{ML}, 
  the lower half-bandwidth; and \id{IER}, an error return flag, which is  
  $0$ for success , $-1$ if a memory allocation failure occurred, or $-2$ 
  in case an input has an illegal value.     
  
  \index{Jacobian approximation function!band!use in {\fida}}
  As an option when using the {\band} linear solver, the user may supply a
  routine that computes a band approximation of the system Jacobian. If supplied,
  it must have the following form:
  \index{FIDABJAC@\texttt{FIDABJAC}}
\begin{verbatim}
      SUBROUTINE FIDABJAC(NEQ, MU, ML, MDIM, T, Y, YP, R, CJ, BJAC,
     &                    EWT, H, IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), BJAC(MDIM,*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*)
\end{verbatim}
  This routine must load the \id{MDIM} by \id{NEQ} array \id{BJAC} with the
  Jacobian matrix at the current $(t, y, y')$ in band form.  Store in
  \id{BJAC}$(k,j)$ the Jacobian element $J_{i,j}$ with $k = i - j + $\id{MU}$ + 1$
  ($k = 1 \cdots $\id{ML} + \id{MU} + 1) and $j = 1 \cdots N$. The vectors
  \id{WK1}, \id{WK2}, and \id{WK3} of length \id{NEQ} are provided as work space
  for use in \id{FIDABJAC}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $y'$, $F(t,y,y')$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDABJAC} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If the \id{FIDABJAC} routine is provided, then, following the call to
  \id{FIDABAND}, the user must make the call:
  \index{FIDABANDSETJAC@\texttt{FIDABANDSETJAC}}
\begin{verbatim}
      CALL FIDABANDSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ to specify use of the user-supplied Jacobian
  approximation.  The argument \id{IER} is an error return flag, which is $0$ 
  for success or non-zero if an error occurred.
  
  Optional outputs specific to the {\band} case are listed in
  Table~\ref{t:fida_out}.

  %%-------------------------------------------------

  {\s}{\p} {\bf SPGMR treatment of the linear systems}
  \index{IDASPGMR@{\idaspgmr} linear solver!use in {\fida}}
  
  For the Scaled Preconditioned GMRES solution of the linear systems,
  the user must make the call
  \index{FIDASPGMR@\texttt{FIDASPGMR}}
\begin{verbatim}
      CALL FIDASPGMR (MAXL, IGSTYPE, MAXRS, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{IGSTYPE} indicates the Gram-Schmidt process type: $1$ for modified,
   or $2$ for classical.
  \id{MAXRS} maximum number of restarts.
  \id{EPLIFAC} is the linear convergence tolerance factor.
  \id{DQINCFAC} is the optional increment factor used in the matrix-vector product
  $Jv$.
  For all the input arguments, a value of 0 or $0.0$ indicates the default.
  \id{IER} is an error return flag, which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\spgmr} case are listed in
  Table~\ref{t:fida_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR} below.

  %%-------------------------------------------------

  {\s}{\p} {\bf SPBCG treatment of the linear systems}
  \index{IDASPBCG@{\idaspbcg} linear solver!use in {\fida}}
  
  For the Scaled Preconditioned Bi-CGStab solution of the linear systems,
  the user must make the call
  \index{FIDASPBCG@\texttt{FIDASPBCG}}
\begin{verbatim}
      CALL FIDASPBCG (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{EPLIFAC} is the linear convergence tolerance factor.
  \id{DQINCFAC} is the optional increment factor used in the matrix-vector product
  $Jv$.
  For all the input arguments, a value of 0 or $0.0$ indicates the default.
  \id{IER} is an error return flag, which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\spbcg} case are listed in
  Table~\ref{t:fida_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR} below.

  %%-------------------------------------------------

  {\s}{\p} {\bf SPTFQMR treatment of the linear systems}
  \index{IDASPTFQMR@{\idasptfqmr} linear solver!use in {\fida}}
  
  For the Scaled Preconditioned Transpose-Free Quasi-Minimal Residual solution of
  the linear systems, the user must make the call
  \index{FIDASPTFQMR@\texttt{FIDASPTFQMR}}
\begin{verbatim}
      CALL FIDASPTFQMR (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  The arguments are as follows.
  \id{MAXL} is the maximum Krylov subspace dimension.
  \id{EPLIFAC} is the linear convergence tolerance factor.
  \id{DQINCFAC} is the optional increment factor used in the matrix-vector product
  $Jv$.
  For all the input arguments, a value of 0 or $0.0$ indicates the default.
  \id{IER} is an error return flag, which is $0$ to indicate success, $-1$
  if a memory allocation failure occurred, or $-2$ to indicate an illegal input.
  
  Optional outputs specific to the {\sptfqmr} case are listed in
  Table~\ref{t:fida_out}.

  For descriptions of the relevant optional user-supplied routines, see 
  below.

  %%-------------------------------------------------
  
  {\s}{\p} {\bf Functions used by SPGMR/SPBCG/SPTFQMR}
  
  An optional user-supplied routine, \id{FIDAJTIMES}, can be provided for
  Jacobian-vector products.  If it is, then, following the call to
  \id{FIDASPGMR}, \id{FIDASPBCG}, or \id{FIDASPTFQMR}, the user must make the call:
  \index{FIDASPILSSETJAC@\texttt{FIDASPILSSETJAC}}
\begin{verbatim}
      CALL FIDASPILSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if successful,
  or negative if a memory error occurred.

  If preconditioning is to be done, then the user must call
  \index{FIDASPILSSETPREC@\texttt{FIDASPILSSETPREC}}
\begin{verbatim}
      CALL FIDASPILSSETPREC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$.  The return flag \id{IER} is 0 if successful,
  or negative if a memory error occurred.  In addition, the user must
  supply preconditioner routines \id{FIDAPSET} and \id{FIDAPSOL}.

  %%-------------------------------------------------

  {\s}{\p} {\bf User-supplied routines for SPGMR/SPBCG/SPTFQMR}

  With treatment of the linear systems by any of the Krylov iterative
  solvers, there are three optional user-supplied routines ---
  \id{FIDAJTIMES}, \id{FIDAPSOL}, and \id{FIDAPSET}.  The specifications
  for these routines are given below.

  \index{Jacobian approximation function!Jacobian times vector!use in {\fida}}
  As an option when using any of the Krylov iterative solvers, the user may
  supply a routine that computes the product of the system Jacobian
  $J = \partial F / \partial y + \alpha \partial F / \partial y^\prime$
  and a given vector $v$.  If supplied, it must have the following form:
  \index{FIDAJTIMES@\texttt{FIDAJTIMES}}
\begin{verbatim}
      SUBROUTINE FIDAJTIMES(T, Y, YP, R, V, FJV, CJ, EWT, H, 
     &                      IPAR, RPAR, WK1, WK2, IER)
      DIMENSION Y(*), YP(*), R(*), V(*), FJV(*), EWT(*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*)
\end{verbatim}
  This routine must compute the product vector $Jv$, where the vector $v$ is
  stored in \id{V}, and store the product in \id{FJV}.  On return, set
  \id{IER = 0} if \id{FIDAJTIMES} was successful, and nonzero otherwise.
  The vectors \id{W1K} and \id{WK2}, of length \id{NEQ}, are
  provided as work space for use in \id{FIDAJTIMES}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $y'$, $F(t,y,y')$, and $\alpha$, respectively.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDAJTIMES} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  If preconditioning is to be included, the following routine must be
  supplied, for solution of the preconditioner linear system:
  \index{FIDAPSOL@\texttt{FIDAPSOL}}
\begin{verbatim}
      SUBROUTINE FIDAPSOL(T, Y, YP, R, RV, ZV, CJ, DELTA, EWT, 
     &                    IPAR, RPAR, WK1, IER)
      DIMENSION Y(*), YP(*), R(*), RV(*), ZV(*), EWT(*), 
     &          IPAR(*), RPAR(*), WK1(*)
\end{verbatim}
  It must solve the preconditioner linear system $Pz = r$, where $r =$ \id{RV} 
  is input, and store the solution $z$ in \id{ZV}. Here $P$ is the left 
  preconditioner if \id{LR=1} and the right preconditioner if \id{LR=2}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $y'$, $F(t,y,y')$, and $\alpha$, respectively.
  On return, set \id{IER = 0} if \id{FIDAPSOL} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a 
  non-recoverable error occurred.

  The arguments \id{EWT} and \id{DELTA} are input and provide the error weight
  array and a scalar tolerance, respectively, for use by \id{FIDAPSOL} if it uses
  an iterative method in its solution.  In that case, the residual vector
  $\rho = r - Pz$ of the system should be made less than \id{DELTA} in weighted
  $\ell_2$ norm, i.e. $\sqrt{\sum(\rho_i * \id{EWT}[i])^2} < $ \id{DELTA}.
  The argument \id{WK1} is a work array of length \id{NEQ} for use by this
  routine.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's preconditioner requires that any Jacobian-related data be evaluated
  or preprocessed, then the following routine is to be used for the evaluation and 
  preprocessing of the preconditioner:
  \index{FIDAPSET@\texttt{FIDAPSET}}
\begin{verbatim}
      SUBROUTINE FIDAPSET(T, Y, YP, R, CJ, EWT, H, 
     &                    IPAR, RPAR, WK1, WK2, WK3, IER)
      DIMENSION Y(*), YP(*), R(*), EWT(*), 
     &          IPAR(*), RPAR(*), WK1(*), WK2(*), WK3(*) 
\end{verbatim}
  It must perform any evaluation of Jacobian-related data and preprocessing needed
  for the solution of the preconditioner linear systems by \id{FIDAPSOL}.
  The input arguments \id{T}, \id{Y}, \id{YP}, \id{R}, and \id{CJ} are the
  current values of $t$, $y$, $y'$, $F(t,y,y')$, and $\alpha$, respectively.
  On return, set \id{IER = 0} if \id{FIDAPSET} was successful, set \id{IER}
  positive if a recoverable error occurred, and set \id{IER} negative if a 
  non-recoverable error occurred.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  If the user's \id{FIDAPSET} uses difference quotient approximations, it
  may need to use the error weight array \id{EWT} and current stepsize \id{H}
  in the calculation of suitable increments.  It may also need the unit
  roundoff, which can be obtained as the optional output \id{ROUT(6)},
  passed from the calling program to this routine using \id{COMMON}.

  {\warn} If the user calls \id{FIDASPILSSETPREC},
  the subroutine \id{FIDAPSET} must be provided, even if it is not needed and
  must return \id{IER=0}.

\item {\bf Correct initial values}

  Optionally, to correct the initial values $y$ and/or $y'$, make the call
\begin{verbatim}
      CALL FIDACALCIC (T0, Y0, YP0, ICOPT, TOUT1, IER)
\end{verbatim}
  (See \S\ref{ss:ivp_sol} for details.)  The arguments are as follows:
  \id{T0} is $t_0$. \id{Y0} and \id{YP0} are the initial guesses for $y$
  and $y'$ at $t_0$.
  \id{ICOPT} is 1 for initializing the algebraic components of $y$ and
  differential components of $y'$, or 2 for initializing all of $y$.
  \id{IER} is an error return flag, which is 0 for success, or negative
  for a failure (see \id{IDACalcIC} return values).

\item {\bf Problem solution}

  Carrying out the integration is accomplished by making calls as follows:
  \index{FIDASOLVE@\texttt{FIDASOLVE}}
\begin{verbatim}
      CALL FIDASOLVE (TOUT, T, Y, YP, ITASK, IER)
\end{verbatim}
  The arguments are as follows.
  \id{TOUT} specifies the next value of $t$ at which a solution is desired (input).
  \id{T} is the value of $t$ reached by the solver on output.
  \id{Y} is an array containing the computed solution vector $y$ on output.
  \id{YP} is an array containing the computed solution vector $y'$ on output.
  \id{ITASK} is a task indicator and should be set to $1$ for normal mode 
  (overshoot \id{TOUT} and interpolate), to $2$ for one-step mode 
  (return after each internal step taken), to $3$ for normal mode with
  the additional \id{tstop} constraint, or to $4$ for one-step mode 
  with the additional constraint \id{tstop}.
  \id{IER} is a completion flag and will be set to a positive value upon
  successful return or to a negative value if an error occurred. These values
  correspond to the \id{IDASolve} returns (see \S\ref{sss:idasolve} and \S\ref{s:ida_out_constants}).
  The current values of the optional outputs are available in \id{IOUT} and
  \id{ROUT} (see Table~\ref{t:fida_out}).
  
\item {\bf Additional solution output}

  After a successful return from \id{FIDASOLVE}, the routine \id{FIDAGETSOL} may
  be called to get interpolated values of $y$ and $y'$ for any value of $t$ in
  the last internal step taken by {\ida}.
  \index{FIDAGETSOL@\texttt{FIDAGETSOL}}
\begin{verbatim}
      CALL FIDAGETSOL (T, Y, YP, IER)
\end{verbatim}
  where
  \id{T} is the input value of $t$ at which solution derivative is desired, and
  \id{Y} and \id{YP} are arrays containing the computed vectors $y$ and $y'$
  on return.  The value \id{T} must lie between \id{TCUR-HLAST} and \id{TCUR}.
  The return flag \id{IER} is set to $0$ upon successful return, or to a
  negative value to indicate an illegal input.
  
\item {\bf Problem reinitialization}

  To re-initialize the {\ida} solver for the solution of a new problem
  of the same size as one already solved, make the following call:
  \index{FIDAREINIT@\texttt{FIDAREINIT}}
\begin{verbatim}
      CALL FIDAREINIT (T0, Y0, YP0, IATOL, RTOL, ATOL, IER)
\end{verbatim}
  The arguments have the same names and meanings as those of \id{FIDAMALLOC}.
  \id{FIDAREINIT} performs the same initializations as \id{FIDAMALLOC}, but
  does no memory allocation, using instead the existing internal memory
  created by the previous \id{FIDAMALLOC} call.

  Following this call, a call to specify the linear system solver must be
  made if the choice of linear solver is being changed.  Otherwise, a call
  to reinitialize the linear solver last used may or may not be needed,
  depending on changes in the inputs to it.

  In the case of the {\band} solver, for any change in the half-bandwidths,
  call \id{FIDABAND} as described above.

  In the case of {\spgmr}, for a change of inputs other than \id{MAXL},
  make the call
  \index{FIDASPGMRREINIT@\texttt{FIDASPGMRREINIT}}
\begin{verbatim}
      CALL FIDASPGMRREINIT (IGSTYPE, MAXRS, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  which reinitializes {\spgmr} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FIDASPGMR}.
  If \id{MAXL} is being changed, then call \id{FIDASPGMR}.

  In the case of {\spbcg}, for a change in any inputs, make the call
  \index{FIDASPBCGREINIT@\texttt{FIDASPBCGREINIT}}
\begin{verbatim}
      CALL FIDASPBCGREINIT (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  which reinitializes {\spbcg} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FIDASPBCG}.

  In the case of {\sptfqmr}, for a change in any inputs, make the call
  \index{FIDASPTFQMRREINIT@\texttt{FIDASPTFQMRREINIT}}
\begin{verbatim}
      CALL FIDASPTFQMRREINIT (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  which reinitializes {\sptfqmr} without reallocating its memory.
  The arguments have the same names and meanings as those of \id{FIDASPTFQMR}.

\item {\bf Memory deallocation}

  To free the internal memory created by the call to \id{FIDAMALLOC},
  make the call
  \index{FIDAFREE@\texttt{FIDAFREE}}
\begin{verbatim}
      CALL FIDAFREE
\end{verbatim}

\end{Steps}
\index{FIDA@{\fida} interface module!usage|)}

%%==============================================================================
\section{FIDA optional input and output}
%%==============================================================================
\index{FIDA@{\fida} interface module!optional input and output}

In order to keep the number of user-callable {\fida} interface routines to
a minimum, optional inputs to the {\ida} solver are passed through only
three routines: \Id{FIDASETIIN} for integer optional inputs, \Id{FIDASETRIN}
for real optional inputs, and \Id{FIDASETVIN} for real vector (array) optional
inputs.  These functions should be called as follows:
\begin{verbatim}
      CALL FIDASETIIN(KEY, IVAL, IER)
      CALL FIDASETRIN(KEY, RVAL, IER)
      CALL FIDASETVIN(KEY, VVAL, IER)
\end{verbatim}
where \id{KEY} is a quoted string indicating which optoinal input is set
(see Table \ref{t:fida_in}), \id{IVAL} is the input integer value,
\id{RVAL} is the input real value (scalar),
\id{VVAL} is the input real array, and
\id{IER} is an integer return flag which is set to $0$ on success and
a negative value if a failure occurred.

When using \id{FIDASETVIN} to specify the variable types (\id{KEY = 'ID\_VEC'})
the components in the array \id{VVAL} must be $1.0$ to indicate a differential 
variable, or $0.0$ to indicate an algebraic variable.
Note that this array is required only if \id{FIDACALCIC} is to be called
with \id{ICOPT = 1}, or if algebraic variables are suppressed from the error
test (indicated using \id{FIDASETIIN} with \id{KEY = 'SUPPRESS\_ALG'}).
%
When using \id{FIDASETVIN} to specify optional constraints on the
solution vector (\id{KEY = 'CONSTR\_VEC'}) the components in the
array \id{VVAL} should be one of $-2.0$, $-1.0$, $0.0$, $1.0$, or $2.0$.
See the description of \id{IDASetConstraints} (\S\ref{sss:optin_main})
for details.

The optional outputs from the {\ida} solver are accessed not through
individual functions, but rather through a pair of arrays, \Id{IOUT}
(integer type) of dimension at least $21$, and \Id{ROUT} (real type) of
dimension at least $6$.  These arrays are owned (and allocated) by
the user and are passed as arguments to \id{FIDAMALLOC}.  Table
\ref{t:fida_out} lists the entries in these two arrays and specifies
the optional variable as well as the {\ida} function which is actually
called to extract the optional output.

For more details on the optional inputs and outputs, see \S\ref{ss:optional_input}
and \S\ref{ss:optional_output}.

\begin{table}
\centering
\caption{Keys for setting {\fida} optional inputs}
\label{t:fida_in}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer optional inputs (\id{FIDASETIIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{MAX\_ORD}      & Maximum LMM method order & $5$  \\
\Id{MAX\_NSTEPS}   & Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$
                   & $500$  \\
\Id{MAX\_ERRFAIL}  & Maximum no. of error test failures & $10$  \\
\Id{MAX\_NITERS}   & Maximum no. of nonlinear iterations & $4$  \\
\Id{MAX\_CONVFAIL} & Maximum no. of convergence failures & $10$  \\
\Id{SUPPRESS\_ALG}   & Suppress alg. vars. from error test (1 = TRUE)
                     & 0 (= FALSE)  \\
\Id{MAX\_NSTEPS\_IC}   & Maximum no. of steps for IC calc. & $5$  \\
\Id{MAX\_NITERS\_IC}   & Maximum no. of Newton iterations for IC calc.& $10$  \\
\Id{MAX\_NJE\_IC}  & Maximum no. of Jac. evals fo IC calc. & $4$  \\
\Id{LS\_OFF\_IC}  & Turn off line search (1 = TRUE) & 0 (= FALSE)  \\


\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real optional inputs (\id{FIDASETRIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{INIT\_STEP}   & Initial step size & estimated \\
\Id{MAX\_STEP}    & Maximum absolute step size & $\infty$ \\
\Id{STOP\_TIME}   & Value of $t_{stop}$ & undefined \\
\Id{NLCONV\_COEF} & Coeff. in the nonlinear conv. test & $0.33$ \\
\Id{NLCONV\_COEF\_IC} & Coeff. in the nonlinear conv. test for IC calc.& $0.0033$ \\
\Id{STEP\_TOL\_IC} & Lower bound on Newton step for IC calc. & uround$^{2/3}$ \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real vector optional inputs (\id{FIDASETVIN})}\\
\hline
{\bf Key} & {\bf Optional input} & Default value \\ 
\hline
\Id{ID\_VEC}   & Differential/algebraic component types & undefined\\
\Id{CONSTR\_VEC}   & Inequality constraints on solution & undefined \\
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Description of the {\fida} optional output arrays \Id{IOUT} and \Id{ROUT}}
\label{t:fida_out}
\medskip
\begin{tabular}{|r|c|l|}
\multicolumn{3}{c}{Integer output array \id{IOUT}}\\\hline
{\bf Index} & {\bf Optional output} & {\ida} {\bf function} \\ 
\hline
\multicolumn{3}{|c|}{{\ida} main solver}\\
\hline
 1 & \id{LENRW}     & \id{IDAGetWorkSpace} \\
 2 & \id{LENIW}     & \id{IDAGetWorkSpace} \\
 3 & \id{NST}       & \id{IDAGetNumSteps} \\
 4 & \id{NRE}       & \id{IDAGetNumResEvals} \\
 5 & \id{NETF}      & \id{IDAGetNumErrTestFails} \\
 6 & \id{NNCFAILS}  & \id{IDAGetNonlinSolvConvFails} \\
 7 & \id{NNI}       & \id{IDAGetNumNonlinSolvIters} \\
 8 & \id{NSETUPS}   & \id{IDAGetNumLinSolvSetups} \\
 9 & \id{QLAST}     & \id{IDAGetLastOrder} \\
10 & \id{QCUR}      & \id{IDAGetCurrentOrder} \\
11 & \id{NBCKTRKOPS}& \id{IDAGetNumBacktrackOps} \\
12 & \id{NGE}       & \id{IDAGetNumGEvals} \\
\hline
\multicolumn{3}{|c|}{{\idadense} linear solver}\\
\hline
13 &  \id{LENRWLS}  & \id{IDADenseGetWorkSpace} \\ 
14 &  \id{LENIWLS}  & \id{IDADenseGetWorkSpace} \\ 
15 &  \id{LS\_FLAG} & \id{IDADenseGetLastFlag} \\
16 &  \id{NRELS}    & \id{IDADenseGetNumResEvals} \\
17 &  \id{NJE}      & \id{IDADenseGetNumJacEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\idaband} linear solver}\\
\hline
13 &  \id{LENRWLS}  & \id{IDABandGetWorkSpace} \\ 
14 &  \id{LENIWLS}  & \id{IDABandGetWorkSpace} \\ 
15 &  \id{LS\_FLAG} & \id{IDABandGetLastFlag} \\ 
16 &  \id{NRELS}    & \id{IDABandGetNumResEvals} \\
17 &  \id{NJE}      & \id{IDABandGetNumJacEvals} \\ 
\hline
\multicolumn{3}{|c|}{{\idaspgmr}, {\idaspbcg}, {\idasptfqmr} linear solvers}\\
\hline
13 &  \id{LENRWLS}  & \id{IDASpilsGetWorkSpace} \\ 
14 &  \id{LENIWLS}  & \id{IDASpilsGetWorkSpace} \\ 
15 &  \id{LS\_FLAG} & \id{IDASpilsGetLastFlag} \\ 
16 &  \id{NRELS}    & \id{IDASpilsGetNumResEvals} \\
17 &  \id{NJE}      & \id{IDASpilsGetNumJtimesEvals} \\
18 &  \id{NPE}      & \id{IDASpilsGetNumPrecEvals} \\ 
19 &  \id{NPS}      & \id{IDASpilsGetNumPrecSolves} \\ 
20 &  \id{NLI}      & \id{IDASpilsGetNumLinIters} \\ 
21 &  \id{NCFL}     & \id{IDASpilsGetNumConvFails} \\
\hline
\multicolumn{3}{c}{}\\
\multicolumn{3}{c}{Real output array \id{ROUT}}\\\hline
{\bf Index} & {\bf Optional output} & {\ida} {\bf function} \\ 
\hline
 1 & \id{H0\_USED} & \id{IDAGetActualInitStep} \\
 2 & \id{HLAST}    & \id{IDAGetLastStep} \\
 3 & \id{HCUR}     & \id{IDAGetCurrentStep} \\
 4 & \id{TCUR}     & \id{IDAGetCurrentTime} \\
 5 & \id{TOLFACT}  & \id{IDAGetTolScaleFactor} \\
 6 & \id{UROUND}   & unit roundoff \\
\hline
\end{tabular}
\end{table}

In addition to the optional inputs communicated through \id{FIDASET*}
calls and the optional outputs extracted from \id{IOUT}
and \id{ROUT}, the following user-callable routines are available:

To reset the tolerances at any time, make the following call:
\index{FIDATOLREINIT@\texttt{FIDATOLREINIT}}
\begin{verbatim}
      CALL FIDATOLREINIT (IATOL, RTOL, ATOL, IER)
\end{verbatim}
The tolerance arguments have the same names and meanings as those of
\id{FIDAMALLOC}.  The error return flag \id{IER} is 0 if successful,
and negative if there was a memory failure or illegal input.

To obtain the error weight array \id{EWT}, containing the multiplicative
error weights used the WRMS norms, make the following call:
\index{FIDAGETERRWEIGHTS@\texttt{FIDAGETERRWEIGHTS}}
\begin{verbatim}
      CALL FIDAGETERRWEIGHTS (EWT, IER)
\end{verbatim}
This computes the \id{EWT} array, normally defined by Eq. (\ref{e:errwt}). 
The array \id{EWT}, of length \id{NEQ} or \id{NLOCAL}, must already have been
declared by the user.  The error return flag \id{IER} is zero if successful,
and negative if there was a memory error.

To obtain the estimated local errors, following a successful call to
\id{FIDASOLVE}, make the following call:
\index{FIDAGETESTLOCALERR@\texttt{FIDAGETESTLOCALERR}}
\begin{verbatim}
      CALL FIDAGETESTLOCALERR (ELE, IER)
\end{verbatim}
This computes the \id{ELE} array of estimated local errors as of the last
step taken.  The array \id{ELE} must already have been declared by the user.
The error return flag \id{IER} is zero if successful, and negative if there
was a memory error.

%%==============================================================================
\section{Usage of the FIDAROOT interface to rootfinding}
%%==============================================================================
\index{FIDA@{\fida} interface module!rootfinding|(}
\index{Rootfinding}

The {\fidaroot} interface package allows programs written in {\F} to
use the rootfinding feature of the {\ida} solver module.
%%
The user-callable functions in {\fidaroot}, with the corresponding
{\ida} functions, are as follows: 
\begin{itemize}
  \item \id{FIDAROOTINIT} interfaces to \id{IDARootInit}.
  \item \id{FIDAROOTINFO} interfaces to \id{IDAGetRootInfo}.
  \item \id{FIDAROOTFREE} interfaces to \id{IDARootFree}.
\end{itemize}
%%
In order to use the rootfinding feature of {\ida}, the following call must
be made, after calling \id{FIDAMALLOC} but prior to calling \id{FIDASOLVE},
to allocate and initialize memory for the \id{FIDAROOT} module:
\begin{verbatim}
      CALL FIDAROOTINIT (NRTFN, IER)
\end{verbatim}
The arguments are as follows:
\id{NRTFN} is the number of root functions.
\id{IER} is a return completion flag; its values are $0$ for success, $-1$ 
if the \id{IDA} memory was \id{NULL}, and $-14$ if a memory allocation failed.

To specifiy the functions whose roots are to be found, the user must
define the following routine:
\begin{verbatim}
      SUBROUTINE FIDAROOTFN (T, Y, YP, G, IPAR, RPAR, IER)
      DIMENSION Y(*), YP(*), G(*), IPAR(*), RPAR(*)
\end{verbatim}
It must set the \id{G} array, of length \id{NRTFN}, with components
$g_i(t,y,y')$, as a function of \id{T} $= t$ and the arrays \id{Y} $= y$
and \id{YP} $= y'$.
The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
and are the same as those passed to \id{FIDAMALLOC}.
Set \id{IER} on 0 if successful, or on a non-zero value if an error occurred.

When making calls to \id{FIDASOLVE} to solve the DAE system, the occurrence
of a root is flagged by the return value \id{IER} = 2.  In that case, if
\id{NRTFN} $> 1$, the functions $g_i$ which were found to have a root can
be identified by making the following call:
\begin{verbatim}
      CALL FIDAROOTINFO (NRTFN, INFO, IER)
\end{verbatim}
The arguments are as follows: \id{NRTFN} is the number of root functions.
\id{INFO} is an integer array of length \id{NRTFN} with root information.
\id{IER} is a return completion flag; its values are $0$ for success, 
negative if there was a memory failure.  The returned values of \id{INFO(i)}
(\id{i}$ = 1,\ldots,$ \id{NRTFN}) are 0 or 1, such that \id{INFO(i)} $ = 1$
if $g_{\id{i}}$ was found to have a root, and \id{INFO(i)} $ = 0$ otherwise.

The total number of calls made to the root function \id{FIDAROOTFN},
denoted \id{NGE}, can be obtained from \id{IOUT(12)}.
%%
If the {\fida}/{\ida} memory block is reinitialized to solve a
different problem via a call to \id{FIDAREINIT}, then the counter
\id{NGE} is reset to zero.

To free the memory resources allocated by a prior call to \id{FIDAROOTINIT} make
the following call:
\begin{verbatim}
      CALL FIDAROOTFREE
\end{verbatim}
See \S\ref{s:using_rootfinding} for additional information on the
rootfinding feature.
\index{FIDA@{\fida} interface module!rootfinding|)}



%%==============================================================================
\section{Usage of the FIDABBD interface to IDABBDPRE}
%%==============================================================================
\index{FIDA@{\fida} interface module!interface to the {\idabbdpre} module|(}

The {\fidabbd} interface sub-module is a package of {\C} functions
which, as part of the {\fida} interface module, support the use of the
{\ida} solver with the parallel {\nvecp} module, in a combination of
any of the Krylov iterative solver modules with the {\idabbdpre} preconditioner
module (see \S\ref{sss:idabbdpre}).

The user-callable functions in this package, with the corresponding
{\ida} and {\idabbdpre} functions, are as follows: 
\begin{itemize}
\item \id{FIDABBDINIT}
  interfaces to \id{IDABBDPrecAlloc}.
\item \id{FIDABBDSPGMR}
  interfaces to \id{IDABBDSpgmr} and {\spgmr} optional input functions.
\item \id{FIDABBDSPBCG}
  interfaces to \id{IDABBDSpbcg} and {\spbcg} optional input functions.
\item \id{FIDABBDSPTFQMR}
  interfaces to \id{IDABBDSptfqmr} and {\sptfqmr} optional input functions.
\item \id{FIDABBDREINIT}
  interfaces to \id{IDABBDPrecReInit}.
\item \id{FIDABBDOPT}
  interfaces to {\idabbdpre} optional output functions.
\item \id{FIDABBDFREE}
  interfaces to \id{IDABBDPrecFree}.
\end{itemize}

In addition to the {\F} residual function \id{FIDARESFUN}, the
user-supplied functions used by this package, are listed below,
each with the corresponding interface function which calls it (and its
type within {\idabbdpre} or {\ida}):
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\fidabbd} routine ({\F})  &  {\ida} function ({\C}) & {\ida} function type \\\hline
\id{FIDAGLOCFN}  & \id{FIDAgloc}     & \id{IDABBDLocalFn} \\
\id{FIDACOMMFN}  & \id{FIDAcfn}      & \id{IDABBDCommFn} \\
\id{FIDAJTIMES} & \id{FIDAJtimes}   & \id{IDASpilsJacTimesVecFn} \\ \hline
\end{tabular}
\end{center}
As with the rest of the {\fida} routines, the names of all user-supplied routines 
here are fixed, in order to maximize portability for the resulting mixed-language
program.  Additionally, based on flags discussed above in \S\ref{sss:fidaroutines},
the names of the user-supplied routines are mapped to actual values
through a series of definitions in the header file \id{fidabbd.h}.

The following is a summary of the usage of this module. Steps that are unchanged
from the main program described in \S\ref{ss:fida_usage} are grayed-out.

\index{User main program!FIDABBD@{\fidabbd} usage}
\begin{Steps}
  
\item \textcolor{gray}{\bf Residual function specification}

\item \textcolor{gray}{\bf {\nvector} module initialization}

\item \textcolor{gray}{\bf Problem specification}

\item {\bf Linear solver specification}

  To initialize the {\idabbdpre} preconditioner, make the following call:
  \index{FIDABBDINIT@\texttt{FIDABBDINIT}}
\begin{verbatim}
       CALL FIDABBDINIT (NLOCAL, MUDQ, MLDQ, MU, ML, DQRELY, IER)
\end{verbatim}
  The arguments are as follows.
  \id{NLOCAL} is the local size of vectors on this processor.
  \id{MUDQ} and \id{MLDQ} are the upper and lower half-bandwidths to be used in 
  the computation of the local Jacobian blocks by difference quotients.
  These may be smaller than the true half-bandwidths of the
  Jacobian of the local block of $G$, when smaller values may
  provide greater efficiency.
  \id{MU} and \id{ML} are the upper and lower half-bandwidths of the band matrix
  that  is retained as an approximation of the local Jacobian block.
  These may be smaller than \id{MUDQ} and \id{MLDQ}.
  \id{DQRELY} is the relative increment factor in $y$ for difference quotients
  (optional). A value of $0.0$ indicates the default, $\sqrt{\text{unit roundoff}}$.
  \id{IER} is a return completion flag.  A value of $0$ indicates success, while
  a value of $-1$ indicates that a memory failure occurred or that an input had
  an illegal value.

  To specify the {\spgmr} linear system solver and use the {\idabbdpre}
  preconditioner, make the following call:
  \index{FIDABBDSPGMR@\texttt{FIDABBDSPGMR}}
\begin{verbatim}
       CALL FIDABBDSPGMR (MAXL, IGSTYPE, MAXRS, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  Its arguments are the same as those of \id{FIDASPGMR}
  (see step \ref{i:fida_lin_solv_spec} in \S\ref{ss:fida_usage}).

  To specify the {\spbcg} linear system solver and use the {\idabbdpre}
  preconditioner, make the following call:
  \index{FIDABBDSPBCG@\texttt{FIDABBDSPBCG}}
\begin{verbatim}
       CALL FIDABBDSPBCG (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  Its arguments are the same as those of \id{FIDASPBCG}
  (see step \ref{i:fida_lin_solv_spec} in \S\ref{ss:fida_usage}).

  To specify the {\sptfqmr} linear system solver and use the {\idabbdpre}
  preconditioner, make the following call:
  \index{FIDABBDSPTFQMR@\texttt{FIDABBDSPTFQMR}}
\begin{verbatim}
       CALL FIDABBDSPTFQMR (MAXL, EPLIFAC, DQINCFAC, IER)
\end{verbatim}
  Its arguments are the same as those of \id{FIDASPTFQMR}
  (see step \ref{i:fida_lin_solv_spec} in \S\ref{ss:fida_usage}).

  Optionally, to specify that {\spgmr}, {\spbcg}, or {\sptfqmr} should use 
  the supplied \id{FIDAJTIMES}, make the call
  \index{FIDASPILSSETJAC@\texttt{FIDASPILSSETJAC}}
\begin{verbatim}
       CALL FIDASPILSSETJAC (FLAG, IER)
\end{verbatim}
  with \id{FLAG} $\neq 0$ 
  (see step \ref{i:fida_lin_solv_spec} in \S\ref{ss:fida_usage} for details).

\item \textcolor{gray}{\bf Problem solution}
  
\item {\bf {\idabbdpre} Optional outputs}

  Optional outputs specific to the {\spgmr}, {\spbcg}, or {\sptfqmr} solver are 
  listed in Table \ref{t:fida_out}.
  To obtain the optional outputs associated with the {\idabbdpre}
  module, make the following call:
  \index{FIDABBDOPT@\texttt{FIDABBDOPT}}
\begin{verbatim}
       CALL FIDABBDOPT (LENRWBBD, LENIWBBD, NGEBBD)
\end{verbatim}
  The arguments returned are as follows.
  \id{LENRWBBD} is the length of real preconditioner work space, in \id{realtype}
  words.  \id{LENIWBBD} is the length of integer preconditioner work space, in
  integer words.  Both of these sizes are local to the current processor.
  \id{NGEBBD} is the number of $G(t,y,y')$ evaluations (calls to \id{FIDALOCFN})
  so far.
  
\item {\bf Problem reinitialization}
  
  If a sequence of problems of the same size is being solved using the {\spgmr},
  {\spbcg}, or {\sptfqmr} linear solver in combination with the {\idabbdpre}
  preconditioner, then the {\ida} package can be re-initialized for the second
  and subsequent problems by calling \id{FIDAREINIT}, following which a call
  to \id{FIDABBDINIT} may or  may not be needed.
  If the input arguments are the same, no \id{FIDABBDINIT} call is needed.
  If there is a change in input arguments other than \id{MU}, \id{ML}, or
  \id{MAXL}, then the user program should make the call 
  \index{FIDABBDREINIT@\texttt{FIDABBDREINIT}}
\begin{verbatim}
       CALL FIDABBDREINIT (NLOCAL, MUDQ, MLDQ, DQRELY, IER)
\end{verbatim}
  This reinitializes the {\idabbdpre} preconditioner, but without
  reallocating its memory.  The arguments of the \id{FIDABBDREINIT}
  routine have the same names and meanings as those of \id{FIDABBDINIT}.
  If the value of \id{MU} or \id{ML} is being changed, then a call to
  \id{FIDABBDINIT} must be made.  Finally, if \id{MAXL} is being  changed,
  then a call to \id{FIDABBDSPGMR}, \id{FIDABBDSPBCG}, or \id{FIDASPTFQMR}
  must be made; in this case the linear solver memory is reallocated.

\item {\bf Memory deallocation}

  To free the internal memory created by the call to \id{FIDABBDINIT}, before
  calling \id{FIDAFREE}, the user must call
  \index{FIDABBDFREE@\texttt{FIDABBDFREE}}
\begin{verbatim}
      CALL FIDABBDFREE
\end{verbatim}
\index{FIDA@{\fida} interface module!interface to the {\idabbdpre} module|)}

\item {\bf User-supplied routines}

  The following two routines must be supplied for use with the {\idabbdpre}
  module:
  \index{FIDAGLOCFN@\texttt{FIDAGLOCFN}}
\begin{verbatim}
      SUBROUTINE FIDAGLOCFN (NLOC, T, YLOC, YPLOC, GLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), YPLOC(*), GLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to evaluate the function $G(t,y,y')$ approximating $F$
  (possibly identical to $F$), in terms of \id{T} $ = t$, and the arrays
  \id{YLOC} and \id{YPLOC} (of length \id{NLOC}), which are the sub-vectors
  of $y$ and $y'$ local to this processor.  The resulting (local) sub-vector
  is to be stored in the array \id{GLOC}.  \id{IER} is a return flag that
  should be set to 0 if successful, to 1 (for a recoverable error), or to
  -1 (for a non-recoverable error).
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.

  \index{FIDACOMMFN@\texttt{FIDACOMMFN}}
\begin{verbatim}
      SUBROUTINE FIDACOMMFN (NLOC, T, YLOC, YPLOC, IPAR, RPAR, IER)
      DIMENSION YLOC(*), YPLOC(*), IPAR(*), RPAR(*)
\end{verbatim}
  This routine is to perform the inter-processor communication necessary
  for the \id{FIDAGLOCFN} routine.
  Each call to \id{FIDACOMMFN} is preceded by a call to the residual routine
  \id{FIDARESFUN} with the same arguments \id{T}, \id{YLOC}, and \id{YPLOC}.
  Thus \id{FIDACOMMFN} can omit any communications done by \id{FIDARESFUN} if
  relevant to the evaluation of \id{GLOC}.
  The arrays \id{IPAR} (of integers) and \id{RPAR} (of reals) contain user data
  and are the same as those passed to \id{FIDAMALLOC}.
  \id{IER} is a return flag that should be set to 0 if successful, to 1
  (for a recoverable error), or to -1 (for a non-recoverable error).

  {\warn}The subroutine \id{FIDACOMMFN} must be supplied even if it is empty and it must
  return \id{IER=0}.

  \index{FIDAJTIMES@\texttt{FIDAJTIMES}}
  Optionally, the user can supply a routine \id{FIDAJTIMES} for the evaluation of
  Jacobian-vector products, as described above in step \ref{i:fida_lin_solv_spec}
  in \S\ref{ss:fida_usage}.

\end{Steps}
